<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>V2M</title>
  <subtitle>Way to MM.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://maimieng.com/"/>
  <updated>2017-01-20T02:24:21.000Z</updated>
  <id>https://maimieng.com/</id>
  
  <author>
    <name>kingcos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift 中的 UIAppearance</title>
    <link href="https://maimieng.com/2017/5/"/>
    <id>https://maimieng.com/2017/5/</id>
    <published>2017-01-18T16:00:00.000Z</published>
    <updated>2017-01-20T02:24:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>UIAppearance in Swift<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>Swift 3.0</li>
<li>Xcode 8.2.1</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UIAppearance，即用户界面外观，是 iOS 中 UIKit 的一个协议。外观对于用户体验是至关重要的一点，NSHipster 的 Mattt Thompson 在 UIAppearance 一文中说：<strong>Users will pay a premium for good-looking software.</strong>（用户乐意为高颜值的软件额外付费）。</p>
<p>使用 UIAppearance 协议可以得到一个类的外观代理（proxy）。我们可以调用类的外观代理来更简单地自定义一个实例的外观。不过由于官方文档仍是 Objective-C 的例子，这里就总结一下 Swift 中的使用。这里为了方便演示，我创建了一个 Demo，您可以在 <a href="">kingcos/UIAppearance-Demo</a> 下载，并在 Xcode 中运行。</p>
<p>该 Demo 为纯代码，不涉及 Storyboard 和 XIB。</p>
<p><img src="http://7xkam0.com1.z0.glb.clouddn.com/blog/uiappearance_01.png" alt="原始界面"></p>
<p>其中自定义了两个 TabBar 控制器，MM 和 VV TabBar 控制器的初始外观（后续主要针对 TabBarItem 的修改）如下所示。</p>
<p><img src="http://7xkam0.com1.z0.glb.clouddn.com/blog/uiappearance_02.png" alt="MMTabBarController"></p>
<p><img src="http://7xkam0.com1.z0.glb.clouddn.com/blog/uiappearance_03.png" alt="VVTabBarController"></p>
<h2 id="全局修改外观"><a href="#全局修改外观" class="headerlink" title="全局修改外观"></a>全局修改外观</h2><p>全局修改即修改该类型的<strong>所有</strong>实例的外观。</p>
<p>这里的 Demo 以 <code>UITabBarItem</code> 为例，如果我们需要修改整个应用中所有的 <code>UITabBarItem</code>  外观，即全局修改，那么我们直接使用以下方法即可获取该类的外观代理，进而进行修改。注意调用该方法的为<strong>类</strong>，而非实例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">appearance</span><span class="params">()</span></span> -&gt; <span class="type">Self</span></div></pre></td></tr></table></figure>
<p>将修改外观（此处以字体大小为例）的操作放在一个方法中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">setGlobalAppearance</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> attrsNormal = [<span class="type">String</span> : <span class="type">Any</span>]()</div><div class="line">    attrsNormal[<span class="type">NSFontAttributeName</span>] = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">30</span>)</div><div class="line">    </div><div class="line">    <span class="type">UITabBarItem</span>.appearance().setTitleTextAttributes(attrsNormal, <span class="keyword">for</span>: <span class="type">UIControlState</span>.normal)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>viewDidLoad</code> 方法中调用该方法并运行，我们即可看到两种 TabBar 控制器的 TabBarItem 的字体均受到了影响。</p>
<p><img src="http://7xkam0.com1.z0.glb.clouddn.com/blog/uiappearance_04.png" alt="MMTabBarController"></p>
<p><img src="http://7xkam0.com1.z0.glb.clouddn.com/blog/uiappearance_05.png" alt="VVTabBarController"></p>
<h2 id="部分修改外观"><a href="#部分修改外观" class="headerlink" title="部分修改外观"></a>部分修改外观</h2><p>部分修改即修改该类型的<strong>某些</strong>实例的外观。</p>
<p>在 Demo 中，我们可以使用以下方法，传入 UIAppearance 容器类型，即可修改该容器内部的相应类型实例的外观。需要注意的是，这里的参数为数组，即传入多个不同类型也是允许的。同样注意调用该方法的为<strong>类</strong>，而非实例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@available</span>(iOS <span class="number">9.0</span>, *)</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">appearance</span><span class="params">(whenContainedInInstancesOf containerTypes: [UIAppearanceContainer.<span class="keyword">Type</span>])</span></span> -&gt; <span class="type">Self</span></div></pre></td></tr></table></figure>
<p>将修改外观（此处以字体大小为例）的操作放在一个方法中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">setLocalAppearance</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> attrsNormal = [<span class="type">String</span> : <span class="type">Any</span>]()</div><div class="line">    attrsNormal[<span class="type">NSFontAttributeName</span>] = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">30</span>)</div><div class="line">    </div><div class="line">    <span class="type">UITabBarItem</span>.appearance(whenContainedInInstancesOf: [<span class="type">MMTabBarController</span>.<span class="keyword">self</span>]).setTitleTextAttributes(attrsNormal, <span class="keyword">for</span>: <span class="type">UIControlState</span>.normal)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>viewDidLoad</code> 方法中调用该方法并运行，我们即可看到只有作为参数的 MMTabBarController 的 TabBarItem 的字体受到了影响。</p>
<p><img src="http://7xkam0.com1.z0.glb.clouddn.com/blog/uiappearance_06.png" alt="MMTabBarController"></p>
<p><img src="http://7xkam0.com1.z0.glb.clouddn.com/blog/uiappearance_07.png" alt="VVTabBarController"></p>
<h2 id="自定义-UIView-子类的实现"><a href="#自定义-UIView-子类的实现" class="headerlink" title="自定义 UIView 子类的实现"></a>自定义 UIView 子类的实现</h2><p>通过以上的 Demo，我们可以看出，通过 UIAppearance 可以很便捷且统一的管理界面外观。系统中遵守 UIAppearance 的方法和属性可以在 <a href="https://gist.github.com/mattt/5135521" target="_blank" rel="external">mattt/uiappearance-selector.md</a> 查到，那我们如何使自定义的 UIView 类也能用 UIAppearance 管理呢？</p>
<p>这里以自定义按钮为例，为了方便演示，直接使用了 Demo 中跳转的两个按钮。新建一个 MMButton 的类，继承 UIButton。UIView 本身已经实现了 UIAppearance 和 UIAppearanceContainer 协议，所以我们只需要添加需要 UIAppearance 修改的属性即可。</p>
<p><img src="http://7xkam0.com1.z0.glb.clouddn.com/blog/uiappearance_08.png" alt="UIView 已实现了 UIAppearance 和 UIAppearanceContainer 协议"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MMButton</span>: <span class="title">UIButton</span> </span>&#123;</div><div class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> btnBorderWidth: <span class="type">CGFloat</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">return</span> layer.borderWidth</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">set</span> &#123;</div><div class="line">            layer.borderWidth = newValue</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是以按钮的边框宽度为例，该属性为<strong>计算属性</strong>。同时需要在定义前加上 <code>dynamic</code>，以赋予该处 Swift 代码的<strong>运行时（runtime）</strong>特性。</p>
<p>这样便可以使用 <code>appearance()</code> 来全局修改 MMButton 的该属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">MMButton</span>.appearance().btnBorderWidth = <span class="type">CGFloat</span>(<span class="number">10.0</span>)</div></pre></td></tr></table></figure>
<p>效果即如图所示：</p>
<p><img src="http://7xkam0.com1.z0.glb.clouddn.com/blog/uiappearance_09.png" alt="自定义 MMButton"></p>
<p>需要注意的是，可以支持修改的属性只能为 <code>id</code>，<code>NSInteger</code>，<code>NSUInteger</code>，<code>CGFloat</code>，<code>CGPoint</code>，<code>CGSize</code>，<code>CGRect</code>，<code>UIEdgeInsets</code> 或 <code>UIOffset</code>（官方提供的均为 Objective-C 类型）。</p>
<blockquote>
<p>极端特殊的情况下，你也可以参考文末的 UIAppearance proxy for custom objects，其中 LombaX 提供了继承自 NSObject 的普通类的 appearance 实现。由于 UIAppearance 多用于 UIView 的子类，所以本文不再探究，但给出参考。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 UIAppearance 协议可以很方便的自定义外观。当然，UIAppearance 并不是外观修改的唯一选择。在 Mattt Thompson 的 UIAppearance 一文中也提到了几个替代 UIAppearance 的第三方库，通过把样式和内容分开（很像 CSS 和 HTML 的关系）来定义外观，更加清晰。在为 App 开发主题抑或是夜间模式时，也可以选择轻量级颜色框架 <a href="https://github.com/ViccAlexander/Chameleon" target="_blank" rel="external">ViccAlexander/Chameleon</a>，其已经在 GitHub 上拿到了超过 7000+ Stars。</p>
<p>UIAppearance 中还有两个方法本文没有涉及：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">appearance</span><span class="params">(<span class="keyword">for</span>: UITraitCollection, whenContainedInInstancesOf: [UIAppearanceContainer.<span class="keyword">Type</span>])</span></span></div><div class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">appearance</span><span class="params">(whenContainedInInstancesOf: [UIAppearanceContainer.<span class="keyword">Type</span>])</span></span></div></pre></td></tr></table></figure>
<p>这两个方法是关于 Trait Collection，和多屏适配相关。目前这块的相关中文资料不是太多，我会找时间进行搜索、总结，届时再与大家分享。</p>
<p>另外本文略有涉及 Swift 和 Objective-C 的兼容，<code>dynamic</code> 关键字便可以保证和 Objective-C 里动态调用时相同的<strong>运行时（runtime）</strong>特性。为大家所熟知的还有 <code>@objc</code>，关于这两者（<code>dynamic</code> &amp; <code>@objc</code>）的区别，您可以参考文末中喵神的 @OBJC 和 DYNAMIC。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.apple.com/reference/uikit/uiappearance" target="_blank" rel="external">UIAppearance - Apple Inc.</a></li>
<li><a href="https://developer.apple.com/reference/uikit/uiappearancecontainer" target="_blank" rel="external">UIAppearanceContainer - Apple Inc.</a></li>
<li><a href="http://nshipster.com/uiappearance/" target="_blank" rel="external">UIAppearance - NSHipster</a></li>
<li><a href="https://gist.github.com/mattt/5135521" target="_blank" rel="external">mattt/uiappearance-selector.md</a></li>
<li><a href="http://stackoverflow.com/questions/15732885/uiappearance-proxy-for-custom-objects" target="_blank" rel="external">UIAppearance proxy for custom objects - StackOverflow</a></li>
<li><a href="http://swifter.tips/objc-dynamic/" target="_blank" rel="external">@OBJC 和 DYNAMIC</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;UIAppearance in Swift&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>「周记」逃避</title>
    <link href="https://maimieng.com/2017/4/"/>
    <id>https://maimieng.com/2017/4/</id>
    <published>2017-01-14T16:00:00.000Z</published>
    <updated>2017-01-15T16:26:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>爱，是折磨人的东西。<br></blockquote><br><a id="more"></a><br>很遗憾，科二挂在了最后直角转弯。所以只能等开学再来考了。</p>
<p>在每个假期回家前，我基本上都会找一部短剧来追，以缓解路上四个多小时无聊时间。这次看的是日剧《逃避虽可耻但有用》。其实在放假前有和舍友断断续续看过一些片段，题材比较新颖，加上男主也是程序猿，所以就下载了放在路上看。整个剧 11 集，算的是一部比较短小的剧。看后也是感慨很多，也能感受到日本社会的秩序，总之是一部很暖心的爱情剧。</p>
<p>这一周总算是回到家了，在家免不了会惰性很大。不过这也算是大学最后一个假期了，今年的暑假就要出去找实习了。所以我计划寒假能够有时间来巩固基础，并对目前手头的项目进行一个分析，方便开学后的开发。</p>
<blockquote>
<p>我看透了很多，多么希望遇到一个开明的人。听我诉说，然后，跟我一起离开这里。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;爱，是折磨人的东西。&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Weekly Journal" scheme="https://maimieng.com/tags/Weekly-Journal/"/>
    
  </entry>
  
  <entry>
    <title>「周记」患得患失</title>
    <link href="https://maimieng.com/2017/3/"/>
    <id>https://maimieng.com/2017/3/</id>
    <published>2017-01-08T16:00:00.000Z</published>
    <updated>2017-01-15T15:37:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>怕得不到，又，怕得到了会失去。<br></blockquote><br><a id="more"></a><br>2017 年的第一周就这样过去了。这一周，考完了大三上学期唯一一门考试——《计算机组成原理》。不过由于想在回家前把驾照的科目二考过，因此便没有直接回家。</p>
<p>6 号晚上，看了同学参加的街舞社表演，略有感慨。生活真的不只是 Code，有很多精彩的地方，每个人都在努力。我们只看到他表演的精彩，却不知道背后的付出。要去尊重每个人的努力。虽然每个人都有所擅长，有所不擅长。但哪怕环境再差，也要拥抱阳光。</p>
<p>7 号，为了听同学唱歌，下载了「全民 K 歌」。发现大家唱歌也都挺好的。唱歌对我来说也算是难题，特别是自从我发现自己唱不上高音（变声之后），去 KTV 唱歌总会遇到高音，就会很尴尬。不过既然大家也都唱的不错，我也想去努力练习唱歌。不过和大家直接在宿舍用软件录歌不一样，我做不到直接在宿舍唱歌，所以我跑到房顶，一个人在冷风中录歌。可能是「只有我一个人的时候，我才愿意放下。」</p>
<p>在新年第一天知道自己又一次成为「Single Dog」之后，没有觉得多难受，只是释然。昨晚又和同学聊天，发现自己被看的清清楚楚，可能我就是这么容易被看穿吧。</p>
<blockquote>
<p>我不是一个爱冒险的人，只有成功率大于一定程度时，我才愿意迈出去。</p>
</blockquote>
<p>下一周重要的就是拿下科目二，然后回家，今年在家也许会很「闲」吧。如果真的「走不了」，那就让我再「整理整理」吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;怕得不到，又，怕得到了会失去。&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Weekly Journal" scheme="https://maimieng.com/tags/Weekly-Journal/"/>
    
  </entry>
  
  <entry>
    <title>阅读 UIColor-Hex-Swift 源码</title>
    <link href="https://maimieng.com/2017/2/"/>
    <id>https://maimieng.com/2017/2/</id>
    <published>2017-01-07T16:00:00.000Z</published>
    <updated>2017-01-08T12:16:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Read the mind behind the code.<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>Swift 3.0</li>
<li>Xcode 8.2.1</li>
<li>UIColor Hex Swift 3.0.2</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://7xkam0.com1.z0.glb.clouddn.com/blog/UIColor-Hex-Swift_code_01.png" alt="yeahdongcn/UIColor-Hex-Swift"></p>
<p><a href="https://github.com/yeahdongcn/UIColor-Hex-Swift/" target="_blank" rel="external"><strong>yeahdongcn/UIColor-Hex-Swift</strong></a> 是一个使用 Swift 3.0 编写并开源在 GitHub 上的 iOS 第三方库。核心为不到 200 行代码，即可以使用 RGBA 十六进制数／字符串创建颜色（<code>UIColor</code>）。其支持通过 CocoaPods 管理，目前在 GitHub 上已经拥有 683 Stars，说明该库已经帮助了不少开发者使用在了项目中。而我作为一个新手，就来仔细阅读一下该库的源码，看看是否有值得借鉴的地方。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>利用枚举，通过遵守 <code>Error</code> 协议，来定义统一的错误处理。Swift 中的 <code>Error</code> 协议也有说明，通过遵守该协议即可使错误在 Swift 的错误处理系统中保持一致性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UIColorInputError</span> : <span class="title">Error</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> missingHashMarkAsPrefix,</div><div class="line">    unableToScanHexValue,</div><div class="line">    mismatchedHexStringLength</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>Swift 中的扩展（extension）能够很方便地扩充而不破坏原有的类。特别是在官方提供的类上，使用 extension 可以很容易的加上我们的自定义方法以及<strong>计算</strong>属性（扩展不支持存储属性）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIColor</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="便利构造器"><a href="#便利构造器" class="headerlink" title="便利构造器"></a>便利构造器</h2><p>便利构造器（Convenience initializers）与指定构造器（Designated initializers）不同。便利构造器是次要的，即不是必需的。也可以在便利构造器的内部调用指定构造器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(hex3: <span class="type">UInt16</span>, alpha: <span class="type">CGFloat</span> = <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">let</span> divisor = <span class="type">CGFloat</span>(<span class="number">15</span>)</div><div class="line">    <span class="keyword">let</span> red     = <span class="type">CGFloat</span>((hex3 &amp; <span class="number">0xF00</span>) &gt;&gt; <span class="number">8</span>) / divisor</div><div class="line">    <span class="keyword">let</span> green   = <span class="type">CGFloat</span>((hex3 &amp; <span class="number">0x0F0</span>) &gt;&gt; <span class="number">4</span>) / divisor</div><div class="line">    <span class="keyword">let</span> blue    = <span class="type">CGFloat</span>( hex3 &amp; <span class="number">0x00F</span>      ) / divisor</div><div class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(red: red, green: green, blue: blue, alpha: alpha)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>一般的单行注释和多行注释都已为人所知。但如何与官方注释保持一致性和规范性，我个人却在之前没有了解到。在 Xcode 8 支持了 markdown 语法后，有人已经开始通过 Playground 制作很多带样式的代码教程。结合 Xcode 自带的规范，可以达到和官方保持一致的效果。关于具体的标记样式可以查看文末的参考。</p>
<p><img src="http://7xkam0.com1.z0.glb.clouddn.com/blog/UIColor-Hex-Swift_code_02.png" alt="带样式的 Xcode 注释"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line"> The shorthand three-digit hexadecimal representation of color.</div><div class="line"> #RGB defines to the color #RRGGBB.</div><div class="line"> </div><div class="line"> - parameter hex3: Three-digit hexadecimal value.</div><div class="line"> - parameter alpha: 0.0 - 1.0. The default is 1.0.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(hex3: <span class="type">UInt16</span>, alpha: <span class="type">CGFloat</span> = <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">let</span> divisor = <span class="type">CGFloat</span>(<span class="number">15</span>)</div><div class="line">    <span class="keyword">let</span> red     = <span class="type">CGFloat</span>((hex3 &amp; <span class="number">0xF00</span>) &gt;&gt; <span class="number">8</span>) / divisor</div><div class="line">    <span class="keyword">let</span> green   = <span class="type">CGFloat</span>((hex3 &amp; <span class="number">0x0F0</span>) &gt;&gt; <span class="number">4</span>) / divisor</div><div class="line">    <span class="keyword">let</span> blue    = <span class="type">CGFloat</span>( hex3 &amp; <span class="number">0x00F</span>      ) / divisor</div><div class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(red: red, green: green, blue: blue, alpha: alpha)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h2><p>Travis CI，是一个专门为开源项目打造的持续集成环境。最为显著的标示就是在很多 GitHub 等开源的项目 README 中，有很多简介项目的标签。我也正准备将自己的项目建立 Travis CI。</p>
<p><img src="http://7xkam0.com1.z0.glb.clouddn.com/blog/UIColor-Hex-Swift_code_03.png" alt="Travis CI 标签"></p>
<h2 id="十六进制转-RGB"><a href="#十六进制转-RGB" class="headerlink" title="十六进制转 RGB"></a>十六进制转 RGB</h2><p>以六位十六进制转换 RGB 为例。<code>&amp;</code> 是按位与运算符。<code>&gt;&gt;</code> 是右移运算符。通过 <code>(hex6 &amp; 0xFF0000) &gt;&gt; 16</code>，<code>(hex6 &amp; 0x00FF00) &gt;&gt;  8</code>，<code>hex6 &amp; 0x0000FF</code>，分别把  RR、GG、BB 位上的数字提取。由于 RGB 最大值为 255.0，iOS 中 UIColor 的初始化方法必须按与 255.0 的比例作为参数，因此比上除数 255.0。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     The six-digit hexadecimal representation of color of the form #RRGGBB.</div><div class="line">     </div><div class="line">     - parameter hex6: Six-digit hexadecimal value.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(hex6: <span class="type">UInt32</span>, alpha: <span class="type">CGFloat</span> = <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">let</span> divisor = <span class="type">CGFloat</span>(<span class="number">255</span>)</div><div class="line">        <span class="keyword">let</span> red     = <span class="type">CGFloat</span>((hex6 &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>) / divisor</div><div class="line">        <span class="keyword">let</span> green   = <span class="type">CGFloat</span>((hex6 &amp; <span class="number">0x00FF00</span>) &gt;&gt;  <span class="number">8</span>) / divisor</div><div class="line">        <span class="keyword">let</span> blue    = <span class="type">CGFloat</span>( hex6 &amp; <span class="number">0x0000FF</span>       ) / divisor</div><div class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(red: red, green: green, blue: blue, alpha: alpha)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508" target="_blank" rel="external">Error Handling</a><br><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151" target="_blank" rel="external">Extensions</a><br><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html" target="_blank" rel="external">Initialization</a><br><a href="https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/index.html" target="_blank" rel="external">Markup Formatting Reference</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Read the mind behind the code.&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>回顾 2016，展望 2017</title>
    <link href="https://maimieng.com/2017/1/"/>
    <id>https://maimieng.com/2017/1/</id>
    <published>2016-12-31T16:00:00.000Z</published>
    <updated>2017-01-02T16:15:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>New Year, New Start.<br></blockquote><br><a id="more"></a></p>
<blockquote>
<p>今天是 2017 年 1 月 1 日，其实在昨天我已经起草了一份年终总结。每次的年终总结总要回想一年的时光，可又哪是一时半会可以总结的好的呢？</p>
</blockquote>
<p>2016 年，我从大二升到大三。这一年，有很多的感慨，有得到一些，也失去一些。纵然 2016 已经过去，那么现在就是时候就做个总结，记下展望。</p>
<h2 id="回顾-2016"><a href="#回顾-2016" class="headerlink" title="回顾 2016"></a>回顾 2016</h2><h3 id="百度-IFE-amp-FCC"><a href="#百度-IFE-amp-FCC" class="headerlink" title="百度 IFE &amp; FCC"></a>百度 IFE &amp; FCC</h3><p>在 2016 年 3 月到 4 月的一个月时间，我召集了几个学习前端的同学一起参加<a href="http://ife.baidu.com/" target="_blank" rel="external">百度前端技术学院</a>。虽然当时也在 FreeCodeCamp 上学习前端的基础知识，但遗憾的是我们并没有坚持下去。最近在完成课程设计中，开发前端页面中使用了 Element UI 和 Vue.js，由于对前端的不了解，发现了很多坑。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/from2016to2017_01.png" alt="Team Bug"></p>
<h4 id="体会："><a href="#体会：" class="headerlink" title="体会："></a>体会：</h4><ol>
<li>代码规范的重要性</li>
<li>前端中，JavaScript 是一个难点，重点</li>
<li>前端的 UI 框架和 JS 框架都需要学习</li>
<li>前端组件化，前后端分离</li>
</ol>
<h3 id="CET-6"><a href="#CET-6" class="headerlink" title="CET-6"></a>CET-6</h3><p>比起四级前的疯狂学习（至少抄了 100 页单词，做了 20 套卷子），六级的复习就仅仅在考前的三周，临近考试的一周还得了感冒，于是就放弃复习。那次六级又是第一次听力改革，加上收音耳机不给力，考完就没有报太大的信心。结果是考了 446 分，不算高，但也算是过了及格线。平时学英语的途径也就只有翻译电台的演讲，并没有其他刻意的学习。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/from2016to2017_02.png" alt="Twitter 推文"></p>
<h4 id="体会：-1"><a href="#体会：-1" class="headerlink" title="体会："></a>体会：</h4><ol>
<li>英语是一种工具，要掌握好</li>
<li>未来要拓展除英文之外的语种（例如：日语）</li>
<li>语言的学习不应该是为了考试分数，而是应该追求实学（奶爸文章有感）</li>
</ol>
<h3 id="培训"><a href="#培训" class="headerlink" title="培训"></a>培训</h3><p>2016 年暑假的第一个月是卓越班的 Java 培训。虽然我已经了解 Java 的基本使用，但在这一个月体验培训也很有感触。</p>
<h4 id="体会：-2"><a href="#体会：-2" class="headerlink" title="体会："></a>体会：</h4><ol>
<li>专心才能学好。在这一个月的时间，从早到晚，几乎都在教室，虽然天气很热，但是这样集中时间干一件事确实学习速度很快，干劲很足</li>
<li>培训的弊端。培训由于时间的紧凑，没有太多时间留给个人去思考，而是灌输式地教学。「别问为什么，你只要会用就行」，这样确实加速了开发，但是这样没有<strong>主动地探索式</strong>的学习，我个人是觉得不太牢靠。当然培训也存在其他问题，但也有很多好处，见仁见智</li>
</ol>
<h3 id="国奖"><a href="#国奖" class="headerlink" title="国奖"></a>国奖</h3><p>在小学、初中、高中从来没有拿过第一的我，在大学里终于算是「扳回一局」。之所以带引号，是因为我也知道大学课程很水，成绩更水。有的老师要求苛刻，有的可能全部给过。学生们也是抱着 60 分万岁，多一分犯罪的态度。毕竟大学除了学习还有很多甚至更重要的事情。</p>
<p>而我把国家奖学金仅仅当作一种肯定。以那样的高考分数进到这样一所学校，我<strong>没有任何</strong>「炫耀」的资本。这两年算是勤勤恳恳地学过来了，虽然「成绩」并不优异，但这个奖算是对我的一种肯定，一种鼓励。</p>
<h4 id="体会：-3"><a href="#体会：-3" class="headerlink" title="体会："></a>体会：</h4><ol>
<li>只要方向正确，努力终会有所回报</li>
<li>要学会适当的自我营销</li>
</ol>
<h3 id="电台"><a href="#电台" class="headerlink" title="电台"></a>电台</h3><p>网易云上的电台是我 2015 年 4 月 18 日开设的。到现在已经快两年了，奥巴马总统也快要卸任了。一周一更的速度其实并不快，但是近几个月也停更了。也很感谢支持、订阅我的朋友，可我最近的弃更确实对不住你们的期待。我想在最近思考下电台和公众号的未来，绝不会放弃这样的平台。</p>
<h4 id="体会：-4"><a href="#体会：-4" class="headerlink" title="体会："></a>体会：</h4><ol>
<li>坚持，坚持，再坚持</li>
<li>有些事情看似对自己毫无意义，但在无形中就能帮到他人</li>
</ol>
<h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>2016 年，我一共写了 38 篇博客。在接近年终的时候，我开始下定决心学习 iOS，并把学习过程的中的一些问题的解决总结成文，发表出去。这一想法的起始于暑假培训时写的两篇 Java 的文章，我开始思考博客的意义。博客不应该是一个记笔记的地方，而是个人思想传播的途径。<strong>在学习过程解决疑问，却很值得记录，与他人分享。</strong></p>
<p>我很享受这样一个写作、分享的过程。虽然一篇文章我常常需要打开十几个网页，对比学习，并用 Xcode 写下 Demo，再进行测试。但是每在简书或是掘金收到一次喜欢或是收藏都会十分激动。虽然可能有一些虚荣，但是如果虚荣能促使一个人进步，那么我觉得也是不错的。</p>
<p>当然现在的写作速度很慢，有时候又被很多事情拖着，未来一定会继续更新！希望能够帮到更多的人。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/from2016to2017_03.png" alt="简书个人主页"></p>
<h4 id="体会：-5"><a href="#体会：-5" class="headerlink" title="体会："></a>体会：</h4><ol>
<li>写技术文章一定要经得起考证</li>
<li>技术文章一定要严谨，重视细节</li>
<li>有时候，一句简单的评论就能给作者带来好心情（这点是我自己感受到的）</li>
</ol>
<h2 id="展望-2017"><a href="#展望-2017" class="headerlink" title="展望 2017"></a>展望 2017</h2><h3 id="驾照"><a href="#驾照" class="headerlink" title="驾照"></a>驾照</h3><p>2017 年第一个展望便是在离校前把驾照考下来。虽然考过驾照，家里也没有车能让我开，但确实是一个必备技能了。我报驾照的时间确实有些晚，已经没有太多时间拖延，所以第一个展望就留给驾照吧。</p>
<h3 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h3><p>2017 年，最重要的可能就是实习了。即将踏入职场，现在的我很兴奋，很憧憬。我知道自己可能进不了 BAT 这样的巨头，也进不了那些大家耳熟能详的互联网公司。剩下的时间也没多少了，只希望自己能找到一份热情的工作吧！但起码要够自己租房和生活的支出。</p>
<h3 id="博客-1"><a href="#博客-1" class="headerlink" title="博客"></a>博客</h3><p>计划 2017 年至少写 30 篇技术文章。另外看另一位大神的博客，准备开始周记计划，即每周总结。</p>
<h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>2017 年我会多读书，并写下笔记，与大家分享。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>2016 年，我的 <a href="https://github.com/kingcos" target="_blank" rel="external">GitHub</a> 上终于够了 10 颗星。2017 我希望这个数字达到 100。我相信这个目标并不难，因为已经有计划开始写开源项目了。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/from2016to2017_04.png" alt="GitHub"></p>
<h3 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h3><p>新的一年，我也希望自己能够坚持锻炼身体，坚持早起，坚持学习。</p>
<hr>
<p>最后呢，谢谢 FF 所说的「<strong><em>好感并不等于喜欢</em></strong>」。另外我也会尽力和一些人保持联系，而不是像以前那样时间长了，就断了联系。</p>
<p>寒假的计划也放在这里吧：</p>
<ol>
<li>完成 Swift 设计模式相应的文章</li>
<li>学习基础算法</li>
<li>读完两本书</li>
<li>在课程设计基础上完善项目并开源</li>
<li>拿到驾照</li>
<li>开更电台 &amp; 公众号</li>
</ol>
<blockquote>
<p>一切尚早，我，还在路上。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;New Year, New Start.&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Plan" scheme="https://maimieng.com/tags/Plan/"/>
    
  </entry>
  
  <entry>
    <title>研读 CSAPP 之一： A Tour of Computer Systems</title>
    <link href="https://maimieng.com/2016/38/"/>
    <id>https://maimieng.com/2016/38/</id>
    <published>2016-12-23T16:00:00.000Z</published>
    <updated>2016-12-26T00:59:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>第一章：计算机系统之旅<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.3 Beta</li>
<li>CS: APP 3e Eng</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学习越深入时，就越发觉得基础不牢靠。有幸找到一本神书，CS:APP 第三版的英文原版。由于几乎已经习惯阅读英文，虽可能速度较慢，但可以免受翻译者思维的干扰。书很好，但还是希望沉下心，好好阅读，做好笔记，融会贯通。</p>
<p><strong>需要注意的是：该研读系列为个人总结，不免有一些错误，希望您能提出意见或建议，我都会细心研究，做出改正。谢谢！</strong></p>
<h2 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h2><p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.1.png" alt="1.1"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.2.png" alt="1.2"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.3.png" alt="1.3"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.4.png" alt="1.4"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.5.png" alt="1.5"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.6.png" alt="1.6"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.7.png" alt="1.7"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.8.png" alt="1.8"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.9.png" alt="1.9"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.10.png" alt="1.10"></p>
<h2 id="练习题解"><a href="#练习题解" class="headerlink" title="练习题解"></a>练习题解</h2><blockquote>
<p>虽然书中有练习的答案，但我仍尝试自己解决，并将问题和解法发布在此与大家交流。</p>
</blockquote>
<h3 id="Practice-Problem-1-1"><a href="#Practice-Problem-1-1" class="headerlink" title="Practice Problem 1.1"></a>Practice Problem 1.1</h3><blockquote>
<p>假设你是一位卡车司机，被雇佣运输一车土豆从 BI 地到 MM 地，两地距离 2500km。由于限速，你预估自己能以 100km/hr 的速度行驶，所以全程需要 25 小时。</p>
</blockquote>
<h4 id="A"><a href="#A" class="headerlink" title="A"></a>A</h4><blockquote>
<p>你听新闻说，MM 地刚刚取消限速，相当于全程中的 1500km，你的卡车能以 150km/hr 的速度行驶。那么全程的加速比是多少？</p>
</blockquote>
<h4 id="B"><a href="#B" class="headerlink" title="B"></a>B</h4><blockquote>
<p>你可以为你的卡车购买一个新的涡轮增压器。经销商处有不同的型号，但是速度越快，价格也就越贵。如果想在全程拥有 1.67* 的加速比，那么你需要以多快的速度行驶？</p>
</blockquote>
<h3 id="Practice-Problem-1-2"><a href="#Practice-Problem-1-2" class="headerlink" title="Practice Problem 1.2"></a>Practice Problem 1.2</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;第一章：计算机系统之旅&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="CSAPP" scheme="https://maimieng.com/tags/CSAPP/"/>
    
      <category term="Reading" scheme="https://maimieng.com/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的字符串截取</title>
    <link href="https://maimieng.com/2016/37/"/>
    <id>https://maimieng.com/2016/37/</id>
    <published>2016-12-13T16:00:00.000Z</published>
    <updated>2016-12-14T10:47:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Substring in Swift 3.0<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.2 Beta</li>
<li>Xcode 8.2 Beta</li>
<li>Swift 3.0</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>最近更文的频率也是越来越慢，除去已到期末的缘故，加上在忙老师的项目，自己的时间便被压缩殆尽。不过好在 <a href="https://github.com/kingcos/Swift-3-Design-Patterns" target="_blank" rel="external">Swift 设计模式</a>基本上已经更新完毕，下来就准备补齐每个模式对应的说明。</p>
</blockquote>
<p>在尝试使用 Swift 实现《大话设计模式》一书中的<a href="https://github.com/kingcos/Swift-3-Design-Patterns/blob/master/24-Interpreter_Pattern.playground/Contents.swift" target="_blank" rel="external">解释器模式</a>时，书中的 Demo 多次使用了截取字符串的方法，当然，Swift 作为一门先进的编程语言不会缺少这一常用的方法。然而在使用中，可能由于 Swift 是一门较为注重（类型）安全的语言，其字符串截取方法使用方式与 Java 等编程语言便有一些语法上的不同。在 Swift 自身的迭代过程中，这部分的语法变化也很大。所以这次就来简单研究一下 Swift 中的字符串截取。需要注意的是，虽然 Swift 也可以使用 NSString 类型的字符串，而且两者可以很容易的桥接，但考虑到个人对 Objective-C 的了解程度，便暂时不探讨。</p>
<h2 id="String-Index"><a href="#String-Index" class="headerlink" title="String.Index"></a>String.Index</h2><h3 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h3><blockquote>
<p>索引与下标，即 index 和 subscript。一般来说，两者的概念是类似的，不过个人觉得索引有泛指的概念，而下标是具体的。</p>
</blockquote>
<p>Swift 中字符串的索引类型并不是其他语言中的整型（int），而是 String.Index。String.Index，即标注字符串的索引类型。在 Swift 的标准库中，可以看到其本质是 <code>String.CharacterView.Index</code> 的别名。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// The index type for subscripting a string.</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Index</span> = <span class="type">String</span>.<span class="type">CharacterView</span>.<span class="type">Index</span></div></pre></td></tr></table></figure>
<p>再进一步查看 <code>String.CharacterView</code>，即创建给定字符串的<strong>字符</strong>视图类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">CharacterView</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/// Creates a view of the given string.</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> text: <span class="type">String</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>常用的 <code>&quot;maimieng.com&quot;.characters</code> 的类型其实就是 <code>String.CharacterView</code> 类型。<code>.characters</code> 将字符串内容转化为字符序列的视图。</p>
<h3 id="start-amp-end"><a href="#start-amp-end" class="headerlink" title="start &amp; end"></a>start &amp; end</h3><p>字符串必然是一个字符的有限序列，Swift 为了方便开发者迅速定位，便集成了 <code>startIndex</code> 和 <code>endIndex</code>。但是需要注意的是：<code>startIndex</code> 是指字符串的第一个字符的下标，而 <code>endIndex</code> 是指字符串的最后一个字符<strong>之后</strong>的下标。当字符串为空时，<code>startIndex</code> 和 <code>endIndex</code> 相同。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"maimieng.com"</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(str.characters.<span class="built_in">count</span>)</div><div class="line"></div><div class="line"><span class="built_in">print</span>(str.startIndex)</div><div class="line"><span class="built_in">print</span>(str.endIndex)</div><div class="line"></div><div class="line"><span class="comment">// 12</span></div><div class="line"><span class="comment">// Index(_base: Swift.String.UnicodeScalarView.Index(_position: 0), _countUTF16: 1)</span></div><div class="line"><span class="comment">// Index(_base: Swift.String.UnicodeScalarView.Index(_position: 12), _countUTF16: 0)</span></div></pre></td></tr></table></figure>
<p>从上面的 Demo 也可以看出，<code>startIndex</code> 的位置为 0，而 <code>endIndex</code> 的位置为 12，等同于字符串的长度，而<strong>不是</strong>字符串长度减一。</p>
<p>除了给出了起始和结尾的下标，Swift 也提供了根据下标定位其他索引的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: String.Index)</span></span> -&gt; <span class="type">String</span>.<span class="type">Index</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(before i: String.Index)</span></span> -&gt; <span class="type">String</span>.<span class="type">Index</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(<span class="number">_</span> i: String.Index, offsetBy n: String.IndexDistance)</span></span> -&gt; <span class="type">String</span>.<span class="type">Index</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(<span class="number">_</span> i: String.Index, offsetBy n: String.IndexDistance, limitedBy limit: String.Index)</span></span> -&gt; <span class="type">String</span>.<span class="type">Index</span>?</div></pre></td></tr></table></figure>
<p>这样就可以通过给出的 <code>startIndex</code> 和 <code>endIndex</code> 来定位到其他的下标了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"maimieng.com"</span></div><div class="line"></div><div class="line"><span class="comment">// 返回传入下标之后的下标</span></div><div class="line"><span class="built_in">print</span>(str.index(after: str.startIndex))</div><div class="line"><span class="comment">// 返回传入下标之前的下标</span></div><div class="line"><span class="built_in">print</span>(str.index(before: str.endIndex))</div><div class="line"></div><div class="line"><span class="comment">// 返回传入下标偏移后的下标（偏移量可正可负可为 0）</span></div><div class="line"><span class="built_in">print</span>(str.index(str.startIndex, offsetBy: <span class="number">1</span>))</div><div class="line"></div><div class="line"><span class="comment">// print(str.index(str.endIndex, offsetBy: 10))</span></div><div class="line"><span class="comment">// 作用同上，但如果超过传入的界限返回 nil</span></div><div class="line"><span class="built_in">print</span>(str.index(str.endIndex, offsetBy: <span class="number">10</span>, limitedBy: str.endIndex) ?? <span class="string">"越界"</span>)</div></pre></td></tr></table></figure>
<p>下标之间的间距，也可以利用 <code>func distance(from start: String.Index, to end: String.Index) -&gt; String.IndexDistance</code> 方法求出：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"maimieng.com"</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(str.<span class="built_in">distance</span>(from: str.startIndex, to: str.endIndex))</div><div class="line"><span class="comment">// 12</span></div><div class="line"><span class="built_in">print</span>(str.<span class="built_in">distance</span>(from: str.endIndex, to: str.startIndex))</div><div class="line"><span class="comment">// -12</span></div></pre></td></tr></table></figure>
<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p>Range 即范围，Swift 中实现了 Comparable 协议的类型都可以用 Range 来表示范围。以下的 Range 特指：<code>Range&lt;String.Index&gt;</code>。</p>
<p>Range 的构造方法是 <code>init(uncheckedBounds bounds: (lower: Bound, upper: Bound))</code>。即传入一个元组，返回一个范围。需要注意的是：这个范围 Swift 是不会检查的，需要程序员自觉维护。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"maimieng.com"</span></div><div class="line"></div><div class="line"><span class="comment">// 前闭后开</span></div><div class="line"><span class="keyword">let</span> rangeA = <span class="type">Range</span>(uncheckedBounds: (str.startIndex, str.endIndex))</div><div class="line"><span class="built_in">print</span>(rangeA)</div><div class="line"><span class="comment">// Index(_base: Swift.String.UnicodeScalarView.Index(_position: 0), _countUTF16: 1)..&lt;Index(_base: Swift.String.UnicodeScalarView.Index(_position: 12), _countUTF16: 0)</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(str.substring(with: rangeA))</div><div class="line"><span class="comment">// maimieng.com</span></div><div class="line"></div><div class="line"><span class="comment">// 即使范围首尾颠倒，也没有报错</span></div><div class="line"><span class="keyword">let</span> rangeB = <span class="type">Range</span>(uncheckedBounds: (str.endIndex, str.startIndex))</div><div class="line"><span class="built_in">print</span>(rangeB)</div><div class="line"><span class="comment">// Index(_base: Swift.String.UnicodeScalarView.Index(_position: 12), _countUTF16: 0)..&lt;Index(_base: Swift.String.UnicodeScalarView.Index(_position: 0), _countUTF16: 1)</span></div><div class="line"><span class="comment">// 但在使用中会出错</span></div><div class="line"><span class="comment">// fatal error: Can't form Range with upperBound &lt; lowerBound</span></div><div class="line"><span class="comment">// str.substring(with: rangeB)</span></div></pre></td></tr></table></figure>
<p>在上面的 Demo 中，从输出中也可以看出，<code>init(uncheckedBounds bounds: (lower: Bound, upper: Bound))</code> 构造的范围是一个<strong>前闭后开</strong>的区间。</p>
<p>Swift 中，字符串本身也能构造出 Range，例如：得到字符串子串的范围，若不存在则返回 nil：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"maimieng.com"</span></div><div class="line"></div><div class="line"><span class="comment">// 返回前闭后开的范围</span></div><div class="line"><span class="built_in">print</span>(str.range(of: <span class="string">".com"</span>) ?? <span class="string">"不存在"</span>)</div><div class="line"><span class="comment">// Index(_base: Swift.String.UnicodeScalarView.Index(_position: 8), _countUTF16: 1)..&lt;Index(_base: Swift.String.UnicodeScalarView.Index(_position: 12), _countUTF16: 0)</span></div></pre></td></tr></table></figure>
<h2 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h2><p>在 Range 一节的 Demo 中，已经使用了 <code>substring(with:)</code> 方法测试范围的使用。Swift 中的字符串截取与其他语言其实是相似的，都是根据索引或索引范围来截取，只是 Swift 中的索引的类型不是整型，稍有麻烦。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"maimieng.com"</span></div><div class="line"></div><div class="line"><span class="comment">// 截取传入范围（左开右闭）的子串</span></div><div class="line"><span class="keyword">let</span> range = <span class="type">Range</span>(uncheckedBounds: (str.startIndex, str.endIndex))</div><div class="line"><span class="built_in">print</span>(str.substring(with: range))</div><div class="line"></div><div class="line"><span class="comment">// 从传入的索引开始截取到末尾（含 str.startIndex 元素）</span></div><div class="line"><span class="built_in">print</span>(str.substring(from: str.startIndex))</div><div class="line"><span class="comment">// 从传入的索引的前一个位置开始截取到头部（不含 str.endIndex 元素）</span></div><div class="line"><span class="built_in">print</span>(str.substring(to: str.endIndex))</div><div class="line"></div><div class="line"><span class="comment">// maimieng.com</span></div><div class="line"><span class="comment">// maimieng.com</span></div><div class="line"><span class="comment">// maimieng.com</span></div></pre></td></tr></table></figure>
<p>以上的 Demo 便是 Swift 中最基本的截取字符串使用。然而有时候条件一多，代码的重复率也会增加，那么可以利用 Swift 中的 extension 来扩展原有的 String，让 Swift 的 String 可以像 C#、Java 一样截取字符串，需要注意的是 这里的 IndexDistance 实际上是 String.CharacterView.IndexDistance 的别名，而 String.CharacterView.IndexDistance 又是 Int 类型的别名。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">substring</span><span class="params">(from: IndexDistance)</span></span> -&gt; <span class="type">String</span>? &#123;</div><div class="line">        <span class="keyword">let</span> index = <span class="keyword">self</span>.index(<span class="keyword">self</span>.startIndex, offsetBy: from)</div><div class="line">        <span class="keyword">return</span> str.substring(from: index)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">substring</span><span class="params">(to: IndexDistance)</span></span> -&gt; <span class="type">String</span>? &#123;</div><div class="line">        <span class="keyword">let</span> index = <span class="keyword">self</span>.index(<span class="keyword">self</span>.startIndex, offsetBy: to + <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> str.substring(to: index)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">substring</span><span class="params">(with range: Range&lt;IndexDistance&gt;)</span></span> -&gt; <span class="type">String</span>? &#123;</div><div class="line">        <span class="keyword">let</span> lower = <span class="keyword">self</span>.index(<span class="keyword">self</span>.startIndex, offsetBy: range.lowerBound)</div><div class="line">        <span class="keyword">let</span> upper = <span class="keyword">self</span>.index(<span class="keyword">self</span>.startIndex, offsetBy: range.upperBound)</div><div class="line">        <span class="keyword">let</span> range = <span class="type">Range</span>(uncheckedBounds: (lower, upper))</div><div class="line">        <span class="keyword">return</span> str.substring(with: range)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">substring</span><span class="params">(<span class="number">_</span> lower: IndexDistance, <span class="number">_</span> range: IndexDistance)</span></span> -&gt; <span class="type">String</span>? &#123;</div><div class="line">        <span class="keyword">let</span> lowerIndex = <span class="keyword">self</span>.index(<span class="keyword">self</span>.startIndex, offsetBy: lower)</div><div class="line">        <span class="keyword">let</span> upperIndex = <span class="keyword">self</span>.index(lowerIndex, offsetBy: range)</div><div class="line">        <span class="keyword">let</span> range = <span class="type">Range</span>(uncheckedBounds: (lowerIndex, upperIndex))</div><div class="line">        <span class="keyword">return</span> str.substring(with: range)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(str.substring(to: <span class="number">0</span>) ?? <span class="string">"nil"</span>)</div><div class="line"><span class="built_in">print</span>(str.substring(from: <span class="number">2</span>) ?? <span class="string">"nil"</span>)</div><div class="line"><span class="built_in">print</span>(str.substring(with: <span class="number">0</span>..&lt;<span class="number">1</span>) ?? <span class="string">"nil"</span>)</div><div class="line"><span class="built_in">print</span>(str.substring(<span class="number">1</span>, <span class="number">2</span>) ?? <span class="string">"nil"</span>)</div><div class="line"></div><div class="line"><span class="comment">// m</span></div><div class="line"><span class="comment">// imieng.com</span></div><div class="line"><span class="comment">// m</span></div><div class="line"><span class="comment">// ai</span></div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Documentation &amp; API Reference</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Substring in Swift 3.0&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的值类型与引用类型</title>
    <link href="https://maimieng.com/2016/36/"/>
    <id>https://maimieng.com/2016/36/</id>
    <published>2016-11-21T16:00:00.000Z</published>
    <updated>2016-11-28T16:47:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Value Type &amp; Reference Type<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.2 Beta</li>
<li>Xcode 8.2 Beta</li>
<li>Swift 3.0</li>
</ul>
</li>
</ul>
<p><strong>2016-11-28 Update: 调整了行文顺序，并增加了一部分图文。</strong></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在学设计模式中，发现 Swift 中的 struct，class 以及 enum 在一般的使用中能够做到互相替换，因此探究其背后的逻辑就十分有必要。而这一问题又引出了 Swift 中的值类型和引用类型的区别。在网上搜寻一番，虽然也找到很多很棒的资料，不过有的有些过时，或是比较分散，因此总结一篇，以便自己加深印象，也方便与大家交流。</p>
<p>由于 Swift 中的 struct 为值类型，class 为引用类型，因此文中以这两种类型为代表来具体阐述。</p>
<h2 id="stack-amp-heap"><a href="#stack-amp-heap" class="headerlink" title="stack &amp; heap"></a>stack &amp; heap</h2><p>内存（RAM）中有两个区域，栈区（stack）和堆区（heap）。<strong>在 Swift 中，值类型，存放在栈区；引用类型，存放在堆区。</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RectClass</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> height = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RectStruct</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> height = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> rectCls = <span class="type">RectClass</span>()</div><div class="line"><span class="keyword">var</span> rectStrct = <span class="type">RectStruct</span>()</div></pre></td></tr></table></figure>
<p><img src="https://o7y30w6c6.qnssl.com/blog/swift_vrtype_01.png" alt="stack &amp; heap in RAM"></p>
<h2 id="值类型-amp-引用类型"><a href="#值类型-amp-引用类型" class="headerlink" title="值类型 &amp; 引用类型"></a>值类型 &amp; 引用类型</h2><h3 id="值类型（Value-Type）"><a href="#值类型（Value-Type）" class="headerlink" title="值类型（Value Type）"></a>值类型（Value Type）</h3><p><strong>值类型，即每个实例保持一份数据拷贝。</strong></p>
<p>在 Swift 中，典型的有 struct，enum，以及 tuple 都是值类型。而平时使用的 <code>Int</code>，    <code>Double</code>，<code>Float</code>，<code>String</code>，<code>Array</code>，<code>Dictionary</code>，<code>Set</code> 其实都是用结构体实现的，也是值类型。</p>
<p>Swift 中，值类型的赋值为深拷贝（Deep Copy），值语义（Value Semantics）即新对象和源对象是独立的，当改变新对象的属性，源对象不会受到影响，反之同理。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/swift_vrtype_02.png" alt="值类型"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CoordinateStruct</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x: <span class="type">Double</span></div><div class="line">    <span class="keyword">var</span> y: <span class="type">Double</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> coordA = <span class="type">CoordinateStruct</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</div><div class="line"><span class="keyword">var</span> coordB = coordA</div><div class="line"></div><div class="line">coordA.x = <span class="number">100.0</span></div><div class="line"><span class="built_in">print</span>(<span class="string">"coordA.x -&gt; \(coordA.x)"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"coordB.x -&gt; \(coordB.x)"</span>)</div><div class="line"></div><div class="line"><span class="comment">// coordA.x -&gt; 100.0</span></div><div class="line"><span class="comment">// coordB.x -&gt; 0.0</span></div></pre></td></tr></table></figure>
<p>如果声明一个值类型的<strong>常量</strong>，那么就意味着该常量是不可变的（无论内部数据为 <code>var</code>/<code>let</code>）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> coordC = <span class="type">CoordinateStruct</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</div><div class="line"><span class="comment">// WRONG: coordC.x = 100.0</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在 Swift 3.0 中，可以使用 <code>withUnsafePointer(to:_:)</code> 函数来打印<strong>值类型</strong>变量的内存地址，这样就能看出两个变量的内存地址并不相同。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;coordA) &#123; <span class="built_in">print</span>(<span class="string">"\($0)"</span>) &#125;</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;coordB) &#123; <span class="built_in">print</span>(<span class="string">"\($0)"</span>) &#125;</div><div class="line"></div><div class="line"><span class="comment">// 0x000000011df6ec10</span></div><div class="line"><span class="comment">// 0x000000011df6ec20</span></div></pre></td></tr></table></figure>
<p>在 Swift 中，双等号（<code>==</code> &amp; <code>!=</code>）可以用来比较变量存储的内容是否一致，如果要让我们的 <code>struct</code> 类型支持该符号，则必须遵守 <code>Equatable</code> 协议。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CoordinateStruct</span>: <span class="title">Equatable</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(<span class="keyword">left</span>: CoordinateStruct, <span class="keyword">right</span>: CoordinateStruct)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">left</span>.x == <span class="keyword">right</span>.x &amp;&amp; <span class="keyword">left</span>.y == <span class="keyword">right</span>.y)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> coordA != coordB &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"coordA != coordB"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// coordA != coordB</span></div></pre></td></tr></table></figure>
<h3 id="引用类型（Reference-Type）"><a href="#引用类型（Reference-Type）" class="headerlink" title="引用类型（Reference Type）"></a>引用类型（Reference Type）</h3><p><strong>引用类型，即所有实例共享一份数据拷贝。</strong></p>
<p>在 Swift 中，class 和闭包是引用类型。引用类型的赋值是浅拷贝（Shallow Copy），引用语义（Reference Semantics）即新对象和源对象的变量名不同，但其引用（指向的内存空间）是一样的，因此当使用新对象操作其内部数据时，源对象的内部数据也会受到影响。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/swift_vrtype_03.png" alt="引用类型"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> height = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> weight = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> dogA = <span class="type">Dog</span>()</div><div class="line"><span class="keyword">var</span> dogB = dogA</div><div class="line"></div><div class="line">dogA.height = <span class="number">50.0</span></div><div class="line"><span class="built_in">print</span>(<span class="string">"dogA.height -&gt; \(dogA.height)"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"dogB.height -&gt; \(dogB.height)"</span>)</div><div class="line"></div><div class="line"><span class="comment">// dogA.height -&gt; 50.0</span></div><div class="line"><span class="comment">// dogB.height -&gt; 50.0</span></div></pre></td></tr></table></figure>
<p>如果声明一个引用类型的<strong>常量</strong>，那么就意味着该常量的引用不能改变（即不能被同类型变量赋值），但指向的内存中所存储的<strong>变量</strong>是可以改变的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> dogC = <span class="type">Dog</span>()</div><div class="line">dogC.height = <span class="number">50</span></div><div class="line"></div><div class="line"><span class="comment">// WRONG: dogC = dogA</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在 Swift 3.0 中，可以使用以下方法来打印<strong>引用类型</strong>变量指向的内存地址。从中即可发现，两个变量指向的是同一块内存空间。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(<span class="type">Unmanaged</span>.passUnretained(dogA).toOpaque())</div><div class="line"><span class="built_in">print</span>(<span class="type">Unmanaged</span>.passUnretained(dogB).toOpaque())</div><div class="line"></div><div class="line"><span class="comment">// 0x0000600000031380</span></div><div class="line"><span class="comment">// 0x0000600000031380</span></div></pre></td></tr></table></figure>
<p>在 Swift 中，三等号（<code>===</code> &amp; <code>!==</code>）可以用来比较引用类型的引用（即指向的内存地址）是否一致。也可以在遵守 <code>Equatable</code> 协议后，使用双等号（<code>==</code> &amp; <code>!=</code>）用来比较变量的内容是否一致。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (dogA === dogB) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"dogA === dogB"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// dogA === dogB</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> dogC !== dogA &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"dogC !== dogA"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// dogC !== dogA</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Animal</span>: <span class="title">Equatable</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(<span class="keyword">left</span>: Animal, <span class="keyword">right</span>: Animal)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">left</span>.height == <span class="keyword">right</span>.height &amp;&amp; <span class="keyword">left</span>.weight == <span class="keyword">right</span>.weight)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> dogC == dogA &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"dogC == dogA"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// dogC == dogA</span></div></pre></td></tr></table></figure>
<h3 id="参数-与-inout"><a href="#参数-与-inout" class="headerlink" title="参数 与 inout"></a>参数 与 inout</h3><h4 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h4><p>定义一个 <code>ResolutionStruct</code> 结构体，以及一个 <code>ResolutionClass</code> 类。这里为了方便打印对象属性，<code>ResolutionClass</code> 类遵从了 <code>CustomStringConvertible</code> 协议。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ResolutionStruct</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> height = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResolutionClass</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> height = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"ResolutionClass(height: \(height), width: \(width))"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h4><p>在 Swift 中，函数的参数默认为<strong>常量</strong>，即在函数体内只能访问参数，而不能修改参数值。具体来说：</p>
<ol>
<li>值类型作为参数传入时，函数体内部不能修改其值</li>
<li>引用类型作为参数传入时，函数体内部不能修改其指向的内存地址，但是可以修改其内部的变量值</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(sct: ResolutionStruct)</span></span> &#123;</div><div class="line"><span class="comment">//    WRONG: sct.height = 1080</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> sct = sct</div><div class="line">    sct.height = <span class="number">1080</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(clss: ResolutionClass)</span></span> &#123;</div><div class="line"><span class="comment">//    WRONG: clss = ResolutionClass()</span></div><div class="line">    clss.height = <span class="number">1080</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> clss = clss</div><div class="line">    clss = <span class="type">ResolutionClass</span>()</div><div class="line">    clss.height = <span class="number">1440</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是如果要改变参数值或引用，那么就可以在函数体内部直接<strong>声明同名变量</strong>，并把原有变量赋值于新变量，那么这个新的变量就可以更改其值或引用。那么在函数参数的作用域和生命周期是什么呢？我们来测试一下，定义两个函数，目的为交换内部的 <code>height</code> 和 <code>width</code>。</p>
<p><strong>值类型</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(resSct: ResolutionStruct)</span></span> -&gt; <span class="type">ResolutionStruct</span> &#123;</div><div class="line">    <span class="keyword">var</span> resSct = resSct</div><div class="line">    <span class="built_in">withUnsafePointer</span>(to: &amp;resSct) &#123; <span class="built_in">print</span>(<span class="string">"During calling: \($0)"</span>) &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> temp = resSct.height</div><div class="line">    resSct.height = resSct.width</div><div class="line">    resSct.width = temp</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> resSct</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> iPhone4ResoStruct = <span class="type">ResolutionStruct</span>(height: <span class="number">960</span>, width: <span class="number">640</span>)</div><div class="line"><span class="built_in">print</span>(iPhone4ResoStruct)</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;iPhone4ResoStruct) &#123; <span class="built_in">print</span>(<span class="string">"Before calling: \($0)"</span>) &#125;</div><div class="line"><span class="built_in">print</span>(<span class="built_in">swap</span>(resSct: iPhone4ResoStruct))</div><div class="line"><span class="built_in">print</span>(iPhone4ResoStruct)</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;iPhone4ResoStruct) &#123; <span class="built_in">print</span>(<span class="string">"After calling: \($0)"</span>) &#125;</div><div class="line"></div><div class="line"><span class="comment">// ResolutionStruct(height: 960.0, width: 640.0)</span></div><div class="line"><span class="comment">// Before calling: 0x00000001138d6f50</span></div><div class="line"><span class="comment">// During calling: 0x00007fff5a512148</span></div><div class="line"><span class="comment">// ResolutionStruct(height: 640.0, width: 960.0)</span></div><div class="line"><span class="comment">// ResolutionStruct(height: 960.0, width: 640.0)</span></div><div class="line"><span class="comment">// After calling: 0x00000001138d6f50</span></div></pre></td></tr></table></figure>
<p>小结：在调用函数前后，外界变量值并<strong>没有</strong>因为函数内对参数的修改而发生变化，而且函数体内参数的内存地址与外界<strong>不同</strong>。因此：<strong>当值类型的变量作为参数被传入函数时，相当于创建了新的常量并初始化为传入的变量值，该参数的作用域及生命周期仅存在于函数体内。</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(resCls: ResolutionClass)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"During calling: \(Unmanaged.passUnretained(resCls).toOpaque())"</span>)</div><div class="line">    <span class="keyword">let</span> temp = resCls.height</div><div class="line">    </div><div class="line">    resCls.height = resCls.width</div><div class="line">    resCls.width = temp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iPhone5ResoClss = <span class="type">ResolutionClass</span>()</div><div class="line">iPhone5ResoClss.height = <span class="number">1136</span></div><div class="line">iPhone5ResoClss.width = <span class="number">640</span></div><div class="line"><span class="built_in">print</span>(iPhone5ResoClss)</div><div class="line"><span class="built_in">print</span>(<span class="string">"Before calling: \(Unmanaged.passUnretained(iPhone5ResoClss).toOpaque())"</span>)</div><div class="line"><span class="built_in">swap</span>(resCls: iPhone5ResoClss)</div><div class="line"><span class="built_in">print</span>(iPhone5ResoClss)</div><div class="line"><span class="built_in">print</span>(<span class="string">"After calling: \(Unmanaged.passUnretained(iPhone5ResoClss).toOpaque())"</span>)</div><div class="line"></div><div class="line"><span class="comment">// ResolutionClass(height: 1136.0, width: 640.0)</span></div><div class="line"><span class="comment">// Before calling: 0x00006000000220e0</span></div><div class="line"><span class="comment">// During calling: 0x00006000000220e0</span></div><div class="line"><span class="comment">// ResolutionClass(height: 640.0, width: 1136.0)</span></div><div class="line"><span class="comment">// After calling: 0x00006000000220e0</span></div></pre></td></tr></table></figure>
<p>小结：在调用函数前后，外界变量值随函数内对参数的修改而发生变化，而且函数体内参数的内存地址与外界<strong>一致</strong>。因此：<strong>当引用类型的变量作为参数被传入函数时，相当于创建了新的常量并初始化为传入的变量引用，当函数体内操作参数指向的数据，函数体外也受到了影响。</strong></p>
<h4 id="inout"><a href="#inout" class="headerlink" title="inout"></a>inout</h4><p><code>inout</code>  是 Swift 中的关键字，可以放置于参数类型前，冒号之后。使用 <code>inout</code> 之后，函数体内部可以直接更改参数值，而且改变会保留。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(resSct: <span class="keyword">inout</span> ResolutionStruct)</span></span> &#123;</div><div class="line">    <span class="built_in">withUnsafePointer</span>(to: &amp;resSct) &#123; <span class="built_in">print</span>(<span class="string">"During calling: \($0)"</span>) &#125;</div><div class="line">    <span class="keyword">let</span> temp = resSct.height</div><div class="line">    resSct.height = resSct.width</div><div class="line">    resSct.width = temp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> iPhone6ResoStruct = <span class="type">ResolutionStruct</span>(height: <span class="number">1334</span>, width: <span class="number">750</span>)</div><div class="line"><span class="built_in">print</span>(iPhone6ResoStruct)</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;iPhone6ResoStruct) &#123; <span class="built_in">print</span>(<span class="string">"Before calling: \($0)"</span>) &#125;</div><div class="line"><span class="built_in">swap</span>(resSct: &amp;iPhone6ResoStruct)</div><div class="line"><span class="built_in">print</span>(iPhone6ResoStruct)</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;iPhone6ResoStruct) &#123; <span class="built_in">print</span>(<span class="string">"After calling: \($0)"</span>) &#125;</div><div class="line"></div><div class="line"><span class="comment">// ResolutionStruct(height: 1334.0, width: 750.0)</span></div><div class="line"><span class="comment">// Before calling: 0x000000011ce62f50</span></div><div class="line"><span class="comment">// During calling: 0x000000011ce62f50</span></div><div class="line"><span class="comment">// ResolutionStruct(height: 750.0, width: 1334.0)</span></div><div class="line"><span class="comment">// After calling: 0x000000011ce62f50</span></div></pre></td></tr></table></figure>
<p>小结：<strong>值类型变量作为参数传入函数，外界和函数参数的内存地址一致，函数内对参数的更改得到了保留。</strong></p>
<p>引用类型也可以使用 <code>inout</code> 参数，但意义不大。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(clss: <span class="keyword">inout</span> ResolutionClass)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"During calling: \(Unmanaged.passUnretained(clss).toOpaque())"</span>)</div><div class="line">    <span class="keyword">let</span> temp = clss.height</div><div class="line">    clss.height = clss.width</div><div class="line">    clss.width = temp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> iPhone7PlusResClss = <span class="type">ResolutionClass</span>()</div><div class="line">iPhone7PlusResClss.height = <span class="number">1080</span></div><div class="line">iPhone7PlusResClss.width = <span class="number">1920</span></div><div class="line"><span class="built_in">print</span>(iPhone7PlusResClss)</div><div class="line"><span class="built_in">print</span>(<span class="string">"Before calling: \(Unmanaged.passUnretained(iPhone7PlusResClss).toOpaque())"</span>)</div><div class="line"><span class="built_in">swap</span>(clss: &amp;iPhone7PlusResClss)</div><div class="line"><span class="built_in">print</span>(iPhone7PlusResClss)</div><div class="line"><span class="built_in">print</span>(<span class="string">"After calling: \(Unmanaged.passUnretained(iPhone7PlusResClss).toOpaque())"</span>)</div><div class="line"></div><div class="line"><span class="comment">// ResolutionClass(height: 1080.0, width: 1920.0)</span></div><div class="line"><span class="comment">// Before calling: 0x000060000003e580</span></div><div class="line"><span class="comment">// During calling: 0x000060000003e580</span></div><div class="line"><span class="comment">// ResolutionClass(height: 1920.0, width: 1080.0)</span></div><div class="line"><span class="comment">// After calling: 0x000060000003e580</span></div></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ol>
<li>使用 <code>inout</code> 关键字的函数，在调用时需要在该参数前加上 <code>&amp;</code> 符号</li>
<li><code>inout</code> 参数在传入时必须为变量，不能为常量或字面量（literal）</li>
<li><code>inout</code> 参数不能有默认值，不能为可变参数</li>
<li><code>inout</code> 参数不等同于函数返回值，是一种使参数的作用域超出函数体的方式</li>
<li>多个 <code>inout</code> 参数不能同时传入同一个变量，因为拷入拷出的顺序不定，那么最终值也不能确定</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> y = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> height = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"center GETTER call"</span>)</div><div class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: origin.x + width / <span class="number">2</span>,</div><div class="line">                         y: origin.y + height / <span class="number">2</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">set</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"center SETTER call"</span>)</div><div class="line">            origin.x = newValue.x - width / <span class="number">2</span></div><div class="line">            origin.y = newValue.y - height / <span class="number">2</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">(center: <span class="keyword">inout</span> Point)</span></span> &#123;</div><div class="line">        center.x = <span class="number">0.0</span></div><div class="line">        center.y = <span class="number">0.0</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> rect = <span class="type">Rectangle</span>(width: <span class="number">100</span>, height: <span class="number">100</span>, origin: <span class="type">Point</span>(x: -<span class="number">100</span>, y: -<span class="number">100</span>))</div><div class="line"><span class="built_in">print</span>(rect.center)</div><div class="line">rect.reset(center: &amp;rect.center)</div><div class="line"><span class="built_in">print</span>(rect.center)</div><div class="line"></div><div class="line"><span class="comment">// center GETTER call</span></div><div class="line"><span class="comment">// Point(x: -50.0, y: -50.0)</span></div><div class="line"></div><div class="line"><span class="comment">// center GETTER call</span></div><div class="line"><span class="comment">// center SETTER call</span></div><div class="line"></div><div class="line"><span class="comment">// center GETTER call</span></div><div class="line"><span class="comment">// Point(x: 0.0, y: 0.0)</span></div></pre></td></tr></table></figure>
<p><code>inout</code> 参数的传递过程：</p>
<ol>
<li>当函数被调用时，参数值被拷贝</li>
<li>在函数体内，被拷贝的参数修改</li>
<li>函数返回时，被拷贝的参数值被赋值给原有的变量</li>
</ol>
<p>官方称这个行为为：<code>copy-in copy-out</code> 或 <code>call by value result</code>。我们可以使用 KVO 或计算属性来跟踪这一过程，这里以计算属性为例。排除在调用函数之前与之后的 <code>center GETTER call</code>，从中可以发现：参数值先被获取到（setter 被调用），接着被设值（setter 被调用）。</p>
<p>根据 <code>inout</code> 参数的传递过程，可以得知：<code>inout</code> 参数的本质与引用类型的传参并不是同一回事。<code>inout</code> 参数打破了其生命周期，是一个可变浅拷贝。在 Swift 3.0 中，也彻底摒除了在逃逸闭包（Escape Closure）中被捕获。苹果官方也有如下的说明：</p>
<blockquote>
<p>As an optimization, when the argument is a value stored at a physical address in memory, the same memory location is used both inside and outside the function body. The optimized behavior is known as <em>call by reference</em>; it satisfies all of the requirements of the copy-in copy-out model while removing the overhead of copying. Write your code using the model given by copy-in copy-out, without depending on the call-by-reference optimization, so that it behaves correctly with or without the optimization.</p>
<p>作为一种优化，当参数是一个存储于内存中实际地址的值时，函数体内外共用相同的一块内存地址。该优化行为被称作<em>通过引用调用</em>；其满足 copy-in copy-out 模型的所有必需条件，同时消除了拷贝时的开销。不依赖于通过引用调用的优化，使用 copy-in copy-out 提供的模型来写代码，以便在进不进行优化时（都能）正确运行。</p>
</blockquote>
<h3 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h3><p>在实际使用中，其实值类型和引用类型并不是孤立的，有时值类型里会存在引用类型的变量，反之亦然。这里简要介绍这四种嵌套类型。</p>
<h4 id="值类型嵌套值类型"><a href="#值类型嵌套值类型" class="headerlink" title="值类型嵌套值类型"></a>值类型嵌套值类型</h4><p>值类型嵌套值类型时，赋值时创建了新的变量，两者是独立的，嵌套的值类型变量也会创建新的变量，这两者也是独立的。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/swift_vrtype_04.png" alt="值类型嵌套值类型"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> circleA = <span class="type">Circle</span>(radius: <span class="number">5.0</span>)</div><div class="line"><span class="keyword">var</span> circleB = circleA</div><div class="line">circleA.radius = <span class="number">10</span></div><div class="line"><span class="built_in">print</span>(circleA)</div><div class="line"><span class="built_in">print</span>(circleB)</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;circleA) &#123; <span class="built_in">print</span>(<span class="string">"circleA: \($0)"</span>) &#125;</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;circleB) &#123; <span class="built_in">print</span>(<span class="string">"circleB: \($0)"</span>) &#125;</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;circleA.radius) &#123; <span class="built_in">print</span>(<span class="string">"circleA.radius: \($0)"</span>) &#125;</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;circleB.radius) &#123; <span class="built_in">print</span>(<span class="string">"circleB.radius: \($0)"</span>) &#125;</div><div class="line"></div><div class="line"><span class="comment">// Circle(radius: 10.0)</span></div><div class="line"><span class="comment">// Circle(radius: 5.0)</span></div><div class="line"><span class="comment">// circleA: 0x000000011dc6dc90</span></div><div class="line"><span class="comment">// circleB: 0x000000011dc6dc98</span></div><div class="line"><span class="comment">// circleA.radius: 0x000000011dc6dc90</span></div><div class="line"><span class="comment">// circleB.radius: 0x000000011dc6dc98</span></div></pre></td></tr></table></figure>
<h4 id="值类型嵌套引用类型"><a href="#值类型嵌套引用类型" class="headerlink" title="值类型嵌套引用类型"></a>值类型嵌套引用类型</h4><p>值类型嵌套引用类型时，赋值时创建了新的变量，两者是独立的，但嵌套的引用类型指向的是同一块内存空间，当改变值类型内部嵌套的引用类型变量值时（除了重新初始化），其他对象的该属性也会随之改变。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/swift_vrtype_05.png" alt="值类型嵌套引用类型"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointClass</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x: <span class="type">Double</span></div><div class="line">    <span class="keyword">var</span> y: <span class="type">Double</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"(\(x), \(y))"</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.x = x</div><div class="line">        <span class="keyword">self</span>.y = y</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> center: <span class="type">PointClass</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> circleA = <span class="type">Circle</span>(center: <span class="type">PointClass</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>))</div><div class="line"><span class="keyword">var</span> circleB = circleA</div><div class="line">circleA.center.x = <span class="number">10.0</span></div><div class="line"><span class="built_in">print</span>(circleA)</div><div class="line"><span class="built_in">print</span>(circleB)</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;circleA) &#123; <span class="built_in">print</span>(<span class="string">"circleA: \($0)"</span>) &#125;</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;circleB) &#123; <span class="built_in">print</span>(<span class="string">"circleB: \($0)"</span>) &#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"circleA.center: \(Unmanaged.passUnretained(circleA.center).toOpaque())"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"circleB.center: \(Unmanaged.passUnretained(circleB.center).toOpaque())"</span>)</div><div class="line"></div><div class="line"><span class="comment">// Circle(center: (10.0, 0.0))</span></div><div class="line"><span class="comment">// Circle(center: (10.0, 0.0))</span></div><div class="line"><span class="comment">// circleA: 0x0000000118251fa0</span></div><div class="line"><span class="comment">// circleB: 0x0000000118251fa8</span></div><div class="line"><span class="comment">// circleA.center: 0x000060000003e100</span></div><div class="line"><span class="comment">// circleB.center: 0x000060000003e100</span></div></pre></td></tr></table></figure>
<h4 id="引用类型嵌套值类型"><a href="#引用类型嵌套值类型" class="headerlink" title="引用类型嵌套值类型"></a>引用类型嵌套值类型</h4><p>引用类型嵌套值类型时，赋值时创建了新的变量，但是新变量和源变量指向同一块内存，因此改变源变量的内部值，会影响到其他变量的值。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/swift_vrtype_06.png" alt="引用类型嵌套值类型"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Radius:\(radius)"</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(radius: <span class="type">Double</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.radius = radius</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> circleA = <span class="type">Circle</span>(radius: <span class="number">0.0</span>)</div><div class="line"><span class="keyword">var</span> circleB = circleA</div><div class="line"></div><div class="line">circleA.radius = <span class="number">5.0</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(circleA)</div><div class="line"><span class="built_in">print</span>(circleB)</div><div class="line"><span class="built_in">print</span>(<span class="string">"circleA: \(Unmanaged.passUnretained(circleA).toOpaque())"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"circleB: \(Unmanaged.passUnretained(circleB).toOpaque())"</span>)</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;circleA.radius) &#123; <span class="built_in">print</span>(<span class="string">"circleA.radius: \($0)"</span>) &#125;</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;circleB.radius) &#123; <span class="built_in">print</span>(<span class="string">"circleB.radius: \($0)"</span>) &#125;</div><div class="line"></div><div class="line"><span class="comment">// Radius:5.0</span></div><div class="line"><span class="comment">// Radius:5.0</span></div><div class="line"><span class="comment">// circleA: 0x000060000003bc80</span></div><div class="line"><span class="comment">// circleB: 0x000060000003bc80</span></div><div class="line"><span class="comment">// circleA.radius: 0x000060000003bc90</span></div><div class="line"><span class="comment">// circleB.radius: 0x000060000003bc90</span></div></pre></td></tr></table></figure>
<h4 id="引用类型嵌套引用类型"><a href="#引用类型嵌套引用类型" class="headerlink" title="引用类型嵌套引用类型"></a>引用类型嵌套引用类型</h4><p>引用类型嵌套引用类型时，赋值时创建了新的变量，但是新变量和源变量指向同一块内存，内部引用类型变量也指向同一块内存地址，改变引用类型嵌套的引用类型的值，也会影响到其他变量的值。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/swift_vrtype_07.png" alt="引用类型嵌套引用类型"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointClass</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x: <span class="type">Double</span></div><div class="line">    <span class="keyword">var</span> y: <span class="type">Double</span></div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.x = x</div><div class="line">        <span class="keyword">self</span>.y = y</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"(\(x), \(y))"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> center: <span class="type">PointClass</span></div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Center:\(center)"</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(center: <span class="type">PointClass</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.center = center</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> circleA = <span class="type">Circle</span>(center: <span class="type">PointClass</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>))</div><div class="line"><span class="keyword">let</span> circleB = circleA</div><div class="line"></div><div class="line">circleA.center.x = <span class="number">5.0</span></div><div class="line"><span class="built_in">print</span>(circleA)</div><div class="line"><span class="built_in">print</span>(circleB)</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"circleA: \(Unmanaged.passUnretained(circleA).toOpaque())"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"circleB: \(Unmanaged.passUnretained(circleB).toOpaque())"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"circleA.center: \(Unmanaged.passUnretained(circleA.center).toOpaque())"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"circleB.center: \(Unmanaged.passUnretained(circleB.center).toOpaque())"</span>)</div><div class="line"></div><div class="line"><span class="comment">// Center:(5.0, 0.0)</span></div><div class="line"><span class="comment">// Center:(5.0, 0.0)</span></div><div class="line"><span class="comment">// circleA: 0x0000608000025fa0</span></div><div class="line"><span class="comment">// circleB: 0x0000608000025fa0</span></div><div class="line"><span class="comment">// circleA.center: 0x0000608000025820</span></div><div class="line"><span class="comment">// circleB.center: 0x0000608000025820</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章是我在着手写 <a href="https://maimieng.com/2016/37/">Swift 中的 struct &amp; class &amp; enum</a> 一文时抽离出来的一篇。主要还是围绕了值类型中的 struct 和引用类型中的 class，在本文 stack &amp; heap 一节中，只是简单描述，因为一直对此部分内容感到迷惑，也查阅很多资料，希望最近可以总结出来一篇小文，与大家分享。</p>
<table>
<thead>
<tr>
<th>When</th>
<th>值类型 Value Type</th>
<th>引用类型 Reference Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>==</code> 有意义时</td>
<td><code>===</code> 有意义时</td>
</tr>
<tr>
<td>2</td>
<td>独立</td>
<td>共享，可变</td>
</tr>
<tr>
<td>3</td>
<td>在多线程使用的数据</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>在本文的叙述中，可能有许多说法与您平时所用的术语略有差池，例如变量指向的内存空间，其实也等价于变量指向的内存地址。在行文过程中，查阅了很多国外的资料，也尽力将语言规范，以免产生歧义，如果有任何错误或建议，您都可以在评论中直接提出，我会研究学习，虚心接受，并作出相应整改。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.apple.com/videos/play/wwdc2015/414/" target="_blank" rel="external">WWDC 2015 Building Better Apps with Value Types in Swift</a><br><a href="https://developer.apple.com/swift/blog/?id=10" target="_blank" rel="external">Value and Reference Types</a><br><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID173" target="_blank" rel="external">In-Out Parameters</a><br><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID545" target="_blank" rel="external">In-Out Parameters</a><br><a href="https://www.raywenderlich.com/112027/reference-value-types-in-swift-part-1" target="_blank" rel="external">Reference vs Value Types in Swift: Part 1/2</a></p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><p><a href="https://www.raywenderlich.com/112027/reference-value-types-in-swift-part-2" target="_blank" rel="external">Reference vs Value Types in Swift: Part 2/2</a><br><a href="http://www.jianshu.com/p/70684b2e0c15" target="_blank" rel="external">Swift 3 必看：foundation 中数据引用类型改为值类型</a><br><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md" target="_blank" rel="external">Mutability and Foundation Value Types</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Value Type &amp;amp; Reference Type&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>腾讯云 Ubuntu 安装并远程访问 MySQL</title>
    <link href="https://maimieng.com/2016/35/"/>
    <id>https://maimieng.com/2016/35/</id>
    <published>2016-11-18T16:00:00.000Z</published>
    <updated>2016-11-22T07:14:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>道理都懂，但还是连不上的话你就应该来看看…<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>Ubuntu Server 14.04.01 LTS 64 位</li>
<li>DataGrip 2016.2</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了完成作业，不让服务器闲置，决定把数据库放在远程。免去本地配置的麻烦，这次的配置是基于腾讯的学生云，系统选择的是 Ubuntu Server 14.04.01 LTS 64 位，顺便学习下命令行操作。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>安装和配置的步骤比较详细，如果你已经安装过 MySQL 可以跳过相应章节。</p>
<h3 id="配置服务器安全组"><a href="#配置服务器安全组" class="headerlink" title="配置服务器安全组"></a>配置服务器安全组</h3><p>服务器的安全组可以在腾讯云上修改、配置。因为 MySQL 默认远程访问端口为 3306，因此，我们至少要开放该端口。这里由于我的服务器仅供折腾，所以开放了所有端口，实际使用的服务器应当考虑到相应的安全问题。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/ubuntu_mysql_1.png" alt="配置服务器安全组"></p>
<h3 id="设置服务器-root-账户密码"><a href="#设置服务器-root-账户密码" class="headerlink" title="设置服务器 root 账户密码"></a>设置服务器 root 账户密码</h3><p>在后面的使用中，我们需要 root 账户的权限，因此需要设置 root 账户的密码。腾讯云默认会提供一个 ubuntu 账户，在装系统时可以设置密码。</p>
<p>使用 ubuntu 账户登录服务器（0.0.0.0 替换为你的服务器 IP）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh ubuntu@0.0.0.0</div></pre></td></tr></table></figure>
<p>登录成功后，设置 root 账户密码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo passwd</div></pre></td></tr></table></figure>
<p>你需要先输入 ubuntu 账户密码，之后设置 root 账户密码。</p>
<h3 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h3><p>安装时，若提示 <code>Do you want to continue? [Y/n]</code> 输入 Y 即可。在 MySQL 快安装完毕时，会跳出设置 root 密码的界面。该 root 为数据库的用户，而非服务器账户。注意区分和记忆密码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install mysql-server</div><div class="line">apt-get isntall mysql-client</div><div class="line">sudo apt-get install libmysqlclient-dev</div></pre></td></tr></table></figure>
<p>安装完成后，尝试连接 MySQL，使用 root 用户验证是否安装成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -u root –p</div></pre></td></tr></table></figure>
<h3 id="配置-MySQL-远程访问"><a href="#配置-MySQL-远程访问" class="headerlink" title="配置 MySQL 远程访问"></a>配置 MySQL 远程访问</h3><p>查看 3306 端口状态，在 MySQL 安装成功，但没有配置远程访问时，会显示 <code>127.0.0.1:3306</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -an|grep 3306</div></pre></td></tr></table></figure>
<p>为保证安全，首先停止 MySQL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service mysql stop</div></pre></td></tr></table></figure>
<p>切换为 root 账户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">su root</div></pre></td></tr></table></figure>
<p>使用 vim 打开 my.cnf。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/mysql/my.cnf</div></pre></td></tr></table></figure>
<p>将 <code>bind-address = 127.0.0.1</code> 注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># bind-address = 127.0.0.1</div></pre></td></tr></table></figure>
<p>保存并退出后，启动 MySQL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service mysql start</div></pre></td></tr></table></figure>
<p>查看 3306 端口状态，现在应当显示 <code>0.0.0.0:3306</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -an|grep 3306</div></pre></td></tr></table></figure>
<h3 id="新建用户并授权"><a href="#新建用户并授权" class="headerlink" title="新建用户并授权"></a>新建用户并授权</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 创建 kingcos 用户，设置密码为 123456</div><div class="line">CREATE USER kingcos IDENTIFIED BY '123456';</div><div class="line"></div><div class="line"># 授权</div><div class="line">GRANT ALL PRIVILEGES ON *.* TO 'kingcos'@'%'</div><div class="line">IDENTIFIED BY '123456'</div><div class="line">WITH GRANT OPTION;</div><div class="line"></div><div class="line"># 更新权限</div><div class="line">FLUSH PRIVILEGES;</div></pre></td></tr></table></figure>
<h3 id="尝试远程访问"><a href="#尝试远程访问" class="headerlink" title="尝试远程访问"></a>尝试远程访问</h3><p>这里以 JetBrains 的 DataGrip 2016.2 为例。</p>
<p>如图，即连接成功。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/ubuntu_mysql_2.png" alt="DataGrip 2016.2"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;道理都懂，但还是连不上的话你就应该来看看…&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://maimieng.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>计组实验 - Cache</title>
    <link href="https://maimieng.com/2016/34/"/>
    <id>https://maimieng.com/2016/34/</id>
    <published>2016-11-10T16:00:00.000Z</published>
    <updated>2016-11-11T15:06:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Analysis of L1 Cache<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>L1 Cache</li>
<li>Cache Simulator by <a href="https://github.com/jiangxincode" target="_blank" rel="external">jiangxincode</a></li>
</ul>
</li>
</ul>
<p>花了近乎一周时间，本是想用 Java 或 JavaScript 写一个 Cache 模拟器，但由于时间和精力有限，暂放弃。</p>
<p>不过为了实验效果，将老师所提供的 CacheSim 程序进行了微调（源程序未提供 License），并将结果数据绘成图表（使用 <a href="http://echarts.baidu.com" target="_blank" rel="external">ECharts</a>）。</p>
<p>虽然最后实验部分分数得了满分，但由于该程序可能存在一些问题，导致某些结果并非完全正确，实验结果仅供参考。</p>
<p>实验结果及相应分析可在下方网站中获取，相应的参考资料也在其中，这里不再赘述。</p>
<p><a href="https://maimieng.com/skipsrc/CacheSimulator">https://maimieng.com/skipsrc/CacheSimulator</a></p>
<p>以上的实验结果出自 <a href="https://github.com/jiangxincode/CacheSim" target="_blank" rel="external">jiangxincode/CacheSim</a> 程序，向开源致敬！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Analysis of L1 Cache&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Technology" scheme="https://maimieng.com/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>小窥 iOS 中的 Target-Action 设计模式</title>
    <link href="https://maimieng.com/2016/32/"/>
    <id>https://maimieng.com/2016/32/</id>
    <published>2016-11-01T16:00:00.000Z</published>
    <updated>2016-11-02T09:54:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Design Pattern in iOS<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.1</li>
<li>Xcode 8.2 Beta 1</li>
<li>Swift 3.0</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前两天学习 iOS 中的 UISlider 控件时，看到官方文档提到，Slider 使用了 Target-Action 设计模式。即当用户移动滑块，将通知应用。同理，UIButton 也使用了该设计模式。那么，我们能从这个设计模式中学到什么呢？</p>
<h2 id="Target-Action"><a href="#Target-Action" class="headerlink" title="Target-Action"></a>Target-Action</h2><p>Target-Action，意为 目标-行为，行为即要调用的方法，目标即消息的接收对象（Objective-C 语言使用消息机制，类似但不同于方法调用，该两种概念可能未来会进行探讨）。整个过程为：用户点击按钮，触发某事件发生，该消息由按钮传到另外的接收对象，接收对象再做相应处理。接收对象可以为任何对象，但通常为控制器（Controller）。</p>
<h2 id="Responder-Chain"><a href="#Responder-Chain" class="headerlink" title="Responder Chain"></a>Responder Chain</h2><p>在有关于 Target-Action 的官方文档章节中，提到了通过设置 Target 为 nil 来使用响应链。这样可以使得在运行时（Runtime）决定 Target 对象。关于此的探讨可以参照 Dominik Hauser 的 Utilize The Responder Chain For Target-Action 一文。</p>
<p>但是鉴于个人能力有限，而且在其原文中，作者新加了这么一句话：</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/target_action_1.png" alt="Utilize The Responder Chain For Target-Action"></p>
<p>显然，作者虽然了解响应链的存在，但不会去使用。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="Interface-Builder"><a href="#Interface-Builder" class="headerlink" title="Interface Builder"></a>Interface Builder</h3><p>通过 Interface Builder 可以拖线来实现（注意 Connection 选择 Action）。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/target_action_2.png" alt="Action"></p>
<p>之后便可以在其内部进行其他操作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">buttonClick</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</div><div class="line">	<span class="comment">// do something...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，也可以先定义方法，再拖线，这样也是允许的。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>通过代码进行绑定 Target，可以先采用将控件拖线至代码中，这时 Connection 选择 Outlet。纯代码可以无视拖线。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/target_action_3.png" alt="Outlet"></p>
<p>之后便可以通过 <code>addTarget(_:action:for:)</code> 来绑定 Target 和 Action。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/target_action_4.png" alt="addTarget(_:action:for:)"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    </div><div class="line">    demoButton.addTarget(<span class="keyword">self</span>,</div><div class="line">                         action: #selector(demoFunc),</div><div class="line">                         <span class="keyword">for</span>: .touchUpInside)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">demoFunc</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// do something...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="selector"><a href="#selector" class="headerlink" title="#selector()"></a><code>#selector()</code></h2><p>据考证，<code>#selector()</code> 是 Swift 2.2 中新增的写法。使得选择方法更加安全，因为 IDE 可以自动提示自动补全，即可在编译时刻检查。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/target_action_5.png" alt="Selector 结构体"></p>
<p><code>#selector()</code> 在 Swift 中为 <code>Selector</code> 结构体类型，但其本质是 Objective-C 的运行时概念。如果有方法为 <code>private</code>，则需要在方法前加上 <code>@objc</code> 才能运行正常。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    <span class="keyword">let</span> selectorStruct = #selector(demoFunc)</div><div class="line"></div><div class="line">    demoButton.addTarget(<span class="keyword">self</span>,</div><div class="line">                         action: selectorStruct,</div><div class="line">                         <span class="keyword">for</span>: .touchUpInside)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@objc</span> <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">demoFunc</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// do something...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于 <code>Selector</code> 也可以参考喵神的文章，所有本文提及的文章均在参考资料中列出。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/TargetAction.html#//apple_ref/doc/uid/TP40009071-CH3" target="_blank" rel="external">Target-Action</a><br><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Target-Action/Target-Action.html#//apple_ref/doc/uid/TP40010810-CH12" target="_blank" rel="external">Target-Action</a><br><a href="http://swiftandpainless.com/utilize-the-responder-chain-for-target-action/" target="_blank" rel="external">Utilize The Responder Chain For Target-Action</a><br><a href="http://swift.gg/2016/01/06/utilize-the-responder-chain-for-target-action/" target="_blank" rel="external">在 Target-Action 中使用响应链</a><br><a href="http://swifter.tips/selector/" target="_blank" rel="external">SELECTOR</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Design Pattern in iOS&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>初探 iOS 中自定义 UIView 的初始化过程</title>
    <link href="https://maimieng.com/2016/33/"/>
    <id>https://maimieng.com/2016/33/</id>
    <published>2016-11-01T16:00:00.000Z</published>
    <updated>2016-11-03T16:20:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>awakeFromNib()<br>init(frame:)<br>init(coder:)<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.1</li>
<li>Xcode 8.2 Beta 1</li>
<li>Swift 3.0</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 StoryBoard 和 Xib 出现之后，iOS UI 开发出现了三足鼎立之势。本文不涉及 StoryBoard、Xib、纯代码的优劣之分。仅仅涉及几个初始化方法：<code>awakeFromNib()</code> &amp; <code>init(frame:)</code> &amp; <code>init(coder:)</code>，探讨他们何时调用，为何调用。</p>
<h2 id="Xib-amp-Nib"><a href="#Xib-amp-Nib" class="headerlink" title="Xib &amp; Nib"></a>Xib &amp; Nib</h2><p>ib 是 Interface Builder 的缩写，即界面构造器。这里简要说下，Xib 和 Nib 各是什么，有什么区别。</p>
<p>Xib 实际是一个 XML 文件，而 Nib 是二进制文件。当应用编译时，Xib 文件被翻译为 Nib。所以在 Xcode 中，我们可以自己新建 Xib 文件来构造 UI，而当编译时，Xcode 会自动生成相应的 Nib 文件，而不需我们额外关注。关于其详细介绍，您可以参考文末的资料。</p>
<blockquote>
<p>OK! Talk is cheap, show me the code!</p>
</blockquote>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>在下面的 Demo 中，统一将自定义 UIView 命名为 MyView。</p>
<p>MyView.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span>: <span class="title">UIView</span> </span>&#123;</div><div class="line">	<span class="comment">// methods</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Interface-Builder"><a href="#Interface-Builder" class="headerlink" title="Interface Builder"></a>Interface Builder</h3><p>如果使用 Interface Builder 拖控件，那么其默认属于 UIView 类型。为将其改为自定义控件，需要将 Utilities 中 Identity inspector 的 Custom Class 改为 MyView。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/custom_uiview_1.png" alt="Custom Class 改为 MyView"></p>
<p>为了方便看出调用顺序，将 MyView.swift 改为如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span>: <span class="title">UIView</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</div><div class="line">        </div><div class="line">        <span class="built_in">print</span>(<span class="string">"init(frame:)"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</div><div class="line">        </div><div class="line">        <span class="built_in">print</span>(<span class="string">"init(coder:)"</span>)</div><div class="line">        <span class="comment">// fatalError("init(coder:) has not been implemented")</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.awakeFromNib()</div><div class="line">        </div><div class="line">        <span class="built_in">print</span>(<span class="string">"awakeFromNib()"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后运行即可在屏幕上看到该自定义 UIView，控制台输出：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">init</span>(coder:)</div><div class="line">awakeFromNib()</div></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过打印的输出，可以看出使用 Interface Builder 载入 View 不会调用 <code>init(frame:)</code> 方法，而是调用了 <code>init(coder:)</code>。<code>init(coder:)</code> 是 NSCoding 协议中的方法，NSCoding 是负责编码解码，归档处理的协议。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>)</div></pre></td></tr></table></figure>
<p>代码中的 <code>init(coder:)</code> 与平时见到的其他初始化方法有点不同：<code>required</code> 是指其为必要构造器，即子类「必须」重写该构造器，但当父类的构造器可以完全满足初始化时，也可不重写。<code>init?</code> 是指其为可失败构造器，即其可以 <code>return nil</code> 告知外界构造失败。若想详细了解 Swift 中的构造器，可以参考苹果官方文档。</p>
<p><code>init(coder:)</code> 的调用处于 Nib <strong>载入时</strong>，而 <code>awakeFromNib()</code> 的调用处于 Nib <strong>载入后</strong>。Nib 的载入过程如下：</p>
<ol>
<li>Nib 文件内容和引用的资源文件加载到内存；</li>
<li>反归档存储于 Nib 文件的图像数据对象并初始化；<ol>
<li>遵从 NSCoding 的对象（UIView &amp; UIViewController）调用 <code>init(coder:)</code></li>
<li>其他对象调用其他构造器方法</li>
</ol>
</li>
<li>建立对象间连接：Outlet &amp; Action</li>
<li>实现 <code>awakeFromNib()</code> 的对象调用该方法</li>
</ol>
<p>需要注意的是，<code>awakeFromNib()</code> 中需要调用父类的该方法以保证父类的进行额外初始化。而在本例中重写的 <code>init(coder:)</code> 目的主要是查看调用顺序，并没有加入特别的操作。因此在实际使用中，如果使用 Interface Builder，可以不重写该方法。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>MyView.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span>: <span class="title">UIView</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</div><div class="line">        </div><div class="line">        <span class="built_in">print</span>(<span class="string">"init(frame:)"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</div><div class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.awakeFromNib()</div><div class="line">        </div><div class="line">        <span class="built_in">print</span>(<span class="string">"awakeFromNib"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ViewController.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> myView = <span class="type">MyView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">100</span>, width: <span class="number">50</span>, height: <span class="number">50</span>))</div><div class="line">        myView.backgroundColor =  .black</div><div class="line">        view.addSubview(myView)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后运行即可在屏幕上看到该自定义 UIView，控制台输出：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">init</span>(frame:)</div></pre></td></tr></table></figure>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>通过纯代码创建自定义 UIView，便只调用 <code>init(frame:)</code> 方法，不涉及 Nib 的方法，因此不会调用 <code>awakeFromNib()</code> 和 <code>init(coder:)</code> 方法。而由于 <code>init(coder:)</code> 为必要构造器，因此重写 <code>init(frame:)</code> 时，必须实现该方法。</p>
<p>有时，为了便于从 Interface Builder 和纯代码都能创建自定义 UIView 对象，可以将 <code>init(coder:)</code> 方法改为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</div><div class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</div><div class="line">    <span class="comment">// fatalError("init(coder:) has not been implemented")</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>若保留 <code>fatalError()</code>，则从 Nib 初始化时会无条件输出语句并停止运行。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>可能是强迫症作祟，学习中每遇到一个知识点，都想要查看官方文档或者 Google 出为什么，然后自己敲代码验证，再总结出一篇文章，投稿给简书、掘金。一篇文章有时要耗费一两天，因为查阅的资料都是略有过时且几乎全为英文，但自己挺享受这样的学习状态，也很享受分享给大家之后获得的收藏所带来的鼓励。最近也看了很多实习生的招聘，现在深感基础的重要，未来可能会倾向一些基础，例如数据结构、算法、网络等知识。也希望自己在寒假或下学期能找一份 iOS 实习，虽然自己也有所涉猎 Android 等其他的一些技术栈，但还是对 iOS 最感兴趣。Come on!</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html" target="_blank" rel="external">Nib Files</a><br><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203" target="_blank" rel="external">Initialization</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;awakeFromNib()&lt;br&gt;init(frame:)&lt;br&gt;init(coder:)&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UITableViewCell 的简单优化</title>
    <link href="https://maimieng.com/2016/31/"/>
    <id>https://maimieng.com/2016/31/</id>
    <published>2016-10-30T16:00:00.000Z</published>
    <updated>2016-10-31T11:31:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>UITableView in iOS by Swift<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.1</li>
<li>Xcode 8.1</li>
<li>Swift 3.0</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UITableView 是 iOS 开发中极其重要且经常使用的视图，有时候也直接使用 UITableViewController。和 Android 中的 ListView 一样，列表视图总是和内存分不开，因为他们可以承载很多条不同的信息，而随着用户手指滑动，需要即时呈现，不卡顿，不拖沓。因此对其的优化便与生俱来。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>首先，使用一个 static 常量存储复用 ID。之后在 <code>viewDidLoad</code> 中为自定义 Cell 注册该 ID（使用自定义 Cell 可以更加方便，自由的自定义表格 Cell 中的内容）。然后在 <code>func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath)</code> 方法中使用静态常量作为复用 ID，若 Cell 已存在于缓存池则取出，反之创建。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">let</span> id = <span class="string">"reuseIdentifier"</span></div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        tableView.register(<span class="type">CustomCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="type">TableViewController</span>.id)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</div><div class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">200</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="type">TableViewController</span>.id, <span class="keyword">for</span>: indexPath)</div><div class="line">        cell.textLabel?.text = <span class="string">"\(indexPath.row)"</span></div><div class="line">        <span class="keyword">return</span> cell</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomCell</span>: <span class="title">UITableViewCell</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="Swift-中的-static"><a href="#Swift-中的-static" class="headerlink" title="Swift 中的 static"></a>Swift 中的 static</h3><h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">(<span class="number">_</span> cellClass: AnyClass?, forCellReuseIdentifier identifier: String)</span></span></div></pre></td></tr></table></figure>
<h3 id="dequeueReusableCell"><a href="#dequeueReusableCell" class="headerlink" title="dequeueReusableCell"></a>dequeueReusableCell</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">dequeueReusableCell</span><span class="params">(withIdentifier identifier: String)</span></span> -&gt; <span class="type">UITableViewCell</span>?</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;UITableView in iOS by Swift&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>简单使用 UIColor 生成 UIImage</title>
    <link href="https://maimieng.com/2016/30/"/>
    <id>https://maimieng.com/2016/30/</id>
    <published>2016-10-28T16:00:00.000Z</published>
    <updated>2016-10-29T16:29:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>UIColor &lt;-&gt; UIImage<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.1</li>
<li>Xcode 8.1</li>
<li>Swift 3.0</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在平时的练习中，经常需要使用 UIImage，但图片又不好找。为了解决这个问题，我想到了使用 UIColor 生成 UIImage。该部分的具体知识涉及到 Core Graphics，也是一个新的知识点。在网上寻找一番，只有 Objective-C 版本，这次使用 Swift 3.0 进行重写。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateImageWith</span><span class="params">(<span class="number">_</span> color: UIColor, andFrame frame: CGRect)</span></span> -&gt; <span class="type">UIImage</span>? &#123;</div><div class="line">    <span class="comment">// 开始绘图</span></div><div class="line">    <span class="type">UIGraphicsBeginImageContext</span>(frame.size)</div><div class="line">    </div><div class="line">    <span class="comment">// 获取绘图上下文</span></div><div class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</div><div class="line">    <span class="comment">// 设置填充颜色</span></div><div class="line">    context?.setFillColor(color.cgColor)</div><div class="line">    <span class="comment">// 使用填充颜色填充区域</span></div><div class="line">    context?.fill(frame)</div><div class="line">    </div><div class="line">    <span class="comment">// 获取绘制的图像</span></div><div class="line">    <span class="keyword">let</span> image = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</div><div class="line">    </div><div class="line">    <span class="comment">// 结束绘图</span></div><div class="line">    <span class="type">UIGraphicsEndImageContext</span>()</div><div class="line">    <span class="keyword">return</span> image</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用时直接调用该方法，并传入相应参数即可，那么反过来呢？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> color = <span class="type">UIColor</span>(patternImage: image!)</div></pre></td></tr></table></figure>
<p>这样就可以从图片获取颜色。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;UIColor &amp;lt;-&amp;gt; UIImage&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>初探 Swift 中的 KVC 之补充</title>
    <link href="https://maimieng.com/2016/29/"/>
    <id>https://maimieng.com/2016/29/</id>
    <published>2016-10-26T16:00:00.000Z</published>
    <updated>2016-10-27T08:30:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Updated for Swift 3.0.1<br></blockquote><br><a id="more"></a></p>
<h2 id="Swift-3-0-1-中的-KVC"><a href="#Swift-3-0-1-中的-KVC" class="headerlink" title="Swift 3.0.1 中的 KVC"></a>Swift 3.0.1 中的 KVC</h2><p>按照官网，其实在 Swift 3.0 中已经为如下写法，但我是根据 10 月 24 日更新的 KVC 编程指南中的链接才发现该更新的。<code>#keyPath</code> 表达式使得键（路径）更加安全，因为其可以在编译时检查，极大程度避免传入 undefinedkey。但在测试中，也发现了其中的问题，如果该属性在外界无法访问，那么 <code>#keyPath</code> 也无能为力，但仍传入字符串可以做到动态设置。Demo 包含在下面的 Demo 中。</p>
<h2 id="使用-KVC-设置访问控制属性"><a href="#使用-KVC-设置访问控制属性" class="headerlink" title="使用 KVC 设置访问控制属性"></a>使用 KVC 设置访问控制属性</h2><p>在前面，我已经大致总结了 Swift 中的<a href="https://maimieng.com/2016/25/">访问控制</a>以及 <a href="https://maimieng.com/2016/27/">KVC</a>，其实很不全面，而且漏掉了 KVC 可以突破访问控制修饰的限制。似乎这样做会破坏封装，但这也是 Cocoa 的一个特性，使得我们可以在<strong>运行时</strong>进行更加灵活的设置。这次结合两者谈谈简单说下。</p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>在 Demo 中，将各个访问控制修饰符均列出，但他们都能通过 KVC 设值。</p>
<p>Person.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">dynamic</span> open <span class="keyword">var</span> openProp = <span class="string">""</span></div><div class="line">    <span class="keyword">dynamic</span> <span class="keyword">public</span> <span class="keyword">var</span> publicProp = <span class="string">""</span></div><div class="line">    <span class="keyword">dynamic</span> <span class="keyword">internal</span> <span class="keyword">var</span> internalProp = <span class="string">""</span></div><div class="line">    <span class="keyword">dynamic</span> fileprivate <span class="keyword">var</span> fileprivateProp = <span class="string">""</span></div><div class="line">    <span class="keyword">dynamic</span> <span class="keyword">private</span> <span class="keyword">var</span> privateProp = <span class="string">""</span></div><div class="line">    </div><div class="line">    <span class="keyword">override</span> open <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"[\(openProp), \(publicProp), \(internalProp), \(fileprivateProp), \(privateProp)]"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="type">Person</span>()</div><div class="line"></div><div class="line">p.setValue(<span class="string">"open"</span>, forKey: #keyPath(<span class="type">Person</span>.openProp))</div><div class="line">p.setValue(<span class="string">"public"</span>, forKey: #keyPath(<span class="type">Person</span>.publicProp))</div><div class="line">p.setValue(<span class="string">"internal"</span>, forKey: #keyPath(<span class="type">Person</span>.internalProp))</div><div class="line">p.setValue(<span class="string">"fileprivate"</span>, forKey: <span class="string">"fileprivateProp"</span>)</div><div class="line">p.setValue(<span class="string">"private"</span>, forKey: <span class="string">"privateProp"</span>)</div><div class="line"></div><div class="line"><span class="built_in">print</span>(p)</div><div class="line"></div><div class="line"><span class="comment">// [open, public, internal, fileprivate, private]</span></div></pre></td></tr></table></figure>
<h2 id="浅谈集合属性的-KVC"><a href="#浅谈集合属性的-KVC" class="headerlink" title="浅谈集合属性的 KVC"></a>浅谈集合属性的 KVC</h2><p><a href="http://swiftcafe.io/2016/01/03/kvc/" target="_blank" rel="external">漫谈 KVC 与 KVO</a>，这篇文章在写上篇 KVC 时已经看过，但没有注意末尾提到的集合属性的 KVC，感谢<a href="http://weibo.com/u/2305821027" target="_blank" rel="external">木杉</a>同学的提问，才让我注意到这个细节。</p>
<p>关于这点，我查了很多资料，尤其是关心苹果的官方 KVC 指南，官方的 KVC 编程指南的最新更新日期是 2016 年 10 月 24 日，我特意查了更新历史，上一次更新要追溯的 2012 年。但指南仅仅更新了部分的 Swift 内容，而对于集合属性部分，仍为 Objective-C。</p>
<h3 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo-1"></a>Demo-1</h3><p>如果按照<a href="http://swiftcafe.io/2016/01/03/kvc/" target="_blank" rel="external">漫谈 KVC 与 KVO</a>所提到的，Swift 中的写法应当为下，但通过运行发现，并不走 <code>countOfArr()</code> 方法，而是直接输出 <code>arr.count</code>，即 0。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionDemo</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = <span class="type">NSMutableArray</span>()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">countOfArr</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"countOfArr"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">100</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 该方法虽然未调用，但不能缺少</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">objectInArrAt</span><span class="params">(index: Int)</span></span> -&gt; <span class="type">Any</span>? &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"objectInArrAt"</span>)</div><div class="line">        <span class="keyword">return</span> arr.object(at: index)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="type">CollectionDemo</span>()</div><div class="line"></div><div class="line"><span class="built_in">print</span>(obj.mutableArrayValue(forKeyPath: <span class="string">"arr"</span>).<span class="built_in">count</span>)</div><div class="line"><span class="built_in">print</span>(obj.mutableArrayValue(forKeyPath: #keyPath(<span class="type">CollectionDemo</span>.arr)).<span class="built_in">count</span>)</div><div class="line"></div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 0</span></div></pre></td></tr></table></figure>
<h3 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo-2"></a>Demo-2</h3><p><code>mutableArrayValue:</code> 的默认实现为传入键，返回该键对应的可变代理数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionDemo</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> <span class="type">Arr</span> = <span class="type">NSMutableArray</span>()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">countOfArr</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"countOfArr"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="type">Arr</span>.<span class="built_in">count</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">objectInArrAt</span><span class="params">(index: Int)</span></span> -&gt; <span class="type">Any</span>? &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"objectInArrAt"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="type">Arr</span>[index]</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">insertObject</span><span class="params">(<span class="number">_</span> obj: Any, inArrAtIndex index: Int)</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"insertObject"</span>)</div><div class="line">        <span class="type">Arr</span>[index] = obj</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="type">CollectionDemo</span>()</div><div class="line"><span class="keyword">let</span> arrayProxy = obj.mutableArrayValue(forKeyPath: <span class="string">"arr"</span>)</div><div class="line">arrayProxy.add(<span class="string">"Test1"</span>)</div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"></div><div class="line">arrayProxy.add(<span class="string">"Test2"</span>)</div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"><span class="comment">// objectInArrAt</span></div><div class="line"></div><div class="line">arrayProxy.add(<span class="string">"Test3"</span>)</div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"><span class="comment">// objectInArrAt</span></div><div class="line"><span class="comment">// objectInArrAt</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(arrayProxy.<span class="built_in">count</span>)</div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"><span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(arrayProxy[<span class="number">0</span>])</div><div class="line"><span class="comment">// objectInArrAt</span></div><div class="line"><span class="comment">// Test1</span></div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://stackoverflow.com/questions/31951681/mutablearrayvalueforkey-countofkey-not-being-called-countofsongs?answertab=active#tab-top" target="_blank" rel="external">mutableArrayValueForKey: countOf<key> not being called, countOfSongs</key></a><br><a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1" target="_blank" rel="external">Key-Value Coding Programming Guide</a><br><a href="http://swiftcafe.io/2016/01/03/kvc/" target="_blank" rel="external">漫谈 KVC 与 KVO</a><br><a href="https://maimieng.com/2016/27/">初探 Swift 中的 KVC</a><br><a href="https://maimieng.com/2016/25/">浅谈 Swift 3 中的访问控制</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Updated for Swift 3.0.1&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Swift 中的属性（Property）</title>
    <link href="https://maimieng.com/2016/28/"/>
    <id>https://maimieng.com/2016/28/</id>
    <published>2016-10-24T16:00:00.000Z</published>
    <updated>2016-10-30T13:32:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Stored Properties<br>Computed Properties<br>Property Observers<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.1</li>
<li>Xcode 8.1 Beta 3</li>
<li>Swift 3.0</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Swift 中的属性分为存储属性与计算属性，存储属性即为我们平时常用的属性，可以直接赋值使用，而计算属性不直接存储值，而是根据其他（存储）属性计算得来的值。</p>
<p>在其他面向对象的编程语言中，例如 Java 和 Objective-C 中，get 和 set 方法提供了统一、规范的接口，可以使得外部访问或设置对象的私有属性，而不破坏封装性，也可以很好的控制权限（选择性实现 get 或 set 方法）。而 Swift 中似乎并没有见到类似的 get 和 set 方法，而 Swift 使用了一种名为属性观察器的概念来解决该问题。</p>
<p>本文简单介绍下 Swift 中的这两种属性，以及属性观察器。</p>
<h2 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h2><p>存储属性使用广泛，即是类或结构体中的变量或常量，可以直接赋初始值，也可以修改其初始值（仅指变量）。延迟存储属性是指第一次使用到该变量再进行运算（这里的运算不能依赖其他属性）。延迟存储属性必须声明为 <code>var</code> 变量，因为其属性值在对象实例化前可能无法得到，而常量必须在初始化完成前拥有初始值。</p>
<p>在 Swift 中，可以将消耗性能才能得到的值的初始化放在延迟存储属性中，即懒加载。</p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>这里假定在 ViewController.swift 有一个属性，需要从 plist 文件读取内容，将其中的字典转为模型。如果 plist 文件内容很多，那么就十分消耗性能。如果用户不触发相应事件，也没有必要加载这些数据。那么这里就很适合使用懒加载，即延迟存储属性。</p>
<p>ViewController.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> goods: <span class="type">NSArray</span>? = &#123;</div><div class="line">        <span class="keyword">var</span> goodsArray: <span class="type">NSMutableArray</span> = []</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> path = <span class="type">Bundle</span>.main.path(forResource: <span class="string">"Goods"</span>, ofType: <span class="string">"plist"</span>) &#123;</div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> array = <span class="type">NSArray</span>(contentsOfFile: path) &#123;</div><div class="line">                <span class="keyword">for</span> goodsDict <span class="keyword">in</span> array &#123;</div><div class="line">                    goodsArray.add(<span class="type">Goods</span>(goodsDict <span class="keyword">as</span>! <span class="type">NSDictionary</span>))</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> goodsArray</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;()</div><div class="line">    </div><div class="line">    <span class="comment">// 这样也是允许的</span></div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> testLazy = <span class="type">Person</span>()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p><em>可以在延迟存储属性运算的代码中加入 <code>print()</code>，即可验证其何时初始化。</em></p>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>举个例子，一个<strong>矩形</strong>结构体（类同理），拥有<strong>宽度</strong>和<strong>高度</strong>两个存储属性，以及一个只读<strong>面积</strong>的计算属性，因为通过设置矩形的宽度和高度即可<strong>计算</strong>出矩形的面积，而无需直接设置其值。当宽度或高度改变，面积也应当可以跟随其变化（反之不能推算，因此为只读）。为说明 setter 以及便捷 setter 说明，另外添加了<strong>原点</strong>（矩形左下角）存储属性，以及<strong>中心</strong>计算属性。</p>
<h3 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> y = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> height = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</div><div class="line">    </div><div class="line">    <span class="comment">// 只读计算属性</span></div><div class="line">    <span class="keyword">var</span> size: <span class="type">Double</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">return</span> width * height</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 只读计算属性简写为</span></div><div class="line"><span class="comment">//    var size: Double &#123;</span></div><div class="line"><span class="comment">//        return width * height</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: origin.x + width / <span class="number">2</span>,</div><div class="line">                         y: origin.y + height / <span class="number">2</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">set</span>(newCenter) &#123;</div><div class="line">            origin.x = newCenter.x - width / <span class="number">2</span></div><div class="line">            origin.y = newCenter.y - height / <span class="number">2</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 便捷 setter 声明</span></div><div class="line"><span class="comment">//        set &#123;</span></div><div class="line"><span class="comment">//            origin.x = newValue.x - width / 2</span></div><div class="line"><span class="comment">//            origin.y = newValue.y - height / 2</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> rect = <span class="type">Rectangle</span>()</div><div class="line">rect.width = <span class="number">100</span></div><div class="line">rect.height = <span class="number">50</span></div><div class="line"><span class="built_in">print</span>(rect.size)</div><div class="line"></div><div class="line">rect.origin = <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</div><div class="line"><span class="built_in">print</span>(rect.center)</div><div class="line"></div><div class="line">rect.center = <span class="type">Point</span>(x: <span class="number">100</span>, y: <span class="number">100</span>)</div><div class="line"><span class="built_in">print</span>(rect.origin)</div><div class="line"></div><div class="line"><span class="comment">// 5000.0</span></div><div class="line"><span class="comment">// Point(x: 50.0, y: 25.0)</span></div><div class="line"><span class="comment">// Point(x: 50.0, y: 75.0)</span></div></pre></td></tr></table></figure>
<p><em>综上，getter 可以根据存储属性推算计算属性的值，setter 可以在被赋值时根据新值倒推存储属性，但它们与我们在其他语言中的 get/set 方法却不一样。</em></p>
<h2 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h2><p>属性观察器算是 Swift 中的一个 feature，变量在设值<strong>前</strong>会先进入 <code>willSet</code>，这时默认 <code>newValue</code> 等于即将要赋值的值，而变量本身尚未改变。变量在设值<strong>后</strong>会先进入 <code>didSet</code>，这时默认 <code>oldValue</code> 等于赋值前变量的值，而变量变为新值。</p>
<p>这样，开发者即可在 <code>willSet</code> 和 <code>didSet</code> 中进行相应的操作，如果只是取值和设值而不进行额外操作，那么直接使用点语法即可。但是有时候一个变量只需要被访问，而不能在外界赋值，那么可以使用<a href="https://maimieng.com/2016/25/">访问控制修饰符</a>加上 <code>(set)</code> 即可私有化 set 方法。例如 <code>fileprivate(set)</code>，<code>private(set)</code>，以及 <code>internal(set)</code>。值得注意的是，这里的访问控制修饰符修饰的是 set 方法，访问权限（即 get）是另外设置的。例如 <code>public fileprivate(set) var prop = 0</code>，该变量全局可以访问，但只有同文件内可以使用 set 方法。</p>
<h3 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="comment">// internal 为默认权限，可不加</span></div><div class="line">    <span class="keyword">internal</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> privateSetProp = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> hungryValue = <span class="number">0</span> &#123;</div><div class="line">        <span class="comment">// 设置前调用</span></div><div class="line">        <span class="keyword">willSet</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"willSet \(hungryValue) newValue: \(newValue)"</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 设置后调用</span></div><div class="line">        <span class="keyword">didSet</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"didSet \(hungryValue) oldValue: \(oldValue)"</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 也可以自己命名默认的 newValue/oldValue</span></div><div class="line">        <span class="comment">// willSet(new) &#123;&#125;</span></div><div class="line">        <span class="comment">// didSet(old) &#123;&#125;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> cat = <span class="type">Animal</span>()</div><div class="line"></div><div class="line"><span class="comment">// private(set) 即只读</span></div><div class="line"><span class="comment">// cat.privateSetProp = 10</span></div><div class="line"><span class="built_in">print</span>(cat.privateSetProp)</div><div class="line"></div><div class="line">cat.hungryValue += <span class="number">10</span></div><div class="line"><span class="built_in">print</span>(cat.hungryValue)</div><div class="line"></div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// willSet 0 newValue: 10</span></div><div class="line"><span class="comment">// didSet 10 oldValue: 0</span></div><div class="line"><span class="comment">// 10</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Swift 的这几个 feature 我未曾在其他语言中见过，对于初学者确实容易凌乱。特别是 getter/setter 以及属性观察器中均没有代码提示，容易造成手误，代码似乎也变得臃肿。但是熟悉之后，这些也都能完成之前的功能，甚至更加细分。保持每一部分可控，便使得整个程序更加严谨，更加安全。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://maimieng.com/2016/25/">浅谈 Swift 3 中的访问控制</a><br><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html" target="_blank" rel="external">Access Control</a><br><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html" target="_blank" rel="external">Properties</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Stored Properties&lt;br&gt;Computed Properties&lt;br&gt;Property Observers&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>初探 Swift 中的 KVC</title>
    <link href="https://maimieng.com/2016/27/"/>
    <id>https://maimieng.com/2016/27/</id>
    <published>2016-10-20T16:00:00.000Z</published>
    <updated>2016-10-27T08:23:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Key-Value Coding<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.1 Beta 4</li>
<li>Xcode 8.1 Beta 3</li>
<li>Swift 3</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>这两天（2016-10-27），苹果一言不合更新了官网的文档，有些文档上次的更新日期甚至为 2012 年，说明这次的更新十分重要且稳定，并且将 Swift 版本更新到 3.0.1，本文中的一些写法随能运行，但已经过时，并非最佳实践，为此以及一些本文未涉及的内容，可以参照另一文——<a href="https://maimieng.com/2016/29/">初探 Swift 中的 KVC 之补充</a>。</strong></p>
<p>Key-Value Coding 中文译为「键值编码」，简称 KVC。是 iOS 开发中极其重要且基础的概念。苹果官网对于 KVC 有详细的编程指南，但均是基于 Objective-C 语言。Swift 也继承了该特性，KVC 常用于从网络获取请求进行处理，这次只是简单探究下 Swift 中的 KVC。</p>
<p>在 Swift 中想要兼容 KVC，需要该类继承 <code>NSObject</code>。下面是 KVC 中常用的几个方法：</p>
<ul>
<li>根据传入的 <code>key</code>，设置 <code>value</code>：</li>
</ul>
<p><code>func setValue(_ value: Any?, forKey key: String)</code></p>
<ul>
<li>根据传入的 <code>keyPath</code>，设置 <code>value</code>，<code>keyPath</code> 即键路径可利用 <code>.</code> 遍历至键：</li>
</ul>
<p><code>func setValue(_ value: Any?, forKeyPath keyPath: String)</code></p>
<ul>
<li>根据传入的字典，设值，如果字典中有对象不存在的属性，则会抛出异常：</li>
</ul>
<p><code>func setValuesForKeys(_ keyedValues: [String : Any])</code></p>
<ul>
<li>当为不存在的某个键设值时，默认调用该方法抛出 <code>NSUndefinedKeyException</code> 异常，子类可重写该方法：</li>
</ul>
<p><code>func setValue(_ value: Any?, forUndefinedKey key: String)</code></p>
<ul>
<li>设置特定键的值为 <code>nil</code> 时，默认调用该方法抛出 <code>NSInvalidArgumentException</code>，子类可重写该方法（注：官方称该方法针对标量值（scalar value），例如整型和浮点型）对于其他类型没有提到，在 Demo 中有详细的列出是否支持）：</li>
</ul>
<p><code>func setNilValueForKey(_ key: String)</code></p>
<ul>
<li>返回传入指定键的对应值：</li>
</ul>
<p><code>func value(forKey key: String) -&gt; Any?</code></p>
<ul>
<li>返回传入指定键路径的对应值：</li>
</ul>
<p><code>func value(forKeyPath keyPath: String) -&gt; Any?</code></p>
<ul>
<li>返回传入未定义的键路径的对应值：</li>
</ul>
<p><code>func value(forUndefinedKey key: String) -&gt; Any?</code></p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>KVC 兼容的类，需要继承自 <code>NSObject</code>。在学习 KVC 的过程中，发现并不是所有的数据类型都支持通过 KVC 设值。KVC 设值的方便之处在于可以动态的设值，即使封装在内部的细节也可以设值，而且可以自动将类型转换（注意：有些类型是不可行的）。这种特性使得从网络获取的数据可以轻松设置到模型中。以下的 Demo，选取了几个常用的 Swift 中的数据类型，测试一下是否支持 KVC 以及是否在设置 <code>nil</code> 值时调用 <code>setNilValueForKey</code> 方法。</p>
<p>DataType.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataType</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> aInt: <span class="type">Int</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> bUInt: <span class="type">UInt</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> cFloat: <span class="type">Float</span> = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> dDouble: <span class="type">Double</span> = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> eBool: <span class="type">Bool</span> = <span class="literal">false</span></div><div class="line">    <span class="keyword">var</span> fCharacter: <span class="type">Character</span> = <span class="string">"f"</span></div><div class="line">    <span class="keyword">var</span> gString: <span class="type">String</span> = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> hArray: [<span class="type">Any</span>] = [<span class="number">0</span>]</div><div class="line">    <span class="keyword">var</span> iDictionary: [<span class="type">String</span>: <span class="type">Any</span>] = [<span class="string">"0"</span>: <span class="number">0</span>]</div><div class="line">    <span class="keyword">var</span> jTuple: (<span class="type">Int</span>, <span class="type">Int</span>) = (<span class="number">0</span>, <span class="number">0</span>)</div><div class="line">    <span class="keyword">var</span> kOptional: <span class="type">Int</span>?</div><div class="line">    <span class="keyword">var</span> lObject: <span class="type">Type</span> = <span class="type">Type</span>()</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> mNSDictionary: <span class="type">NSDictionary</span> = [<span class="string">"0"</span>: <span class="number">0</span>]</div><div class="line">    <span class="keyword">var</span> nNSArray: <span class="type">NSArray</span> = [<span class="number">0</span>, <span class="string">"0"</span>]</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> oArrayAny: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt; = [<span class="number">0</span>, <span class="string">"0"</span>]</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setNilValueForKey</span><span class="params">(<span class="number">_</span> key: String)</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"You set nil for \(key)"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> prop = <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> o = <span class="type">DataType</span>()</div></pre></td></tr></table></figure>
<h3 id="Int"><a href="#Int" class="headerlink" title="Int"></a><code>Int</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">o.setValue(<span class="string">"1"</span>, forKeyPath: <span class="string">"aInt"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"aInt: \(o.aInt)"</span>)</div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"aInt"</span>)</div><div class="line"></div><div class="line"><span class="comment">// aInt: 1</span></div><div class="line"><span class="comment">// You set nil for aInt</span></div></pre></td></tr></table></figure>
<p><strong><code>Int</code> 支持 <code>setValue</code> 自动转换设值，且支持设值为 <code>nil</code> 时调用 <code>setNilValueForKey</code> 方法。</strong></p>
<h3 id="UInt"><a href="#UInt" class="headerlink" title="UInt"></a><code>UInt</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不支持通过自动转换</span></div><div class="line"><span class="comment">// Error: -[Swift._NSContiguousString unsignedLongLongValue]: unrecognized selector sent to instance</span></div><div class="line"><span class="comment">// o.setValue("1", forKeyPath: "bUInt")</span></div><div class="line">o.setValue(<span class="number">1</span>, forKeyPath: <span class="string">"bUInt"</span>)</div><div class="line"><span class="built_in">print</span>(o.bUInt)</div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"bUInt"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// You set nil for bUInt</span></div></pre></td></tr></table></figure>
<p><strong><code>UInt</code> 支持 <code>setValue</code> 设值，但不支持自动转换，且支持设值为 <code>nil</code> 时调用 <code>setNilValueForKey</code> 方法。</strong></p>
<h3 id="Float"><a href="#Float" class="headerlink" title="Float"></a><code>Float</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">o.setValue(<span class="string">"1"</span>, forKeyPath: <span class="string">"cFloat"</span>)</div><div class="line"><span class="built_in">print</span>(o.cFloat)</div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"cFloat"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 1.0</span></div><div class="line"><span class="comment">// You set nil for cFloat</span></div></pre></td></tr></table></figure>
<p><strong><code>Float</code> 支持 <code>setValue</code> 自动转换设值，且支持设值为 <code>nil</code> 时调用 <code>setNilValueForKey</code> 方法。</strong></p>
<h3 id="Double"><a href="#Double" class="headerlink" title="Double"></a><code>Double</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">o.setValue(<span class="string">"1"</span>, forKeyPath: <span class="string">"dDouble"</span>)</div><div class="line"><span class="built_in">print</span>(o.dDouble)</div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"dDouble"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 1.0</span></div><div class="line"><span class="comment">// You set nil for dDouble</span></div></pre></td></tr></table></figure>
<p><strong><code>Double</code> 支持 <code>setValue</code> 自动转换设值，且支持设值为 <code>nil</code> 时调用 <code>setNilValueForKey</code> 方法。</strong></p>
<h3 id="Bool"><a href="#Bool" class="headerlink" title="Bool"></a><code>Bool</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不支持通过自动转换</span></div><div class="line"><span class="comment">// Error: -[Swift._NSContiguousString charValue]: unrecognized selector sent to instance</span></div><div class="line"><span class="comment">// o.setValue("true", forKeyPath: "eBool")</span></div><div class="line">o.setValue(<span class="literal">true</span>, forKeyPath: <span class="string">"eBool"</span>)</div><div class="line"><span class="built_in">print</span>(o.eBool)</div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"eBool"</span>)</div><div class="line"></div><div class="line"><span class="comment">// true</span></div><div class="line"><span class="comment">// You set nil for eBool</span></div></pre></td></tr></table></figure>
<p><strong><code>Bool</code> 支持 <code>setValue</code> 设值，但不支持自动转换，且支持设值为 <code>nil</code> 时调用 <code>setNilValueForKey</code> 方法。</strong></p>
<h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a><code>Character</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不支持 setValue</span></div><div class="line"><span class="comment">// Error: [&lt;DataType&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key fCharacter.</span></div><div class="line"><span class="comment">// let b: Character = "b"</span></div><div class="line"><span class="comment">// o.setValue(b, forKeyPath: "fCharacter")</span></div><div class="line"><span class="comment">// o.setValue(nil, forKeyPath: "fCharacter")</span></div></pre></td></tr></table></figure>
<p><strong><code>Character</code> 不支持 setValue。</strong></p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a><code>String</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">o.setValue(<span class="string">"gString"</span>, forKeyPath: <span class="string">"gString"</span>)</div><div class="line"><span class="built_in">print</span>(o.gString)</div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"gString"</span>)</div><div class="line"><span class="built_in">print</span>(o.gString)</div><div class="line"></div><div class="line"><span class="comment">// gString</span></div><div class="line"><span class="comment">//</span></div></pre></td></tr></table></figure>
<p><strong><code>String</code> 支持 <code>setValue</code> 设值，设值为 <code>nil</code> 时不调用 <code>setNilValueForKey</code> 方法，但可以清空。</strong></p>
<h3 id="Array-lt-Int-gt"><a href="#Array-lt-Int-gt" class="headerlink" title="Array&lt;Int&gt;"></a><code>Array&lt;Int&gt;</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不支持自动转换</span></div><div class="line"><span class="comment">// Error: -[Swift._NSContiguousString count]: unrecognized selector sent to instance</span></div><div class="line"><span class="comment">// o.setValue("1", forKeyPath: "hArray")</span></div><div class="line">o.setValue([<span class="number">1</span>], forKeyPath: <span class="string">"hArray"</span>)</div><div class="line"><span class="built_in">print</span>(o.hArray)</div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"hArray"</span>)</div><div class="line"><span class="built_in">print</span>(o.hArray)</div><div class="line"></div><div class="line"><span class="comment">// [1]</span></div><div class="line"><span class="comment">// []</span></div></pre></td></tr></table></figure>
<p><strong><code>Array&lt;Int&gt;</code> 支持 <code>setValue</code> 设值，但不支持自动转换，设值为 <code>nil</code> 时不调用 <code>setNilValueForKey</code> 方法，但可以清空。</strong></p>
<h3 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a><code>Dictionary</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不支持自动转换</span></div><div class="line"><span class="comment">// Error: -[Swift._NSContiguousString count]: unrecognized selector sent to instance</span></div><div class="line"><span class="comment">// o.setValue("[\"2\": 2]", forKeyPath: "iDictionary")</span></div><div class="line">o.setValue([<span class="string">"2"</span>: <span class="number">2</span>], forKeyPath: <span class="string">"iDictionary"</span>)</div><div class="line"><span class="built_in">print</span>(o.iDictionary)</div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"iDictionary"</span>)</div><div class="line"><span class="built_in">print</span>(o.iDictionary)</div><div class="line"></div><div class="line"><span class="comment">// ["2": 2]</span></div><div class="line"><span class="comment">// [:]</span></div></pre></td></tr></table></figure>
<p><strong><code>Dictionary</code> 支持 <code>setValue</code> 设值，但不支持自动转换，设值为 <code>nil</code> 时不调用 <code>setNilValueForKey</code> 方法，但可以清空。</strong></p>
<h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a><code>Tuple</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不支持 setValue</span></div><div class="line"><span class="comment">// Error: [&lt;DataType&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key jTuple.</span></div><div class="line"><span class="comment">// let t = (1, 1)</span></div><div class="line"><span class="comment">// o.setValue(t, forKeyPath: "jTuple")</span></div><div class="line"><span class="comment">// o.setValue(nil, forKeyPath: "jTuple")</span></div></pre></td></tr></table></figure>
<p><strong><code>Tuple</code> 不支持 setValue。</strong></p>
<h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a><code>Optional</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不支持 setValue</span></div><div class="line"><span class="comment">// Error: [&lt;DataType&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key kOptional.</span></div><div class="line"><span class="comment">// o.setValue(1, forKeyPath: "kOptional")</span></div><div class="line"><span class="comment">// o.setValue(nil, forKeyPath: "kOptional")</span></div></pre></td></tr></table></figure>
<p><strong><code>Optional</code> 不支持 setValue。</strong></p>
<h3 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">o.setValue(<span class="string">"1"</span>, forKeyPath: <span class="string">"lObject.prop"</span>)</div><div class="line"><span class="built_in">print</span>(o.lObject.prop)</div><div class="line"><span class="comment">// 不支持设值 nil</span></div><div class="line"><span class="comment">// Error: [&lt;Type&gt; setNilValueForKey]: could not set nil as the value for the key prop.</span></div><div class="line"><span class="comment">//o.setValue(nil, forKeyPath: "lObject.prop")</span></div><div class="line"></div><div class="line"><span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p><strong>自定义类的对象的属性支持 <code>setValue</code> 自动转换设值，但不支持设值为 <code>nil</code>。</strong></p>
<h3 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a><code>NSDictionary</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> nsDict: <span class="type">NSDictionary</span> = [<span class="string">"1"</span>: <span class="number">1</span>]</div><div class="line">o.setValue(nsDict, forKeyPath: <span class="string">"mNSDictionary"</span>)</div><div class="line"><span class="built_in">print</span>(o.mNSDictionary[<span class="string">"1"</span>])</div><div class="line"></div><div class="line"><span class="keyword">let</span> swiftDict = [<span class="string">"2"</span>: <span class="number">2</span>]</div><div class="line">o.setValue(swiftDict, forKeyPath: <span class="string">"mNSDictionary"</span>)</div><div class="line"><span class="built_in">print</span>(o.mNSDictionary[<span class="string">"2"</span>])</div><div class="line"></div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"mNSDictionary"</span>)</div><div class="line"><span class="built_in">print</span>(o.mNSDictionary[<span class="string">"2"</span>])</div><div class="line"></div><div class="line"><span class="comment">// Optional(1)</span></div><div class="line"><span class="comment">// Optional(2)</span></div><div class="line"><span class="comment">// nil</span></div></pre></td></tr></table></figure>
<p><strong><code>NSDictionary</code> 支持 <code>setValue</code> 设值（支持 Swift 中的 <code>Dictionary</code> 以及 <code>NSDictionary</code>），但不支持自动转换，设值为 <code>nil</code> 时不调用 <code>setNilValueForKey</code> 方法，但可以清空。</strong></p>
<h3 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a><code>NSArray</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">o.setValue(<span class="string">"a"</span>, forKeyPath: <span class="string">"nNSArray"</span>)</div><div class="line"><span class="built_in">print</span>(o.nNSArray)</div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"nNSArray"</span>)</div><div class="line"><span class="built_in">print</span>(o.nNSArray == <span class="literal">nil</span>)</div><div class="line"></div><div class="line"><span class="comment">// a</span></div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><strong><code>NSArray</code> 支持 <code>setValue</code> 设值（<code>NSArray</code> 存储 <code>Any</code> 类型，因此不存在自动转换），设值为 <code>nil</code> 时不调用 <code>setNilValueForKey</code> 方法，但会设值为 <code>nil</code>。</strong></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这次将 Swift 中的一些数据类型拿出来单独测试了 KVC，结果来看有部分类型对此支持并不完全，所以在往后从网络获取数据一定要进行相应的处理再 <code>setValue</code>。也最好重写 <code>func setValue(_ value: Any?, forUndefinedKey key: String)</code>，必要时重写 <code>func setNilValueForKey(_ key: String)</code>。Swift 是一门强类型语言，就要求程序员多加注意类型转换等其他问题，以减少或避免程序崩溃，带来不好的用户体验。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Key-Value Coding&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Swift 3 中的访问控制</title>
    <link href="https://maimieng.com/2016/25/"/>
    <id>https://maimieng.com/2016/25/</id>
    <published>2016-10-19T16:00:00.000Z</published>
    <updated>2016-10-26T09:46:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Access Control in Swift 3.0<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.1 Beta 4</li>
<li>Xcode 8.1 Beta 3</li>
<li>Swift 3.0</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习过 Java 等面向对象语言的同学对访问控制一定不陌生，Swift 3 相较于之前的版本，新加了两个关于访问控制修饰符，<code>open</code> 和 <code>fileprivate</code>。因此，是时候总结一下这四个关键字的<strong>基本用法</strong>，因为暂未涉及到复杂的访问控制，故为浅谈。</p>
<p>另外，由于 Apple.com 的所有文档均无权翻译，所以取消之前的翻译，转为自己的理解和代码，权当给自己做个笔记。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>访问控制修饰符的限制性 <strong>高-&gt;低</strong> 排序为下：</p>
<p><code>open</code> &gt; <code>public</code> &gt; <code>internal</code>(默认) &gt; <code>fileprivate</code> &gt; <code>private</code></p>
<p>访问控制的使用原则：<strong>不允许将实体定义在限制性更强的实体内。</strong>所以，以下代码均为错误用法，并注明了错误信息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">var</span> cat = <span class="type">Cat</span>()</div><div class="line"><span class="comment">// Error: Variable cannot be declared public because its type 'Cat' uses an internal type</span></div><div class="line"><span class="comment">// public 变量不能为 internal，fileprivate，private 类型</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">testAccessControl</span><span class="params">(<span class="number">_</span> cat: Cat)</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> cat</div><div class="line">&#125;</div><div class="line"><span class="comment">// Error: Function cannot be declared public because its parameter uses an internal type</span></div><div class="line"><span class="comment">// 函数或方法的访问限制级别不能高于其参数类型</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">testAccessControl</span><span class="params">()</span></span> -&gt; <span class="type">Cat</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Cat</span>()</div><div class="line">&#125;</div><div class="line"><span class="comment">// Error: Function cannot be declared public because its result uses an internal type</span></div><div class="line"><span class="comment">// 函数或方法的访问限制级别不能高于其返回值类型</span></div></pre></td></tr></table></figure>
<h3 id="open-amp-public"><a href="#open-amp-public" class="headerlink" title="open &amp; public"></a><code>open</code> &amp; <code>public</code></h3><p><code>open</code> 是 Swift 3 新增的访问控制符，相较于 <code>public</code> 更加开放。<code>open</code> 和 <code>public</code> 都是可以跨 Module 访问的，但 <code>open</code> 修饰的类可以继承，修饰的方法可以重写（此时，<code>open</code> 需同时修饰该方法以及所在类），而 <code>public</code> 不可以。</p>
<p>至于 <code>public final</code> 与 <code>public</code>，前者在任何地方均不可重写，而后者可在本 Module 内重写。</p>
<h4 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h4><p>ModuleA: Person.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// open 修饰的类可以为其他 Module 所访问和继承</span></div><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="comment">// 属性：</span></div><div class="line">    <span class="comment">// 子类可访问，不可重写</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> note = <span class="string">"maimieng.com"</span></div><div class="line">    </div><div class="line">    <span class="comment">// 方法：</span></div><div class="line">    <span class="comment">// 子类可访问，可重写</span></div><div class="line">    open <span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Work"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 子类可访问，不可重写</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Eat it"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 子类可访问，不可重写</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Take a walk"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ModuleB: Programmer.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ModuleA</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span>: <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="comment">// 只可重写 open 方法</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">// 可访问父类 public 和 public final 方法</span></div><div class="line">        eat()</div><div class="line">        walk()</div><div class="line">        </div><div class="line">        <span class="built_in">print</span>(<span class="string">"Writing \(note)"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="错误信息汇总"><a href="#错误信息汇总" class="headerlink" title="错误信息汇总"></a>错误信息汇总</h4><h5 id="重写父类-public-方法"><a href="#重写父类-public-方法" class="headerlink" title="重写父类 public 方法"></a>重写父类 public 方法</h5><p>ModuleA: Person.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Eat it"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ModuleB: Programmer.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ModuleA</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span>: <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Hamburger!!"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Overriding non-open instance method outside of its defining module</strong></p>
<hr>
<h5 id="重写父类-public-属性"><a href="#重写父类-public-属性" class="headerlink" title="重写父类 public 属性"></a>重写父类 public 属性</h5><p>ModuleA: Person.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> note = <span class="string">"maimieng.com"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ModuleB: Programmer.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ModuleA</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span>: <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="keyword">var</span> note: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"v1024.cn"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>Overriding non-open var outside of its defining module</strong></p>
<h5 id="重写-public-父类"><a href="#重写-public-父类" class="headerlink" title="重写 public 父类"></a>重写 public 父类</h5><p>ModuleA: Animal.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span>: <span class="title">NSObject</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>ModuleB: Programmer.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ModuleA</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Animal</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p><strong>Cannot inherit from non-open class ‘Animal’ outside of its defining module</strong></p>
<h3 id="internal"><a href="#internal" class="headerlink" title="internal"></a><code>internal</code></h3><p><code>internal</code> 是 Swift 中默认／缺省的访问控制级别。网上对于其他修饰符的解释有很多，而 <code>internal</code> 却很少。<code>internal</code> 对自身 Module 开放所有源文件，而对外界源代码屏蔽。</p>
<h4 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo"></a>Demo</h4><p>ModuleA: Person.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Person Name"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ModuleA: Designer.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Designer</span>: <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"test internal"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="错误信息汇总-1"><a href="#错误信息汇总-1" class="headerlink" title="错误信息汇总"></a>错误信息汇总</h4><p>在 ModuleB 访问 ModuleA</p>
<p>ModuleA: Person.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Person Name"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ModuleB: Programmer.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ModuleA</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span>: <span class="title">Person</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p><strong>Use of undeclared type ‘Person’</strong></p>
<h3 id="fileprivate-amp-private"><a href="#fileprivate-amp-private" class="headerlink" title="fileprivate &amp; private"></a><code>fileprivate</code> &amp; <code>private</code></h3><p>Swift 3 新增的另一个访问修饰符是 <code>fileprivate</code>。</p>
<h4 id="Demo-3"><a href="#Demo-3" class="headerlink" title="Demo"></a>Demo</h4><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="comment">// 默认／缺省 internal</span></div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</div><div class="line">    </div><div class="line">    <span class="comment">// private 仅可在本类中访问</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> privateProp = <span class="string">"Private Property"</span></div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">privateMethod</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">    </div><div class="line">    <span class="comment">// fileprivate 可在当前文件内所有类访问</span></div><div class="line">    fileprivate <span class="keyword">var</span> filePrivateProp = <span class="string">"File Private Property"</span></div><div class="line">    fileprivate <span class="function"><span class="keyword">func</span> <span class="title">filePrivateMethod</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</div><div class="line">        filePrivateMethod()</div><div class="line">        <span class="built_in">print</span>(<span class="string">"\(filePrivateProp)"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    fileprivate <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">filePrivateMethod</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="错误信息汇总-2"><a href="#错误信息汇总-2" class="headerlink" title="错误信息汇总"></a>错误信息汇总</h4><h5 id="子类访问父类-private-成员"><a href="#子类访问父类-private-成员" class="headerlink" title="子类访问父类 private 成员"></a>子类访问父类 private 成员</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">privateMethod</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</div><div class="line">        privateMethod()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>‘privateMethod’ is inaccessible due to ‘private’ protection level</strong></p>
<hr>
<h5 id="其他文件的子类访问-fileprivate-成员"><a href="#其他文件的子类访问-fileprivate-成员" class="headerlink" title="其他文件的子类访问 fileprivate 成员"></a>其他文件的子类访问 fileprivate 成员</h5><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    fileprivate <span class="keyword">var</span> filePrivateProp = <span class="string">"File Private Property"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Cat.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"\(filePrivateProp)"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>‘filePrivateProp’ is inaccessible due to ‘fileprivate’ protection level</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 Swift 3 中新增的访问控制修饰符，使得 Swift 的访问控制更加灵活。使用不同的访问修饰符，可以使得程序耦合性降低，对外界屏蔽内部的实现细节。但是，Objective-C 是一门允许动态处理的语言，<code>private</code> 只是所谓的私有，而不是真正的私有，通过 KVC 还是可以获取到内部的细节，而 Swift 由于性能的考虑，默认关闭了动态处理，下一篇谈谈 Swift 中的 KVC &amp; KVO。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html" target="_blank" rel="external">Access Control</a></li>
<li><a href="https://maimieng.com/2016/24/">在 iOS 项目中新建 Module</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Access Control in Swift 3.0&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>在 iOS 项目中新建 Module</title>
    <link href="https://maimieng.com/2016/24/"/>
    <id>https://maimieng.com/2016/24/</id>
    <published>2016-10-19T16:00:00.000Z</published>
    <updated>2016-10-26T09:46:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Access Control Prerequisite Article<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.1 Beta 4</li>
<li>Xcode 8.1 Beta 3</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Module，中文译为「标准部件；模块」。iOS 中的 Module 类似于 Java 中的 Jar 包，也可以称作第三方库，或者框架（Framework)。Swift 中的访问控制就涉及到了不同 Module 下的情况，因此简单记录下如何在 iOS 项目中新建 Module。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>首先建立一个 iOS Single View Application。</p>
<p>选择 File-New-Target。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/new_module_1.png" alt="File"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/new_module_2.png" alt="New"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/new_module_3.png" alt="Target"></p>
<p>选择 Cocoa Touch Framework。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/new_module_4.png" alt="Cocoa Touch Framework"></p>
<p>如图，即为建立的 Module（此处建立两个方便后续测试访问控制修饰符）。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/new_module_5.png" alt="新建完成"></p>
<p>使用时，<code>import ModuleA</code> 即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Access Control Prerequisite Article&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>生日记</title>
    <link href="https://maimieng.com/2016/26/"/>
    <id>https://maimieng.com/2016/26/</id>
    <published>2016-10-19T16:00:00.000Z</published>
    <updated>2016-10-31T11:35:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>生命不息，向死而生。<br>内容有些凌乱，暂不修改<br></blockquote><br><a id="more"></a><br>在 QQ 空间里朋友送的礼物提醒下，似乎快要过生日了。虽然在今天之前也知道自己快要过生日了，但是到了这一天也似乎没什么分别。可能是最近有些忙碌，可能其实生日也算不了什么吧。也好久没有什么理由写点什么了，这里总是冷冰冰的技术文也不太好，所以还是写点什么，记录下吧。</p>
<p>很遗憾，大学似乎在知乎大神口中是绚丽多彩的，在小时代中也是很精彩的。而我这几年的重心只放在了学习上，虽说可能比不上 985／211 的学霸们，但也算是没有太大的愧疚吧。</p>
<p>来到大学已两年有余，大一刚进来的时候，一心想要进入卓越班，也想拿到国家奖学金。毕竟这所大学不怎么样，没有什么能够证明自己。结果，卓越班迟迟未开始，拿着专业第一的成绩才发现国家奖学金仅仅属于大三，结果连国家励志也没有拿到。说实话，那时候心里很不服，但我只是想，不就再努力一年嘛，有什么大不了的。</p>
<p>大一的暑假似乎是完全浪费的，由于在家里我的惰性很强，可能是习惯竞争的环境。虽然我不玩游戏，但也没有去学习，只是在暑假的最后一段时间，学了学 Java 基础，很欣慰，当时的笔记得到了浙大翁凯老师的微博推荐。</p>
<p>大一就那样过去了，迎来了大二。大二，进入了卓越班，考过了四级，六级。虽然这样看来算是有点成绩，而且大二的杂事少多了，我也退出了社团，但现在看来，大二这一年所学习的有些杂乱，虽然对于计算机的热情仍在，但缺少方向。由于大四就可以出去实习，最近也看了一些招聘帖，所以也是感觉时间紧迫，要学有所长，而不是蜻蜓点水。</p>
<p>从大一到现在，我的学习环境几乎都是在宿舍，虽然在大二时有去过汇森学习，也去过图书馆，但最久的还是宿舍。虽然有时候觉得在宿舍效率低，但是似乎我已经习惯了这个嘈杂的环境。至少我认为，虽然我身在宿舍，但我所做的事是学习，</p>
<p>今年最好的生日礼物，算是获得了国家奖学金吧。金钱固然重要，但这张奖状算是对我这两年的一个肯定吧。毕竟没有多少人知道我所做的，没有多少人肯定我所做的，没有正面的反馈，想要单单靠热情来驱动，的确是挺难的。老罗曾经说过，具体原话是否如此不太记得:“通过干干净净地赚钱来证明，在中国是可以做到干干净净地赚钱”。我不清楚也不关心老罗是否干净的赚钱。我只是觉得，通过自己的努力，在没有出身也可以尽力做到最好。</p>
<p>今天呢，Apple 宣布 2016 年 10 月 27 日召开发布会，360 云盘宣布即将关闭。每天，都有不同的事情发生，最近在听一档关于日本的播客，很有深度，引人思考。人的一生不过几十年，多去尝试，多去思考，虽然荆棘遍地，人心叵测，但我仍愿意相信美好。生命不息，向死而生。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;生命不息，向死而生。&lt;br&gt;内容有些凌乱，暂不修改&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Essay" scheme="https://maimieng.com/tags/Essay/"/>
    
  </entry>
  
</feed>
