<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>V2M</title>
  <subtitle>Way to MM.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://maimieng.com/"/>
  <updated>2017-01-02T16:10:37.000Z</updated>
  <id>https://maimieng.com/</id>
  
  <author>
    <name>kingcos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>回顾 2016，展望 2017</title>
    <link href="https://maimieng.com/2017/1/"/>
    <id>https://maimieng.com/2017/1/</id>
    <published>2016-12-31T16:00:00.000Z</published>
    <updated>2017-01-02T16:10:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>New Year, New Start.<br></blockquote><br><a id="more"></a></p>
<blockquote>
<p>今天是 2017 年 1 月 1 日，其实在昨天我已经起草了一份年终总结。每次的年终总结总要回想一年的时光，可又哪是一时半会可以总结的好的呢？</p>
</blockquote>
<p>2016 年，我从大二升到大三。这一年，有很多的感慨，有得到一些，也失去一些。纵然 2016 已经过去，那么现在就是时候就做个总结，记下展望。</p>
<h2 id="回顾-2016"><a href="#回顾-2016" class="headerlink" title="回顾 2016"></a>回顾 2016</h2><h3 id="百度-IFE-amp-FCC"><a href="#百度-IFE-amp-FCC" class="headerlink" title="百度 IFE &amp; FCC"></a>百度 IFE &amp; FCC</h3><p>在 2016 年 3 月到 4 月的一个月时间，我召集了几个学习前端的同学一起参加<a href="http://ife.baidu.com/" target="_blank" rel="external">百度前端技术学院</a>。虽然当时也在 FreeCodeCamp 上学习前端的基础知识，但遗憾的是我们并没有坚持下去。最近在完成课程设计中，开发前端页面中使用了 Element UI 和 Vue.js，由于对前端的不了解，发现了很多坑。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/from2016to2017_01.png" alt="Team Bug"></p>
<h4 id="体会："><a href="#体会：" class="headerlink" title="体会："></a>体会：</h4><ol>
<li>代码规范的重要性</li>
<li>前端中，JavaScript 是一个难点，重点</li>
<li>前端的 UI 框架和 JS 框架都需要学习</li>
<li>前端组件化，前后端分离</li>
</ol>
<h3 id="CET-6"><a href="#CET-6" class="headerlink" title="CET-6"></a>CET-6</h3><p>比起四级前的疯狂学习（至少抄了 100 页单词，做了 20 套卷子），六级的复习就仅仅在考前的三周，临近考试的一周还得了感冒，于是就放弃复习。那次六级又是第一次听力改革，加上收音耳机不给力，考完就没有报太大的信心。结果是考了 446 分，不算高，但也算是过了及格线。平时学英语的途径也就只有翻译电台的演讲，并没有其他刻意的学习。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/from2016to2017_02.png" alt="Twitter 推文"></p>
<h4 id="体会：-1"><a href="#体会：-1" class="headerlink" title="体会："></a>体会：</h4><ol>
<li>英语是一种工具，要掌握好</li>
<li>未来要拓展除英文之外的语种（例如：日语）</li>
<li>语言的学习不应该是为了考试分数，而是应该追求实学（奶爸文章有感）</li>
</ol>
<h3 id="培训"><a href="#培训" class="headerlink" title="培训"></a>培训</h3><p>2016 年暑假的第一个月是卓越班的 Java 培训。虽然我已经了解 Java 的基本使用，但在这一个月体验培训也很有感触。</p>
<h4 id="体会：-2"><a href="#体会：-2" class="headerlink" title="体会："></a>体会：</h4><ol>
<li>专心才能学好。在这一个月的时间，从早到晚，几乎都在教室，虽然天气很热，但是这样集中时间干一件事确实学习速度很快，干劲很足</li>
<li>培训的弊端。培训由于时间的紧凑，没有太多时间留给个人去思考，而是灌输式地教学。「别问为什么，你只要会用就行」，这样确实加速了开发，但是这样没有<strong>主动地探索式</strong>的学习，我个人是觉得不太牢靠。当然培训也存在其他问题，但也有很多好处，见仁见智</li>
</ol>
<h3 id="国奖"><a href="#国奖" class="headerlink" title="国奖"></a>国奖</h3><p>在小学、初中、高中从来没有拿过第一的我，在大学里终于算是「扳回一局」。之所以带引号，是因为我也知道大学课程很水，成绩更水。有的老师要求苛刻，有的可能全部给过。学生们也是抱着 60 分万岁，多一分犯罪的态度。毕竟大学除了学习还有很多甚至更重要的事情。</p>
<p>而我把国家奖学金仅仅当作一种肯定。以那样的高考分数进到这样一所学校，我<strong>没有任何</strong>「炫耀」的资本。这两年算是勤勤恳恳地学过来了，虽然「成绩」并不优异，但这个奖算是对我的一种肯定，一种鼓励。</p>
<h4 id="体会：-3"><a href="#体会：-3" class="headerlink" title="体会："></a>体会：</h4><ol>
<li>只要方向正确，努力终会有所回报</li>
<li>要学会适当的自我营销</li>
</ol>
<h3 id="电台"><a href="#电台" class="headerlink" title="电台"></a>电台</h3><p>网易云上的电台是我 2015 年 4 月 18 日开设的。到现在已经快两年了，奥巴马总统也快要卸任了。一周一更的速度其实并不快，但是近几个月也停更了。也很感谢支持、订阅我的朋友，可我最近的弃更确实对不住你们的期待。我想在最近思考下电台和公众号的未来，绝不会放弃这样的平台。</p>
<h4 id="体会：-4"><a href="#体会：-4" class="headerlink" title="体会："></a>体会：</h4><ol>
<li>坚持，坚持，再坚持</li>
<li>有些事情看似对自己毫无意义，但在无形中就能帮到他人</li>
</ol>
<h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>2016 年，我一共写了 38 篇博客。在接近年终的时候，我开始下定决心学习 iOS，并把学习过程的中的一些问题的解决总结成文，发表出去。这一想法的起始于暑假培训时写的两篇 Java 的文章，我开始思考博客的意义。博客不应该是一个记笔记的地方，而是个人思想传播的途径。<strong>在学习过程解决疑问，却很值得记录，与他人分享。</strong></p>
<p>我很享受这样一个写作、分享的过程。虽然一篇文章我常常需要打开十几个网页，对比学习，并用 Xcode 写下 Demo，再进行测试。但是每在简书或是掘金收到一次喜欢或是收藏都会十分激动。虽然可能有一些虚荣，但是如果虚荣能促使一个人进步，那么我觉得也是不错的。</p>
<p>当然现在的写作速度很慢，有时候又被很多事情拖着，未来一定会继续更新！希望能够帮到更多的人。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/from2016to2017_03.png" alt="简书个人主页"></p>
<h4 id="体会：-5"><a href="#体会：-5" class="headerlink" title="体会："></a>体会：</h4><ol>
<li>写技术文章一定要经得起考证</li>
<li>技术文章一定要严谨，重视细节</li>
<li>有时候，一句简单的评论就能给作者带来好心情（这点是我自己感受到的）</li>
</ol>
<h2 id="展望-2017"><a href="#展望-2017" class="headerlink" title="展望 2017"></a>展望 2017</h2><h3 id="驾照"><a href="#驾照" class="headerlink" title="驾照"></a>驾照</h3><p>2017 年第一个展望便是在离校前把驾照考下来。虽然考过驾照，家里也没有车能让我开，但确实是一个必备技能了。我报驾照的时间确实有些晚，已经没有太多时间拖延，所以第一个展望就留给驾照吧。</p>
<h3 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h3><p>2017 年，最重要的可能就是实习了。即将踏入职场，现在的我很兴奋，很憧憬。我知道自己可能进不了 BAT 这样的巨头，也进不了那些大家耳熟能详的互联网公司。剩下的时间也没多少了，只希望自己能找到一份热情的工作吧！但起码要够自己租房和生活的支出。</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>在最近的学习中，才深切发现计算机基础的薄弱。在找实习之前的时间，我会尽力巩固基础。</p>
<h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>2017 年我会多读书，并写下笔记，与大家分享。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>2016 年，我的 GitHub 上终于够了 10 颗星。2017 我希望这个数字达到 100。我相信这个目标并不难，因为已经有计划开始写开源项目了。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/from2016to2017_04.png" alt="GitHub"></p>
<h3 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h3><p>新的一年，我也希望自己能够坚持锻炼身体，坚持早起，坚持学习。Apple Watch S1 作为给自己的礼物也不能浪费是不。。</p>
<hr>
<p>最后呢，谢谢 FF 所说的「<strong><em>好感并不等于喜欢</em></strong>」。另外我也会尽力和一些人保持联系，而不是像以前那样时间长了，就断了联系。</p>
<p>寒假的计划也放在这里吧：</p>
<ol>
<li>完成 Swift 设计模式相应的文章</li>
<li>学习基础算法</li>
<li>读完两本书</li>
<li>在课程设计基础上完善项目并开源</li>
<li>拿到驾照</li>
<li>开更电台 &amp; 公众号</li>
</ol>
<blockquote>
<p>一切尚早，我，还在路上。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;New Year, New Start.&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Plan" scheme="https://maimieng.com/tags/Plan/"/>
    
  </entry>
  
  <entry>
    <title>研读 CSAPP 之一： A Tour of Computer Systems</title>
    <link href="https://maimieng.com/2016/38/"/>
    <id>https://maimieng.com/2016/38/</id>
    <published>2016-12-23T16:00:00.000Z</published>
    <updated>2016-12-26T00:59:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>第一章：计算机系统之旅<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.3 Beta</li>
<li>CS: APP 3e Eng</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学习越深入时，就越发觉得基础不牢靠。有幸找到一本神书，CS:APP 第三版的英文原版。由于几乎已经习惯阅读英文，虽可能速度较慢，但可以免受翻译者思维的干扰。书很好，但还是希望沉下心，好好阅读，做好笔记，融会贯通。</p>
<p><strong>需要注意的是：该研读系列为个人总结，不免有一些错误，希望您能提出意见或建议，我都会细心研究，做出改正。谢谢！</strong></p>
<h2 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h2><p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.1.png" alt="1.1"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.2.png" alt="1.2"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.3.png" alt="1.3"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.4.png" alt="1.4"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.5.png" alt="1.5"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.6.png" alt="1.6"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.7.png" alt="1.7"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.8.png" alt="1.8"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.9.png" alt="1.9"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/csapp_1_1.10.png" alt="1.10"></p>
<h2 id="练习题解"><a href="#练习题解" class="headerlink" title="练习题解"></a>练习题解</h2><blockquote>
<p>虽然书中有练习的答案，但我仍尝试自己解决，并将问题和解法发布在此与大家交流。</p>
</blockquote>
<h3 id="Practice-Problem-1-1"><a href="#Practice-Problem-1-1" class="headerlink" title="Practice Problem 1.1"></a>Practice Problem 1.1</h3><blockquote>
<p>假设你是一位卡车司机，被雇佣运输一车土豆从 BI 地到 MM 地，两地距离 2500km。由于限速，你预估自己能以 100km/hr 的速度行驶，所以全程需要 25 小时。</p>
</blockquote>
<h4 id="A"><a href="#A" class="headerlink" title="A"></a>A</h4><blockquote>
<p>你听新闻说，MM 地刚刚取消限速，相当于全程中的 1500km，你的卡车能以 150km/hr 的速度行驶。那么全程的加速比是多少？</p>
</blockquote>
<h4 id="B"><a href="#B" class="headerlink" title="B"></a>B</h4><blockquote>
<p>你可以为你的卡车购买一个新的涡轮增压器。经销商处有不同的型号，但是速度越快，价格也就越贵。如果想在全程拥有 1.67* 的加速比，那么你需要以多快的速度行驶？</p>
</blockquote>
<h3 id="Practice-Problem-1-2"><a href="#Practice-Problem-1-2" class="headerlink" title="Practice Problem 1.2"></a>Practice Problem 1.2</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;第一章：计算机系统之旅&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="CSAPP" scheme="https://maimieng.com/tags/CSAPP/"/>
    
      <category term="Reading" scheme="https://maimieng.com/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的字符串截取</title>
    <link href="https://maimieng.com/2016/37/"/>
    <id>https://maimieng.com/2016/37/</id>
    <published>2016-12-13T16:00:00.000Z</published>
    <updated>2016-12-14T10:47:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Substring in Swift 3.0<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.2 Beta</li>
<li>Xcode 8.2 Beta</li>
<li>Swift 3.0</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>最近更文的频率也是越来越慢，除去已到期末的缘故，加上在忙老师的项目，自己的时间便被压缩殆尽。不过好在 <a href="https://github.com/kingcos/Swift-3-Design-Patterns" target="_blank" rel="external">Swift 设计模式</a>基本上已经更新完毕，下来就准备补齐每个模式对应的说明。</p>
</blockquote>
<p>在尝试使用 Swift 实现《大话设计模式》一书中的<a href="https://github.com/kingcos/Swift-3-Design-Patterns/blob/master/24-Interpreter_Pattern.playground/Contents.swift" target="_blank" rel="external">解释器模式</a>时，书中的 Demo 多次使用了截取字符串的方法，当然，Swift 作为一门先进的编程语言不会缺少这一常用的方法。然而在使用中，可能由于 Swift 是一门较为注重（类型）安全的语言，其字符串截取方法使用方式与 Java 等编程语言便有一些语法上的不同。在 Swift 自身的迭代过程中，这部分的语法变化也很大。所以这次就来简单研究一下 Swift 中的字符串截取。需要注意的是，虽然 Swift 也可以使用 NSString 类型的字符串，而且两者可以很容易的桥接，但考虑到个人对 Objective-C 的了解程度，便暂时不探讨。</p>
<h2 id="String-Index"><a href="#String-Index" class="headerlink" title="String.Index"></a>String.Index</h2><h3 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h3><blockquote>
<p>索引与下标，即 index 和 subscript。一般来说，两者的概念是类似的，不过个人觉得索引有泛指的概念，而下标是具体的。</p>
</blockquote>
<p>Swift 中字符串的索引类型并不是其他语言中的整型（int），而是 String.Index。String.Index，即标注字符串的索引类型。在 Swift 的标准库中，可以看到其本质是 <code>String.CharacterView.Index</code> 的别名。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// The index type for subscripting a string.</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Index</span> = <span class="type">String</span>.<span class="type">CharacterView</span>.<span class="type">Index</span></div></pre></td></tr></table></figure>
<p>再进一步查看 <code>String.CharacterView</code>，即创建给定字符串的<strong>字符</strong>视图类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">CharacterView</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/// Creates a view of the given string.</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> text: <span class="type">String</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>常用的 <code>&quot;maimieng.com&quot;.characters</code> 的类型其实就是 <code>String.CharacterView</code> 类型。<code>.characters</code> 将字符串内容转化为字符序列的视图。</p>
<h3 id="start-amp-end"><a href="#start-amp-end" class="headerlink" title="start &amp; end"></a>start &amp; end</h3><p>字符串必然是一个字符的有限序列，Swift 为了方便开发者迅速定位，便集成了 <code>startIndex</code> 和 <code>endIndex</code>。但是需要注意的是：<code>startIndex</code> 是指字符串的第一个字符的下标，而 <code>endIndex</code> 是指字符串的最后一个字符<strong>之后</strong>的下标。当字符串为空时，<code>startIndex</code> 和 <code>endIndex</code> 相同。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"maimieng.com"</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(str.characters.<span class="built_in">count</span>)</div><div class="line"></div><div class="line"><span class="built_in">print</span>(str.startIndex)</div><div class="line"><span class="built_in">print</span>(str.endIndex)</div><div class="line"></div><div class="line"><span class="comment">// 12</span></div><div class="line"><span class="comment">// Index(_base: Swift.String.UnicodeScalarView.Index(_position: 0), _countUTF16: 1)</span></div><div class="line"><span class="comment">// Index(_base: Swift.String.UnicodeScalarView.Index(_position: 12), _countUTF16: 0)</span></div></pre></td></tr></table></figure>
<p>从上面的 Demo 也可以看出，<code>startIndex</code> 的位置为 0，而 <code>endIndex</code> 的位置为 12，等同于字符串的长度，而<strong>不是</strong>字符串长度减一。</p>
<p>除了给出了起始和结尾的下标，Swift 也提供了根据下标定位其他索引的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after i: String.Index)</span></span> -&gt; <span class="type">String</span>.<span class="type">Index</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(before i: String.Index)</span></span> -&gt; <span class="type">String</span>.<span class="type">Index</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(<span class="number">_</span> i: String.Index, offsetBy n: String.IndexDistance)</span></span> -&gt; <span class="type">String</span>.<span class="type">Index</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(<span class="number">_</span> i: String.Index, offsetBy n: String.IndexDistance, limitedBy limit: String.Index)</span></span> -&gt; <span class="type">String</span>.<span class="type">Index</span>?</div></pre></td></tr></table></figure>
<p>这样就可以通过给出的 <code>startIndex</code> 和 <code>endIndex</code> 来定位到其他的下标了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"maimieng.com"</span></div><div class="line"></div><div class="line"><span class="comment">// 返回传入下标之后的下标</span></div><div class="line"><span class="built_in">print</span>(str.index(after: str.startIndex))</div><div class="line"><span class="comment">// 返回传入下标之前的下标</span></div><div class="line"><span class="built_in">print</span>(str.index(before: str.endIndex))</div><div class="line"></div><div class="line"><span class="comment">// 返回传入下标偏移后的下标（偏移量可正可负可为 0）</span></div><div class="line"><span class="built_in">print</span>(str.index(str.startIndex, offsetBy: <span class="number">1</span>))</div><div class="line"></div><div class="line"><span class="comment">// print(str.index(str.endIndex, offsetBy: 10))</span></div><div class="line"><span class="comment">// 作用同上，但如果超过传入的界限返回 nil</span></div><div class="line"><span class="built_in">print</span>(str.index(str.endIndex, offsetBy: <span class="number">10</span>, limitedBy: str.endIndex) ?? <span class="string">"越界"</span>)</div></pre></td></tr></table></figure>
<p>下标之间的间距，也可以利用 <code>func distance(from start: String.Index, to end: String.Index) -&gt; String.IndexDistance</code> 方法求出：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"maimieng.com"</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(str.<span class="built_in">distance</span>(from: str.startIndex, to: str.endIndex))</div><div class="line"><span class="comment">// 12</span></div><div class="line"><span class="built_in">print</span>(str.<span class="built_in">distance</span>(from: str.endIndex, to: str.startIndex))</div><div class="line"><span class="comment">// -12</span></div></pre></td></tr></table></figure>
<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p>Range 即范围，Swift 中实现了 Comparable 协议的类型都可以用 Range 来表示范围。以下的 Range 特指：<code>Range&lt;String.Index&gt;</code>。</p>
<p>Range 的构造方法是 <code>init(uncheckedBounds bounds: (lower: Bound, upper: Bound))</code>。即传入一个元组，返回一个范围。需要注意的是：这个范围 Swift 是不会检查的，需要程序员自觉维护。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"maimieng.com"</span></div><div class="line"></div><div class="line"><span class="comment">// 前闭后开</span></div><div class="line"><span class="keyword">let</span> rangeA = <span class="type">Range</span>(uncheckedBounds: (str.startIndex, str.endIndex))</div><div class="line"><span class="built_in">print</span>(rangeA)</div><div class="line"><span class="comment">// Index(_base: Swift.String.UnicodeScalarView.Index(_position: 0), _countUTF16: 1)..&lt;Index(_base: Swift.String.UnicodeScalarView.Index(_position: 12), _countUTF16: 0)</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(str.substring(with: rangeA))</div><div class="line"><span class="comment">// maimieng.com</span></div><div class="line"></div><div class="line"><span class="comment">// 即使范围首尾颠倒，也没有报错</span></div><div class="line"><span class="keyword">let</span> rangeB = <span class="type">Range</span>(uncheckedBounds: (str.endIndex, str.startIndex))</div><div class="line"><span class="built_in">print</span>(rangeB)</div><div class="line"><span class="comment">// Index(_base: Swift.String.UnicodeScalarView.Index(_position: 12), _countUTF16: 0)..&lt;Index(_base: Swift.String.UnicodeScalarView.Index(_position: 0), _countUTF16: 1)</span></div><div class="line"><span class="comment">// 但在使用中会出错</span></div><div class="line"><span class="comment">// fatal error: Can't form Range with upperBound &lt; lowerBound</span></div><div class="line"><span class="comment">// str.substring(with: rangeB)</span></div></pre></td></tr></table></figure>
<p>在上面的 Demo 中，从输出中也可以看出，<code>init(uncheckedBounds bounds: (lower: Bound, upper: Bound))</code> 构造的范围是一个<strong>前闭后开</strong>的区间。</p>
<p>Swift 中，字符串本身也能构造出 Range，例如：得到字符串子串的范围，若不存在则返回 nil：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"maimieng.com"</span></div><div class="line"></div><div class="line"><span class="comment">// 返回前闭后开的范围</span></div><div class="line"><span class="built_in">print</span>(str.range(of: <span class="string">".com"</span>) ?? <span class="string">"不存在"</span>)</div><div class="line"><span class="comment">// Index(_base: Swift.String.UnicodeScalarView.Index(_position: 8), _countUTF16: 1)..&lt;Index(_base: Swift.String.UnicodeScalarView.Index(_position: 12), _countUTF16: 0)</span></div></pre></td></tr></table></figure>
<h2 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h2><p>在 Range 一节的 Demo 中，已经使用了 <code>substring(with:)</code> 方法测试范围的使用。Swift 中的字符串截取与其他语言其实是相似的，都是根据索引或索引范围来截取，只是 Swift 中的索引的类型不是整型，稍有麻烦。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"maimieng.com"</span></div><div class="line"></div><div class="line"><span class="comment">// 截取传入范围（左开右闭）的子串</span></div><div class="line"><span class="keyword">let</span> range = <span class="type">Range</span>(uncheckedBounds: (str.startIndex, str.endIndex))</div><div class="line"><span class="built_in">print</span>(str.substring(with: range))</div><div class="line"></div><div class="line"><span class="comment">// 从传入的索引开始截取到末尾（含 str.startIndex 元素）</span></div><div class="line"><span class="built_in">print</span>(str.substring(from: str.startIndex))</div><div class="line"><span class="comment">// 从传入的索引的前一个位置开始截取到头部（不含 str.endIndex 元素）</span></div><div class="line"><span class="built_in">print</span>(str.substring(to: str.endIndex))</div><div class="line"></div><div class="line"><span class="comment">// maimieng.com</span></div><div class="line"><span class="comment">// maimieng.com</span></div><div class="line"><span class="comment">// maimieng.com</span></div></pre></td></tr></table></figure>
<p>以上的 Demo 便是 Swift 中最基本的截取字符串使用。然而有时候条件一多，代码的重复率也会增加，那么可以利用 Swift 中的 extension 来扩展原有的 String，让 Swift 的 String 可以像 C#、Java 一样截取字符串，需要注意的是 这里的 IndexDistance 实际上是 String.CharacterView.IndexDistance 的别名，而 String.CharacterView.IndexDistance 又是 Int 类型的别名。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">substring</span><span class="params">(from: IndexDistance)</span></span> -&gt; <span class="type">String</span>? &#123;</div><div class="line">        <span class="keyword">let</span> index = <span class="keyword">self</span>.index(<span class="keyword">self</span>.startIndex, offsetBy: from)</div><div class="line">        <span class="keyword">return</span> str.substring(from: index)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">substring</span><span class="params">(to: IndexDistance)</span></span> -&gt; <span class="type">String</span>? &#123;</div><div class="line">        <span class="keyword">let</span> index = <span class="keyword">self</span>.index(<span class="keyword">self</span>.startIndex, offsetBy: to + <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> str.substring(to: index)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">substring</span><span class="params">(with range: Range&lt;IndexDistance&gt;)</span></span> -&gt; <span class="type">String</span>? &#123;</div><div class="line">        <span class="keyword">let</span> lower = <span class="keyword">self</span>.index(<span class="keyword">self</span>.startIndex, offsetBy: range.lowerBound)</div><div class="line">        <span class="keyword">let</span> upper = <span class="keyword">self</span>.index(<span class="keyword">self</span>.startIndex, offsetBy: range.upperBound)</div><div class="line">        <span class="keyword">let</span> range = <span class="type">Range</span>(uncheckedBounds: (lower, upper))</div><div class="line">        <span class="keyword">return</span> str.substring(with: range)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">substring</span><span class="params">(<span class="number">_</span> lower: IndexDistance, <span class="number">_</span> range: IndexDistance)</span></span> -&gt; <span class="type">String</span>? &#123;</div><div class="line">        <span class="keyword">let</span> lowerIndex = <span class="keyword">self</span>.index(<span class="keyword">self</span>.startIndex, offsetBy: lower)</div><div class="line">        <span class="keyword">let</span> upperIndex = <span class="keyword">self</span>.index(lowerIndex, offsetBy: range)</div><div class="line">        <span class="keyword">let</span> range = <span class="type">Range</span>(uncheckedBounds: (lowerIndex, upperIndex))</div><div class="line">        <span class="keyword">return</span> str.substring(with: range)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(str.substring(to: <span class="number">0</span>) ?? <span class="string">"nil"</span>)</div><div class="line"><span class="built_in">print</span>(str.substring(from: <span class="number">2</span>) ?? <span class="string">"nil"</span>)</div><div class="line"><span class="built_in">print</span>(str.substring(with: <span class="number">0</span>..&lt;<span class="number">1</span>) ?? <span class="string">"nil"</span>)</div><div class="line"><span class="built_in">print</span>(str.substring(<span class="number">1</span>, <span class="number">2</span>) ?? <span class="string">"nil"</span>)</div><div class="line"></div><div class="line"><span class="comment">// m</span></div><div class="line"><span class="comment">// imieng.com</span></div><div class="line"><span class="comment">// m</span></div><div class="line"><span class="comment">// ai</span></div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Documentation &amp; API Reference</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Substring in Swift 3.0&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的值类型与引用类型</title>
    <link href="https://maimieng.com/2016/36/"/>
    <id>https://maimieng.com/2016/36/</id>
    <published>2016-11-21T16:00:00.000Z</published>
    <updated>2016-11-28T16:47:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Value Type &amp; Reference Type<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.2 Beta</li>
<li>Xcode 8.2 Beta</li>
<li>Swift 3.0</li>
</ul>
</li>
</ul>
<p><strong>2016-11-28 Update: 调整了行文顺序，并增加了一部分图文。</strong></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在学设计模式中，发现 Swift 中的 struct，class 以及 enum 在一般的使用中能够做到互相替换，因此探究其背后的逻辑就十分有必要。而这一问题又引出了 Swift 中的值类型和引用类型的区别。在网上搜寻一番，虽然也找到很多很棒的资料，不过有的有些过时，或是比较分散，因此总结一篇，以便自己加深印象，也方便与大家交流。</p>
<p>由于 Swift 中的 struct 为值类型，class 为引用类型，因此文中以这两种类型为代表来具体阐述。</p>
<h2 id="stack-amp-heap"><a href="#stack-amp-heap" class="headerlink" title="stack &amp; heap"></a>stack &amp; heap</h2><p>内存（RAM）中有两个区域，栈区（stack）和堆区（heap）。<strong>在 Swift 中，值类型，存放在栈区；引用类型，存放在堆区。</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RectClass</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> height = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RectStruct</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> height = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> rectCls = <span class="type">RectClass</span>()</div><div class="line"><span class="keyword">var</span> rectStrct = <span class="type">RectStruct</span>()</div></pre></td></tr></table></figure>
<p><img src="https://o7y30w6c6.qnssl.com/blog/swift_vrtype_01.png" alt="stack &amp; heap in RAM"></p>
<h2 id="值类型-amp-引用类型"><a href="#值类型-amp-引用类型" class="headerlink" title="值类型 &amp; 引用类型"></a>值类型 &amp; 引用类型</h2><h3 id="值类型（Value-Type）"><a href="#值类型（Value-Type）" class="headerlink" title="值类型（Value Type）"></a>值类型（Value Type）</h3><p><strong>值类型，即每个实例保持一份数据拷贝。</strong></p>
<p>在 Swift 中，典型的有 struct，enum，以及 tuple 都是值类型。而平时使用的 <code>Int</code>，    <code>Double</code>，<code>Float</code>，<code>String</code>，<code>Array</code>，<code>Dictionary</code>，<code>Set</code> 其实都是用结构体实现的，也是值类型。</p>
<p>Swift 中，值类型的赋值为深拷贝（Deep Copy），值语义（Value Semantics）即新对象和源对象是独立的，当改变新对象的属性，源对象不会受到影响，反之同理。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/swift_vrtype_02.png" alt="值类型"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CoordinateStruct</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x: <span class="type">Double</span></div><div class="line">    <span class="keyword">var</span> y: <span class="type">Double</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> coordA = <span class="type">CoordinateStruct</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</div><div class="line"><span class="keyword">var</span> coordB = coordA</div><div class="line"></div><div class="line">coordA.x = <span class="number">100.0</span></div><div class="line"><span class="built_in">print</span>(<span class="string">"coordA.x -&gt; \(coordA.x)"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"coordB.x -&gt; \(coordB.x)"</span>)</div><div class="line"></div><div class="line"><span class="comment">// coordA.x -&gt; 100.0</span></div><div class="line"><span class="comment">// coordB.x -&gt; 0.0</span></div></pre></td></tr></table></figure>
<p>如果声明一个值类型的<strong>常量</strong>，那么就意味着该常量是不可变的（无论内部数据为 <code>var</code>/<code>let</code>）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> coordC = <span class="type">CoordinateStruct</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</div><div class="line"><span class="comment">// WRONG: coordC.x = 100.0</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在 Swift 3.0 中，可以使用 <code>withUnsafePointer(to:_:)</code> 函数来打印<strong>值类型</strong>变量的内存地址，这样就能看出两个变量的内存地址并不相同。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;coordA) &#123; <span class="built_in">print</span>(<span class="string">"\($0)"</span>) &#125;</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;coordB) &#123; <span class="built_in">print</span>(<span class="string">"\($0)"</span>) &#125;</div><div class="line"></div><div class="line"><span class="comment">// 0x000000011df6ec10</span></div><div class="line"><span class="comment">// 0x000000011df6ec20</span></div></pre></td></tr></table></figure>
<p>在 Swift 中，双等号（<code>==</code> &amp; <code>!=</code>）可以用来比较变量存储的内容是否一致，如果要让我们的 <code>struct</code> 类型支持该符号，则必须遵守 <code>Equatable</code> 协议。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CoordinateStruct</span>: <span class="title">Equatable</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(<span class="keyword">left</span>: CoordinateStruct, <span class="keyword">right</span>: CoordinateStruct)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">left</span>.x == <span class="keyword">right</span>.x &amp;&amp; <span class="keyword">left</span>.y == <span class="keyword">right</span>.y)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> coordA != coordB &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"coordA != coordB"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// coordA != coordB</span></div></pre></td></tr></table></figure>
<h3 id="引用类型（Reference-Type）"><a href="#引用类型（Reference-Type）" class="headerlink" title="引用类型（Reference Type）"></a>引用类型（Reference Type）</h3><p><strong>引用类型，即所有实例共享一份数据拷贝。</strong></p>
<p>在 Swift 中，class 和闭包是引用类型。引用类型的赋值是浅拷贝（Shallow Copy），引用语义（Reference Semantics）即新对象和源对象的变量名不同，但其引用（指向的内存空间）是一样的，因此当使用新对象操作其内部数据时，源对象的内部数据也会受到影响。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/swift_vrtype_03.png" alt="引用类型"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> height = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> weight = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> dogA = <span class="type">Dog</span>()</div><div class="line"><span class="keyword">var</span> dogB = dogA</div><div class="line"></div><div class="line">dogA.height = <span class="number">50.0</span></div><div class="line"><span class="built_in">print</span>(<span class="string">"dogA.height -&gt; \(dogA.height)"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"dogB.height -&gt; \(dogB.height)"</span>)</div><div class="line"></div><div class="line"><span class="comment">// dogA.height -&gt; 50.0</span></div><div class="line"><span class="comment">// dogB.height -&gt; 50.0</span></div></pre></td></tr></table></figure>
<p>如果声明一个引用类型的<strong>常量</strong>，那么就意味着该常量的引用不能改变（即不能被同类型变量赋值），但指向的内存中所存储的<strong>变量</strong>是可以改变的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> dogC = <span class="type">Dog</span>()</div><div class="line">dogC.height = <span class="number">50</span></div><div class="line"></div><div class="line"><span class="comment">// WRONG: dogC = dogA</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在 Swift 3.0 中，可以使用以下方法来打印<strong>引用类型</strong>变量指向的内存地址。从中即可发现，两个变量指向的是同一块内存空间。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(<span class="type">Unmanaged</span>.passUnretained(dogA).toOpaque())</div><div class="line"><span class="built_in">print</span>(<span class="type">Unmanaged</span>.passUnretained(dogB).toOpaque())</div><div class="line"></div><div class="line"><span class="comment">// 0x0000600000031380</span></div><div class="line"><span class="comment">// 0x0000600000031380</span></div></pre></td></tr></table></figure>
<p>在 Swift 中，三等号（<code>===</code> &amp; <code>!==</code>）可以用来比较引用类型的引用（即指向的内存地址）是否一致。也可以在遵守 <code>Equatable</code> 协议后，使用双等号（<code>==</code> &amp; <code>!=</code>）用来比较变量的内容是否一致。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (dogA === dogB) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"dogA === dogB"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// dogA === dogB</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> dogC !== dogA &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"dogC !== dogA"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// dogC !== dogA</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Animal</span>: <span class="title">Equatable</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(<span class="keyword">left</span>: Animal, <span class="keyword">right</span>: Animal)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">left</span>.height == <span class="keyword">right</span>.height &amp;&amp; <span class="keyword">left</span>.weight == <span class="keyword">right</span>.weight)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> dogC == dogA &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"dogC == dogA"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// dogC == dogA</span></div></pre></td></tr></table></figure>
<h3 id="参数-与-inout"><a href="#参数-与-inout" class="headerlink" title="参数 与 inout"></a>参数 与 inout</h3><h4 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h4><p>定义一个 <code>ResolutionStruct</code> 结构体，以及一个 <code>ResolutionClass</code> 类。这里为了方便打印对象属性，<code>ResolutionClass</code> 类遵从了 <code>CustomStringConvertible</code> 协议。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ResolutionStruct</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> height = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResolutionClass</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> height = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"ResolutionClass(height: \(height), width: \(width))"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h4><p>在 Swift 中，函数的参数默认为<strong>常量</strong>，即在函数体内只能访问参数，而不能修改参数值。具体来说：</p>
<ol>
<li>值类型作为参数传入时，函数体内部不能修改其值</li>
<li>引用类型作为参数传入时，函数体内部不能修改其指向的内存地址，但是可以修改其内部的变量值</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(sct: ResolutionStruct)</span></span> &#123;</div><div class="line"><span class="comment">//    WRONG: sct.height = 1080</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> sct = sct</div><div class="line">    sct.height = <span class="number">1080</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(clss: ResolutionClass)</span></span> &#123;</div><div class="line"><span class="comment">//    WRONG: clss = ResolutionClass()</span></div><div class="line">    clss.height = <span class="number">1080</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> clss = clss</div><div class="line">    clss = <span class="type">ResolutionClass</span>()</div><div class="line">    clss.height = <span class="number">1440</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是如果要改变参数值或引用，那么就可以在函数体内部直接<strong>声明同名变量</strong>，并把原有变量赋值于新变量，那么这个新的变量就可以更改其值或引用。那么在函数参数的作用域和生命周期是什么呢？我们来测试一下，定义两个函数，目的为交换内部的 <code>height</code> 和 <code>width</code>。</p>
<p><strong>值类型</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(resSct: ResolutionStruct)</span></span> -&gt; <span class="type">ResolutionStruct</span> &#123;</div><div class="line">    <span class="keyword">var</span> resSct = resSct</div><div class="line">    <span class="built_in">withUnsafePointer</span>(to: &amp;resSct) &#123; <span class="built_in">print</span>(<span class="string">"During calling: \($0)"</span>) &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> temp = resSct.height</div><div class="line">    resSct.height = resSct.width</div><div class="line">    resSct.width = temp</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> resSct</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> iPhone4ResoStruct = <span class="type">ResolutionStruct</span>(height: <span class="number">960</span>, width: <span class="number">640</span>)</div><div class="line"><span class="built_in">print</span>(iPhone4ResoStruct)</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;iPhone4ResoStruct) &#123; <span class="built_in">print</span>(<span class="string">"Before calling: \($0)"</span>) &#125;</div><div class="line"><span class="built_in">print</span>(<span class="built_in">swap</span>(resSct: iPhone4ResoStruct))</div><div class="line"><span class="built_in">print</span>(iPhone4ResoStruct)</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;iPhone4ResoStruct) &#123; <span class="built_in">print</span>(<span class="string">"After calling: \($0)"</span>) &#125;</div><div class="line"></div><div class="line"><span class="comment">// ResolutionStruct(height: 960.0, width: 640.0)</span></div><div class="line"><span class="comment">// Before calling: 0x00000001138d6f50</span></div><div class="line"><span class="comment">// During calling: 0x00007fff5a512148</span></div><div class="line"><span class="comment">// ResolutionStruct(height: 640.0, width: 960.0)</span></div><div class="line"><span class="comment">// ResolutionStruct(height: 960.0, width: 640.0)</span></div><div class="line"><span class="comment">// After calling: 0x00000001138d6f50</span></div></pre></td></tr></table></figure>
<p>小结：在调用函数前后，外界变量值并<strong>没有</strong>因为函数内对参数的修改而发生变化，而且函数体内参数的内存地址与外界<strong>不同</strong>。因此：<strong>当值类型的变量作为参数被传入函数时，相当于创建了新的常量并初始化为传入的变量值，该参数的作用域及生命周期仅存在于函数体内。</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(resCls: ResolutionClass)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"During calling: \(Unmanaged.passUnretained(resCls).toOpaque())"</span>)</div><div class="line">    <span class="keyword">let</span> temp = resCls.height</div><div class="line">    </div><div class="line">    resCls.height = resCls.width</div><div class="line">    resCls.width = temp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iPhone5ResoClss = <span class="type">ResolutionClass</span>()</div><div class="line">iPhone5ResoClss.height = <span class="number">1136</span></div><div class="line">iPhone5ResoClss.width = <span class="number">640</span></div><div class="line"><span class="built_in">print</span>(iPhone5ResoClss)</div><div class="line"><span class="built_in">print</span>(<span class="string">"Before calling: \(Unmanaged.passUnretained(iPhone5ResoClss).toOpaque())"</span>)</div><div class="line"><span class="built_in">swap</span>(resCls: iPhone5ResoClss)</div><div class="line"><span class="built_in">print</span>(iPhone5ResoClss)</div><div class="line"><span class="built_in">print</span>(<span class="string">"After calling: \(Unmanaged.passUnretained(iPhone5ResoClss).toOpaque())"</span>)</div><div class="line"></div><div class="line"><span class="comment">// ResolutionClass(height: 1136.0, width: 640.0)</span></div><div class="line"><span class="comment">// Before calling: 0x00006000000220e0</span></div><div class="line"><span class="comment">// During calling: 0x00006000000220e0</span></div><div class="line"><span class="comment">// ResolutionClass(height: 640.0, width: 1136.0)</span></div><div class="line"><span class="comment">// After calling: 0x00006000000220e0</span></div></pre></td></tr></table></figure>
<p>小结：在调用函数前后，外界变量值随函数内对参数的修改而发生变化，而且函数体内参数的内存地址与外界<strong>一致</strong>。因此：<strong>当引用类型的变量作为参数被传入函数时，相当于创建了新的常量并初始化为传入的变量引用，当函数体内操作参数指向的数据，函数体外也受到了影响。</strong></p>
<h4 id="inout"><a href="#inout" class="headerlink" title="inout"></a>inout</h4><p><code>inout</code>  是 Swift 中的关键字，可以放置于参数类型前，冒号之后。使用 <code>inout</code> 之后，函数体内部可以直接更改参数值，而且改变会保留。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(resSct: <span class="keyword">inout</span> ResolutionStruct)</span></span> &#123;</div><div class="line">    <span class="built_in">withUnsafePointer</span>(to: &amp;resSct) &#123; <span class="built_in">print</span>(<span class="string">"During calling: \($0)"</span>) &#125;</div><div class="line">    <span class="keyword">let</span> temp = resSct.height</div><div class="line">    resSct.height = resSct.width</div><div class="line">    resSct.width = temp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> iPhone6ResoStruct = <span class="type">ResolutionStruct</span>(height: <span class="number">1334</span>, width: <span class="number">750</span>)</div><div class="line"><span class="built_in">print</span>(iPhone6ResoStruct)</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;iPhone6ResoStruct) &#123; <span class="built_in">print</span>(<span class="string">"Before calling: \($0)"</span>) &#125;</div><div class="line"><span class="built_in">swap</span>(resSct: &amp;iPhone6ResoStruct)</div><div class="line"><span class="built_in">print</span>(iPhone6ResoStruct)</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;iPhone6ResoStruct) &#123; <span class="built_in">print</span>(<span class="string">"After calling: \($0)"</span>) &#125;</div><div class="line"></div><div class="line"><span class="comment">// ResolutionStruct(height: 1334.0, width: 750.0)</span></div><div class="line"><span class="comment">// Before calling: 0x000000011ce62f50</span></div><div class="line"><span class="comment">// During calling: 0x000000011ce62f50</span></div><div class="line"><span class="comment">// ResolutionStruct(height: 750.0, width: 1334.0)</span></div><div class="line"><span class="comment">// After calling: 0x000000011ce62f50</span></div></pre></td></tr></table></figure>
<p>小结：<strong>值类型变量作为参数传入函数，外界和函数参数的内存地址一致，函数内对参数的更改得到了保留。</strong></p>
<p>引用类型也可以使用 <code>inout</code> 参数，但意义不大。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(clss: <span class="keyword">inout</span> ResolutionClass)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"During calling: \(Unmanaged.passUnretained(clss).toOpaque())"</span>)</div><div class="line">    <span class="keyword">let</span> temp = clss.height</div><div class="line">    clss.height = clss.width</div><div class="line">    clss.width = temp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> iPhone7PlusResClss = <span class="type">ResolutionClass</span>()</div><div class="line">iPhone7PlusResClss.height = <span class="number">1080</span></div><div class="line">iPhone7PlusResClss.width = <span class="number">1920</span></div><div class="line"><span class="built_in">print</span>(iPhone7PlusResClss)</div><div class="line"><span class="built_in">print</span>(<span class="string">"Before calling: \(Unmanaged.passUnretained(iPhone7PlusResClss).toOpaque())"</span>)</div><div class="line"><span class="built_in">swap</span>(clss: &amp;iPhone7PlusResClss)</div><div class="line"><span class="built_in">print</span>(iPhone7PlusResClss)</div><div class="line"><span class="built_in">print</span>(<span class="string">"After calling: \(Unmanaged.passUnretained(iPhone7PlusResClss).toOpaque())"</span>)</div><div class="line"></div><div class="line"><span class="comment">// ResolutionClass(height: 1080.0, width: 1920.0)</span></div><div class="line"><span class="comment">// Before calling: 0x000060000003e580</span></div><div class="line"><span class="comment">// During calling: 0x000060000003e580</span></div><div class="line"><span class="comment">// ResolutionClass(height: 1920.0, width: 1080.0)</span></div><div class="line"><span class="comment">// After calling: 0x000060000003e580</span></div></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ol>
<li>使用 <code>inout</code> 关键字的函数，在调用时需要在该参数前加上 <code>&amp;</code> 符号</li>
<li><code>inout</code> 参数在传入时必须为变量，不能为常量或字面量（literal）</li>
<li><code>inout</code> 参数不能有默认值，不能为可变参数</li>
<li><code>inout</code> 参数不等同于函数返回值，是一种使参数的作用域超出函数体的方式</li>
<li>多个 <code>inout</code> 参数不能同时传入同一个变量，因为拷入拷出的顺序不定，那么最终值也不能确定</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> y = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> height = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"center GETTER call"</span>)</div><div class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: origin.x + width / <span class="number">2</span>,</div><div class="line">                         y: origin.y + height / <span class="number">2</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">set</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"center SETTER call"</span>)</div><div class="line">            origin.x = newValue.x - width / <span class="number">2</span></div><div class="line">            origin.y = newValue.y - height / <span class="number">2</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">(center: <span class="keyword">inout</span> Point)</span></span> &#123;</div><div class="line">        center.x = <span class="number">0.0</span></div><div class="line">        center.y = <span class="number">0.0</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> rect = <span class="type">Rectangle</span>(width: <span class="number">100</span>, height: <span class="number">100</span>, origin: <span class="type">Point</span>(x: -<span class="number">100</span>, y: -<span class="number">100</span>))</div><div class="line"><span class="built_in">print</span>(rect.center)</div><div class="line">rect.reset(center: &amp;rect.center)</div><div class="line"><span class="built_in">print</span>(rect.center)</div><div class="line"></div><div class="line"><span class="comment">// center GETTER call</span></div><div class="line"><span class="comment">// Point(x: -50.0, y: -50.0)</span></div><div class="line"></div><div class="line"><span class="comment">// center GETTER call</span></div><div class="line"><span class="comment">// center SETTER call</span></div><div class="line"></div><div class="line"><span class="comment">// center GETTER call</span></div><div class="line"><span class="comment">// Point(x: 0.0, y: 0.0)</span></div></pre></td></tr></table></figure>
<p><code>inout</code> 参数的传递过程：</p>
<ol>
<li>当函数被调用时，参数值被拷贝</li>
<li>在函数体内，被拷贝的参数修改</li>
<li>函数返回时，被拷贝的参数值被赋值给原有的变量</li>
</ol>
<p>官方称这个行为为：<code>copy-in copy-out</code> 或 <code>call by value result</code>。我们可以使用 KVO 或计算属性来跟踪这一过程，这里以计算属性为例。排除在调用函数之前与之后的 <code>center GETTER call</code>，从中可以发现：参数值先被获取到（setter 被调用），接着被设值（setter 被调用）。</p>
<p>根据 <code>inout</code> 参数的传递过程，可以得知：<code>inout</code> 参数的本质与引用类型的传参并不是同一回事。<code>inout</code> 参数打破了其生命周期，是一个可变浅拷贝。在 Swift 3.0 中，也彻底摒除了在逃逸闭包（Escape Closure）中被捕获。苹果官方也有如下的说明：</p>
<blockquote>
<p>As an optimization, when the argument is a value stored at a physical address in memory, the same memory location is used both inside and outside the function body. The optimized behavior is known as <em>call by reference</em>; it satisfies all of the requirements of the copy-in copy-out model while removing the overhead of copying. Write your code using the model given by copy-in copy-out, without depending on the call-by-reference optimization, so that it behaves correctly with or without the optimization.</p>
<p>作为一种优化，当参数是一个存储于内存中实际地址的值时，函数体内外共用相同的一块内存地址。该优化行为被称作<em>通过引用调用</em>；其满足 copy-in copy-out 模型的所有必需条件，同时消除了拷贝时的开销。不依赖于通过引用调用的优化，使用 copy-in copy-out 提供的模型来写代码，以便在进不进行优化时（都能）正确运行。</p>
</blockquote>
<h3 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h3><p>在实际使用中，其实值类型和引用类型并不是孤立的，有时值类型里会存在引用类型的变量，反之亦然。这里简要介绍这四种嵌套类型。</p>
<h4 id="值类型嵌套值类型"><a href="#值类型嵌套值类型" class="headerlink" title="值类型嵌套值类型"></a>值类型嵌套值类型</h4><p>值类型嵌套值类型时，赋值时创建了新的变量，两者是独立的，嵌套的值类型变量也会创建新的变量，这两者也是独立的。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/swift_vrtype_04.png" alt="值类型嵌套值类型"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> circleA = <span class="type">Circle</span>(radius: <span class="number">5.0</span>)</div><div class="line"><span class="keyword">var</span> circleB = circleA</div><div class="line">circleA.radius = <span class="number">10</span></div><div class="line"><span class="built_in">print</span>(circleA)</div><div class="line"><span class="built_in">print</span>(circleB)</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;circleA) &#123; <span class="built_in">print</span>(<span class="string">"circleA: \($0)"</span>) &#125;</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;circleB) &#123; <span class="built_in">print</span>(<span class="string">"circleB: \($0)"</span>) &#125;</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;circleA.radius) &#123; <span class="built_in">print</span>(<span class="string">"circleA.radius: \($0)"</span>) &#125;</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;circleB.radius) &#123; <span class="built_in">print</span>(<span class="string">"circleB.radius: \($0)"</span>) &#125;</div><div class="line"></div><div class="line"><span class="comment">// Circle(radius: 10.0)</span></div><div class="line"><span class="comment">// Circle(radius: 5.0)</span></div><div class="line"><span class="comment">// circleA: 0x000000011dc6dc90</span></div><div class="line"><span class="comment">// circleB: 0x000000011dc6dc98</span></div><div class="line"><span class="comment">// circleA.radius: 0x000000011dc6dc90</span></div><div class="line"><span class="comment">// circleB.radius: 0x000000011dc6dc98</span></div></pre></td></tr></table></figure>
<h4 id="值类型嵌套引用类型"><a href="#值类型嵌套引用类型" class="headerlink" title="值类型嵌套引用类型"></a>值类型嵌套引用类型</h4><p>值类型嵌套引用类型时，赋值时创建了新的变量，两者是独立的，但嵌套的引用类型指向的是同一块内存空间，当改变值类型内部嵌套的引用类型变量值时（除了重新初始化），其他对象的该属性也会随之改变。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/swift_vrtype_05.png" alt="值类型嵌套引用类型"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointClass</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x: <span class="type">Double</span></div><div class="line">    <span class="keyword">var</span> y: <span class="type">Double</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"(\(x), \(y))"</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.x = x</div><div class="line">        <span class="keyword">self</span>.y = y</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> center: <span class="type">PointClass</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> circleA = <span class="type">Circle</span>(center: <span class="type">PointClass</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>))</div><div class="line"><span class="keyword">var</span> circleB = circleA</div><div class="line">circleA.center.x = <span class="number">10.0</span></div><div class="line"><span class="built_in">print</span>(circleA)</div><div class="line"><span class="built_in">print</span>(circleB)</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;circleA) &#123; <span class="built_in">print</span>(<span class="string">"circleA: \($0)"</span>) &#125;</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;circleB) &#123; <span class="built_in">print</span>(<span class="string">"circleB: \($0)"</span>) &#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"circleA.center: \(Unmanaged.passUnretained(circleA.center).toOpaque())"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"circleB.center: \(Unmanaged.passUnretained(circleB.center).toOpaque())"</span>)</div><div class="line"></div><div class="line"><span class="comment">// Circle(center: (10.0, 0.0))</span></div><div class="line"><span class="comment">// Circle(center: (10.0, 0.0))</span></div><div class="line"><span class="comment">// circleA: 0x0000000118251fa0</span></div><div class="line"><span class="comment">// circleB: 0x0000000118251fa8</span></div><div class="line"><span class="comment">// circleA.center: 0x000060000003e100</span></div><div class="line"><span class="comment">// circleB.center: 0x000060000003e100</span></div></pre></td></tr></table></figure>
<h4 id="引用类型嵌套值类型"><a href="#引用类型嵌套值类型" class="headerlink" title="引用类型嵌套值类型"></a>引用类型嵌套值类型</h4><p>引用类型嵌套值类型时，赋值时创建了新的变量，但是新变量和源变量指向同一块内存，因此改变源变量的内部值，会影响到其他变量的值。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/swift_vrtype_06.png" alt="引用类型嵌套值类型"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Radius:\(radius)"</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(radius: <span class="type">Double</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.radius = radius</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> circleA = <span class="type">Circle</span>(radius: <span class="number">0.0</span>)</div><div class="line"><span class="keyword">var</span> circleB = circleA</div><div class="line"></div><div class="line">circleA.radius = <span class="number">5.0</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(circleA)</div><div class="line"><span class="built_in">print</span>(circleB)</div><div class="line"><span class="built_in">print</span>(<span class="string">"circleA: \(Unmanaged.passUnretained(circleA).toOpaque())"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"circleB: \(Unmanaged.passUnretained(circleB).toOpaque())"</span>)</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;circleA.radius) &#123; <span class="built_in">print</span>(<span class="string">"circleA.radius: \($0)"</span>) &#125;</div><div class="line"><span class="built_in">withUnsafePointer</span>(to: &amp;circleB.radius) &#123; <span class="built_in">print</span>(<span class="string">"circleB.radius: \($0)"</span>) &#125;</div><div class="line"></div><div class="line"><span class="comment">// Radius:5.0</span></div><div class="line"><span class="comment">// Radius:5.0</span></div><div class="line"><span class="comment">// circleA: 0x000060000003bc80</span></div><div class="line"><span class="comment">// circleB: 0x000060000003bc80</span></div><div class="line"><span class="comment">// circleA.radius: 0x000060000003bc90</span></div><div class="line"><span class="comment">// circleB.radius: 0x000060000003bc90</span></div></pre></td></tr></table></figure>
<h4 id="引用类型嵌套引用类型"><a href="#引用类型嵌套引用类型" class="headerlink" title="引用类型嵌套引用类型"></a>引用类型嵌套引用类型</h4><p>引用类型嵌套引用类型时，赋值时创建了新的变量，但是新变量和源变量指向同一块内存，内部引用类型变量也指向同一块内存地址，改变引用类型嵌套的引用类型的值，也会影响到其他变量的值。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/swift_vrtype_07.png" alt="引用类型嵌套引用类型"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointClass</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x: <span class="type">Double</span></div><div class="line">    <span class="keyword">var</span> y: <span class="type">Double</span></div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.x = x</div><div class="line">        <span class="keyword">self</span>.y = y</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"(\(x), \(y))"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> center: <span class="type">PointClass</span></div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Center:\(center)"</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(center: <span class="type">PointClass</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.center = center</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> circleA = <span class="type">Circle</span>(center: <span class="type">PointClass</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>))</div><div class="line"><span class="keyword">let</span> circleB = circleA</div><div class="line"></div><div class="line">circleA.center.x = <span class="number">5.0</span></div><div class="line"><span class="built_in">print</span>(circleA)</div><div class="line"><span class="built_in">print</span>(circleB)</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"circleA: \(Unmanaged.passUnretained(circleA).toOpaque())"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"circleB: \(Unmanaged.passUnretained(circleB).toOpaque())"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"circleA.center: \(Unmanaged.passUnretained(circleA.center).toOpaque())"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"circleB.center: \(Unmanaged.passUnretained(circleB.center).toOpaque())"</span>)</div><div class="line"></div><div class="line"><span class="comment">// Center:(5.0, 0.0)</span></div><div class="line"><span class="comment">// Center:(5.0, 0.0)</span></div><div class="line"><span class="comment">// circleA: 0x0000608000025fa0</span></div><div class="line"><span class="comment">// circleB: 0x0000608000025fa0</span></div><div class="line"><span class="comment">// circleA.center: 0x0000608000025820</span></div><div class="line"><span class="comment">// circleB.center: 0x0000608000025820</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章是我在着手写 <a href="https://maimieng.com/2016/37/">Swift 中的 struct &amp; class &amp; enum</a> 一文时抽离出来的一篇。主要还是围绕了值类型中的 struct 和引用类型中的 class，在本文 stack &amp; heap 一节中，只是简单描述，因为一直对此部分内容感到迷惑，也查阅很多资料，希望最近可以总结出来一篇小文，与大家分享。</p>
<table>
<thead>
<tr>
<th>When</th>
<th>值类型 Value Type</th>
<th>引用类型 Reference Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>==</code> 有意义时</td>
<td><code>===</code> 有意义时</td>
</tr>
<tr>
<td>2</td>
<td>独立</td>
<td>共享，可变</td>
</tr>
<tr>
<td>3</td>
<td>在多线程使用的数据</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>在本文的叙述中，可能有许多说法与您平时所用的术语略有差池，例如变量指向的内存空间，其实也等价于变量指向的内存地址。在行文过程中，查阅了很多国外的资料，也尽力将语言规范，以免产生歧义，如果有任何错误或建议，您都可以在评论中直接提出，我会研究学习，虚心接受，并作出相应整改。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.apple.com/videos/play/wwdc2015/414/" target="_blank" rel="external">WWDC 2015 Building Better Apps with Value Types in Swift</a><br><a href="https://developer.apple.com/swift/blog/?id=10" target="_blank" rel="external">Value and Reference Types</a><br><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID173" target="_blank" rel="external">In-Out Parameters</a><br><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID545" target="_blank" rel="external">In-Out Parameters</a><br><a href="https://www.raywenderlich.com/112027/reference-value-types-in-swift-part-1" target="_blank" rel="external">Reference vs Value Types in Swift: Part 1/2</a></p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><p><a href="https://www.raywenderlich.com/112027/reference-value-types-in-swift-part-2" target="_blank" rel="external">Reference vs Value Types in Swift: Part 2/2</a><br><a href="http://www.jianshu.com/p/70684b2e0c15" target="_blank" rel="external">Swift 3 必看：foundation 中数据引用类型改为值类型</a><br><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md" target="_blank" rel="external">Mutability and Foundation Value Types</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Value Type &amp;amp; Reference Type&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>腾讯云 Ubuntu 安装并远程访问 MySQL</title>
    <link href="https://maimieng.com/2016/35/"/>
    <id>https://maimieng.com/2016/35/</id>
    <published>2016-11-18T16:00:00.000Z</published>
    <updated>2016-11-22T07:14:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>道理都懂，但还是连不上的话你就应该来看看…<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>Ubuntu Server 14.04.01 LTS 64 位</li>
<li>DataGrip 2016.2</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了完成作业，不让服务器闲置，决定把数据库放在远程。免去本地配置的麻烦，这次的配置是基于腾讯的学生云，系统选择的是 Ubuntu Server 14.04.01 LTS 64 位，顺便学习下命令行操作。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>安装和配置的步骤比较详细，如果你已经安装过 MySQL 可以跳过相应章节。</p>
<h3 id="配置服务器安全组"><a href="#配置服务器安全组" class="headerlink" title="配置服务器安全组"></a>配置服务器安全组</h3><p>服务器的安全组可以在腾讯云上修改、配置。因为 MySQL 默认远程访问端口为 3306，因此，我们至少要开放该端口。这里由于我的服务器仅供折腾，所以开放了所有端口，实际使用的服务器应当考虑到相应的安全问题。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/ubuntu_mysql_1.png" alt="配置服务器安全组"></p>
<h3 id="设置服务器-root-账户密码"><a href="#设置服务器-root-账户密码" class="headerlink" title="设置服务器 root 账户密码"></a>设置服务器 root 账户密码</h3><p>在后面的使用中，我们需要 root 账户的权限，因此需要设置 root 账户的密码。腾讯云默认会提供一个 ubuntu 账户，在装系统时可以设置密码。</p>
<p>使用 ubuntu 账户登录服务器（0.0.0.0 替换为你的服务器 IP）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh ubuntu@0.0.0.0</div></pre></td></tr></table></figure>
<p>登录成功后，设置 root 账户密码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo passwd</div></pre></td></tr></table></figure>
<p>你需要先输入 ubuntu 账户密码，之后设置 root 账户密码。</p>
<h3 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h3><p>安装时，若提示 <code>Do you want to continue? [Y/n]</code> 输入 Y 即可。在 MySQL 快安装完毕时，会跳出设置 root 密码的界面。该 root 为数据库的用户，而非服务器账户。注意区分和记忆密码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install mysql-server</div><div class="line">apt-get isntall mysql-client</div><div class="line">sudo apt-get install libmysqlclient-dev</div></pre></td></tr></table></figure>
<p>安装完成后，尝试连接 MySQL，使用 root 用户验证是否安装成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -u root –p</div></pre></td></tr></table></figure>
<h3 id="配置-MySQL-远程访问"><a href="#配置-MySQL-远程访问" class="headerlink" title="配置 MySQL 远程访问"></a>配置 MySQL 远程访问</h3><p>查看 3306 端口状态，在 MySQL 安装成功，但没有配置远程访问时，会显示 <code>127.0.0.1:3306</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -an|grep 3306</div></pre></td></tr></table></figure>
<p>为保证安全，首先停止 MySQL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service mysql stop</div></pre></td></tr></table></figure>
<p>切换为 root 账户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">su root</div></pre></td></tr></table></figure>
<p>使用 vim 打开 my.cnf。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/mysql/my.cnf</div></pre></td></tr></table></figure>
<p>将 <code>bind-address = 127.0.0.1</code> 注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># bind-address = 127.0.0.1</div></pre></td></tr></table></figure>
<p>保存并退出后，启动 MySQL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service mysql start</div></pre></td></tr></table></figure>
<p>查看 3306 端口状态，现在应当显示 <code>0.0.0.0:3306</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -an|grep 3306</div></pre></td></tr></table></figure>
<h3 id="新建用户并授权"><a href="#新建用户并授权" class="headerlink" title="新建用户并授权"></a>新建用户并授权</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 创建 kingcos 用户，设置密码为 123456</div><div class="line">CREATE USER kingcos IDENTIFIED BY '123456';</div><div class="line"></div><div class="line"># 授权</div><div class="line">GRANT ALL PRIVILEGES ON *.* TO 'kingcos'@'%'</div><div class="line">IDENTIFIED BY '123456'</div><div class="line">WITH GRANT OPTION;</div><div class="line"></div><div class="line"># 更新权限</div><div class="line">FLUSH PRIVILEGES;</div></pre></td></tr></table></figure>
<h3 id="尝试远程访问"><a href="#尝试远程访问" class="headerlink" title="尝试远程访问"></a>尝试远程访问</h3><p>这里以 JetBrains 的 DataGrip 2016.2 为例。</p>
<p>如图，即连接成功。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/ubuntu_mysql_2.png" alt="DataGrip 2016.2"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;道理都懂，但还是连不上的话你就应该来看看…&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://maimieng.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>计组实验 - Cache</title>
    <link href="https://maimieng.com/2016/34/"/>
    <id>https://maimieng.com/2016/34/</id>
    <published>2016-11-10T16:00:00.000Z</published>
    <updated>2016-11-11T15:06:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Analysis of L1 Cache<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>L1 Cache</li>
<li>Cache Simulator by <a href="https://github.com/jiangxincode" target="_blank" rel="external">jiangxincode</a></li>
</ul>
</li>
</ul>
<p>花了近乎一周时间，本是想用 Java 或 JavaScript 写一个 Cache 模拟器，但由于时间和精力有限，暂放弃。</p>
<p>不过为了实验效果，将老师所提供的 CacheSim 程序进行了微调（源程序未提供 License），并将结果数据绘成图表（使用 <a href="http://echarts.baidu.com" target="_blank" rel="external">ECharts</a>）。</p>
<p>虽然最后实验部分分数得了满分，但由于该程序可能存在一些问题，导致某些结果并非完全正确，实验结果仅供参考。</p>
<p>实验结果及相应分析可在下方网站中获取，相应的参考资料也在其中，这里不再赘述。</p>
<p><a href="https://maimieng.com/skipsrc/CacheSimulator">https://maimieng.com/skipsrc/CacheSimulator</a></p>
<p>以上的实验结果出自 <a href="https://github.com/jiangxincode/CacheSim" target="_blank" rel="external">jiangxincode/CacheSim</a> 程序，向开源致敬！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Analysis of L1 Cache&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Technology" scheme="https://maimieng.com/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>初探 iOS 中自定义 UIView 的初始化过程</title>
    <link href="https://maimieng.com/2016/33/"/>
    <id>https://maimieng.com/2016/33/</id>
    <published>2016-11-01T16:00:00.000Z</published>
    <updated>2016-11-03T16:20:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>awakeFromNib()<br>init(frame:)<br>init(coder:)<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.1</li>
<li>Xcode 8.2 Beta 1</li>
<li>Swift 3.0</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 StoryBoard 和 Xib 出现之后，iOS UI 开发出现了三足鼎立之势。本文不涉及 StoryBoard、Xib、纯代码的优劣之分。仅仅涉及几个初始化方法：<code>awakeFromNib()</code> &amp; <code>init(frame:)</code> &amp; <code>init(coder:)</code>，探讨他们何时调用，为何调用。</p>
<h2 id="Xib-amp-Nib"><a href="#Xib-amp-Nib" class="headerlink" title="Xib &amp; Nib"></a>Xib &amp; Nib</h2><p>ib 是 Interface Builder 的缩写，即界面构造器。这里简要说下，Xib 和 Nib 各是什么，有什么区别。</p>
<p>Xib 实际是一个 XML 文件，而 Nib 是二进制文件。当应用编译时，Xib 文件被翻译为 Nib。所以在 Xcode 中，我们可以自己新建 Xib 文件来构造 UI，而当编译时，Xcode 会自动生成相应的 Nib 文件，而不需我们额外关注。关于其详细介绍，您可以参考文末的资料。</p>
<blockquote>
<p>OK! Talk is cheap, show me the code!</p>
</blockquote>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>在下面的 Demo 中，统一将自定义 UIView 命名为 MyView。</p>
<p>MyView.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span>: <span class="title">UIView</span> </span>&#123;</div><div class="line">	<span class="comment">// methods</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Interface-Builder"><a href="#Interface-Builder" class="headerlink" title="Interface Builder"></a>Interface Builder</h3><p>如果使用 Interface Builder 拖控件，那么其默认属于 UIView 类型。为将其改为自定义控件，需要将 Utilities 中 Identity inspector 的 Custom Class 改为 MyView。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/custom_uiview_1.png" alt="Custom Class 改为 MyView"></p>
<p>为了方便看出调用顺序，将 MyView.swift 改为如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span>: <span class="title">UIView</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</div><div class="line">        </div><div class="line">        <span class="built_in">print</span>(<span class="string">"init(frame:)"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</div><div class="line">        </div><div class="line">        <span class="built_in">print</span>(<span class="string">"init(coder:)"</span>)</div><div class="line">        <span class="comment">// fatalError("init(coder:) has not been implemented")</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.awakeFromNib()</div><div class="line">        </div><div class="line">        <span class="built_in">print</span>(<span class="string">"awakeFromNib()"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后运行即可在屏幕上看到该自定义 UIView，控制台输出：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">init</span>(coder:)</div><div class="line">awakeFromNib()</div></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过打印的输出，可以看出使用 Interface Builder 载入 View 不会调用 <code>init(frame:)</code> 方法，而是调用了 <code>init(coder:)</code>。<code>init(coder:)</code> 是 NSCoding 协议中的方法，NSCoding 是负责编码解码，归档处理的协议。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>)</div></pre></td></tr></table></figure>
<p>代码中的 <code>init(coder:)</code> 与平时见到的其他初始化方法有点不同：<code>required</code> 是指其为必要构造器，即子类「必须」重写该构造器，但当父类的构造器可以完全满足初始化时，也可不重写。<code>init?</code> 是指其为可失败构造器，即其可以 <code>return nil</code> 告知外界构造失败。若想详细了解 Swift 中的构造器，可以参考苹果官方文档。</p>
<p><code>init(coder:)</code> 的调用处于 Nib <strong>载入时</strong>，而 <code>awakeFromNib()</code> 的调用处于 Nib <strong>载入后</strong>。Nib 的载入过程如下：</p>
<ol>
<li>Nib 文件内容和引用的资源文件加载到内存；</li>
<li>反归档存储于 Nib 文件的图像数据对象并初始化；<ol>
<li>遵从 NSCoding 的对象（UIView &amp; UIViewController）调用 <code>init(coder:)</code></li>
<li>其他对象调用其他构造器方法</li>
</ol>
</li>
<li>建立对象间连接：Outlet &amp; Action</li>
<li>实现 <code>awakeFromNib()</code> 的对象调用该方法</li>
</ol>
<p>需要注意的是，<code>awakeFromNib()</code> 中需要调用父类的该方法以保证父类的进行额外初始化。而在本例中重写的 <code>init(coder:)</code> 目的主要是查看调用顺序，并没有加入特别的操作。因此在实际使用中，如果使用 Interface Builder，可以不重写该方法。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>MyView.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span>: <span class="title">UIView</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</div><div class="line">        </div><div class="line">        <span class="built_in">print</span>(<span class="string">"init(frame:)"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</div><div class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.awakeFromNib()</div><div class="line">        </div><div class="line">        <span class="built_in">print</span>(<span class="string">"awakeFromNib"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ViewController.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> myView = <span class="type">MyView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">100</span>, width: <span class="number">50</span>, height: <span class="number">50</span>))</div><div class="line">        myView.backgroundColor =  .black</div><div class="line">        view.addSubview(myView)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后运行即可在屏幕上看到该自定义 UIView，控制台输出：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">init</span>(frame:)</div></pre></td></tr></table></figure>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>通过纯代码创建自定义 UIView，便只调用 <code>init(frame:)</code> 方法，不涉及 Nib 的方法，因此不会调用 <code>awakeFromNib()</code> 和 <code>init(coder:)</code> 方法。而由于 <code>init(coder:)</code> 为必要构造器，因此重写 <code>init(frame:)</code> 时，必须实现该方法。</p>
<p>有时，为了便于从 Interface Builder 和纯代码都能创建自定义 UIView 对象，可以将 <code>init(coder:)</code> 方法改为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</div><div class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</div><div class="line">    <span class="comment">// fatalError("init(coder:) has not been implemented")</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>若保留 <code>fatalError()</code>，则从 Nib 初始化时会无条件输出语句并停止运行。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>可能是强迫症作祟，学习中每遇到一个知识点，都想要查看官方文档或者 Google 出为什么，然后自己敲代码验证，再总结出一篇文章，投稿给简书、掘金。一篇文章有时要耗费一两天，因为查阅的资料都是略有过时且几乎全为英文，但自己挺享受这样的学习状态，也很享受分享给大家之后获得的收藏所带来的鼓励。最近也看了很多实习生的招聘，现在深感基础的重要，未来可能会倾向一些基础，例如数据结构、算法、网络等知识。也希望自己在寒假或下学期能找一份 iOS 实习，虽然自己也有所涉猎 Android 等其他的一些技术栈，但还是对 iOS 最感兴趣。Come on!</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html" target="_blank" rel="external">Nib Files</a><br><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203" target="_blank" rel="external">Initialization</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;awakeFromNib()&lt;br&gt;init(frame:)&lt;br&gt;init(coder:)&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>小窥 iOS 中的 Target-Action 设计模式</title>
    <link href="https://maimieng.com/2016/32/"/>
    <id>https://maimieng.com/2016/32/</id>
    <published>2016-11-01T16:00:00.000Z</published>
    <updated>2016-11-02T09:54:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Design Pattern in iOS<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.1</li>
<li>Xcode 8.2 Beta 1</li>
<li>Swift 3.0</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前两天学习 iOS 中的 UISlider 控件时，看到官方文档提到，Slider 使用了 Target-Action 设计模式。即当用户移动滑块，将通知应用。同理，UIButton 也使用了该设计模式。那么，我们能从这个设计模式中学到什么呢？</p>
<h2 id="Target-Action"><a href="#Target-Action" class="headerlink" title="Target-Action"></a>Target-Action</h2><p>Target-Action，意为 目标-行为，行为即要调用的方法，目标即消息的接收对象（Objective-C 语言使用消息机制，类似但不同于方法调用，该两种概念可能未来会进行探讨）。整个过程为：用户点击按钮，触发某事件发生，该消息由按钮传到另外的接收对象，接收对象再做相应处理。接收对象可以为任何对象，但通常为控制器（Controller）。</p>
<h2 id="Responder-Chain"><a href="#Responder-Chain" class="headerlink" title="Responder Chain"></a>Responder Chain</h2><p>在有关于 Target-Action 的官方文档章节中，提到了通过设置 Target 为 nil 来使用响应链。这样可以使得在运行时（Runtime）决定 Target 对象。关于此的探讨可以参照 Dominik Hauser 的 Utilize The Responder Chain For Target-Action 一文。</p>
<p>但是鉴于个人能力有限，而且在其原文中，作者新加了这么一句话：</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/target_action_1.png" alt="Utilize The Responder Chain For Target-Action"></p>
<p>显然，作者虽然了解响应链的存在，但不会去使用。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="Interface-Builder"><a href="#Interface-Builder" class="headerlink" title="Interface Builder"></a>Interface Builder</h3><p>通过 Interface Builder 可以拖线来实现（注意 Connection 选择 Action）。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/target_action_2.png" alt="Action"></p>
<p>之后便可以在其内部进行其他操作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">buttonClick</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</div><div class="line">	<span class="comment">// do something...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，也可以先定义方法，再拖线，这样也是允许的。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>通过代码进行绑定 Target，可以先采用将控件拖线至代码中，这时 Connection 选择 Outlet。纯代码可以无视拖线。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/target_action_3.png" alt="Outlet"></p>
<p>之后便可以通过 <code>addTarget(_:action:for:)</code> 来绑定 Target 和 Action。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/target_action_4.png" alt="addTarget(_:action:for:)"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    </div><div class="line">    demoButton.addTarget(<span class="keyword">self</span>,</div><div class="line">                         action: #selector(demoFunc),</div><div class="line">                         <span class="keyword">for</span>: .touchUpInside)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">demoFunc</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// do something...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="selector"><a href="#selector" class="headerlink" title="#selector()"></a><code>#selector()</code></h2><p>据考证，<code>#selector()</code> 是 Swift 2.2 中新增的写法。使得选择方法更加安全，因为 IDE 可以自动提示自动补全，即可在编译时刻检查。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/target_action_5.png" alt="Selector 结构体"></p>
<p><code>#selector()</code> 在 Swift 中为 <code>Selector</code> 结构体类型，但其本质是 Objective-C 的运行时概念。如果有方法为 <code>private</code>，则需要在方法前加上 <code>@objc</code> 才能运行正常。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    <span class="keyword">let</span> selectorStruct = #selector(demoFunc)</div><div class="line"></div><div class="line">    demoButton.addTarget(<span class="keyword">self</span>,</div><div class="line">                         action: selectorStruct,</div><div class="line">                         <span class="keyword">for</span>: .touchUpInside)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@objc</span> <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">demoFunc</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// do something...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于 <code>Selector</code> 也可以参考喵神的文章，所有本文提及的文章均在参考资料中列出。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/TargetAction.html#//apple_ref/doc/uid/TP40009071-CH3" target="_blank" rel="external">Target-Action</a><br><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Target-Action/Target-Action.html#//apple_ref/doc/uid/TP40010810-CH12" target="_blank" rel="external">Target-Action</a><br><a href="http://swiftandpainless.com/utilize-the-responder-chain-for-target-action/" target="_blank" rel="external">Utilize The Responder Chain For Target-Action</a><br><a href="http://swift.gg/2016/01/06/utilize-the-responder-chain-for-target-action/" target="_blank" rel="external">在 Target-Action 中使用响应链</a><br><a href="http://swifter.tips/selector/" target="_blank" rel="external">SELECTOR</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Design Pattern in iOS&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UITableViewCell 的简单优化</title>
    <link href="https://maimieng.com/2016/31/"/>
    <id>https://maimieng.com/2016/31/</id>
    <published>2016-10-30T16:00:00.000Z</published>
    <updated>2016-10-31T11:31:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>UITableView in iOS by Swift<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.1</li>
<li>Xcode 8.1</li>
<li>Swift 3.0</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UITableView 是 iOS 开发中极其重要且经常使用的视图，有时候也直接使用 UITableViewController。和 Android 中的 ListView 一样，列表视图总是和内存分不开，因为他们可以承载很多条不同的信息，而随着用户手指滑动，需要即时呈现，不卡顿，不拖沓。因此对其的优化便与生俱来。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>首先，使用一个 static 常量存储复用 ID。之后在 <code>viewDidLoad</code> 中为自定义 Cell 注册该 ID（使用自定义 Cell 可以更加方便，自由的自定义表格 Cell 中的内容）。然后在 <code>func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath)</code> 方法中使用静态常量作为复用 ID，若 Cell 已存在于缓存池则取出，反之创建。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">let</span> id = <span class="string">"reuseIdentifier"</span></div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        tableView.register(<span class="type">CustomCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="type">TableViewController</span>.id)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</div><div class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">200</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="type">TableViewController</span>.id, <span class="keyword">for</span>: indexPath)</div><div class="line">        cell.textLabel?.text = <span class="string">"\(indexPath.row)"</span></div><div class="line">        <span class="keyword">return</span> cell</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomCell</span>: <span class="title">UITableViewCell</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="Swift-中的-static"><a href="#Swift-中的-static" class="headerlink" title="Swift 中的 static"></a>Swift 中的 static</h3><h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">register</span><span class="params">(<span class="number">_</span> cellClass: AnyClass?, forCellReuseIdentifier identifier: String)</span></span></div></pre></td></tr></table></figure>
<h3 id="dequeueReusableCell"><a href="#dequeueReusableCell" class="headerlink" title="dequeueReusableCell"></a>dequeueReusableCell</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">dequeueReusableCell</span><span class="params">(withIdentifier identifier: String)</span></span> -&gt; <span class="type">UITableViewCell</span>?</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;UITableView in iOS by Swift&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>简单使用 UIColor 生成 UIImage</title>
    <link href="https://maimieng.com/2016/30/"/>
    <id>https://maimieng.com/2016/30/</id>
    <published>2016-10-28T16:00:00.000Z</published>
    <updated>2016-10-29T16:29:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>UIColor &lt;-&gt; UIImage<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.1</li>
<li>Xcode 8.1</li>
<li>Swift 3.0</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在平时的练习中，经常需要使用 UIImage，但图片又不好找。为了解决这个问题，我想到了使用 UIColor 生成 UIImage。该部分的具体知识涉及到 Core Graphics，也是一个新的知识点。在网上寻找一番，只有 Objective-C 版本，这次使用 Swift 3.0 进行重写。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateImageWith</span><span class="params">(<span class="number">_</span> color: UIColor, andFrame frame: CGRect)</span></span> -&gt; <span class="type">UIImage</span>? &#123;</div><div class="line">    <span class="comment">// 开始绘图</span></div><div class="line">    <span class="type">UIGraphicsBeginImageContext</span>(frame.size)</div><div class="line">    </div><div class="line">    <span class="comment">// 获取绘图上下文</span></div><div class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</div><div class="line">    <span class="comment">// 设置填充颜色</span></div><div class="line">    context?.setFillColor(color.cgColor)</div><div class="line">    <span class="comment">// 使用填充颜色填充区域</span></div><div class="line">    context?.fill(frame)</div><div class="line">    </div><div class="line">    <span class="comment">// 获取绘制的图像</span></div><div class="line">    <span class="keyword">let</span> image = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</div><div class="line">    </div><div class="line">    <span class="comment">// 结束绘图</span></div><div class="line">    <span class="type">UIGraphicsEndImageContext</span>()</div><div class="line">    <span class="keyword">return</span> image</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用时直接调用该方法，并传入相应参数即可，那么反过来呢？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> color = <span class="type">UIColor</span>(patternImage: image!)</div></pre></td></tr></table></figure>
<p>这样就可以从图片获取颜色。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;UIColor &amp;lt;-&amp;gt; UIImage&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>初探 Swift 中的 KVC 之补充</title>
    <link href="https://maimieng.com/2016/29/"/>
    <id>https://maimieng.com/2016/29/</id>
    <published>2016-10-26T16:00:00.000Z</published>
    <updated>2016-10-27T08:30:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Updated for Swift 3.0.1<br></blockquote><br><a id="more"></a></p>
<h2 id="Swift-3-0-1-中的-KVC"><a href="#Swift-3-0-1-中的-KVC" class="headerlink" title="Swift 3.0.1 中的 KVC"></a>Swift 3.0.1 中的 KVC</h2><p>按照官网，其实在 Swift 3.0 中已经为如下写法，但我是根据 10 月 24 日更新的 KVC 编程指南中的链接才发现该更新的。<code>#keyPath</code> 表达式使得键（路径）更加安全，因为其可以在编译时检查，极大程度避免传入 undefinedkey。但在测试中，也发现了其中的问题，如果该属性在外界无法访问，那么 <code>#keyPath</code> 也无能为力，但仍传入字符串可以做到动态设置。Demo 包含在下面的 Demo 中。</p>
<h2 id="使用-KVC-设置访问控制属性"><a href="#使用-KVC-设置访问控制属性" class="headerlink" title="使用 KVC 设置访问控制属性"></a>使用 KVC 设置访问控制属性</h2><p>在前面，我已经大致总结了 Swift 中的<a href="https://maimieng.com/2016/25/">访问控制</a>以及 <a href="https://maimieng.com/2016/27/">KVC</a>，其实很不全面，而且漏掉了 KVC 可以突破访问控制修饰的限制。似乎这样做会破坏封装，但这也是 Cocoa 的一个特性，使得我们可以在<strong>运行时</strong>进行更加灵活的设置。这次结合两者谈谈简单说下。</p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>在 Demo 中，将各个访问控制修饰符均列出，但他们都能通过 KVC 设值。</p>
<p>Person.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">dynamic</span> open <span class="keyword">var</span> openProp = <span class="string">""</span></div><div class="line">    <span class="keyword">dynamic</span> <span class="keyword">public</span> <span class="keyword">var</span> publicProp = <span class="string">""</span></div><div class="line">    <span class="keyword">dynamic</span> <span class="keyword">internal</span> <span class="keyword">var</span> internalProp = <span class="string">""</span></div><div class="line">    <span class="keyword">dynamic</span> fileprivate <span class="keyword">var</span> fileprivateProp = <span class="string">""</span></div><div class="line">    <span class="keyword">dynamic</span> <span class="keyword">private</span> <span class="keyword">var</span> privateProp = <span class="string">""</span></div><div class="line">    </div><div class="line">    <span class="keyword">override</span> open <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"[\(openProp), \(publicProp), \(internalProp), \(fileprivateProp), \(privateProp)]"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="type">Person</span>()</div><div class="line"></div><div class="line">p.setValue(<span class="string">"open"</span>, forKey: #keyPath(<span class="type">Person</span>.openProp))</div><div class="line">p.setValue(<span class="string">"public"</span>, forKey: #keyPath(<span class="type">Person</span>.publicProp))</div><div class="line">p.setValue(<span class="string">"internal"</span>, forKey: #keyPath(<span class="type">Person</span>.internalProp))</div><div class="line">p.setValue(<span class="string">"fileprivate"</span>, forKey: <span class="string">"fileprivateProp"</span>)</div><div class="line">p.setValue(<span class="string">"private"</span>, forKey: <span class="string">"privateProp"</span>)</div><div class="line"></div><div class="line"><span class="built_in">print</span>(p)</div><div class="line"></div><div class="line"><span class="comment">// [open, public, internal, fileprivate, private]</span></div></pre></td></tr></table></figure>
<h2 id="浅谈集合属性的-KVC"><a href="#浅谈集合属性的-KVC" class="headerlink" title="浅谈集合属性的 KVC"></a>浅谈集合属性的 KVC</h2><p><a href="http://swiftcafe.io/2016/01/03/kvc/" target="_blank" rel="external">漫谈 KVC 与 KVO</a>，这篇文章在写上篇 KVC 时已经看过，但没有注意末尾提到的集合属性的 KVC，感谢<a href="http://weibo.com/u/2305821027" target="_blank" rel="external">木杉</a>同学的提问，才让我注意到这个细节。</p>
<p>关于这点，我查了很多资料，尤其是关心苹果的官方 KVC 指南，官方的 KVC 编程指南的最新更新日期是 2016 年 10 月 24 日，我特意查了更新历史，上一次更新要追溯的 2012 年。但指南仅仅更新了部分的 Swift 内容，而对于集合属性部分，仍为 Objective-C。</p>
<h3 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo-1"></a>Demo-1</h3><p>如果按照<a href="http://swiftcafe.io/2016/01/03/kvc/" target="_blank" rel="external">漫谈 KVC 与 KVO</a>所提到的，Swift 中的写法应当为下，但通过运行发现，并不走 <code>countOfArr()</code> 方法，而是直接输出 <code>arr.count</code>，即 0。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionDemo</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = <span class="type">NSMutableArray</span>()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">countOfArr</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"countOfArr"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">100</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 该方法虽然未调用，但不能缺少</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">objectInArrAt</span><span class="params">(index: Int)</span></span> -&gt; <span class="type">Any</span>? &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"objectInArrAt"</span>)</div><div class="line">        <span class="keyword">return</span> arr.object(at: index)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="type">CollectionDemo</span>()</div><div class="line"></div><div class="line"><span class="built_in">print</span>(obj.mutableArrayValue(forKeyPath: <span class="string">"arr"</span>).<span class="built_in">count</span>)</div><div class="line"><span class="built_in">print</span>(obj.mutableArrayValue(forKeyPath: #keyPath(<span class="type">CollectionDemo</span>.arr)).<span class="built_in">count</span>)</div><div class="line"></div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 0</span></div></pre></td></tr></table></figure>
<h3 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo-2"></a>Demo-2</h3><p><code>mutableArrayValue:</code> 的默认实现为传入键，返回该键对应的可变代理数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionDemo</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> <span class="type">Arr</span> = <span class="type">NSMutableArray</span>()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">countOfArr</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"countOfArr"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="type">Arr</span>.<span class="built_in">count</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">objectInArrAt</span><span class="params">(index: Int)</span></span> -&gt; <span class="type">Any</span>? &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"objectInArrAt"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="type">Arr</span>[index]</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">insertObject</span><span class="params">(<span class="number">_</span> obj: Any, inArrAtIndex index: Int)</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"insertObject"</span>)</div><div class="line">        <span class="type">Arr</span>[index] = obj</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="type">CollectionDemo</span>()</div><div class="line"><span class="keyword">let</span> arrayProxy = obj.mutableArrayValue(forKeyPath: <span class="string">"arr"</span>)</div><div class="line">arrayProxy.add(<span class="string">"Test1"</span>)</div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"></div><div class="line">arrayProxy.add(<span class="string">"Test2"</span>)</div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"><span class="comment">// objectInArrAt</span></div><div class="line"></div><div class="line">arrayProxy.add(<span class="string">"Test3"</span>)</div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"><span class="comment">// objectInArrAt</span></div><div class="line"><span class="comment">// objectInArrAt</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(arrayProxy.<span class="built_in">count</span>)</div><div class="line"><span class="comment">// countOfArr</span></div><div class="line"><span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(arrayProxy[<span class="number">0</span>])</div><div class="line"><span class="comment">// objectInArrAt</span></div><div class="line"><span class="comment">// Test1</span></div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://stackoverflow.com/questions/31951681/mutablearrayvalueforkey-countofkey-not-being-called-countofsongs?answertab=active#tab-top" target="_blank" rel="external">mutableArrayValueForKey: countOf<key> not being called, countOfSongs</key></a><br><a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1" target="_blank" rel="external">Key-Value Coding Programming Guide</a><br><a href="http://swiftcafe.io/2016/01/03/kvc/" target="_blank" rel="external">漫谈 KVC 与 KVO</a><br><a href="https://maimieng.com/2016/27/">初探 Swift 中的 KVC</a><br><a href="https://maimieng.com/2016/25/">浅谈 Swift 3 中的访问控制</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Updated for Swift 3.0.1&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Swift 中的属性（Property）</title>
    <link href="https://maimieng.com/2016/28/"/>
    <id>https://maimieng.com/2016/28/</id>
    <published>2016-10-24T16:00:00.000Z</published>
    <updated>2016-10-30T13:32:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Stored Properties<br>Computed Properties<br>Property Observers<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.1</li>
<li>Xcode 8.1 Beta 3</li>
<li>Swift 3.0</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Swift 中的属性分为存储属性与计算属性，存储属性即为我们平时常用的属性，可以直接赋值使用，而计算属性不直接存储值，而是根据其他（存储）属性计算得来的值。</p>
<p>在其他面向对象的编程语言中，例如 Java 和 Objective-C 中，get 和 set 方法提供了统一、规范的接口，可以使得外部访问或设置对象的私有属性，而不破坏封装性，也可以很好的控制权限（选择性实现 get 或 set 方法）。而 Swift 中似乎并没有见到类似的 get 和 set 方法，而 Swift 使用了一种名为属性观察器的概念来解决该问题。</p>
<p>本文简单介绍下 Swift 中的这两种属性，以及属性观察器。</p>
<h2 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h2><p>存储属性使用广泛，即是类或结构体中的变量或常量，可以直接赋初始值，也可以修改其初始值（仅指变量）。延迟存储属性是指第一次使用到该变量再进行运算（这里的运算不能依赖其他属性）。延迟存储属性必须声明为 <code>var</code> 变量，因为其属性值在对象实例化前可能无法得到，而常量必须在初始化完成前拥有初始值。</p>
<p>在 Swift 中，可以将消耗性能才能得到的值的初始化放在延迟存储属性中，即懒加载。</p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>这里假定在 ViewController.swift 有一个属性，需要从 plist 文件读取内容，将其中的字典转为模型。如果 plist 文件内容很多，那么就十分消耗性能。如果用户不触发相应事件，也没有必要加载这些数据。那么这里就很适合使用懒加载，即延迟存储属性。</p>
<p>ViewController.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> goods: <span class="type">NSArray</span>? = &#123;</div><div class="line">        <span class="keyword">var</span> goodsArray: <span class="type">NSMutableArray</span> = []</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> path = <span class="type">Bundle</span>.main.path(forResource: <span class="string">"Goods"</span>, ofType: <span class="string">"plist"</span>) &#123;</div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> array = <span class="type">NSArray</span>(contentsOfFile: path) &#123;</div><div class="line">                <span class="keyword">for</span> goodsDict <span class="keyword">in</span> array &#123;</div><div class="line">                    goodsArray.add(<span class="type">Goods</span>(goodsDict <span class="keyword">as</span>! <span class="type">NSDictionary</span>))</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> goodsArray</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;()</div><div class="line">    </div><div class="line">    <span class="comment">// 这样也是允许的</span></div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> testLazy = <span class="type">Person</span>()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p><em>可以在延迟存储属性运算的代码中加入 <code>print()</code>，即可验证其何时初始化。</em></p>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>举个例子，一个<strong>矩形</strong>结构体（类同理），拥有<strong>宽度</strong>和<strong>高度</strong>两个存储属性，以及一个只读<strong>面积</strong>的计算属性，因为通过设置矩形的宽度和高度即可<strong>计算</strong>出矩形的面积，而无需直接设置其值。当宽度或高度改变，面积也应当可以跟随其变化（反之不能推算，因此为只读）。为说明 setter 以及便捷 setter 说明，另外添加了<strong>原点</strong>（矩形左下角）存储属性，以及<strong>中心</strong>计算属性。</p>
<h3 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> y = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> height = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</div><div class="line">    </div><div class="line">    <span class="comment">// 只读计算属性</span></div><div class="line">    <span class="keyword">var</span> size: <span class="type">Double</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">return</span> width * height</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 只读计算属性简写为</span></div><div class="line"><span class="comment">//    var size: Double &#123;</span></div><div class="line"><span class="comment">//        return width * height</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: origin.x + width / <span class="number">2</span>,</div><div class="line">                         y: origin.y + height / <span class="number">2</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">set</span>(newCenter) &#123;</div><div class="line">            origin.x = newCenter.x - width / <span class="number">2</span></div><div class="line">            origin.y = newCenter.y - height / <span class="number">2</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 便捷 setter 声明</span></div><div class="line"><span class="comment">//        set &#123;</span></div><div class="line"><span class="comment">//            origin.x = newValue.x - width / 2</span></div><div class="line"><span class="comment">//            origin.y = newValue.y - height / 2</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> rect = <span class="type">Rectangle</span>()</div><div class="line">rect.width = <span class="number">100</span></div><div class="line">rect.height = <span class="number">50</span></div><div class="line"><span class="built_in">print</span>(rect.size)</div><div class="line"></div><div class="line">rect.origin = <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</div><div class="line"><span class="built_in">print</span>(rect.center)</div><div class="line"></div><div class="line">rect.center = <span class="type">Point</span>(x: <span class="number">100</span>, y: <span class="number">100</span>)</div><div class="line"><span class="built_in">print</span>(rect.origin)</div><div class="line"></div><div class="line"><span class="comment">// 5000.0</span></div><div class="line"><span class="comment">// Point(x: 50.0, y: 25.0)</span></div><div class="line"><span class="comment">// Point(x: 50.0, y: 75.0)</span></div></pre></td></tr></table></figure>
<p><em>综上，getter 可以根据存储属性推算计算属性的值，setter 可以在被赋值时根据新值倒推存储属性，但它们与我们在其他语言中的 get/set 方法却不一样。</em></p>
<h2 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h2><p>属性观察器算是 Swift 中的一个 feature，变量在设值<strong>前</strong>会先进入 <code>willSet</code>，这时默认 <code>newValue</code> 等于即将要赋值的值，而变量本身尚未改变。变量在设值<strong>后</strong>会先进入 <code>didSet</code>，这时默认 <code>oldValue</code> 等于赋值前变量的值，而变量变为新值。</p>
<p>这样，开发者即可在 <code>willSet</code> 和 <code>didSet</code> 中进行相应的操作，如果只是取值和设值而不进行额外操作，那么直接使用点语法即可。但是有时候一个变量只需要被访问，而不能在外界赋值，那么可以使用<a href="https://maimieng.com/2016/25/">访问控制修饰符</a>加上 <code>(set)</code> 即可私有化 set 方法。例如 <code>fileprivate(set)</code>，<code>private(set)</code>，以及 <code>internal(set)</code>。值得注意的是，这里的访问控制修饰符修饰的是 set 方法，访问权限（即 get）是另外设置的。例如 <code>public fileprivate(set) var prop = 0</code>，该变量全局可以访问，但只有同文件内可以使用 set 方法。</p>
<h3 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="comment">// internal 为默认权限，可不加</span></div><div class="line">    <span class="keyword">internal</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> privateSetProp = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> hungryValue = <span class="number">0</span> &#123;</div><div class="line">        <span class="comment">// 设置前调用</span></div><div class="line">        <span class="keyword">willSet</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"willSet \(hungryValue) newValue: \(newValue)"</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 设置后调用</span></div><div class="line">        <span class="keyword">didSet</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"didSet \(hungryValue) oldValue: \(oldValue)"</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 也可以自己命名默认的 newValue/oldValue</span></div><div class="line">        <span class="comment">// willSet(new) &#123;&#125;</span></div><div class="line">        <span class="comment">// didSet(old) &#123;&#125;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> cat = <span class="type">Animal</span>()</div><div class="line"></div><div class="line"><span class="comment">// private(set) 即只读</span></div><div class="line"><span class="comment">// cat.privateSetProp = 10</span></div><div class="line"><span class="built_in">print</span>(cat.privateSetProp)</div><div class="line"></div><div class="line">cat.hungryValue += <span class="number">10</span></div><div class="line"><span class="built_in">print</span>(cat.hungryValue)</div><div class="line"></div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// willSet 0 newValue: 10</span></div><div class="line"><span class="comment">// didSet 10 oldValue: 0</span></div><div class="line"><span class="comment">// 10</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Swift 的这几个 feature 我未曾在其他语言中见过，对于初学者确实容易凌乱。特别是 getter/setter 以及属性观察器中均没有代码提示，容易造成手误，代码似乎也变得臃肿。但是熟悉之后，这些也都能完成之前的功能，甚至更加细分。保持每一部分可控，便使得整个程序更加严谨，更加安全。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://maimieng.com/2016/25/">浅谈 Swift 3 中的访问控制</a><br><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html" target="_blank" rel="external">Access Control</a><br><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html" target="_blank" rel="external">Properties</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Stored Properties&lt;br&gt;Computed Properties&lt;br&gt;Property Observers&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>初探 Swift 中的 KVC</title>
    <link href="https://maimieng.com/2016/27/"/>
    <id>https://maimieng.com/2016/27/</id>
    <published>2016-10-20T16:00:00.000Z</published>
    <updated>2016-10-27T08:23:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Key-Value Coding<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.1 Beta 4</li>
<li>Xcode 8.1 Beta 3</li>
<li>Swift 3</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>这两天（2016-10-27），苹果一言不合更新了官网的文档，有些文档上次的更新日期甚至为 2012 年，说明这次的更新十分重要且稳定，并且将 Swift 版本更新到 3.0.1，本文中的一些写法随能运行，但已经过时，并非最佳实践，为此以及一些本文未涉及的内容，可以参照另一文——<a href="https://maimieng.com/2016/29/">初探 Swift 中的 KVC 之补充</a>。</strong></p>
<p>Key-Value Coding 中文译为「键值编码」，简称 KVC。是 iOS 开发中极其重要且基础的概念。苹果官网对于 KVC 有详细的编程指南，但均是基于 Objective-C 语言。Swift 也继承了该特性，KVC 常用于从网络获取请求进行处理，这次只是简单探究下 Swift 中的 KVC。</p>
<p>在 Swift 中想要兼容 KVC，需要该类继承 <code>NSObject</code>。下面是 KVC 中常用的几个方法：</p>
<ul>
<li>根据传入的 <code>key</code>，设置 <code>value</code>：</li>
</ul>
<p><code>func setValue(_ value: Any?, forKey key: String)</code></p>
<ul>
<li>根据传入的 <code>keyPath</code>，设置 <code>value</code>，<code>keyPath</code> 即键路径可利用 <code>.</code> 遍历至键：</li>
</ul>
<p><code>func setValue(_ value: Any?, forKeyPath keyPath: String)</code></p>
<ul>
<li>根据传入的字典，设值，如果字典中有对象不存在的属性，则会抛出异常：</li>
</ul>
<p><code>func setValuesForKeys(_ keyedValues: [String : Any])</code></p>
<ul>
<li>当为不存在的某个键设值时，默认调用该方法抛出 <code>NSUndefinedKeyException</code> 异常，子类可重写该方法：</li>
</ul>
<p><code>func setValue(_ value: Any?, forUndefinedKey key: String)</code></p>
<ul>
<li>设置特定键的值为 <code>nil</code> 时，默认调用该方法抛出 <code>NSInvalidArgumentException</code>，子类可重写该方法（注：官方称该方法针对标量值（scalar value），例如整型和浮点型）对于其他类型没有提到，在 Demo 中有详细的列出是否支持）：</li>
</ul>
<p><code>func setNilValueForKey(_ key: String)</code></p>
<ul>
<li>返回传入指定键的对应值：</li>
</ul>
<p><code>func value(forKey key: String) -&gt; Any?</code></p>
<ul>
<li>返回传入指定键路径的对应值：</li>
</ul>
<p><code>func value(forKeyPath keyPath: String) -&gt; Any?</code></p>
<ul>
<li>返回传入未定义的键路径的对应值：</li>
</ul>
<p><code>func value(forUndefinedKey key: String) -&gt; Any?</code></p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>KVC 兼容的类，需要继承自 <code>NSObject</code>。在学习 KVC 的过程中，发现并不是所有的数据类型都支持通过 KVC 设值。KVC 设值的方便之处在于可以动态的设值，即使封装在内部的细节也可以设值，而且可以自动将类型转换（注意：有些类型是不可行的）。这种特性使得从网络获取的数据可以轻松设置到模型中。以下的 Demo，选取了几个常用的 Swift 中的数据类型，测试一下是否支持 KVC 以及是否在设置 <code>nil</code> 值时调用 <code>setNilValueForKey</code> 方法。</p>
<p>DataType.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataType</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> aInt: <span class="type">Int</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> bUInt: <span class="type">UInt</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> cFloat: <span class="type">Float</span> = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> dDouble: <span class="type">Double</span> = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> eBool: <span class="type">Bool</span> = <span class="literal">false</span></div><div class="line">    <span class="keyword">var</span> fCharacter: <span class="type">Character</span> = <span class="string">"f"</span></div><div class="line">    <span class="keyword">var</span> gString: <span class="type">String</span> = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> hArray: [<span class="type">Any</span>] = [<span class="number">0</span>]</div><div class="line">    <span class="keyword">var</span> iDictionary: [<span class="type">String</span>: <span class="type">Any</span>] = [<span class="string">"0"</span>: <span class="number">0</span>]</div><div class="line">    <span class="keyword">var</span> jTuple: (<span class="type">Int</span>, <span class="type">Int</span>) = (<span class="number">0</span>, <span class="number">0</span>)</div><div class="line">    <span class="keyword">var</span> kOptional: <span class="type">Int</span>?</div><div class="line">    <span class="keyword">var</span> lObject: <span class="type">Type</span> = <span class="type">Type</span>()</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> mNSDictionary: <span class="type">NSDictionary</span> = [<span class="string">"0"</span>: <span class="number">0</span>]</div><div class="line">    <span class="keyword">var</span> nNSArray: <span class="type">NSArray</span> = [<span class="number">0</span>, <span class="string">"0"</span>]</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> oArrayAny: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt; = [<span class="number">0</span>, <span class="string">"0"</span>]</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setNilValueForKey</span><span class="params">(<span class="number">_</span> key: String)</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"You set nil for \(key)"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> prop = <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> o = <span class="type">DataType</span>()</div></pre></td></tr></table></figure>
<h3 id="Int"><a href="#Int" class="headerlink" title="Int"></a><code>Int</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">o.setValue(<span class="string">"1"</span>, forKeyPath: <span class="string">"aInt"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"aInt: \(o.aInt)"</span>)</div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"aInt"</span>)</div><div class="line"></div><div class="line"><span class="comment">// aInt: 1</span></div><div class="line"><span class="comment">// You set nil for aInt</span></div></pre></td></tr></table></figure>
<p><strong><code>Int</code> 支持 <code>setValue</code> 自动转换设值，且支持设值为 <code>nil</code> 时调用 <code>setNilValueForKey</code> 方法。</strong></p>
<h3 id="UInt"><a href="#UInt" class="headerlink" title="UInt"></a><code>UInt</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不支持通过自动转换</span></div><div class="line"><span class="comment">// Error: -[Swift._NSContiguousString unsignedLongLongValue]: unrecognized selector sent to instance</span></div><div class="line"><span class="comment">// o.setValue("1", forKeyPath: "bUInt")</span></div><div class="line">o.setValue(<span class="number">1</span>, forKeyPath: <span class="string">"bUInt"</span>)</div><div class="line"><span class="built_in">print</span>(o.bUInt)</div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"bUInt"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// You set nil for bUInt</span></div></pre></td></tr></table></figure>
<p><strong><code>UInt</code> 支持 <code>setValue</code> 设值，但不支持自动转换，且支持设值为 <code>nil</code> 时调用 <code>setNilValueForKey</code> 方法。</strong></p>
<h3 id="Float"><a href="#Float" class="headerlink" title="Float"></a><code>Float</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">o.setValue(<span class="string">"1"</span>, forKeyPath: <span class="string">"cFloat"</span>)</div><div class="line"><span class="built_in">print</span>(o.cFloat)</div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"cFloat"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 1.0</span></div><div class="line"><span class="comment">// You set nil for cFloat</span></div></pre></td></tr></table></figure>
<p><strong><code>Float</code> 支持 <code>setValue</code> 自动转换设值，且支持设值为 <code>nil</code> 时调用 <code>setNilValueForKey</code> 方法。</strong></p>
<h3 id="Double"><a href="#Double" class="headerlink" title="Double"></a><code>Double</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">o.setValue(<span class="string">"1"</span>, forKeyPath: <span class="string">"dDouble"</span>)</div><div class="line"><span class="built_in">print</span>(o.dDouble)</div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"dDouble"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 1.0</span></div><div class="line"><span class="comment">// You set nil for dDouble</span></div></pre></td></tr></table></figure>
<p><strong><code>Double</code> 支持 <code>setValue</code> 自动转换设值，且支持设值为 <code>nil</code> 时调用 <code>setNilValueForKey</code> 方法。</strong></p>
<h3 id="Bool"><a href="#Bool" class="headerlink" title="Bool"></a><code>Bool</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不支持通过自动转换</span></div><div class="line"><span class="comment">// Error: -[Swift._NSContiguousString charValue]: unrecognized selector sent to instance</span></div><div class="line"><span class="comment">// o.setValue("true", forKeyPath: "eBool")</span></div><div class="line">o.setValue(<span class="literal">true</span>, forKeyPath: <span class="string">"eBool"</span>)</div><div class="line"><span class="built_in">print</span>(o.eBool)</div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"eBool"</span>)</div><div class="line"></div><div class="line"><span class="comment">// true</span></div><div class="line"><span class="comment">// You set nil for eBool</span></div></pre></td></tr></table></figure>
<p><strong><code>Bool</code> 支持 <code>setValue</code> 设值，但不支持自动转换，且支持设值为 <code>nil</code> 时调用 <code>setNilValueForKey</code> 方法。</strong></p>
<h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a><code>Character</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不支持 setValue</span></div><div class="line"><span class="comment">// Error: [&lt;DataType&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key fCharacter.</span></div><div class="line"><span class="comment">// let b: Character = "b"</span></div><div class="line"><span class="comment">// o.setValue(b, forKeyPath: "fCharacter")</span></div><div class="line"><span class="comment">// o.setValue(nil, forKeyPath: "fCharacter")</span></div></pre></td></tr></table></figure>
<p><strong><code>Character</code> 不支持 setValue。</strong></p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a><code>String</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">o.setValue(<span class="string">"gString"</span>, forKeyPath: <span class="string">"gString"</span>)</div><div class="line"><span class="built_in">print</span>(o.gString)</div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"gString"</span>)</div><div class="line"><span class="built_in">print</span>(o.gString)</div><div class="line"></div><div class="line"><span class="comment">// gString</span></div><div class="line"><span class="comment">//</span></div></pre></td></tr></table></figure>
<p><strong><code>String</code> 支持 <code>setValue</code> 设值，设值为 <code>nil</code> 时不调用 <code>setNilValueForKey</code> 方法，但可以清空。</strong></p>
<h3 id="Array-lt-Int-gt"><a href="#Array-lt-Int-gt" class="headerlink" title="Array&lt;Int&gt;"></a><code>Array&lt;Int&gt;</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不支持自动转换</span></div><div class="line"><span class="comment">// Error: -[Swift._NSContiguousString count]: unrecognized selector sent to instance</span></div><div class="line"><span class="comment">// o.setValue("1", forKeyPath: "hArray")</span></div><div class="line">o.setValue([<span class="number">1</span>], forKeyPath: <span class="string">"hArray"</span>)</div><div class="line"><span class="built_in">print</span>(o.hArray)</div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"hArray"</span>)</div><div class="line"><span class="built_in">print</span>(o.hArray)</div><div class="line"></div><div class="line"><span class="comment">// [1]</span></div><div class="line"><span class="comment">// []</span></div></pre></td></tr></table></figure>
<p><strong><code>Array&lt;Int&gt;</code> 支持 <code>setValue</code> 设值，但不支持自动转换，设值为 <code>nil</code> 时不调用 <code>setNilValueForKey</code> 方法，但可以清空。</strong></p>
<h3 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a><code>Dictionary</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不支持自动转换</span></div><div class="line"><span class="comment">// Error: -[Swift._NSContiguousString count]: unrecognized selector sent to instance</span></div><div class="line"><span class="comment">// o.setValue("[\"2\": 2]", forKeyPath: "iDictionary")</span></div><div class="line">o.setValue([<span class="string">"2"</span>: <span class="number">2</span>], forKeyPath: <span class="string">"iDictionary"</span>)</div><div class="line"><span class="built_in">print</span>(o.iDictionary)</div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"iDictionary"</span>)</div><div class="line"><span class="built_in">print</span>(o.iDictionary)</div><div class="line"></div><div class="line"><span class="comment">// ["2": 2]</span></div><div class="line"><span class="comment">// [:]</span></div></pre></td></tr></table></figure>
<p><strong><code>Dictionary</code> 支持 <code>setValue</code> 设值，但不支持自动转换，设值为 <code>nil</code> 时不调用 <code>setNilValueForKey</code> 方法，但可以清空。</strong></p>
<h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a><code>Tuple</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不支持 setValue</span></div><div class="line"><span class="comment">// Error: [&lt;DataType&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key jTuple.</span></div><div class="line"><span class="comment">// let t = (1, 1)</span></div><div class="line"><span class="comment">// o.setValue(t, forKeyPath: "jTuple")</span></div><div class="line"><span class="comment">// o.setValue(nil, forKeyPath: "jTuple")</span></div></pre></td></tr></table></figure>
<p><strong><code>Tuple</code> 不支持 setValue。</strong></p>
<h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a><code>Optional</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不支持 setValue</span></div><div class="line"><span class="comment">// Error: [&lt;DataType&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key kOptional.</span></div><div class="line"><span class="comment">// o.setValue(1, forKeyPath: "kOptional")</span></div><div class="line"><span class="comment">// o.setValue(nil, forKeyPath: "kOptional")</span></div></pre></td></tr></table></figure>
<p><strong><code>Optional</code> 不支持 setValue。</strong></p>
<h3 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">o.setValue(<span class="string">"1"</span>, forKeyPath: <span class="string">"lObject.prop"</span>)</div><div class="line"><span class="built_in">print</span>(o.lObject.prop)</div><div class="line"><span class="comment">// 不支持设值 nil</span></div><div class="line"><span class="comment">// Error: [&lt;Type&gt; setNilValueForKey]: could not set nil as the value for the key prop.</span></div><div class="line"><span class="comment">//o.setValue(nil, forKeyPath: "lObject.prop")</span></div><div class="line"></div><div class="line"><span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p><strong>自定义类的对象的属性支持 <code>setValue</code> 自动转换设值，但不支持设值为 <code>nil</code>。</strong></p>
<h3 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a><code>NSDictionary</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> nsDict: <span class="type">NSDictionary</span> = [<span class="string">"1"</span>: <span class="number">1</span>]</div><div class="line">o.setValue(nsDict, forKeyPath: <span class="string">"mNSDictionary"</span>)</div><div class="line"><span class="built_in">print</span>(o.mNSDictionary[<span class="string">"1"</span>])</div><div class="line"></div><div class="line"><span class="keyword">let</span> swiftDict = [<span class="string">"2"</span>: <span class="number">2</span>]</div><div class="line">o.setValue(swiftDict, forKeyPath: <span class="string">"mNSDictionary"</span>)</div><div class="line"><span class="built_in">print</span>(o.mNSDictionary[<span class="string">"2"</span>])</div><div class="line"></div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"mNSDictionary"</span>)</div><div class="line"><span class="built_in">print</span>(o.mNSDictionary[<span class="string">"2"</span>])</div><div class="line"></div><div class="line"><span class="comment">// Optional(1)</span></div><div class="line"><span class="comment">// Optional(2)</span></div><div class="line"><span class="comment">// nil</span></div></pre></td></tr></table></figure>
<p><strong><code>NSDictionary</code> 支持 <code>setValue</code> 设值（支持 Swift 中的 <code>Dictionary</code> 以及 <code>NSDictionary</code>），但不支持自动转换，设值为 <code>nil</code> 时不调用 <code>setNilValueForKey</code> 方法，但可以清空。</strong></p>
<h3 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a><code>NSArray</code></h3><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">o.setValue(<span class="string">"a"</span>, forKeyPath: <span class="string">"nNSArray"</span>)</div><div class="line"><span class="built_in">print</span>(o.nNSArray)</div><div class="line">o.setValue(<span class="literal">nil</span>, forKeyPath: <span class="string">"nNSArray"</span>)</div><div class="line"><span class="built_in">print</span>(o.nNSArray == <span class="literal">nil</span>)</div><div class="line"></div><div class="line"><span class="comment">// a</span></div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><strong><code>NSArray</code> 支持 <code>setValue</code> 设值（<code>NSArray</code> 存储 <code>Any</code> 类型，因此不存在自动转换），设值为 <code>nil</code> 时不调用 <code>setNilValueForKey</code> 方法，但会设值为 <code>nil</code>。</strong></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这次将 Swift 中的一些数据类型拿出来单独测试了 KVC，结果来看有部分类型对此支持并不完全，所以在往后从网络获取数据一定要进行相应的处理再 <code>setValue</code>。也最好重写 <code>func setValue(_ value: Any?, forUndefinedKey key: String)</code>，必要时重写 <code>func setNilValueForKey(_ key: String)</code>。Swift 是一门强类型语言，就要求程序员多加注意类型转换等其他问题，以减少或避免程序崩溃，带来不好的用户体验。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Key-Value Coding&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>生日记</title>
    <link href="https://maimieng.com/2016/26/"/>
    <id>https://maimieng.com/2016/26/</id>
    <published>2016-10-19T16:00:00.000Z</published>
    <updated>2016-10-31T11:35:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>生命不息，向死而生。<br>内容有些凌乱，暂不修改<br></blockquote><br><a id="more"></a><br>在 QQ 空间里朋友送的礼物提醒下，似乎快要过生日了。虽然在今天之前也知道自己快要过生日了，但是到了这一天也似乎没什么分别。可能是最近有些忙碌，可能其实生日也算不了什么吧。也好久没有什么理由写点什么了，这里总是冷冰冰的技术文也不太好，所以还是写点什么，记录下吧。</p>
<p>很遗憾，大学似乎在知乎大神口中是绚丽多彩的，在小时代中也是很精彩的。而我这几年的重心只放在了学习上，虽说可能比不上 985／211 的学霸们，但也算是没有太大的愧疚吧。</p>
<p>来到大学已两年有余，大一刚进来的时候，一心想要进入卓越班，也想拿到国家奖学金。毕竟这所大学不怎么样，没有什么能够证明自己。结果，卓越班迟迟未开始，拿着专业第一的成绩才发现国家奖学金仅仅属于大三，结果连国家励志也没有拿到。说实话，那时候心里很不服，但我只是想，不就再努力一年嘛，有什么大不了的。</p>
<p>大一的暑假似乎是完全浪费的，由于在家里我的惰性很强，可能是习惯竞争的环境。虽然我不玩游戏，但也没有去学习，只是在暑假的最后一段时间，学了学 Java 基础，很欣慰，当时的笔记得到了浙大翁凯老师的微博推荐。</p>
<p>大一就那样过去了，迎来了大二。大二，进入了卓越班，考过了四级，六级。虽然这样看来算是有点成绩，而且大二的杂事少多了，我也退出了社团，但现在看来，大二这一年所学习的有些杂乱，虽然对于计算机的热情仍在，但缺少方向。由于大四就可以出去实习，最近也看了一些招聘帖，所以也是感觉时间紧迫，要学有所长，而不是蜻蜓点水。</p>
<p>从大一到现在，我的学习环境几乎都是在宿舍，虽然在大二时有去过汇森学习，也去过图书馆，但最久的还是宿舍。虽然有时候觉得在宿舍效率低，但是似乎我已经习惯了这个嘈杂的环境。至少我认为，虽然我身在宿舍，但我所做的事是学习，</p>
<p>今年最好的生日礼物，算是获得了国家奖学金吧。金钱固然重要，但这张奖状算是对我这两年的一个肯定吧。毕竟没有多少人知道我所做的，没有多少人肯定我所做的，没有正面的反馈，想要单单靠热情来驱动，的确是挺难的。老罗曾经说过，具体原话是否如此不太记得:“通过干干净净地赚钱来证明，在中国是可以做到干干净净地赚钱”。我不清楚也不关心老罗是否干净的赚钱。我只是觉得，通过自己的努力，在没有出身也可以尽力做到最好。</p>
<p>今天呢，Apple 宣布 2016 年 10 月 27 日召开发布会，360 云盘宣布即将关闭。每天，都有不同的事情发生，最近在听一档关于日本的播客，很有深度，引人思考。人的一生不过几十年，多去尝试，多去思考，虽然荆棘遍地，人心叵测，但我仍愿意相信美好。生命不息，向死而生。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;生命不息，向死而生。&lt;br&gt;内容有些凌乱，暂不修改&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Essay" scheme="https://maimieng.com/tags/Essay/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Swift 3 中的访问控制</title>
    <link href="https://maimieng.com/2016/25/"/>
    <id>https://maimieng.com/2016/25/</id>
    <published>2016-10-19T16:00:00.000Z</published>
    <updated>2016-10-26T09:46:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Access Control in Swift 3.0<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.1 Beta 4</li>
<li>Xcode 8.1 Beta 3</li>
<li>Swift 3.0</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习过 Java 等面向对象语言的同学对访问控制一定不陌生，Swift 3 相较于之前的版本，新加了两个关于访问控制修饰符，<code>open</code> 和 <code>fileprivate</code>。因此，是时候总结一下这四个关键字的<strong>基本用法</strong>，因为暂未涉及到复杂的访问控制，故为浅谈。</p>
<p>另外，由于 Apple.com 的所有文档均无权翻译，所以取消之前的翻译，转为自己的理解和代码，权当给自己做个笔记。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>访问控制修饰符的限制性 <strong>高-&gt;低</strong> 排序为下：</p>
<p><code>open</code> &gt; <code>public</code> &gt; <code>internal</code>(默认) &gt; <code>fileprivate</code> &gt; <code>private</code></p>
<p>访问控制的使用原则：<strong>不允许将实体定义在限制性更强的实体内。</strong>所以，以下代码均为错误用法，并注明了错误信息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">var</span> cat = <span class="type">Cat</span>()</div><div class="line"><span class="comment">// Error: Variable cannot be declared public because its type 'Cat' uses an internal type</span></div><div class="line"><span class="comment">// public 变量不能为 internal，fileprivate，private 类型</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">testAccessControl</span><span class="params">(<span class="number">_</span> cat: Cat)</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> cat</div><div class="line">&#125;</div><div class="line"><span class="comment">// Error: Function cannot be declared public because its parameter uses an internal type</span></div><div class="line"><span class="comment">// 函数或方法的访问限制级别不能高于其参数类型</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">testAccessControl</span><span class="params">()</span></span> -&gt; <span class="type">Cat</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Cat</span>()</div><div class="line">&#125;</div><div class="line"><span class="comment">// Error: Function cannot be declared public because its result uses an internal type</span></div><div class="line"><span class="comment">// 函数或方法的访问限制级别不能高于其返回值类型</span></div></pre></td></tr></table></figure>
<h3 id="open-amp-public"><a href="#open-amp-public" class="headerlink" title="open &amp; public"></a><code>open</code> &amp; <code>public</code></h3><p><code>open</code> 是 Swift 3 新增的访问控制符，相较于 <code>public</code> 更加开放。<code>open</code> 和 <code>public</code> 都是可以跨 Module 访问的，但 <code>open</code> 修饰的类可以继承，修饰的方法可以重写（此时，<code>open</code> 需同时修饰该方法以及所在类），而 <code>public</code> 不可以。</p>
<p>至于 <code>public final</code> 与 <code>public</code>，前者在任何地方均不可重写，而后者可在本 Module 内重写。</p>
<h4 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h4><p>ModuleA: Person.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// open 修饰的类可以为其他 Module 所访问和继承</span></div><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="comment">// 属性：</span></div><div class="line">    <span class="comment">// 子类可访问，不可重写</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> note = <span class="string">"maimieng.com"</span></div><div class="line">    </div><div class="line">    <span class="comment">// 方法：</span></div><div class="line">    <span class="comment">// 子类可访问，可重写</span></div><div class="line">    open <span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Work"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 子类可访问，不可重写</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Eat it"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 子类可访问，不可重写</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Take a walk"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ModuleB: Programmer.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ModuleA</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span>: <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="comment">// 只可重写 open 方法</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">// 可访问父类 public 和 public final 方法</span></div><div class="line">        eat()</div><div class="line">        walk()</div><div class="line">        </div><div class="line">        <span class="built_in">print</span>(<span class="string">"Writing \(note)"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="错误信息汇总"><a href="#错误信息汇总" class="headerlink" title="错误信息汇总"></a>错误信息汇总</h4><h5 id="重写父类-public-方法"><a href="#重写父类-public-方法" class="headerlink" title="重写父类 public 方法"></a>重写父类 public 方法</h5><p>ModuleA: Person.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Eat it"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ModuleB: Programmer.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ModuleA</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span>: <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Hamburger!!"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Overriding non-open instance method outside of its defining module</strong></p>
<hr>
<h5 id="重写父类-public-属性"><a href="#重写父类-public-属性" class="headerlink" title="重写父类 public 属性"></a>重写父类 public 属性</h5><p>ModuleA: Person.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> note = <span class="string">"maimieng.com"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ModuleB: Programmer.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ModuleA</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span>: <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="keyword">var</span> note: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"v1024.cn"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>Overriding non-open var outside of its defining module</strong></p>
<h5 id="重写-public-父类"><a href="#重写-public-父类" class="headerlink" title="重写 public 父类"></a>重写 public 父类</h5><p>ModuleA: Animal.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span>: <span class="title">NSObject</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>ModuleB: Programmer.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ModuleA</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Animal</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p><strong>Cannot inherit from non-open class ‘Animal’ outside of its defining module</strong></p>
<h3 id="internal"><a href="#internal" class="headerlink" title="internal"></a><code>internal</code></h3><p><code>internal</code> 是 Swift 中默认／缺省的访问控制级别。网上对于其他修饰符的解释有很多，而 <code>internal</code> 却很少。<code>internal</code> 对自身 Module 开放所有源文件，而对外界源代码屏蔽。</p>
<h4 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo"></a>Demo</h4><p>ModuleA: Person.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Person Name"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ModuleA: Designer.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Designer</span>: <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"test internal"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="错误信息汇总-1"><a href="#错误信息汇总-1" class="headerlink" title="错误信息汇总"></a>错误信息汇总</h4><p>在 ModuleB 访问 ModuleA</p>
<p>ModuleA: Person.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Person Name"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ModuleB: Programmer.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ModuleA</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span>: <span class="title">Person</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p><strong>Use of undeclared type ‘Person’</strong></p>
<h3 id="fileprivate-amp-private"><a href="#fileprivate-amp-private" class="headerlink" title="fileprivate &amp; private"></a><code>fileprivate</code> &amp; <code>private</code></h3><p>Swift 3 新增的另一个访问修饰符是 <code>fileprivate</code>。</p>
<h4 id="Demo-3"><a href="#Demo-3" class="headerlink" title="Demo"></a>Demo</h4><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="comment">// 默认／缺省 internal</span></div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</div><div class="line">    </div><div class="line">    <span class="comment">// private 仅可在本类中访问</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> privateProp = <span class="string">"Private Property"</span></div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">privateMethod</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">    </div><div class="line">    <span class="comment">// fileprivate 可在当前文件内所有类访问</span></div><div class="line">    fileprivate <span class="keyword">var</span> filePrivateProp = <span class="string">"File Private Property"</span></div><div class="line">    fileprivate <span class="function"><span class="keyword">func</span> <span class="title">filePrivateMethod</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</div><div class="line">        filePrivateMethod()</div><div class="line">        <span class="built_in">print</span>(<span class="string">"\(filePrivateProp)"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    fileprivate <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">filePrivateMethod</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="错误信息汇总-2"><a href="#错误信息汇总-2" class="headerlink" title="错误信息汇总"></a>错误信息汇总</h4><h5 id="子类访问父类-private-成员"><a href="#子类访问父类-private-成员" class="headerlink" title="子类访问父类 private 成员"></a>子类访问父类 private 成员</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">privateMethod</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</div><div class="line">        privateMethod()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>‘privateMethod’ is inaccessible due to ‘private’ protection level</strong></p>
<hr>
<h5 id="其他文件的子类访问-fileprivate-成员"><a href="#其他文件的子类访问-fileprivate-成员" class="headerlink" title="其他文件的子类访问 fileprivate 成员"></a>其他文件的子类访问 fileprivate 成员</h5><p>main.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    fileprivate <span class="keyword">var</span> filePrivateProp = <span class="string">"File Private Property"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Cat.swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"\(filePrivateProp)"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>‘filePrivateProp’ is inaccessible due to ‘fileprivate’ protection level</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 Swift 3 中新增的访问控制修饰符，使得 Swift 的访问控制更加灵活。使用不同的访问修饰符，可以使得程序耦合性降低，对外界屏蔽内部的实现细节。但是，Objective-C 是一门允许动态处理的语言，<code>private</code> 只是所谓的私有，而不是真正的私有，通过 KVC 还是可以获取到内部的细节，而 Swift 由于性能的考虑，默认关闭了动态处理，下一篇谈谈 Swift 中的 KVC &amp; KVO。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html" target="_blank" rel="external">Access Control</a></li>
<li><a href="https://maimieng.com/2016/24/">在 iOS 项目中新建 Module</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Access Control in Swift 3.0&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="https://maimieng.com/tags/Swift/"/>
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>在 iOS 项目中新建 Module</title>
    <link href="https://maimieng.com/2016/24/"/>
    <id>https://maimieng.com/2016/24/</id>
    <published>2016-10-19T16:00:00.000Z</published>
    <updated>2016-10-26T09:46:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Access Control Prerequisite Article<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info:<ul>
<li>macOS 10.12.1 Beta 4</li>
<li>Xcode 8.1 Beta 3</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Module，中文译为「标准部件；模块」。iOS 中的 Module 类似于 Java 中的 Jar 包，也可以称作第三方库，或者框架（Framework)。Swift 中的访问控制就涉及到了不同 Module 下的情况，因此简单记录下如何在 iOS 项目中新建 Module。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>首先建立一个 iOS Single View Application。</p>
<p>选择 File-New-Target。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/new_module_1.png" alt="File"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/new_module_2.png" alt="New"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/new_module_3.png" alt="Target"></p>
<p>选择 Cocoa Touch Framework。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/new_module_4.png" alt="Cocoa Touch Framework"></p>
<p>如图，即为建立的 Module（此处建立两个方便后续测试访问控制修饰符）。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/new_module_5.png" alt="新建完成"></p>
<p>使用时，<code>import ModuleA</code> 即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Access Control Prerequisite Article&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://maimieng.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Intellij IDEA 配置 Code Style</title>
    <link href="https://maimieng.com/2016/23/"/>
    <id>https://maimieng.com/2016/23/</id>
    <published>2016-10-02T16:00:00.000Z</published>
    <updated>2016-10-03T02:23:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>IDE 已经如此完备了，<br>为什么还是懒得用？<br></blockquote><br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天自说自话，闲扯了界面设计和代码规范。设计确实需要一些经验，也不一定能取悦所有人。而代码规范却是程序员所起码应当做到的，多人协作中，杂乱的代码就好像批阅潦草的作文，可读性极差。</p>
<p>然而这是个懒人驱动的世界，IDE 其实已经为你准备好了各种工具，等着你去使用。但是由于这些软件基本都是国外开发，汉化不全，新手往往望着密密麻麻的按钮不知所措。</p>
<p>但没办法，英文是程序员所不得不克服的一个「障碍」，障碍我打了引号，因为语言并能算是障碍。语言是共同不同种族的桥梁，然而却阻碍了很多人的前进。</p>
<p>这次，就简单介绍下 Intellij IDEA 如何配置 Code Style 文件，之后便可以通过快捷键规整代码。当然，Code Style 能力有限，更高级的开发者也许早已烂熟于胸。</p>
<p>这里以 Google 的 Java Code Style 为例。</p>
<h2 id="intellij-java-google-style-xml"><a href="#intellij-java-google-style-xml" class="headerlink" title="intellij-java-google-style.xml"></a>intellij-java-google-style.xml</h2><p>Google 在 GitHub 上有一个专门放置编码规范的仓库，地址在：<br><a href="https://github.com/google/styleguide" target="_blank" rel="external">https://github.com/google/styleguide</a>。</p>
<p>可以随时在该网站获得最新的代码规范（但大部分规范几乎很少改动）。</p>
<p>找到其中文件名为 <strong>intellij-java-google-style.xml</strong> 的文件，点击打开。或者直接点击<br><a href="https://github.com/google/styleguide/blob/gh-pages/intellij-java-google-style.xml" target="_blank" rel="external">https://github.com/google/styleguide/blob/gh-pages/intellij-java-google-style.xml</a>。</p>
<p>这里需要将其中的内容保存到本地，当然也可以选择下载整个仓库，只提取所需要的文件。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/intellij_idea_code_style_1.png" alt="复制的内容"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/intellij_idea_code_style_2.png" alt="保存为 xml 文件"></p>
<h2 id="导入-Code-Style"><a href="#导入-Code-Style" class="headerlink" title="导入 Code Style"></a>导入 Code Style</h2><p>切换到 Intellij IDEA，这里我用的是 Android Studio，同理。Android Studio-Preferences…</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/intellij_idea_code_style_3.png" alt="Preference"></p>
<p>侧栏 Editor-Java，点击 Manage。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/intellij_idea_code_style_4.png" alt="Editor-Java-Manage"></p>
<p>打开后的界面如下图，点击 Import，之后点击 OK。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/intellij_idea_code_style_5.png" alt="Import"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/intellij_idea_code_style_6.png" alt="OK"></p>
<p>选中刚刚保存的 xml 文件，点击 OK，之后再次点击 OK。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/intellij_idea_code_style_7.png" alt="选择 Code Style 文件"></p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/intellij_idea_code_style_8.png" alt="再次点击 OK"></p>
<p>如下图，即导入成功。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/intellij_idea_code_style_9.png" alt="导入成功"></p>
<p>回到 Preferences 界面，也可看到当前 Code Style 切换到 Google Style 了。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/intellij_idea_code_style_10.png" alt="Preferences"></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>之后的使用 IDE 会保证格式的符合，为了确保文件格式的符合，也可以手动格式化代码。</p>
<p>选择菜单栏-Code-Reformat Code，也可以使用相应的快捷键。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/intellij_idea_code_style_11.png" alt="Reformat Code"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jetbrains.com/help/idea/2016.2/configuring-code-style.html" target="_blank" rel="external">Configuring Code Style by JetBrains</a><br><a href="https://google.github.io/styleguide/javaguide.html" target="_blank" rel="external">Google Java Style Guide</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;IDE 已经如此完备了，&lt;br&gt;为什么还是懒得用？&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://maimieng.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>瞎扯界面设计与代码规范</title>
    <link href="https://maimieng.com/2016/22/"/>
    <id>https://maimieng.com/2016/22/</id>
    <published>2016-10-01T16:00:00.000Z</published>
    <updated>2016-10-02T12:17:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>而我说的都是错的。<br></blockquote><br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>身处软件学院，周围是数不胜数的「程序员」。也有看过他们所做的 App，网站，等等项目。具体功能的实现我不清楚是否合格，但几乎都有一个共同点，「mess」。我需要说明的是，杂乱并不等于丑，因为审美各有不同，而杂乱的界面与糟糕的代码却往往被忽视。当然，程序员又不是产品经理，也不是设计师，所以我说的都是错的。</p>
<h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>题中的「设计」，我想分为两个截然不同的意义。一是软件的整体设计，即规划，二是软件的界面设计。软件的整体设计可能需要经验的积累，才能做到考虑周到，尽可能不遗漏某些要点，暂且不论。而界面设计则是设计师对流行设计的认知结合特定软件的思考的产物。</p>
<p>私以为会用 Photoshop 等工具则根本不等同于会设计，就好像会用钢笔但不一定写得出庞中华的硬笔书法（注：我不喜欢庞中华的字体，但其能力还是有的）。</p>
<p>题中的「规范」，主要说的是代码规范。暑假时接了一个 Android Project，没有文档，且是 2012 年的代码，资金与精力有限，不可能完全重写。而代码也是十分糟糕的，拼音命名的变量名随处可见，到处充斥的打印日志（个人认为这些用于测试的临时代码应当及时删除），代码风格极差。加上由于是临时组织的团队，我没有主导权。首先尝试了 SVN 管理代码，结果无法连接 SVN 服务器，最后的协作竟然是通过 QQ，Copy-Paste。团队中的成员对代码规范似乎也没有听说过，我无法想象如果未来公司中这样的代码管理会给后期维护造成多大的难度。。。</p>
<p>所以身边也许有会用 Photoshop 切图的人，但没见过几个能设计的；身边都会敲代码，但没过几个代码做到起码的规范。当然，我连 Photoshop 都不会用，也没做过几个项目，所以我说的都是错的。</p>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>暑假培训无聊，草草翻看之前借阅的《写给大家看的设计书》，里面的一些原则也都忘记的差不多了。如果想要做一名专业的设计师，那么掌握工具是基本功，也可能需要看一些理论的书籍，甚至用户心理学的书籍。</p>
<p>说句实话，闲扯这篇，其中一个原因是这次的 Android Project。身为学生，且和计院的不熟悉，不清楚他们平时的写代码是否会多加考虑。上次的 Project 原定 1 周完成，结果到现在也无法交付。这次的 Project 是从头做起，所以我希望可以制定一些代码规范，遵照一些设计规则，这也是我假期这几天所考虑的。</p>
<p>此次的 Project 是基于 Android，所以我希望设计是趋于 Material Design，而不是模仿 iOS。虽然 Apple 的产品我拥有一部分，它们也的确好用，但是一个基于 Android 开发的软件就应当遵照其规范。</p>
<p>但，这里有个悖论。Material Design 在国内其实名存实亡。第三方 ROM 已经把 Android 改的面目全非，当然本地化还是值得称赞的。这也导致现今国内的 Android 手机都神似 iPhone。加上 Android 的碎片化，需要考虑到适配较早的 SDK 版本，导致一些设计无法使用，这也是我最近在考虑是否可以建议有一些 Android 的特有设计。</p>
<p>当然，我又不是决策者，这么做于我来说似乎并没有什么益处，所以我说的都是错的。</p>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>界面设计是为了更好的用户体验，让用户乐于打开你的应用。而代码规范也是为了更好的用户体验，只是这里的用户指的是程序员。</p>
<p>功能的实现也许已经不是关键，App Store 和 Google Play 中有无数的天气预报应用，或是无数的浏览器。但是为什么还是有人不断的开发呢？也许解决了一个用户的痛点，也许只是易用性更好，界面更加美观，运行更加高效。</p>
<p>当然，我站在看热闹不嫌事大的角度，所以我说的都是错的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>本来重点是准备整理一些 Material Design 的相关资料，工具，没想到瞎扯这么多，一气呵成，也不再去纠正什么了，当作随笔吧。</p>
<p>希望有人可以懂点设计，有点规范，也希望未来进入的公司可以如此。</p>
<p><a href="https://material.uplabs.com" target="_blank" rel="external">MaterialUp</a><br><a href="https://www.materialpalette.com" target="_blank" rel="external">Material Palette</a><br><a href="http://www.calltoidea.com" target="_blank" rel="external">CallToIdea</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;而我说的都是错的。&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Essay" scheme="https://maimieng.com/tags/Essay/"/>
    
      <category term="Design" scheme="https://maimieng.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>使用 Gradle 构建 Struts 2 Web 应用</title>
    <link href="https://maimieng.com/2016/21/"/>
    <id>https://maimieng.com/2016/21/</id>
    <published>2016-09-26T16:00:00.000Z</published>
    <updated>2016-12-26T02:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Ant -&gt; Maven -&gt; Gradle<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info<ul>
<li>JDK 1.8</li>
<li>Tomcat 8.5.5</li>
<li>Intellij IDEA 2016.2.3</li>
<li>macOS 10.12.1 beta</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>熟悉 Android 开发的程序员都知道，Android Studio 是基于 Intellij IDEA 社区版所开发的，其默认使用 Gradle 构建项目。</p>
<p>与 Maven 不同，Gradle 的配置更为简单，两者的优劣这里略过，。这次就体验一下使用 Gradle 构建最基本的 Struts 2 Web 应用。记录于此，便于往后查阅。</p>
<h2 id="安装-Tomcat"><a href="#安装-Tomcat" class="headerlink" title="安装 Tomcat"></a>安装 Tomcat</h2><p>下载并解压 Tomcat，将其置于 <code>/usr/local</code> 文件夹内，这里以 Tomcat 8.5.5 为例，因为其支持 Servlet 3.1 标准。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_1.png" alt="Tomcat 放置路径"></p>
<h2 id="新建-Gradle-Web-项目"><a href="#新建-Gradle-Web-项目" class="headerlink" title="新建 Gradle Web 项目"></a>新建 Gradle Web 项目</h2><p>菜单栏：File - New - Project…</p>
<p>选择左侧的 Gradle，勾选 Web 选项，因为要建立的是跑在服务器上的应用。点击 Next。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_2.png" alt="New Gradle"></p>
<p>输入 Group ID 以及 Artifact ID，建议输入真实，唯一的 ID。良好的习惯将减小未来发生错误的概率。继续点击 Next。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_3.png" alt="Group ID &amp; Artifact ID"></p>
<p>勾选必要的选项，Next。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_4.png" alt="配置项目"></p>
<p>设置项目的放置目录，Finish。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_5.png" alt="项目的放置目录"></p>
<p>等待 Gradle 构建项目，可以在窗口下部看到当前状态，构建完毕时，则会消失。和 Maven 类似，Gradle 的构建过程也需要联网下载所需的依赖。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_6.png" alt="等待 Gradle 构建项目"></p>
<h2 id="导入-Struts-2"><a href="#导入-Struts-2" class="headerlink" title="导入 Struts 2"></a>导入 Struts 2</h2><p>Gradle 项目建立基本完毕，需要配置 Struts 2 的依赖。和 Maven 类似，可以搜索 Maven Repository，虽然名字是 Maven 仓库，但却提供了多种依赖的部署方式。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_7.png" alt="搜索 Maven Repository"></p>
<p>搜索 struts，我们能得到很多结果，我们需要选择 Struts 2 Core。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_8.png" alt="Struts 2 Core"></p>
<p>打开之后可以看到 Struts 2 的不同版本，Maven 和 Gradle 的方便之处在于，可以很简单的切换不同版本，而不用手动下载相关 JAR 包。对于版本的选择，首先可以优先选择 release 版。测试版（即 Beta 版）在网页上也有清晰的标注。另外通过阅览 Struts 官网我们得知，Struts 3 将基于 2.5 或更新版本，较大版本更迭会有较大不同，甚至是兼容性的差异。所以我们选择当前 2.3 的最高子版本 2.3.30。当然你也可以选择参考书等资料中的版本，但个人偏向较新的版本，不要沉溺于太过时的东西，限制你的思想。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_9.png" alt="Struts 2.3.30"></p>
<p>切换到 Gradle 标签，拷贝其中的内容。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_10.png" alt="拷贝 Gradle 依赖"></p>
<p>回到 IDEA，打开 build.gradle，将其粘贴到 dependencies 中。由于之前勾选过 auto-import，即可自动导入。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_11.png" alt="build.gradle"></p>
<p>如果忘记勾选，也可在此手动刷新，让其导入。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_12.png" alt="手动刷新导入"></p>
<p>至此，Struts 2 已经导入该项目，但距离使用还差一点距离。</p>
<h2 id="配置-Tomcat"><a href="#配置-Tomcat" class="headerlink" title="配置 Tomcat"></a>配置 Tomcat</h2><p>虽然我们安装了 Tomcat，也选择了 Web 应用，但并没有部署项目，所以无法运行。点击图中菜单的下三角，选择 Edit Configurations…。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_13.png" alt="Edit Configurations"></p>
<p>点击左上角加号。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_14.png" alt="点击左上角加号"></p>
<p>选择 Tomcate Server - Local。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_15.png" alt="Tomcate Server"></p>
<p>根据下图即可配置 Tomcat。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_16.png" alt="配置 Tomcat"></p>
<p>如果 IDEA Application server 为空，那么需要首先添加 Tomcat 服务器，点击 Configure…，点击新窗口的左上角的加号添加新的服务器，选择 Tomcat 的路径即可（图上已经拥有配置好的两个不同版本的 Tomcat 服务器）。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_17.png" alt="添加 Tomcat 服务器"></p>
<p>回到配置 Tomcat，切换到 Deployment 标签，点击图中的加号，选择 Aritifacts。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_18.png" alt="Deployment"></p>
<p>这里选择 exploded 结尾的 war 包，这是展开的 war，便于重载资源，在开发阶段建议选择此。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_19.png" alt="选择 exploded"></p>
<p>配置完成，点击 OK。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_20.png" alt="配置完成"></p>
<h2 id="添加-web-xml-amp-struts-xml"><a href="#添加-web-xml-amp-struts-xml" class="headerlink" title="添加 web.xml &amp; struts.xml"></a>添加 web.xml &amp; struts.xml</h2><p>点击菜单栏的 Project Structure。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_21.png" alt="Project Structure"></p>
<p>选择左侧 Modules，当前 Web Gradle，点击加号。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_22.png" alt="Modules-Web Gradle"></p>
<p>选择创建 web.xml 的路径，注意在最后不要忘记 web.xml，否则并不会创建。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_23.png" alt="web.xml 路径"></p>
<p>配置 web.xml 完成，点击 OK。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_24.png" alt="配置完成"></p>
<p>struts.xml 可以直接在 resources 目录右键 - New - XML Configuration File - Struts Config，即可生成。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_25.png" alt="新建 struts.xml"></p>
<p>新建完成，IDEA 会检测到 struts.xml，提示配置，选择 Configure，勾选刚刚创建的 struts.xml 以及下面的 struts-default（图中漏掉了），点击 OK。<br>（注意：如果 IDEA 没有提示，那么可在选择 Web Gradle 界面，选择左侧的 Facets，点击加号，添加 Struts 2 并勾选上述文件）</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_26.png" alt="勾选 struts.xml"></p>
<p>配置完成，点击 OK。</p>
<p><img src="https://o7y30w6c6.qnssl.com/blog/idea_gradle_struts2_27.png" alt="配置完成"></p>
<p>添加完成这两个 xml 文件，但并没有进行内部的配置，web.xml 是必须配置的，可以按照如下配置 Struts 2 过滤器。</p>
<p>web.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line">         <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></div><div class="line">         <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>至此，Struts 2 基本配置已经完成，可以简单的在 index.jsp 中测试 Struts 2 的标签即可验证是否成功。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Ant -&amp;gt; Maven -&amp;gt; Gradle&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://maimieng.com/tags/Java/"/>
    
      <category term="Gradle" scheme="https://maimieng.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>几种数据结构的多种语言实现</title>
    <link href="https://maimieng.com/2016/20/"/>
    <id>https://maimieng.com/2016/20/</id>
    <published>2016-09-20T16:00:00.000Z</published>
    <updated>2016-09-24T11:48:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>Learning data structures by coding in<br>C/C++/Obj-C/Java/Swift.<br></blockquote><br><a id="more"></a></p>
<ul>
<li>Info<ul>
<li>Xcode 8.0</li>
<li>Intellij IDEA 2016.2</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据结构是一门相对抽象，枯燥的课。</p>
<p>这次算是我第五次学数据结构了吧，之前的几次都没跟上，希望这次至少多敲敲代码，熟悉熟悉。代码全部公开，欢迎指出错误。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本来准备把代码段粘贴到博客中，但是由于文件较多，不好组织，更不便于阅读。因此我在 GitLab 上建立了一个 Group，将所有项目放置于此。</p>
<p>每种数据结构均使用了 5 种编程语言实现，目的是为了巩固基本的语法，也印证了数据结构与具体的编程语言无关。</p>
<p>由于不同语言的特性不同，C 和 Obj-C 均使用特定的整型数据类型（即 <code>int</code>），而 C++ 使用模版来达到泛型的目的，Swift 和 Java 也原生支持泛型，使得数据结构与数据类型解耦。</p>
<h2 id="Loop-Queue"><a href="#Loop-Queue" class="headerlink" title="Loop Queue"></a>Loop Queue</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p><a href="https://gitlab.com/data-structure-learning/Loop-Queue-in-C/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Loop-Queue-in-C</a></p>
<h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><p><a href="https://gitlab.com/data-structure-learning/Loop-Queue-in-Cpp/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Loop-Queue-in-Cpp</a></p>
<h3 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h3><p><a href="https://gitlab.com/data-structure-learning/Loop-Queue-in-ObjC/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Loop-Queue-in-ObjC</a></p>
<h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><p><a href="https://gitlab.com/data-structure-learning/Loop-Queue-in-Swift/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Loop-Queue-in-Swift</a></p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p><a href="https://gitlab.com/data-structure-learning/Loop-Queue-in-Java/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Loop-Queue-in-Java</a></p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><h3 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h3><p><a href="https://gitlab.com/data-structure-learning/Stack-in-C/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Stack-in-C</a></p>
<h3 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h3><p><a href="https://gitlab.com/data-structure-learning/Stack-in-Cpp/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Stack-in-Cpp</a></p>
<h3 id="Objective-C-1"><a href="#Objective-C-1" class="headerlink" title="Objective-C"></a>Objective-C</h3><p><a href="https://gitlab.com/data-structure-learning/Stack-in-ObjC/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Stack-in-ObjC</a></p>
<h3 id="Swift-1"><a href="#Swift-1" class="headerlink" title="Swift"></a>Swift</h3><p><a href="https://gitlab.com/data-structure-learning/Stack-in-Swift/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Stack-in-Swift</a></p>
<h3 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h3><p><a href="https://gitlab.com/data-structure-learning/Stack-in-Java/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Stack-in-Java</a></p>
<h2 id="Sequence-List"><a href="#Sequence-List" class="headerlink" title="Sequence List"></a>Sequence List</h2><h3 id="C-4"><a href="#C-4" class="headerlink" title="C"></a>C</h3><p><a href="https://gitlab.com/data-structure-learning/Sequence-List-in-C/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Sequence-List-in-C</a></p>
<h3 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h3><p><a href="https://gitlab.com/data-structure-learning/Sequence-List-in-Cpp/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Sequence-List-in-Cpp</a></p>
<h3 id="Objective-C-2"><a href="#Objective-C-2" class="headerlink" title="Objective-C"></a>Objective-C</h3><p><a href="https://gitlab.com/data-structure-learning/Sequence-List-in-ObjC/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Sequence-List-in-ObjC</a></p>
<h3 id="Swift-2"><a href="#Swift-2" class="headerlink" title="Swift"></a>Swift</h3><p><a href="https://gitlab.com/data-structure-learning/Sequence-List-in-Swift/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Sequence-List-in-Swift</a></p>
<h3 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h3><p><a href="https://gitlab.com/data-structure-learning/Sequence-List-in-Java/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Sequence-List-in-Java</a></p>
<h2 id="Link-List"><a href="#Link-List" class="headerlink" title="Link List"></a>Link List</h2><h3 id="C-6"><a href="#C-6" class="headerlink" title="C"></a>C</h3><p><a href="https://gitlab.com/data-structure-learning/Sequence-List-in-C/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Link-List-in-C</a></p>
<h3 id="C-7"><a href="#C-7" class="headerlink" title="C++"></a>C++</h3><p><a href="https://gitlab.com/data-structure-learning/Link-List-in-Cpp/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Link-List-in-Cpp</a></p>
<h3 id="Objective-C-3"><a href="#Objective-C-3" class="headerlink" title="Objective-C"></a>Objective-C</h3><p><a href="https://gitlab.com/data-structure-learning/Link-List-in-ObjC/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Link-List-in-ObjC</a></p>
<h3 id="Swift-3"><a href="#Swift-3" class="headerlink" title="Swift"></a>Swift</h3><p><a href="https://gitlab.com/data-structure-learning/Link-List-in-Swift/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Link-List-in-Swift</a></p>
<h3 id="Java-3"><a href="#Java-3" class="headerlink" title="Java"></a>Java</h3><p><a href="https://gitlab.com/data-structure-learning/Link-List-in-Java/tree/master/" target="_blank" rel="external">https://gitlab.com/data-structure-learning/Link-List-in-Java</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://maimieng.com/ipro/interview/">Daily Interview</a><br><a href="http://www.imooc.com/learn/519" target="_blank" rel="external">数据结构探险—队列篇</a><br><a href="http://www.imooc.com/learn/611" target="_blank" rel="external">数据结构探险—栈篇</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Learning data structures by coding in&lt;br&gt;C/C++/Obj-C/Java/Swift.&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Data Structure" scheme="https://maimieng.com/tags/Data-Structure/"/>
    
  </entry>
  
</feed>
