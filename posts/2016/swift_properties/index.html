<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>浅谈 Swift 中的属性（Property） :: iBlog — github.com/kingcos</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Swift Xcode     2017-04-27 扩充 #延迟存储属性# 部分并新增 #devxoul/Then# 3.1 8.3.2   2016-10-26 首次提交 3.0 8.1 Beta 3    前言 Swift 中的属性分为存储属性与计算属性，存储属性即为我们平时常用的属性，可以直接赋值使用，而计算属性不直接存储值，而是根据其他（存储）属性计算得来的值。
在其他面向对象的编程语言中，例如 Java 和 Objective-C 中，get 和 set 方法提供了统一、规范的接口，可以使得外部访问或设置对象的私有属性，而不破坏封装性，也可以很好的控制权限（选择性实现 get 或 set 方法）。而 Swift 中似乎并没有见到类似的 get 和 set 方法，而 Swift 使用了一种名为属性观察器的概念来解决该问题。
本文简单介绍下 Swift 中的这两种属性，以及属性观察器。
延迟存储属性  存储属性使用广泛，即是类或结构体中的变量或常量，可以直接赋初始值，也可以修改其初始值（仅指变量）。 延迟存储属性是指第一次使用到该变量再进行运算（这里的运算不能依赖其他成员属性，但可以使用静态／类属性）。 延迟存储属性必须声明为 var 变量，因为其属性值在对象实例化前可能无法得到，而常量必须在初始化完成前拥有初始值。 在 Swift 中，可以将消耗性能才能得到的值作为延迟存储属性，即懒加载。 全局的常量和变量也是延迟存储属性，但不需要显式声明为 lazy（不支持 Playground）。  Demo  这里假定在 ViewController."/>
<meta name="keywords" content="ios,swift,objective-c,obj-c,objc,oc,geek,python,ruby"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2016/swift_properties/" />





<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="浅谈 Swift 中的属性（Property）"/>
<meta name="twitter:description" content="Swift 中的属性分为存储属性与计算属性，存储属性即为我们平时常用的属性，可以直接赋值使用，而计算属性不直接存储值，而是根据其他（存储）属性计算得来的值。"/>



<meta property="og:title" content="浅谈 Swift 中的属性（Property）" />
<meta property="og:description" content="Swift 中的属性分为存储属性与计算属性，存储属性即为我们平时常用的属性，可以直接赋值使用，而计算属性不直接存储值，而是根据其他（存储）属性计算得来的值。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2016/swift_properties/" />
<meta property="article:published_time" content="2016-10-26T00:00:00+00:00" />
<meta property="article:modified_time" content="2016-10-26T00:00:00+00:00" /><meta property="og:site_name" content="iBlog" />






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">iBlog</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About &amp; AMA</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About &amp; AMA</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="post">
    <h2 class="post-title"><a href="/posts/2016/swift_properties/">浅谈 Swift 中的属性（Property）</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            2016-10-26
        </span>
      
      
      
        <span class="post-read-time">— 4 min read</span>
      
    </div>

    
      <span class="post-tags">
        
          #<a href="/tags/focus/">Focus</a>&nbsp;
        
          #<a href="/tags/ios/">iOS</a>&nbsp;
        
          #<a href="/tags/swift/">Swift</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Swift</th>
<th align="center">Xcode</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2017-04-27</td>
<td align="center">扩充 #延迟存储属性# 部分并新增 #devxoul/Then#</td>
<td align="center">3.1</td>
<td align="center">8.3.2</td>
</tr>

<tr>
<td align="center">2016-10-26</td>
<td align="center">首次提交</td>
<td align="center">3.0</td>
<td align="center">8.1 Beta 3</td>
</tr>
</tbody>
</table>

<h2 id="前言">前言</h2>

<p>Swift 中的属性分为存储属性与计算属性，存储属性即为我们平时常用的属性，可以直接赋值使用，而计算属性不直接存储值，而是根据其他（存储）属性计算得来的值。</p>

<p>在其他面向对象的编程语言中，例如 Java 和 Objective-C 中，get 和 set 方法提供了统一、规范的接口，可以使得外部访问或设置对象的私有属性，而不破坏封装性，也可以很好的控制权限（选择性实现 get 或 set 方法）。而 Swift 中似乎并没有见到类似的 get 和 set 方法，而 Swift 使用了一种名为属性观察器的概念来解决该问题。</p>

<p>本文简单介绍下 Swift 中的这两种属性，以及属性观察器。</p>

<h2 id="延迟存储属性">延迟存储属性</h2>

<ul>
<li>存储属性使用广泛，即是类或结构体中的变量或常量，可以直接赋初始值，也可以修改其初始值（仅指变量）。</li>
<li>延迟存储属性是指第一次使用到该变量再进行运算（这里的运算不能依赖其他成员属性，但可以使用静态／类属性）。</li>
<li>延迟存储属性必须声明为 <code>var</code> 变量，因为其属性值在对象实例化前可能无法得到，而常量必须在初始化完成前拥有初始值。</li>
<li>在 Swift 中，可以将消耗性能才能得到的值作为延迟存储属性，即懒加载。</li>
<li>全局的常量和变量也是延迟存储属性，但不需要显式声明为 lazy（不支持 Playground）。</li>
</ul>

<h3 id="demo">Demo</h3>

<ul>
<li>这里假定在 ViewController.swift 有一个属性，需要从 plist 文件读取内容，将其中的字典转为模型。如果 plist 文件中内容很多，那么就十分消耗性能。如果用户不触发相应事件，也没有必要加载这些数据。那么这里就很适合使用懒加载，即延迟存储属性。</li>
</ul>

<p>ViewController.swift</p>

<pre><code class="language-swift">class ViewController: UIViewController {

    lazy var goods: NSArray? = {
        var goodsArray: NSMutableArray = []

        if let path = Bundle.main.path(forResource: &quot;Goods&quot;, ofType: &quot;plist&quot;) {
            if let array = NSArray(contentsOfFile: path) {
                for goodsDict in array {
                    goodsArray.add(Goods(goodsDict as! NSDictionary))
                }
                return goodsArray
            }
        }

        return nil
    }()

    // 这样也是允许的，可以把初始化的代码直接放在构造方法中
    lazy var testLazy = Person()
}

class Person {}
</code></pre>

<p><em>可以在延迟存储属性运算的代码中加入打印语句，即可验证其何时初始化。</em></p>

<h3 id="lazy-初始化的-演变-过程">Lazy 初始化的「演变」过程</h3>

<ul>
<li><p>根据上面 Demo，延迟存储属性的初始化代码部分可能有些让人迷惑，但其实也是初始化的一步步的演变过程。在 <a href="https://weibo.com/u/1683298872">@Onetaway</a> 的 <a href="http://www.bilibili.com/video/av10139582/">【菜鸡Playground 1】Swift 中 lazy initialization</a> 中也有描述这个过程，简单用代码表示也如下所示：</p>

<pre><code class="language-Swift">struct Person {
var name = &quot;&quot;

init() {
    print(#function)
}
}

// 直接初始化
let p1 = Person()

// 利用闭包
let getOnePerson = { () -&gt; Person in
let p = Person()
return p
}

let p2 = getOnePerson()

// 闭包执行
let p3 = { () -&gt; Person in
let p = Person()
return p
}()

// 简化
let p4: Person = {
let p = Person()
return p
}()
</code></pre></li>
</ul>

<h3 id="lazy-方法">Lazy 方法</h3>

<ul>
<li><p><a href="https://onevcat.com">@Onevcat</a> 的 Swifter Tips 中也提到，在 Swift 标准库中，也有一些 Lazy 方法，就可以在不需要运行时，避免消耗太多的性能。</p>

<pre><code class="language-Swift">let data = 0...3
let result = data.lazy.map { (i: Int) -&gt; Int in
print(&quot;Handling...&quot;)
return i * 2
}

print(&quot;Begin:&quot;)
for i in result {
print(i)
}
// OUTPUT:
// Begin:
// Handling...
// 0
// Handling...
// 2
// Handling...
// 4
// Handling...
// 6
</code></pre></li>
</ul>

<h2 id="devxoul-then">devxoul/Then</h2>

<ul>
<li>在 <a href="http://www.jianshu.com/u/88a056103c02">@没故事的卓同学</a>的<a href="http://www.bilibili.com/video/av10142408/">【菜鸡Playground 2】Swift 中 lazy initialization 的使用场景</a>中提到了一个 <a href="https://github.com/devxoul/Then">devxoul/Then</a> 库，为 Swift 的构造方法加入语法糖。</li>
</ul>

<h3 id="demo-1">Demo</h3>

<p>ViewController.swift</p>

<pre><code class="language-Swift">import UIKit
import Then

class ViewController: UIViewController {
    lazy var myLabel = UILabel().then {
        $0.text = &quot;My Label&quot;
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        myLabel.frame = CGRect(x: 0.0, y: 0.0,
                               width: 100.0, height: 100.0)
        view.addSubview(myLabel)
    }
}
</code></pre>

<h3 id="source-code">Source Code</h3>

<ul>
<li>Then 的核心源码部分总共只有不到 20 行，非常简单易懂。</li>
<li>Then 库中定义了一个名为 Then 的空协议，之后通过协议扩展（Protocol Extension），来为协议添加默认的方法实现。</li>
</ul>

<h3 id="then"><code>then()</code></h3>

<ul>
<li>因为 <code>then()</code> 内部将 <code>self</code> 返回，即可在初始化完成后，调用该方法，并在闭包中设置属性，而且不需要再将自身返回。</li>

<li><p>支持 NSObject 子类，也可以将自定义类型（仅支持 AnyObject 类型，即 class）声明实现该协议即可（协议扩展已经拥有默认实现，所以仅声明实现协议即可）。</p>

<pre><code class="language-Swift">extension Then where Self: AnyObject {

/// Makes it available to set properties with closures just after initializing.
public func then(_ block: (Self) -&gt; Void) -&gt; Self {
block(self)
return self
}

}
</code></pre></li>
</ul>

<h3 id="with"><code>with()</code></h3>

<ul>
<li><code>then()</code> 适用于引用类型，而 <code>with()</code> 适用于值类型。</li>

<li><p>使用了 <code>inout</code> 确保方法内外共用一个值类型变量。</p>

<pre><code class="language-Swift">extension Then where Self: Any {

/// Makes it available to set properties with closures just after initializing and copying the value types.
public func with(_ block: (inout Self) -&gt; Void) -&gt; Self {
var copy = self
block(&amp;copy)
return copy
}

}
</code></pre></li>
</ul>

<h3 id="do"><code>do()</code></h3>

<ul>
<li><p><code>do()</code> 使得可以直接在闭包中简单地执行一些操作。</p>

<pre><code class="language-Swift">extension Then where Self: Any {
/// Makes it available to execute something with closures.
public func `do`(_ block: (Self) -&gt; Void) {
block(self)
}

}
</code></pre></li>
</ul>

<h2 id="计算属性">计算属性</h2>

<ul>
<li>举个例子，一个<strong>矩形</strong>结构体（类同理），拥有<strong>宽度</strong>和<strong>高度</strong>两个存储属性，以及一个只读<strong>面积</strong>的计算属性，因为通过设置矩形的宽度和高度即可<strong>计算</strong>出矩形的面积，而无需直接设置其值。当宽度或高度改变，面积也应当可以跟随其变化（反之不能推算，因此为只读）。为说明 setter 以及便捷 setter 说明，另外添加了<strong>原点</strong>（矩形左下角）存储属性，以及<strong>中心</strong>计算属性。</li>
</ul>

<h3 id="demo-2">Demo</h3>

<pre><code class="language-swift">struct Point {
    var x = 0.0
    var y = 0.0
}

struct Rectangle {
    var width = 0.0
    var height = 0.0
    var origin = Point()

    // 只读计算属性
    var size: Double {
        get {
            return width * height
        }
    }

    // 只读计算属性简写为
//    var size: Double {
//        return width * height
//    }

    var center: Point {
        get {
            return Point(x: origin.x + width / 2,
                         y: origin.y + height / 2)
        }

        set(newCenter) {
            origin.x = newCenter.x - width / 2
            origin.y = newCenter.y - height / 2
        }

        // 便捷 setter 声明
//        set {
//            origin.x = newValue.x - width / 2
//            origin.y = newValue.y - height / 2
//        }
    }

}

var rect = Rectangle()
rect.width = 100
rect.height = 50
print(rect.size)

rect.origin = Point(x: 0, y: 0)
print(rect.center)

rect.center = Point(x: 100, y: 100)
print(rect.origin)

// 5000.0
// Point(x: 50.0, y: 25.0)
// Point(x: 50.0, y: 75.0)
</code></pre>

<p><em>综上，getter 可以根据存储属性推算计算属性的值，setter 可以在被赋值时根据新值倒推存储属性，但它们与我们在其他语言中的 get/set 方法却不一样。</em></p>

<h2 id="属性观察器">属性观察器</h2>

<ul>
<li>属性观察器算是 Swift 中的一个 feature，变量在设值<strong>前</strong>会先进入 <code>willSet</code>，这时默认 <code>newValue</code> 等于即将要赋值的值，而变量本身尚未改变。变量在设值<strong>后</strong>会先进入 <code>didSet</code>，这时默认 <code>oldValue</code> 等于赋值前变量的值，而变量变为新值。</li>
<li>这样，开发者即可在 <code>willSet</code> 和 <code>didSet</code> 中进行相应的操作，如果只是取值和设值而不进行额外操作，那么直接使用点语法即可。但是有时候一个变量只需要被访问，而不能在外界赋值，那么可以使用<a href="/2016/25/">访问控制修饰符</a>加上 <code>(set)</code> 即可私有化 set 方法。例如 <code>fileprivate(set)</code>，<code>private(set)</code>，以及 <code>internal(set)</code>。值得注意的是，这里的访问控制修饰符修饰的是 set 方法，访问权限（即 get）是另外设置的。例如 <code>public fileprivate(set) var prop = 0</code>，该变量全局可以访问，但只有同文件内可以使用 set 方法。</li>
</ul>

<h3 id="demo-3">Demo</h3>

<pre><code class="language-swift">struct Animal {
    // internal 为默认权限，可不加
    internal private(set) var privateSetProp = 0

    var hungryValue = 0 {
        // 设置前调用
        willSet {
            print(&quot;willSet \(hungryValue) newValue: \(newValue)&quot;)
        }

        // 设置后调用
        didSet {
            print(&quot;didSet \(hungryValue) oldValue: \(oldValue)&quot;)
        }

        // 也可以自己命名默认的 newValue/oldValue
        // willSet(new) {}
        // didSet(old) {}
    }
}

var cat = Animal()

// private(set) 即只读
// cat.privateSetProp = 10
print(cat.privateSetProp)

cat.hungryValue += 10
print(cat.hungryValue)

// 0
// willSet 0 newValue: 10
// didSet 10 oldValue: 0
// 10
</code></pre>

<h2 id="总结">总结</h2>

<p>Swift 的这几个 feature 我未曾在其他语言中见过，对于初学者确实容易造成凌乱。特别是 getter/setter 以及属性观察器中均没有代码提示，容易造成手误，代码似乎也变得臃肿。但是熟悉之后，这些也都能完成之前的功能，甚至更加细分。保持每一部分可控，也使得整个程序更加严谨，更加安全。</p>

<h2 id="参考">参考</h2>

<ul>
<li><a href="http://www.jianshu.com/p/80810efe5229">浅谈 Swift 3 中的访问控制</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html">Access Control</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html">Properties</a></li>
<li><a href="http://www.bilibili.com/video/av10139582/">【菜鸡Playground 1】Swift 中 lazy initialization</a></li>
<li><a href="http://www.bilibili.com/video/av10142408/">【菜鸡Playground 2】Swift 中 lazy initialization 的使用场景</a></li>
<li><a href="https://github.com/devxoul/Then">devxoul/Then</a></li>
<li><a href="http://swifter.tips/lazy/">lazy 修饰符和 lazy 方法</a></li>
</ul>

    </div>
    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>
        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="/posts/2017/swift_selector/">
                <span class="button__icon">←</span>
                <span class="button__text">Swift 中的 Selector</span>
              </a>
            </span>
          
          
            <span class="button next">
              <a href="/posts/2015/depr_gitgithub-notes/">
                <span class="button__text">Git/GitHub－Note</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    

    

    
    
    <div>
      <div id="github-comment">
      </div>

      <script type="text/javascript">
        function getUtterances(isDark) {
          var utterances = document.createElement('script');
          utterances.type = 'text/javascript';
          utterances.async = true;
          utterances.setAttribute('issue-term', "pathname")
          utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
          utterances.setAttribute('label', "comments")
          isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
          utterances.crossorigin = 'anonymous';
          utterances.src = 'https://utteranc.es/client.js';

          return utterances
        }

        var themeToggle = document.querySelector(".theme-toggle")
        themeToggle.addEventListener("click", function () {
          var getTheme = window.localStorage && window.localStorage.getItem("theme")
          var divNode = document.getElementById('github-comment')
          while(divNode.hasChildNodes()) {
            divNode.removeChild(divNode.firstChild);
          }
          
          
          

          
          
          
          
          
          
          document.getElementById('github-comment').appendChild(getUtterances(getTheme !== "dark"))
        })

        var getTheme = window.localStorage && window.localStorage.getItem("theme")
        document.getElementById('github-comment').appendChild(getUtterances(getTheme === "dark"))
      </script>
    </div>
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">Powered by github.com/kingcos</div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </body>
</html>
