<!DOCTYPE html>
<html lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="kingcos" />
	
	
	
	<title>Swift 拾遗 - 属性 ｜ kingcos</title>
	
    
    
    <meta name="description" content="《Swift 拾遗》是一个关于 Swift 的新文章专辑，这个系列的文章将不会涉及基本语法的层面，而是尝试从底层「拾」起之前所忽视的内容。今天我们将一起简单探究 Swift 中的属性。" />
    

    
    
    <meta name="keywords" content="Hugo, theme, zozo" />
    

	
    
    <link rel="shortcut icon" href="https://kingcos.me/images/favicon.png" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/highlight.css" />

    
    
</head>

<script data-ad-client="ca-pub-9925978992661955" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<body>
    <div class="main animate__animated animate__fadeInDown">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/posts/">Archive</a>
            </li>
            
            <li>
                <a href="/tags/">Tags</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>


<link rel="stylesheet" href="https://kingcos.me/scss/main.min.75b49085bfb07b1bf150a1d59b4773d857e0452a747e37243805218b528a4045.css" integrity="sha256-dbSQhb&#43;wexvxUKHVm0dz2FfgRSp0fjckOAUhi1KKQEU=" media="screen">

<style>
.nav_container {
  height: 1rem;
}
 
table {
    width: 100%;
    table-layout: fixed;
}

 
.markdown code {
    white-space: normal;
    word-wrap: break-word;
    word-break: break-word;
    line-height: 1.5em;
    font-size: 0.85em;
    font-weight: bold;
    display: inline-block;
     
}

 
.menu_icon a {
    font-size: 16px;
}

 
body {
    font-family: 'Hiragino Sans GB', 'SFMono', 'Lato', '-apple-system';
    -webkit-font-smoothing: 'antialiased';
}

 
.markdown strong, .markdown b, .markdown em {
    font-weight: bold;
}

.post .post_content p {
     

    line-height: 1.75em;
}

 
.markdown img {
    max-width: 100%;
    margin: 0 auto;
    display: block;
    border-radius: 0.25rem;
}

 
.ri-stack-line {
    vertical-align: middle;
}

 
.ri-map-pin-time-line {
    vertical-align: middle;
}

 
.chroma .lntd:nth-child(2) {
    width: 100%;
}

 

 
.markdown .book-hint::before {
    content: none;
}

.markdown .book-hint {
    margin: 1rem 0;
    padding: 0.5rem 1rem 0.5rem 0.75rem;

    border-inline-start: 0.25rem solid #e9ecef;
    border-radius: 0.25rem;

    font-style: normal;
     
}

.book-hint strong {
    background-color: transparent;
}

.markdown .book-hint.info {
    border-left-color:#6bf;
    background-color:rgba(102,187,255,.1);
}

.markdown .book-hint.warning {
    border-left-color:#fd6;
    background-color:rgba(255,221,102,.1);
}

.markdown .book-hint.danger {
    border-left-color:#f66;
    background-color:rgba(255,102,102,.1);
}

</style>

        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            
                <a href="https://kingcos.me/">
                    
                    <img class="kingcos" style="margin-top: -20px; margin-left: -10px;" src="/title.svg" width="150px">
                </a>
            
        </div>
        <div class="description">
            <p class="sub_title">专注、坚持</p>
            <div class="my_socials">
                
                
                <a href="https://github.com/kingcos" title="github" target="_blank"><i class="ri-github-fill"></i></a>
                
                
                
                <a href="https://www.instagram.com/kingcos_v/" title="instagram" target="_blank"><i class="ri-instagram-fill"></i></a>
                
                
                
                <a href="https://twitter.com/kingcos_v" title="twitter" target="_blank"><i class="ri-twitter-fill"></i></a>
                
                
                
                <a href="https://weibo.com/u/1798410923" title="weibo" target="_blank"><i class="ri-weibo-fill"></i></a>
                
                
                
            </div>
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/posts/2016/swift_properties/'>Swift 拾遗 - 属性</a></h2>
                        <span class="date">2020.09.18</span>
                        <span>by kingcos</span>
                        
                        
                        
                        
                    </div>
                    <div class="post_content markdown"><table>
<thead>
<tr>
<th style="text-align:center">Date</th>
<th style="text-align:center">Notes</th>
<th style="text-align:center">Info</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2020-09-18</td>
<td style="text-align:center">纳入 Swift 拾遗系列，并重新整理完善</td>
<td style="text-align:center">Swift 5.3, Xcode 12.0</td>
</tr>
<tr>
<td style="text-align:center">2017-04-27</td>
<td style="text-align:center">扩充「延迟存储属性」部分并新增「devxoul/Then」一节</td>
<td style="text-align:center">Swift 3.1, Xcode 8.3.2</td>
</tr>
<tr>
<td style="text-align:center">2016-10-26</td>
<td style="text-align:center">首次提交</td>
<td style="text-align:center">Swift 3.0, Xcode 8.1 Beta 3</td>
</tr>
</tbody>
</table>
<h2 id="preface">Preface</h2>
<p>《Swift 拾遗》是一个关于 Swift 的新文章专辑，这个系列的文章将不会涉及基本语法的层面，而是尝试从底层「拾」起之前所忽视的内容。今天我们将一起简单探究 Swift 中的属性。</p>
<h2 id="存储属性与计算属性">存储属性与计算属性</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">bar</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">var</span> <span class="nv">baz</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="n">bar</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="p">}</span>

        <span class="kr">set</span> <span class="p">{</span>
            <span class="n">bar</span> <span class="p">=</span> <span class="n">newValue</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nv">customSetParamBaz</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="n">bar</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="p">}</span>

        <span class="kr">set</span><span class="p">(</span><span class="n">customNewValue</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">bar</span> <span class="p">=</span> <span class="n">customNewValue</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">foo</span> <span class="p">=</span> <span class="n">Foo</span><span class="p">(</span><span class="n">bar</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>

<span class="kc">_</span> <span class="p">=</span> <span class="n">foo</span><span class="p">.</span><span class="n">bar</span> <span class="c1">// 10</span>
<span class="kc">_</span> <span class="p">=</span> <span class="n">foo</span><span class="p">.</span><span class="n">baz</span> <span class="c1">// 20  // BREAKPOINT 🔴</span>

<span class="n">foo</span><span class="p">.</span><span class="n">baz</span> <span class="p">=</span> <span class="mi">100</span>

<span class="kc">_</span> <span class="p">=</span> <span class="n">foo</span><span class="p">.</span><span class="n">baz</span> <span class="c1">// 100</span>
<span class="kc">_</span> <span class="p">=</span> <span class="n">foo</span><span class="p">.</span><span class="n">bar</span> <span class="c1">// 50</span>
</code></pre></div><p>如上，<code>bar</code> 为存储属性，即将占用实例对象的内存空间；而 <code>baz</code> 为计算属性，将通过其它变量得出，当外界取值时将得到调用 <code>get</code> 中的返回，设置时将通过 <code>set</code> 中 <code>newValue</code> 将外界的值传递进入并进行一定的计算。那么计算属性是否会占用实例对象的内存空间呢？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="bp">print</span><span class="p">(</span><span class="n">MemoryLayout</span><span class="p">&lt;</span><span class="n">Foo</span><span class="p">&gt;.</span><span class="n">size</span><span class="p">)</span>   <span class="c1">// 8</span>
<span class="bp">print</span><span class="p">(</span><span class="n">MemoryLayout</span><span class="p">&lt;</span><span class="n">Foo</span><span class="p">&gt;.</span><span class="bp">stride</span><span class="p">)</span> <span class="c1">// 8</span>
</code></pre></div><p>我们也可以运行代码，并在断点处以汇编代码分析：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="err">-&gt;</span>  <span class="err">0</span><span class="nf">x1000027a1</span> <span class="err">&lt;+</span><span class="mi">113</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x1000027a4</span> <span class="err">&lt;+</span><span class="mi">116</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">leaq</span>   <span class="p">-</span><span class="mi">0x38</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rsi</span>
    <span class="err">0</span><span class="nf">x1000027a8</span> <span class="err">&lt;+</span><span class="mi">120</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movl</span>   <span class="no">$0x20</span><span class="p">,</span> <span class="nv">%edx</span>
    <span class="err">0</span><span class="nf">x1000027ad</span> <span class="err">&lt;+</span><span class="mi">125</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x100003b92</span>               <span class="c">; symbol stub for: swift_beginAccess
</span><span class="c"></span>    <span class="mi">0x1000027b2</span> <span class="err">&lt;+</span><span class="mi">130</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="mi">0x59bf</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rdi</span>        <span class="c">; demo.foo : demo.Foo
</span><span class="c"></span>    <span class="c">; 将调用计算属性的 getter
</span><span class="c"></span>    <span class="mi">0x1000027b9</span> <span class="err">&lt;+</span><span class="mi">137</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x1000028c0</span>               <span class="c">; demo.Foo.baz.getter : Swift.Int at main.swift:6
</span><span class="c"></span>    <span class="mi">0x1000027be</span> <span class="err">&lt;+</span><span class="mi">142</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">leaq</span>   <span class="p">-</span><span class="mi">0x38</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x1000027c2</span> <span class="err">&lt;+</span><span class="mi">146</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="p">-</span><span class="mi">0xa0</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x1000027c9</span> <span class="err">&lt;+</span><span class="mi">153</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x100003b98</span>               <span class="c">; symbol stub for: swift_endAccess
</span><span class="c"></span>    <span class="mi">0x1000027ce</span> <span class="err">&lt;+</span><span class="mi">158</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">leaq</span>   <span class="mi">0x59a3</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rax</span>        <span class="c">; demo.foo : demo.Foo
</span><span class="c"></span>    <span class="mi">0x1000027d5</span> <span class="err">&lt;+</span><span class="mi">165</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">xorl</span>   <span class="nv">%r8d</span><span class="p">,</span> <span class="nv">%r8d</span>
    <span class="err">0</span><span class="nf">x1000027d8</span> <span class="err">&lt;+</span><span class="mi">168</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movl</span>   <span class="nv">%r8d</span><span class="p">,</span> <span class="nv">%ecx</span>
    <span class="err">0</span><span class="nf">x1000027db</span> <span class="err">&lt;+</span><span class="mi">171</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x1000027de</span> <span class="err">&lt;+</span><span class="mi">174</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">leaq</span>   <span class="p">-</span><span class="mi">0x50</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rsi</span>
    <span class="err">0</span><span class="nf">x1000027e2</span> <span class="err">&lt;+</span><span class="mi">178</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movl</span>   <span class="no">$0x21</span><span class="p">,</span> <span class="nv">%edx</span>
    <span class="err">0</span><span class="nf">x1000027e7</span> <span class="err">&lt;+</span><span class="mi">183</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x100003b92</span>               <span class="c">; symbol stub for: swift_beginAccess
</span><span class="c"></span>    <span class="mi">0x1000027ec</span> <span class="err">&lt;+</span><span class="mi">188</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movl</span>   <span class="no">$0x64</span><span class="p">,</span> <span class="nv">%edi</span>
    <span class="err">0</span><span class="nf">x1000027f1</span> <span class="err">&lt;+</span><span class="mi">193</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">leaq</span>   <span class="mi">0x5980</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%r13</span>        <span class="c">; demo.foo : demo.Foo
</span><span class="c"></span>    <span class="c">; 将调用计算属性的 setter
</span><span class="c"></span>    <span class="mi">0x1000027f8</span> <span class="err">&lt;+</span><span class="mi">200</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x100002960</span>               <span class="c">; demo.Foo.baz.setter : Swift.Int at main.swift:10
</span><span class="c"></span>    <span class="mi">0x1000027fd</span> <span class="err">&lt;+</span><span class="mi">205</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">leaq</span>   <span class="p">-</span><span class="mi">0x50</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x100002801</span> <span class="err">&lt;+</span><span class="mi">209</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x100003b98</span>               <span class="c">; symbol stub for: swift_endAccess
</span></code></pre></div><p>如上，计算属性将不会产生实际的变量，外界的使用将通过 <code>get</code> 和 <code>set</code> 中所生成的 <code>getter</code> 和 <code>setter</code> 方法访问或设置，因此也就不会占用实例对象的内存空间。</p>
<p>计算属性也支持只读（Read-only），只需要不实现 <code>set</code> 即可，此时也可省略显式的 <code>get</code> 关键字：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">bar</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span>

    <span class="kd">var</span> <span class="nv">readonlyBaz1</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="n">bar</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nv">readonlyBaz2</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="n">bar</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">foo</span> <span class="p">=</span> <span class="n">Foo</span><span class="p">()</span>

<span class="c1">// ERROR: Cannot assign to property: &#39;readonlyBaz1&#39; is a get-only property</span>
<span class="n">foo</span><span class="p">.</span><span class="n">readonlyBaz1</span> <span class="p">=</span> <span class="mi">10</span>
<span class="c1">// ERROR: Cannot assign to property: &#39;readonlyBaz2&#39; is a get-only property</span>
<span class="n">foo</span><span class="p">.</span><span class="n">readonlyBaz2</span> <span class="p">=</span> <span class="mi">10</span>
</code></pre></div><p>属性（存储属性与计算属性）也支持为 <code>get</code> 和 <code>set</code> 设置不同的访问控制级别：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">bar</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span>

    <span class="kd">internal</span> <span class="kd">private</span><span class="p">(</span><span class="kr">set</span><span class="p">)</span> <span class="kd">var</span> <span class="nv">privateSetBaz3</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="n">bar</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="p">}</span>

        <span class="kr">set</span> <span class="p">{</span>
            <span class="n">bar</span> <span class="p">=</span> <span class="n">newValue</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">private</span><span class="p">(</span><span class="kr">set</span><span class="p">)</span> <span class="kd">var</span> <span class="nv">privateSetBaz4</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="n">bar</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="p">}</span>

        <span class="kr">set</span> <span class="p">{</span>
            <span class="n">bar</span> <span class="p">=</span> <span class="n">newValue</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">innerFunc</span><span class="p">()</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">privateSetBaz3</span> <span class="p">=</span> <span class="mi">10</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">privateSetBaz4</span> <span class="p">=</span> <span class="mi">10</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">foo</span> <span class="p">=</span> <span class="n">Foo</span><span class="p">()</span>

<span class="n">foo</span><span class="p">.</span><span class="n">innerFunc</span><span class="p">()</span>

<span class="c1">// ERROR: Cannot assign to property: &#39;privateSetBaz3&#39; setter is inaccessible</span>
<span class="n">foo</span><span class="p">.</span><span class="n">privateSetBaz3</span> <span class="p">=</span> <span class="mi">10</span>
<span class="c1">// ERROR: Cannot assign to property: &#39;privateSetBaz4&#39; setter is inaccessible</span>
<span class="n">foo</span><span class="p">.</span><span class="n">privateSetBaz4</span> <span class="p">=</span> <span class="mi">10</span>
</code></pre></div><p>那么计算属性有何使用场景呢？其实当定义的属性依赖于其它属性时，就可以使用计算属性。枚举中的原始值 <code>rawValue</code> 就是通过只读计算属性实现的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">enum</span> <span class="nc">Foo</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">bar</span> <span class="p">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">baz</span>
<span class="p">}</span>

<span class="kc">_</span> <span class="p">=</span> <span class="n">Foo</span><span class="p">.</span><span class="n">bar</span><span class="p">.</span><span class="n">rawValue</span> <span class="c1">// 0 // BREAKPOINT 🔴</span>
</code></pre></div><p>尝试运行后在断点处查看汇编：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">demo</span><span class="err">`</span><span class="no">main</span><span class="p">:</span>
    <span class="err">0</span><span class="nf">x100002500</span> <span class="err">&lt;+</span><span class="mi">0</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">pushq</span>  <span class="nv">%rbp</span>
    <span class="err">0</span><span class="nf">x100002501</span> <span class="err">&lt;+</span><span class="mi">1</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rsp</span><span class="p">,</span> <span class="nv">%rbp</span>
    <span class="err">0</span><span class="nf">x100002504</span> <span class="err">&lt;+</span><span class="mi">4</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">subq</span>   <span class="no">$0x20</span><span class="p">,</span> <span class="nv">%rsp</span>
    <span class="err">0</span><span class="nf">x100002508</span> <span class="err">&lt;+</span><span class="mi">8</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">xorl</span>   <span class="nv">%eax</span><span class="p">,</span> <span class="nv">%eax</span>
    <span class="err">0</span><span class="nf">x10000250a</span> <span class="err">&lt;+</span><span class="mi">10</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movl</span>   <span class="nv">%edi</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x4</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
<span class="err">-&gt;</span>  <span class="err">0</span><span class="nf">x10000250d</span> <span class="err">&lt;+</span><span class="mi">13</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movl</span>   <span class="nv">%eax</span><span class="p">,</span> <span class="nv">%edi</span>
    <span class="err">0</span><span class="nf">x10000250f</span> <span class="err">&lt;+</span><span class="mi">15</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%rsi</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x10</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="c">; 将调用计算属性的 getter
</span><span class="c"></span>    <span class="err">0</span><span class="nf">x100002513</span> <span class="err">&lt;+</span><span class="mi">19</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x1000025a0</span>               <span class="c">; demo.Foo.rawValue.getter : Swift.Int at &lt;compiler-generated&gt;
</span><span class="c"></span>    <span class="mi">0x100002518</span> <span class="err">&lt;+</span><span class="mi">24</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">xorl</span>   <span class="nv">%ecx</span><span class="p">,</span> <span class="nv">%ecx</span>
    <span class="err">0</span><span class="nf">x10000251a</span> <span class="err">&lt;+</span><span class="mi">26</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x18</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x10000251e</span> <span class="err">&lt;+</span><span class="mi">30</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movl</span>   <span class="nv">%ecx</span><span class="p">,</span> <span class="nv">%eax</span>
    <span class="err">0</span><span class="nf">x100002520</span> <span class="err">&lt;+</span><span class="mi">32</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">addq</span>   <span class="no">$0x20</span><span class="p">,</span> <span class="nv">%rsp</span>
    <span class="err">0</span><span class="nf">x100002524</span> <span class="err">&lt;+</span><span class="mi">36</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">popq</span>   <span class="nv">%rbp</span>
    <span class="err">0</span><span class="nf">x100002525</span> <span class="err">&lt;+</span><span class="mi">37</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">retq</span>
</code></pre></div><h2 id="延迟存储属性">延迟存储属性</h2>
<p>延迟存储属性是指该属性的初始化过程将延迟到首次使用时，而非跟随实例的创建而创建。当属性未被使用时，将避免消耗不必要的性能。延迟存储属性使用 <code>lazy</code> 关键字修饰：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kr">lazy</span> <span class="kd">var</span> <span class="nv">bar</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&#34;bar will init&#34;</span><span class="p">)</span>

        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}()</span>

    <span class="kd">var</span> <span class="nv">baz</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&#34;baz will init&#34;</span><span class="p">)</span>

        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}()</span>
<span class="p">}</span>

<span class="kc">_</span> <span class="p">=</span> <span class="n">Foo</span><span class="p">()</span>

<span class="c1">// baz will init</span>
</code></pre></div><p>如上，当构造 <code>Foo</code> 实例对象时，延迟存储属性将暂时不初始化。另外，延迟存储属性需要有几个注意点：首先，延迟存储属性必须使用 <code>var</code> 修饰，而不可使用 <code>let</code> 修饰。这是因为 <code>let</code> 常量一旦创建后就不能再改变，而延迟存储属性会在使用时再初始化将与此相悖；其次，结构体类型中若存在延迟存储属性，那么使用 <code>let</code> 声明的结构体常量将无法访问延迟存储属性，原因其实同理，在首次访问时将执行延迟存储属性的初始化，将会导致常量内存空间改变，也与常量本身的概念相悖；但 <code>class</code> 类型的变量由于本质是引用类型，即使堆空间的内存空间改变，也不会导致指针指向的内存空间地址改变，因此 <code>class</code> 类型的常量仍可以访问延迟存储属性：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="nc">FooClass</span> <span class="p">{</span>
    <span class="kr">lazy</span> <span class="kd">var</span> <span class="nv">a</span> <span class="p">=</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="nc">FooStruct</span> <span class="p">{</span>
    <span class="kr">lazy</span> <span class="kd">var</span> <span class="nv">a</span> <span class="p">=</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">fc</span> <span class="p">=</span> <span class="n">FooClass</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">fc</span><span class="p">.</span><span class="n">a</span><span class="p">)</span>

<span class="kd">let</span> <span class="nv">fs</span> <span class="p">=</span> <span class="n">FooStruct</span><span class="p">()</span>
<span class="c1">// ERROR: Cannot use mutating getter on immutable value: &#39;fs&#39; is a &#39;let&#39; constant</span>
<span class="bp">print</span><span class="p">(</span><span class="n">fs</span><span class="p">.</span><span class="n">a</span><span class="p">)</span>
</code></pre></div><p>还需要注意的是，延迟存储属性是线程<strong>不</strong>安全的，即有可能在多线程中被多次初始化：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">import</span> <span class="nc">Foundation</span>

<span class="kd">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kr">lazy</span> <span class="kd">var</span> <span class="nv">bar</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&#34;bar will init&#34;</span><span class="p">)</span>

        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}()</span>

     <span class="kd">var</span> <span class="nv">baz</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&#34;baz will init&#34;</span><span class="p">)</span>

        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}()</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">foo</span> <span class="p">=</span> <span class="n">Foo</span><span class="p">()</span>

<span class="kd">var</span> <span class="nv">array</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]()</span>

<span class="n">DispatchQueue</span><span class="p">.</span><span class="n">concurrentPerform</span><span class="p">(</span><span class="n">iterations</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;--- </span><span class="si">\(</span><span class="n">Thread</span><span class="p">.</span><span class="n">current</span><span class="si">)</span><span class="s"> ---&#34;</span><span class="p">)</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">bar</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// baz will init</span>
<span class="c1">// --- &lt;NSThread: 0x100611a40&gt;{number = 3, name = (null)} ---</span>
<span class="c1">// --- &lt;NSThread: 0x1029197f0&gt;{number = 2, name = (null)} ---</span>
<span class="c1">// --- &lt;NSThread: 0x10050c580&gt;{number = 1, name = main} ---</span>
<span class="c1">// bar will init</span>
<span class="c1">// bar will init</span>
<span class="c1">// 1</span>
<span class="c1">// 1</span>
<span class="c1">// bar will init</span>
<span class="c1">// 1</span>
</code></pre></div><p>如上，我们使用 GCD 的并发执行 API <code>concurrentPerform</code> 执行三次，如果延迟存储属性是线程安全的，那么将只会进入其构造方法一次，但此时其实输出了三句 <code>bar will init</code>。</p>
<blockquote>
<p><strong><code>lazy</code> 方法</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">doubled</span> <span class="p">=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">.&lt;</span><span class="mi">3</span><span class="p">).</span><span class="bp">map</span> <span class="p">{</span> <span class="n">i</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="k">in</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;mapping&#34;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">lazyDoubled</span> <span class="p">=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">.&lt;</span><span class="mi">3</span><span class="p">).</span><span class="kr">lazy</span><span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="n">i</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="k">in</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;lazy mapping&#34;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="c1">// mapping</span>
<span class="c1">// mapping</span>
<span class="c1">// mapping</span>

<span class="n">lazyDoubled</span><span class="p">.</span><span class="n">forEach</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// lazy mapping</span>
<span class="c1">// 0</span>
<span class="c1">// lazy mapping</span>
<span class="c1">// 2</span>
<span class="c1">// lazy mapping</span>
<span class="c1">// 4</span>
</code></pre></div><p>在 Swift 标准库中也有一些内置的 <code>lazy</code> 方法，它们的执行时机也将推迟到实际使用该方法返回值的时刻。</p>
</blockquote>
<h2 id="属性观察器">属性观察器</h2>
<p>在 Swift 中，我们还可以对非延迟存储属性添加属性观察器，以便在值发生改变之前和之后进行一些操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">bar</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="kr">willSet</span> <span class="p">{</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">bar</span><span class="si">)</span><span class="s"> will set to </span><span class="si">\(</span><span class="n">newValue</span><span class="si">)</span><span class="s">&#34;</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="kr">didSet</span> <span class="p">{</span>
            <span class="c1">// oldValue 会在 willSet 进行保存</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">oldValue</span><span class="si">)</span><span class="s"> did set to </span><span class="si">\(</span><span class="n">bar</span><span class="si">)</span><span class="s">&#34;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nv">customValueParamsBar</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="kr">willSet</span><span class="p">(</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">customValueParamsBar</span><span class="si">)</span><span class="s"> will set </span><span class="si">\(</span><span class="n">new</span><span class="si">)</span><span class="s">&#34;</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="kr">didSet</span><span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="p">{</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">old</span><span class="si">)</span><span class="s"> did set to </span><span class="si">\(</span><span class="n">customValueParamsBar</span><span class="si">)</span><span class="s">&#34;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">foo</span> <span class="p">=</span> <span class="n">Foo</span><span class="p">(</span><span class="n">bar</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">foo</span><span class="p">.</span><span class="n">bar</span> <span class="p">=</span> <span class="mi">20</span> <span class="c1">// BREAKPOINT 🔴</span>

<span class="c1">// 10 will set to 20</span>
<span class="c1">// 10 did set to 20</span>
</code></pre></div><p>如上，在值被真正改变之前，将先通过 <code>willSet</code> 方法，新值将默认可以通过 <code>newValue</code> 变量访问，此时因为尚未执行赋值，因此旧值即可通过变量本身 <code>bar</code> 访问；设置后同理可通过 <code>didSet</code> 方法，此时旧值将默认可以通过 <code>oldValue</code> 变量访问，新值则可直接通过变量本身 <code>bar</code> 访问。</p>
<p>尝试运行后在断点处查看汇编：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="err">-&gt;</span>  <span class="err">0</span><span class="nf">x100001c2e</span> <span class="err">&lt;+</span><span class="mi">62</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rcx</span><span class="p">,</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x100001c31</span> <span class="err">&lt;+</span><span class="mi">65</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">leaq</span>   <span class="p">-</span><span class="mi">0x20</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rax</span>
    <span class="err">0</span><span class="nf">x100001c35</span> <span class="err">&lt;+</span><span class="mi">69</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rsi</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x38</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x100001c39</span> <span class="err">&lt;+</span><span class="mi">73</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rsi</span>
    <span class="err">0</span><span class="nf">x100001c3c</span> <span class="err">&lt;+</span><span class="mi">76</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movl</span>   <span class="no">$0x21</span><span class="p">,</span> <span class="nv">%edx</span>
    <span class="err">0</span><span class="nf">x100001c41</span> <span class="err">&lt;+</span><span class="mi">81</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="p">-</span><span class="mi">0x38</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rcx</span>
    <span class="err">0</span><span class="nf">x100001c45</span> <span class="err">&lt;+</span><span class="mi">85</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">callq</span>  <span class="mi">0x100003bc0</span>               <span class="c">; symbol stub for: swift_beginAccess
</span><span class="c"></span>    <span class="mi">0x100001c4a</span> <span class="err">&lt;+</span><span class="mi">90</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movl</span>   <span class="no">$0x14</span><span class="p">,</span> <span class="nv">%edi</span>
    <span class="err">0</span><span class="nf">x100001c4f</span> <span class="err">&lt;+</span><span class="mi">95</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">leaq</span>   <span class="mi">0x655a</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%r13</span>        <span class="c">; demo.foo : demo.Foo
</span><span class="c"></span>    <span class="c">; 将调用 setter
</span><span class="c"></span>    <span class="mi">0x100001c56</span> <span class="err">&lt;+</span><span class="mi">102</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x100001cb0</span>               <span class="c">; demo.Foo.bar.setter : Swift.Int at main.swift:4
</span><span class="c"></span>    <span class="mi">0x100001c5b</span> <span class="err">&lt;+</span><span class="mi">107</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">leaq</span>   <span class="p">-</span><span class="mi">0x20</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x100001c5f</span> <span class="err">&lt;+</span><span class="mi">111</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x100003bd2</span>               <span class="c">; symbol stub for: swift_endAccess
</span><span class="c"></span>
<span class="nf">demo</span><span class="err">`</span><span class="no">Foo.bar.setter</span><span class="p">:</span>
<span class="err">-&gt;</span>  <span class="err">0</span><span class="nf">x100001cb0</span> <span class="err">&lt;+</span><span class="mi">0</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">pushq</span>  <span class="nv">%rbp</span>
    <span class="err">0</span><span class="nf">x100001cb1</span> <span class="err">&lt;+</span><span class="mi">1</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rsp</span><span class="p">,</span> <span class="nv">%rbp</span>
    <span class="err">0</span><span class="nf">x100001cb4</span> <span class="err">&lt;+</span><span class="mi">4</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">pushq</span>  <span class="nv">%r13</span>
    <span class="err">0</span><span class="nf">x100001cb6</span> <span class="err">&lt;+</span><span class="mi">6</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">subq</span>   <span class="no">$0x38</span><span class="p">,</span> <span class="nv">%rsp</span>
    <span class="err">0</span><span class="nf">x100001cba</span> <span class="err">&lt;+</span><span class="mi">10</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="no">$0x0</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x10</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x100001cc2</span> <span class="err">&lt;+</span><span class="mi">18</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="no">$0x0</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x18</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x100001cca</span> <span class="err">&lt;+</span><span class="mi">26</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="no">$0x0</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x20</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x100001cd2</span> <span class="err">&lt;+</span><span class="mi">34</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%rdi</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x10</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x100001cd6</span> <span class="err">&lt;+</span><span class="mi">38</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%r13</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x18</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x100001cda</span> <span class="err">&lt;+</span><span class="mi">42</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="p">(</span><span class="nv">%r13</span><span class="p">),</span> <span class="nv">%rax</span>
    <span class="err">0</span><span class="nf">x100001cde</span> <span class="err">&lt;+</span><span class="mi">46</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x20</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x100001ce2</span> <span class="err">&lt;+</span><span class="mi">50</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%rdi</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x28</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x100001ce6</span> <span class="err">&lt;+</span><span class="mi">54</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%r13</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x30</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x100001cea</span> <span class="err">&lt;+</span><span class="mi">58</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x38</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="c">; 将调用 willset
</span><span class="c"></span>    <span class="err">0</span><span class="nf">x100001cee</span> <span class="err">&lt;+</span><span class="mi">62</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x100001d20</span>               <span class="c">; demo.Foo.bar.willset : Swift.Int at main.swift:5
</span><span class="c"></span>    <span class="mi">0x100001cf3</span> <span class="err">&lt;+</span><span class="mi">67</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="p">-</span><span class="mi">0x30</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rax</span>
    <span class="err">0</span><span class="nf">x100001cf7</span> <span class="err">&lt;+</span><span class="mi">71</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="p">-</span><span class="mi">0x28</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rcx</span>
    <span class="err">0</span><span class="nf">x100001cfb</span> <span class="err">&lt;+</span><span class="mi">75</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%rcx</span><span class="p">,</span> <span class="p">(</span><span class="nv">%rax</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x100001cfe</span> <span class="err">&lt;+</span><span class="mi">78</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="p">-</span><span class="mi">0x38</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x100001d02</span> <span class="err">&lt;+</span><span class="mi">82</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%r13</span>
    <span class="c">; 将调用 didset
</span><span class="c"></span>    <span class="err">0</span><span class="nf">x100001d05</span> <span class="err">&lt;+</span><span class="mi">85</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x100001fd0</span>               <span class="c">; demo.Foo.bar.didset : Swift.Int at main.swift:9
</span><span class="c"></span>    <span class="mi">0x100001d0a</span> <span class="err">&lt;+</span><span class="mi">90</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">addq</span>   <span class="no">$0x38</span><span class="p">,</span> <span class="nv">%rsp</span>
    <span class="err">0</span><span class="nf">x100001d0e</span> <span class="err">&lt;+</span><span class="mi">94</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">popq</span>   <span class="nv">%r13</span>
    <span class="err">0</span><span class="nf">x100001d10</span> <span class="err">&lt;+</span><span class="mi">96</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">popq</span>   <span class="nv">%rbp</span>
    <span class="err">0</span><span class="nf">x100001d11</span> <span class="err">&lt;+</span><span class="mi">97</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">retq</span>
</code></pre></div><p>此时可以发现，即使我们改变的变量本质是存储属性，但编译器仍然为其生成了 <code>setter</code> 方法，并在该行执行 <code>si</code> 进入后可以发现，即 <code>setter</code> 方法中先调用了 <code>willSet</code>，并在随后调用了 <code>didSet</code>。</p>
<p>另外需要注意的是，初始化方法或在属性定义时给予的默认值时，将不会触发属性观察器；另外，在 <code>willSet</code> 中如果继续编写更改原有变量值的代码时，既不会再次触发属性观察器，但更改也不会生效，但在 <code>didSet</code> 中，虽然也不会再次触发属性观察器，但更改将会生效：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">bar</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="kr">willSet</span> <span class="p">{</span>
            <span class="c1">// WARNING: Attempting to store to property &#39;bar&#39; within its own willSet, which is about to be overwritten by the new value</span>
            <span class="n">bar</span> <span class="p">=</span> <span class="mi">1000</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">bar</span><span class="si">)</span><span class="s"> will set to </span><span class="si">\(</span><span class="n">newValue</span><span class="si">)</span><span class="s">&#34;</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="kr">didSet</span> <span class="p">{</span>
            <span class="n">bar</span> <span class="p">=</span> <span class="mi">2000</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">oldValue</span><span class="si">)</span><span class="s"> did set to </span><span class="si">\(</span><span class="n">bar</span><span class="si">)</span><span class="s">&#34;</span><span class="p">)</span>
            <span class="n">bar</span> <span class="p">=</span> <span class="mi">3000</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">foo</span> <span class="p">=</span> <span class="n">Foo</span><span class="p">(</span><span class="n">bar</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">foo</span><span class="p">.</span><span class="n">bar</span> <span class="p">=</span> <span class="mi">20</span>

<span class="bp">print</span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">bar</span><span class="p">)</span>

<span class="c1">// 10 will set to 20</span>
<span class="c1">// 10 did set to 2000</span>
<span class="c1">// 3000</span>
</code></pre></div><p>如上，虽然我们可以了解这一行为，但在属性观察器中再次进行赋值的操作本身就有些诡异，因此应当避免。</p>
<h2 id="计算属性属性观察器与-inout">计算属性、属性观察器与 inout</h2>
<p>在上面的示例中，我们通常直接通过实例对象对变量本身进行了更改，并触发了属性观察器，那么如果我们将它们传递给含有 <code>inout</code> 参数的方法并进行更改时，还会调用相应的 <code>willSet</code> 和 <code>didSet</code> 方法吗？</p>
<p>首先我们创建一个名为 <code>Foo</code> 的结构体类型，其中包含普通的存储属性、带有属性观察器的属性、和计算属性，并创建名为 <code>inoutFunc(_:)</code> 带有 <code>inout</code> 修饰参数的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="nc">Foo</span><span class="p">:</span> <span class="n">CustomStringConvertible</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">a</span> <span class="p">=</span> <span class="mi">1</span>

    <span class="kd">var</span> <span class="nv">b</span> <span class="p">=</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="kr">willSet</span> <span class="p">{</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&#34;b(</span><span class="si">\(</span><span class="n">b</span><span class="si">)</span><span class="s">) will set to </span><span class="si">\(</span><span class="n">newValue</span><span class="si">)</span><span class="s">&#34;</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="kr">didSet</span> <span class="p">{</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&#34;b(</span><span class="si">\(</span><span class="n">oldValue</span><span class="si">)</span><span class="s">) did set to </span><span class="si">\(</span><span class="n">b</span><span class="si">)</span><span class="s">&#34;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nv">c</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&#34;c get&#34;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">10</span>
        <span class="p">}</span>

        <span class="kr">set</span> <span class="p">{</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&#34;c set&#34;</span><span class="p">)</span>
            <span class="n">a</span> <span class="p">=</span> <span class="n">newValue</span> <span class="o">/</span> <span class="mi">10</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nv">description</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="s">&#34;a: </span><span class="si">\(</span><span class="n">a</span><span class="si">)</span><span class="s">, b: </span><span class="si">\(</span><span class="n">b</span><span class="si">)</span><span class="s">, c: </span><span class="si">\(</span><span class="n">c</span><span class="si">)</span><span class="s">&#34;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">inoutFunc</span><span class="p">(</span><span class="kc">_</span> <span class="n">param</span><span class="p">:</span> <span class="kr">inout</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">param</span> <span class="p">=</span> <span class="mi">100</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">foo</span> <span class="p">=</span> <span class="n">Foo</span><span class="p">()</span>

<span class="bp">print</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

<span class="c1">// c get</span>
<span class="c1">// a: 1, b: 1, c: 10</span>
</code></pre></div><p>首先我们尝试将不带属性观察器的变量传递到 <code>inoutFunc</code> 中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="n">inoutFunc</span><span class="p">(&amp;</span><span class="n">foo</span><span class="p">.</span><span class="n">a</span><span class="p">)</span> <span class="c1">// BREAKPOINT 🔴</span>

<span class="bp">print</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

<span class="c1">// c get</span>
<span class="c1">// a: 100, b: 1, c: 1000</span>
</code></pre></div><p>尝试运行后在断点处查看汇编：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="err">-&gt;</span>  <span class="err">0</span><span class="nf">x100001958</span> <span class="err">&lt;+</span><span class="mi">296</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x10000195b</span> <span class="err">&lt;+</span><span class="mi">299</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">leaq</span>   <span class="p">-</span><span class="mi">0x30</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rsi</span>
    <span class="err">0</span><span class="nf">x10000195f</span> <span class="err">&lt;+</span><span class="mi">303</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movl</span>   <span class="no">$0x21</span><span class="p">,</span> <span class="nv">%edx</span>
    <span class="err">0</span><span class="nf">x100001964</span> <span class="err">&lt;+</span><span class="mi">308</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x100003a3c</span>               <span class="c">; symbol stub for: swift_beginAccess
</span><span class="c"></span>    <span class="c">; 将 rip 寄存器中的地址值加上 0x6850（根据注释，该地址对应的内容为 demo.foo）并存储到 rdi 寄存器（函数第一个参数）中
</span><span class="c"></span>    <span class="mi">0x100001969</span> <span class="err">&lt;+</span><span class="mi">313</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">leaq</span>   <span class="mi">0x6850</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rdi</span>        <span class="c">; demo.foo : demo.Foo
</span><span class="c"></span>    <span class="mi">0x100001970</span> <span class="err">&lt;+</span><span class="mi">320</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x1000026f0</span>               <span class="c">; demo.inoutFunc(inout Swift.Int) -&gt; () at main.swift:33
</span></code></pre></div><p>由于结构体变量的首地址就等同于其中第一个声明的变量的地址，因此此时存储属性即按地址传递到 <code>inout</code> 修饰参数的方法中。那么带有属性观察器的存储属性呢？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// inoutFunc(&amp;foo.a)</span>

<span class="n">inoutFunc</span><span class="p">(&amp;</span><span class="n">foo</span><span class="p">.</span><span class="n">b</span><span class="p">)</span> <span class="c1">// BREAKPOINT 🔴</span>

<span class="bp">print</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

<span class="c1">// b(1) will set to 100</span>
<span class="c1">// b(1) did set to 100</span>
<span class="c1">// c get</span>
<span class="c1">// a: 1, b: 100, c: 10</span>
</code></pre></div><p>通过输出结果，我们可以看出属性观察器同样也被执行了。尝试运行后在断点处查看汇编：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="err">-&gt;</span>  <span class="err">0</span><span class="nf">x100001942</span> <span class="err">&lt;+</span><span class="mi">50</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rcx</span><span class="p">,</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x100001945</span> <span class="err">&lt;+</span><span class="mi">53</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">leaq</span>   <span class="p">-</span><span class="mi">0x20</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rax</span>
    <span class="err">0</span><span class="nf">x100001949</span> <span class="err">&lt;+</span><span class="mi">57</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rsi</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x58</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x10000194d</span> <span class="err">&lt;+</span><span class="mi">61</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rsi</span>
    <span class="err">0</span><span class="nf">x100001950</span> <span class="err">&lt;+</span><span class="mi">64</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movl</span>   <span class="no">$0x21</span><span class="p">,</span> <span class="nv">%edx</span>
    <span class="err">0</span><span class="nf">x100001955</span> <span class="err">&lt;+</span><span class="mi">69</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="p">-</span><span class="mi">0x58</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rcx</span>
    <span class="err">0</span><span class="nf">x100001959</span> <span class="err">&lt;+</span><span class="mi">73</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">callq</span>  <span class="mi">0x100003a2c</span>               <span class="c">; symbol stub for: swift_beginAccess
</span><span class="c"></span>    <span class="mi">0x10000195e</span> <span class="err">&lt;+</span><span class="mi">78</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="mi">0x6863</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rax</span>        <span class="c">; demo.foo : demo.Foo + 8
</span><span class="c"></span>    <span class="mi">0x100001965</span> <span class="err">&lt;+</span><span class="mi">85</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x28</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x100001969</span> <span class="err">&lt;+</span><span class="mi">89</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">leaq</span>   <span class="p">-</span><span class="mi">0x28</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x10000196d</span> <span class="err">&lt;+</span><span class="mi">93</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">callq</span>  <span class="mi">0x1000026e0</span>               <span class="c">; demo.inoutFunc(inout Swift.Int) -&gt; () at main.swift:33
</span><span class="c"></span>    <span class="mi">0x100001972</span> <span class="err">&lt;+</span><span class="mi">98</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="p">-</span><span class="mi">0x28</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x100001976</span> <span class="err">&lt;+</span><span class="mi">102</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">leaq</span>   <span class="mi">0x6843</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%r13</span>        <span class="c">; demo.foo : demo.Foo
</span><span class="c"></span>    <span class="c">; 将调用 setter
</span><span class="c"></span>    <span class="mi">0x10000197d</span> <span class="err">&lt;+</span><span class="mi">109</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x100001b30</span>               <span class="c">; demo.Foo.b.setter : Swift.Int at main.swift:6
</span></code></pre></div><p>与之前不同的是，当执行完 <code>inoutFunc</code> 后，<code>setter</code> 仍然得到了调用，但具体原因我们先继续看下计算属性。我们知道计算属性并不需要内存来存储结果，而其结果来自于其它属性的计算。因此即使 <code>inoutFunc</code> 也并不会获取到变量 <code>c</code> 的内存地址：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// inoutFunc(&amp;foo.a)</span>

<span class="c1">// inoutFunc(&amp;foo.b)</span>

<span class="n">inoutFunc</span><span class="p">(&amp;</span><span class="n">foo</span><span class="p">.</span><span class="n">c</span><span class="p">)</span> <span class="c1">// BREAKPOINT 🔴</span>

<span class="bp">print</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

<span class="c1">// c get</span>
<span class="c1">// c set</span>
<span class="c1">// c get</span>
<span class="c1">// a: 10, b: 1, c: 100</span>
</code></pre></div><p>尝试运行后在断点处查看汇编：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="err">-&gt;</span>  <span class="err">0</span><span class="nf">x100001932</span> <span class="err">&lt;+</span><span class="mi">50</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rcx</span><span class="p">,</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x100001935</span> <span class="err">&lt;+</span><span class="mi">53</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">leaq</span>   <span class="p">-</span><span class="mi">0x20</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rax</span>
    <span class="err">0</span><span class="nf">x100001939</span> <span class="err">&lt;+</span><span class="mi">57</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rsi</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x58</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x10000193d</span> <span class="err">&lt;+</span><span class="mi">61</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rsi</span>
    <span class="err">0</span><span class="nf">x100001940</span> <span class="err">&lt;+</span><span class="mi">64</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movl</span>   <span class="no">$0x21</span><span class="p">,</span> <span class="nv">%edx</span>
    <span class="err">0</span><span class="nf">x100001945</span> <span class="err">&lt;+</span><span class="mi">69</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="p">-</span><span class="mi">0x58</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rcx</span>
    <span class="err">0</span><span class="nf">x100001949</span> <span class="err">&lt;+</span><span class="mi">73</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">callq</span>  <span class="mi">0x100003a2c</span>               <span class="c">; symbol stub for: swift_beginAccess
</span><span class="c"></span>    <span class="mi">0x10000194e</span> <span class="err">&lt;+</span><span class="mi">78</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="mi">0x686b</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rdi</span>        <span class="c">; demo.foo : demo.Foo
</span><span class="c"></span>    <span class="mi">0x100001955</span> <span class="err">&lt;+</span><span class="mi">85</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="mi">0x686c</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rsi</span>        <span class="c">; demo.foo : demo.Foo + 8
</span><span class="c"></span>    <span class="c">; 将调用计算属性的 getter
</span><span class="c"></span>    <span class="mi">0x10000195c</span> <span class="err">&lt;+</span><span class="mi">92</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">callq</span>  <span class="mi">0x1000020d0</span>               <span class="c">; demo.Foo.c.getter : Swift.Int at main.swift:17
</span><span class="c"></span>    <span class="mi">0x100001961</span> <span class="err">&lt;+</span><span class="mi">97</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x28</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x100001965</span> <span class="err">&lt;+</span><span class="mi">101</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">leaq</span>   <span class="p">-</span><span class="mi">0x28</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rdi</span>
    <span class="c">; 将调用 inoutFunc
</span><span class="c"></span>    <span class="err">0</span><span class="nf">x100001969</span> <span class="err">&lt;+</span><span class="mi">105</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x1000026e0</span>               <span class="c">; demo.inoutFunc(inout Swift.Int) -&gt; () at main.swift:33
</span><span class="c"></span>    <span class="mi">0x10000196e</span> <span class="err">&lt;+</span><span class="mi">110</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="p">-</span><span class="mi">0x28</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x100001972</span> <span class="err">&lt;+</span><span class="mi">114</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">leaq</span>   <span class="mi">0x6847</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%r13</span>        <span class="c">; demo.foo : demo.Foo
</span><span class="c"></span>    <span class="c">; 将调用计算属性的 setter
</span><span class="c"></span>    <span class="mi">0x100001979</span> <span class="err">&lt;+</span><span class="mi">121</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x100002220</span>               <span class="c">; demo.Foo.c.setter : Swift.Int at main.swift:22
</span></code></pre></div><p>根据汇编，当遇到计算属性或带有存储属性观察器的存储属性时，将先通过 <code>getter</code> 将值拷贝到一个外界的局部变量上，再将该变量的地址传递到 <code>inoutFunc</code> 方法中，得到结果后外界变量将重新通过 <code>setter</code> 将值设置回原有的计算属性。因此属性观察器也是同理被触发的，而由于属性观察器只包含对设置值的不同时机的监听，因此看不到 <code>getter</code> 的过程。</p>
<h2 id="类型属性">类型属性</h2>
<p>类型属性指的是通过类型直接访问的属性。我们在结构体、类、枚举中均可以定义类型属性，通常使用 <code>static</code> 关键字；在类中，如果定义的类型属性是计算属性，那么也可以使用 <code>class</code> 关键字：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">foo</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Bar</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">bar1</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">static</span> <span class="kd">let</span> <span class="nv">bar2</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span>

    <span class="kd">class</span> <span class="nc">var</span> <span class="n">bar3</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="nc">Baz</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">baz</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">Foo</span><span class="p">.</span><span class="n">foo</span><span class="p">)</span>  <span class="c1">// 0</span>
<span class="bp">print</span><span class="p">(</span><span class="n">Bar</span><span class="p">.</span><span class="n">bar1</span><span class="p">)</span> <span class="c1">// 0</span>
<span class="bp">print</span><span class="p">(</span><span class="n">Bar</span><span class="p">.</span><span class="n">bar2</span><span class="p">)</span> <span class="c1">// 0</span>
<span class="bp">print</span><span class="p">(</span><span class="n">Bar</span><span class="p">.</span><span class="n">bar3</span><span class="p">)</span> <span class="c1">// 0</span>
<span class="bp">print</span><span class="p">(</span><span class="n">Baz</span><span class="p">.</span><span class="n">baz</span><span class="p">)</span>  <span class="c1">// 0</span>
</code></pre></div><p>类型属性其实类似于全局变量，即只会在内存中保存一份，且实际在内存中与全局变量存储在同一位置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">var</span> <span class="nv">foo</span> <span class="p">=</span> <span class="mi">10</span>

<span class="kd">class</span> <span class="nc">Bar</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">bar1</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">20</span>
<span class="p">}</span>

<span class="n">Bar</span><span class="p">.</span><span class="n">bar1</span> <span class="p">=</span> <span class="mi">21</span> <span class="c1">// BREAKPOINT 🔴</span>
<span class="n">Bar</span><span class="p">.</span><span class="n">bar1</span> <span class="p">=</span> <span class="mi">22</span>

<span class="kd">var</span> <span class="nv">baz</span> <span class="p">=</span> <span class="mi">30</span>
</code></pre></div><p>尝试运行后在断点处查看汇编：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">demo</span><span class="err">`</span><span class="no">main</span><span class="p">:</span>
    <span class="err">0</span><span class="nf">x100002940</span> <span class="err">&lt;+</span><span class="mi">0</span><span class="err">&gt;</span><span class="p">:</span>   <span class="no">pushq</span>  <span class="nv">%rbp</span>
    <span class="err">0</span><span class="nf">x100002941</span> <span class="err">&lt;+</span><span class="mi">1</span><span class="err">&gt;</span><span class="p">:</span>   <span class="no">movq</span>   <span class="nv">%rsp</span><span class="p">,</span> <span class="nv">%rbp</span>
    <span class="err">0</span><span class="nf">x100002944</span> <span class="err">&lt;+</span><span class="mi">4</span><span class="err">&gt;</span><span class="p">:</span>   <span class="no">subq</span>   <span class="no">$0x50</span><span class="p">,</span> <span class="nv">%rsp</span>
    <span class="c">; 全局变量 foo：移动立即数 10 到 rip + 0x5955（0x1000082A8）
</span><span class="c"></span>    <span class="err">0</span><span class="nf">x100002948</span> <span class="err">&lt;+</span><span class="mi">8</span><span class="err">&gt;</span><span class="p">:</span>   <span class="no">movq</span>   <span class="no">$0xa</span><span class="p">,</span> <span class="mi">0x5955</span><span class="p">(</span><span class="nv">%rip</span><span class="p">)</span>        <span class="c">; Swift51Overrides + 180
</span><span class="c"></span>    <span class="mi">0x100002953</span> <span class="err">&lt;+</span><span class="mi">19</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movl</span>   <span class="nv">%edi</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x34</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x100002956</span> <span class="err">&lt;+</span><span class="mi">22</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rsi</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x40</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x10000295a</span> <span class="err">&lt;+</span><span class="mi">26</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">callq</span>  <span class="mi">0x100002a20</span>               <span class="c">; demo.Bar.bar.unsafeMutableAddressor : Swift.Int at main.swift
</span><span class="c"></span>    <span class="mi">0x10000295f</span> <span class="err">&lt;+</span><span class="mi">31</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">xorl</span>   <span class="nv">%ecx</span><span class="p">,</span> <span class="nv">%ecx</span>
    <span class="err">0</span><span class="nf">x100002961</span> <span class="err">&lt;+</span><span class="mi">33</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rdx</span>
    <span class="err">0</span><span class="nf">x100002964</span> <span class="err">&lt;+</span><span class="mi">36</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rdx</span><span class="p">,</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x100002967</span> <span class="err">&lt;+</span><span class="mi">39</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">leaq</span>   <span class="p">-</span><span class="mi">0x18</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rsi</span>
    <span class="err">0</span><span class="nf">x10000296b</span> <span class="err">&lt;+</span><span class="mi">43</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movl</span>   <span class="no">$0x21</span><span class="p">,</span> <span class="nv">%edx</span>
    <span class="err">0</span><span class="nf">x100002970</span> <span class="err">&lt;+</span><span class="mi">48</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x48</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x100002974</span> <span class="err">&lt;+</span><span class="mi">52</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">callq</span>  <span class="mi">0x100003cd2</span>               <span class="c">; symbol stub for: swift_beginAccess
</span><span class="c"></span>    <span class="mi">0x100002979</span> <span class="err">&lt;+</span><span class="mi">57</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="p">-</span><span class="mi">0x48</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rax</span>
    <span class="c">; (lldb) register read rax =&gt; rax = 0x00000001000082b0  demo`static demo.Bar.bar : Swift.Int
</span><span class="c"></span>    <span class="c">; 类型属性 Bar.bar：移动立即数 21 到 rax 寄存器中地址对应的内存空间
</span><span class="c"></span><span class="err">-&gt;</span>  <span class="err">0</span><span class="nf">x10000297d</span> <span class="err">&lt;+</span><span class="mi">61</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="no">$0x15</span><span class="p">,</span> <span class="p">(</span><span class="nv">%rax</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x100002984</span> <span class="err">&lt;+</span><span class="mi">68</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">leaq</span>   <span class="p">-</span><span class="mi">0x18</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x100002988</span> <span class="err">&lt;+</span><span class="mi">72</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">callq</span>  <span class="mi">0x100003cde</span>               <span class="c">; symbol stub for: swift_endAccess
</span><span class="c"></span>    <span class="mi">0x10000298d</span> <span class="err">&lt;+</span><span class="mi">77</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">callq</span>  <span class="mi">0x100002a20</span>               <span class="c">; demo.Bar.bar.unsafeMutableAddressor : Swift.Int at main.swift
</span><span class="c"></span>    <span class="mi">0x100002992</span> <span class="err">&lt;+</span><span class="mi">82</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">xorl</span>   <span class="nv">%r8d</span><span class="p">,</span> <span class="nv">%r8d</span>
    <span class="err">0</span><span class="nf">x100002995</span> <span class="err">&lt;+</span><span class="mi">85</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movl</span>   <span class="nv">%r8d</span><span class="p">,</span> <span class="nv">%ecx</span>
    <span class="err">0</span><span class="nf">x100002998</span> <span class="err">&lt;+</span><span class="mi">88</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rdx</span>
    <span class="err">0</span><span class="nf">x10000299b</span> <span class="err">&lt;+</span><span class="mi">91</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rdx</span><span class="p">,</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x10000299e</span> <span class="err">&lt;+</span><span class="mi">94</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">leaq</span>   <span class="p">-</span><span class="mi">0x30</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rsi</span>
    <span class="err">0</span><span class="nf">x1000029a2</span> <span class="err">&lt;+</span><span class="mi">98</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movl</span>   <span class="no">$0x21</span><span class="p">,</span> <span class="nv">%edx</span>
    <span class="err">0</span><span class="nf">x1000029a7</span> <span class="err">&lt;+</span><span class="mi">103</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x50</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x1000029ab</span> <span class="err">&lt;+</span><span class="mi">107</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x100003cd2</span>               <span class="c">; symbol stub for: swift_beginAccess
</span><span class="c"></span>    <span class="mi">0x1000029b0</span> <span class="err">&lt;+</span><span class="mi">112</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="p">-</span><span class="mi">0x50</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rax</span>
    <span class="c">; (lldb) register read rax =&gt; rax = 0x00000001000082b0  demo`static demo.Bar.bar : Swift.Int
</span><span class="c"></span>    <span class="c">; 类型属性 Bar.bar：移动立即数 22 到 rax 寄存器中地址对应的内存空间
</span><span class="c"></span>    <span class="err">0</span><span class="nf">x1000029b4</span> <span class="err">&lt;+</span><span class="mi">116</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="no">$0x16</span><span class="p">,</span> <span class="p">(</span><span class="nv">%rax</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x1000029bb</span> <span class="err">&lt;+</span><span class="mi">123</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">leaq</span>   <span class="p">-</span><span class="mi">0x30</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x1000029bf</span> <span class="err">&lt;+</span><span class="mi">127</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x100003cde</span>               <span class="c">; symbol stub for: swift_endAccess
</span><span class="c"></span>    <span class="mi">0x1000029c4</span> <span class="err">&lt;+</span><span class="mi">132</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">xorl</span>   <span class="nv">%eax</span><span class="p">,</span> <span class="nv">%eax</span>
    <span class="c">; 全局变量 baz：移动立即数 30 到 rip + 0x58e7（0x1000082B8）
</span><span class="c"></span>    <span class="err">0</span><span class="nf">x1000029c6</span> <span class="err">&lt;+</span><span class="mi">134</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="no">$0x1e</span><span class="p">,</span> <span class="mi">0x58e7</span><span class="p">(</span><span class="nv">%rip</span><span class="p">)</span>       <span class="c">; static demo.Bar.bar : Swift.Int + 4
</span><span class="c"></span>    <span class="mi">0x1000029d1</span> <span class="err">&lt;+</span><span class="mi">145</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">addq</span>   <span class="no">$0x50</span><span class="p">,</span> <span class="nv">%rsp</span>
    <span class="err">0</span><span class="nf">x1000029d5</span> <span class="err">&lt;+</span><span class="mi">149</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">popq</span>   <span class="nv">%rbp</span>
    <span class="err">0</span><span class="nf">x1000029d6</span> <span class="err">&lt;+</span><span class="mi">150</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">retq</span>

<span class="c">; 全局变量 foo：0x1000082A8
</span><span class="c">; 类型属性 Bar.bar：0x00000001000082b0（foo：0x1000082B0）
</span><span class="c">; 全局变量 baz：0x1000082B8
</span></code></pre></div><p>如上，三个变量均是在内存中占用了连续的存储空间，也证明了类型属性本质也是存储在全局区，其在整个程序生命周期中只会有一份。只是类型属性定义类的内部，需要通过类名来访问，以及可以额外使用一些访问控制。</p>
<p>需要注意的是，由于类型属性非针对于某一实例对象，因此其必须在声明时即给定初始值；类型属性如果同时为存储属性，默认即为 <code>lazy</code> 延迟：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">foo</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span>

    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">calculateFoo</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&#34;calculateFoo init&#34;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}()</span>
<span class="p">}</span>

<span class="c1">// 0</span>
<span class="c1">// calculateFoo init</span>
</code></pre></div><p>但此时的延迟存储属性是线程安全的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">import</span> <span class="nc">Foundation</span>

<span class="kd">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">foo</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span>

    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">calculateFoo</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&#34;calculateFoo init&#34;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}()</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">Foo</span><span class="p">.</span><span class="n">foo</span><span class="p">)</span>

<span class="n">DispatchQueue</span><span class="p">.</span><span class="n">concurrentPerform</span><span class="p">(</span><span class="n">iterations</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;--- </span><span class="si">\(</span><span class="n">Thread</span><span class="p">.</span><span class="n">current</span><span class="si">)</span><span class="s"> ---&#34;</span><span class="p">)</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">Foo</span><span class="p">.</span><span class="n">calculateFoo</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 0</span>
<span class="c1">// --- &lt;NSThread: 0x1020be860&gt;{number = 4, name = (null)} ---</span>
<span class="c1">// calculateFoo init</span>
<span class="c1">// 0</span>
<span class="c1">// --- &lt;NSThread: 0x1007042d0&gt;{number = 3, name = (null)} ---</span>
<span class="c1">// 0</span>
<span class="c1">// --- &lt;NSThread: 0x1021040c0&gt;{number = 2, name = (null)} ---</span>
<span class="c1">// 0</span>
<span class="c1">// --- &lt;NSThread: 0x10200ab30&gt;{number = 1, name = main} ---</span>
<span class="c1">// 0</span>
<span class="c1">// --- &lt;NSThread: 0x1022040c0&gt;{number = 5, name = (null)} ---</span>
<span class="c1">// 0</span>
<span class="c1">// 0</span>
</code></pre></div><p>如上，即使同时 5 个线程并发访问，<code>calculateFoo</code> 也将被保证只初始化一次。那么如何证明其是线程安全的呢？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="nc">Bar</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">bar</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">20</span> <span class="c1">// BREAKPOINT 🔴</span>
<span class="p">}</span>

<span class="n">Bar</span><span class="p">.</span><span class="n">bar</span> <span class="p">=</span> <span class="mi">21</span> <span class="c1">// BREAKPOINT 🔴</span>
</code></pre></div><p>尝试运行后在断点处查看汇编：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">demo`main:
    0x100002990 &lt;+0&gt;:  pushq  %rbp
    0x100002991 &lt;+1&gt;:  movq   %rsp, %rbp
    0x100002994 &lt;+4&gt;:  subq   $0x30, %rsp
    0x100002998 &lt;+8&gt;:  movl   %edi, -0x1c(%rbp)
    0x10000299b &lt;+11&gt;: movq   %rsi, -0x28(%rbp)
-&gt;  0x10000299f &lt;+15&gt;: callq  0x100002a20               ; demo.Bar.bar.unsafeMutableAddressor : Swift.Int at main.swift
    ; 调用后返回值（即 Bar.bar 的内存地址）存储在 rax 寄存器
    0x1000029a4 &lt;+20&gt;: xorl   %ecx, %ecx
    0x1000029a6 &lt;+22&gt;: movq   %rax, %rdx
    0x1000029a9 &lt;+25&gt;: movq   %rdx, %rdi
    0x1000029ac &lt;+28&gt;: leaq   -0x18(%rbp), %rsi
    0x1000029b0 &lt;+32&gt;: movl   $0x21, %edx
    0x1000029b5 &lt;+37&gt;: movq   %rax, -0x30(%rbp)
    0x1000029b9 &lt;+41&gt;: callq  0x100003cd2               ; symbol stub for: swift_beginAccess
    0x1000029be &lt;+46&gt;: movq   -0x30(%rbp), %rax
    ; (lldb) register read rax =&gt; rax = 0x0000000100008378  demo`static demo.Bar.bar : Swift.Int
    ; 移动立即数 21 到 rax（0x0000000100008378，即 Bar.bar 的内存地址）
    0x1000029c2 &lt;+50&gt;: movq   $0x15, (%rax)
    0x1000029c9 &lt;+57&gt;: leaq   -0x18(%rbp), %rdi
    0x1000029cd &lt;+61&gt;: callq  0x100003cde               ; symbol stub for: swift_endAccess
    0x1000029d2 &lt;+66&gt;: xorl   %eax, %eax
    0x1000029d4 &lt;+68&gt;: addq   $0x30, %rsp
    0x1000029d8 &lt;+72&gt;: popq   %rbp
    0x1000029d9 &lt;+73&gt;: retq

demo`Bar.bar.unsafeMutableAddressor:
    0x100002a20 &lt;+0&gt;:  pushq  %rbp
    0x100002a21 &lt;+1&gt;:  movq   %rsp, %rbp
-&gt;  0x100002a24 &lt;+4&gt;:  cmpq   $-0x1, 0x587c(%rip)       ; Swift51Overrides + 183
    0x100002a2c &lt;+12&gt;: sete   %al
    0x100002a2f &lt;+15&gt;: testb  $0x1, %al
    0x100002a31 &lt;+17&gt;: jne    0x100002a35               ; &lt;+21&gt; at main.swift:4:16
    0x100002a33 &lt;+19&gt;: jmp    0x100002a3e               ; &lt;+30&gt; at main.swift
    ; 将 rip + 0x593c（0x100008378，即 Bar.bar 的内存地址）放在 rax 寄存器中（即返回值）
    0x100002a35 &lt;+21&gt;: leaq   0x593c(%rip), %rax        ; static demo.Bar.bar : Swift.Int
    0x100002a3c &lt;+28&gt;: popq   %rbp
    ; 函数返回
    0x100002a3d &lt;+29&gt;: retq
    ; 将类型属性初始化代码所在闭包的函数地址存储在 rax 寄存器
    0x100002a3e &lt;+30&gt;: leaq   -0x45(%rip), %rax         ; globalinit_33_8E34543FA00B3A97BCFBD7BFA4EE5AD5_func0 at main.swift
    0x100002a45 &lt;+37&gt;: leaq   0x585c(%rip), %rdi        ; globalinit_33_8E34543FA00B3A97BCFBD7BFA4EE5AD5_token0
    ; 移动 rax 寄存器中的内容到 rsi 寄存器（作为 swift_once 函数第一个参数）
    0x100002a4c &lt;+44&gt;: movq   %rax, %rsi
    ; 从 swift_once 开始 si，直到进入 libswiftCore.dylib`swift_once:
    0x100002a4f &lt;+47&gt;: callq  0x100003ce4               ; symbol stub for: swift_once
    ; 跳转到 0x100002a35 ⬆️
    0x100002a54 &lt;+52&gt;: jmp    0x100002a35               ; &lt;+21&gt; at main.swift:4:16

libswiftCore.dylib`swift_once:
-&gt;  0x7fff6806a820 &lt;+0&gt;:  pushq  %rbp
    0x7fff6806a821 &lt;+1&gt;:  movq   %rsp, %rbp
    0x7fff6806a824 &lt;+4&gt;:  cmpq   $-0x1, (%rdi)
    0x7fff6806a828 &lt;+8&gt;:  jne    0x7fff6806a82c            ; &lt;+12&gt;
    0x7fff6806a82a &lt;+10&gt;: popq   %rbp
    0x7fff6806a82b &lt;+11&gt;: retq
    0x7fff6806a82c &lt;+12&gt;: movq   %rsi, %rax
    0x7fff6806a82f &lt;+15&gt;: movq   %rdx, %rsi
    0x7fff6806a832 &lt;+18&gt;: movq   %rax, %rdx
    ; swift_once 内部实际调用了 dispatch_once_f
    0x7fff6806a835 &lt;+21&gt;: callq  0x7fff680bf19c            ; symbol stub for: dispatch_once_f
    0x7fff6806a83a &lt;+26&gt;: popq   %rbp
    0x7fff6806a83b &lt;+27&gt;: retq
    0x7fff6806a83c &lt;+28&gt;: nop
    0x7fff6806a83d &lt;+29&gt;: nop
    0x7fff6806a83e &lt;+30&gt;: nop
    0x7fff6806a83f &lt;+31&gt;: nop

demo`globalinit_33_8E34543FA00B3A97BCFBD7BFA4EE5AD5_func0:
    0x100002a00 &lt;+0&gt;:  pushq  %rbp
    0x100002a01 &lt;+1&gt;:  movq   %rsp, %rbp
    ; 移动立即数 20 到 rip + 0x5969（0x100008378，即 Bar.bar 的内存地址）
-&gt;  0x100002a04 &lt;+4&gt;:  movq   $0x14, 0x5969(%rip)       ; getExistentialTypeMetadata(swift::ProtocolClassConstraint, swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned long, swift::TargetProtocolDescriptorRef&lt;swift::InProcess&gt; const*)::$_3::operator()() const::TheLazy + 12
    0x100002a0f &lt;+15&gt;: popq   %rbp
    0x100002a10 &lt;+16&gt;: retq
</code></pre></div><p>因此类型属性默认即是 <code>lazy</code> 延迟初始化的，并由 <code>swift_once</code> 内的 <code>dispatch_once_f</code> 保证了线程安全。</p>
<p>类型属性通常可以用于单例模式，即整个生命周期内仅初始化一次：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="nc">SomeManager</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">manager</span><span class="p">:</span> <span class="n">SomeManager</span> <span class="p">=</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nv">manager</span> <span class="p">=</span> <span class="n">SomeManager</span><span class="p">()</span>
        <span class="n">manager</span><span class="p">.</span><span class="n">foo</span> <span class="p">=</span> <span class="mi">10</span>
        <span class="k">return</span> <span class="n">manager</span>
    <span class="p">}()</span>

    <span class="kd">var</span> <span class="nv">foo</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span>

    <span class="kd">private</span> <span class="kd">init</span><span class="p">()</span> <span class="p">{}</span>

    <span class="kd">func</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="kc">#function</span><span class="p">,</span> <span class="n">foo</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">SomeManager</span><span class="p">.</span><span class="n">manager</span><span class="p">.</span><span class="n">bar</span><span class="p">()</span>

<span class="c1">// bar() 10</span>
</code></pre></div><h2 id="reference">Reference</h2>
<ul>
<li><a href="http://www.jianshu.com/p/80810efe5229">浅谈 Swift 3 中的访问控制 - kingcos</a></li>
<li><a href="https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html">Access Control - Swift.org</a></li>
<li><a href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html">Properties - Swift.org</a></li>
<li><a href="https://github.com/devxoul/Then">devxoul/Then</a></li>
<li><a href="http://swifter.tips/lazy/">lazy 修饰符和 lazy 方法 - Swifter Tips</a></li>
<li><a href="https://www.bilibili.com/video/BV1cx411S7ay">【菜鸡 Playground 1】Swift 中 lazy initialization</a></li>
<li><a href="https://www.bilibili.com/video/av10142408/">【菜鸡 Playground 2】Swift 中 lazy initialization 的使用场景</a></li>
</ul>
</div>
                    <div class="post_footer">
                        
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    <a href="https://kingcos.me/tags/swift/">Swift</a>
                                    
                                    <a href="https://kingcos.me/tags/swift-%E6%8B%BE%E9%81%97/">Swift 拾遗</a>
                                    
                                </span>
                            </div>
                        </div>
                        
                    </div>
                </div>
                <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<table style="border: 0;">
  <tr>
  <td style="border: 0; width: 30%;">
    <img width='100%' src='/img/about/1.jpg'>
  </td>
  <td style="border: 0; width: 50%;">
    <ins class="adsbygoogle"
     style="display:block;width:100%;"
     data-ad-client="ca-pub-9925978992661955"
     data-ad-slot="3213735320"
     data-ad-format="rectangle"
     data-full-width-responsive="false"></ins>
  </td>
  </tr>
</table>

<hr>

<script>
    (adsbygoogle = window.adsbygoogle || []).push({});
</script>
                
                
                







    
    
    
    <div>
        <div id="github-comment">
        </div>

        <script type="text/javascript">
        function getUtterances(isDark) {
            var utterances = document.createElement('script');
            utterances.type = 'text/javascript';
            utterances.async = true;
            utterances.setAttribute('issue-term', "pathname")
            utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
            utterances.setAttribute('label', "comments")
            isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
            utterances.crossorigin = 'anonymous';
            utterances.src = 'https://utteranc.es/client.js';

            return utterances
        }
        document.getElementById('github-comment').appendChild(getUtterances(false))
        </script>
    </div>
    




                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://kingcos.me">Powered by kingcos with love.</a>
    </div>

    <div class="footer_slogan">
        <span>❤️</span>
    </div>
</footer>
    <script src="https://kingcos.me/js/jquery-3.5.1.min.js"></script>
<link href="https://kingcos.me/css/fancybox.min.css" rel="stylesheet">
<script src="https://kingcos.me/js/fancybox.min.js"></script>
<script src="https://kingcos.me/js/zozo.js"></script>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</body>

</html>