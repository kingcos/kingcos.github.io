<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on iBlog</title>
    <link>/posts/</link>
    <description>Recent content in Posts on iBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 23 Jul 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>C/C&#43;&#43;/Obj-C/C&#43;&#43; 中的 const、static &amp; extern</title>
      <link>/posts/2019/const_static_extern_in_cpp_obj-c/</link>
      <pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/const_static_extern_in_cpp_obj-c/</guid>
      <description>Date Notes Env     2019-07-23 首次提交 clang++, macOS 10.14.6    Preface const、static &amp;amp; extern 是 C/C++ 中的关键字，然而在写 Obj-C/C++ 时却有不免会经常用到。虽然这几个关键字我都知道，但有时会将它们搞混或者用错，那么这次就简单总结下这几个关键字吧。
const 基础类型 对于基础类型，其在内存中存储的即是该类型的变量本身，经过 const 修饰后，此处的变量不可变，即常量。const 的位置并不会影响其作用，更为推荐的写法应当是编译器提示的 const &amp;lt;TYPE&amp;gt;。
以下是在 C/C++ 中的用例，由于 Obj-C/C++ 分别是 C/C++ 的超集，对于 C/C++ 的基础类型，其在 Obj-C/C++ 中的表现是一致的：
int a = 0; a = 10; const int b = 0; // error: cannot assign to variable &#39;b&#39; with const-qualified type &#39;const int&#39; // b = 10; int const c = 0; // c = 10;  对于 Obj-C 中特有的基础类型，const 也与修饰 C/C++ 中基础类型的行为一致：</description>
    </item>
    
    <item>
      <title>objc_msgSend</title>
      <link>/posts/2019/objc_msgsend/</link>
      <pubDate>Sat, 20 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/objc_msgsend/</guid>
      <description>Date Notes Source Code     2019-07-20 首次提交 objc4-750.1    Preface 了解 iOS 开发的同学都知道，Obj-C 中方法调用的本质其实是消息发送，即 [foo bar] 是向 foo 对象发送一条 bar 的消息，而发送消息就是通过 objc_msgSend 所进行的。那么这次本文就简单窥探一下 objc_msgSend 吧。
Where 在开始之前，可能有人会问，为什么 Obj-C 中方法调用的本质是 objc_msgSend 呢？哪里可以证明呢？
我们创建一个使用 Obj-C 的 iOS 项目，如下在「ViewController」中添加一个按钮，并在按钮的点击事件中创建一个 Obj-C 对象，再调用其方法：
#import &amp;quot;ViewController.h&amp;quot; @interface Foo : NSObject - (void)bar; @end @implementation Foo - (void)bar { } @end @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; } - (IBAction)clickOnButton:(UIButton *)sender { Foo *foo = [[Foo alloc] init]; // 断点打在下一行 ⬇️ [foo bar]; } @end  我们将断点打在 [foo bar]; 一行，选择真机运行，启动程序并点击按钮。在 Xcode 的控制台多次输入 si（Step Into）即可跳转到如下图界面：</description>
    </item>
    
    <item>
      <title>[译]摊平由「try?」造成的嵌套可选</title>
      <link>/posts/2019/0230-flatten-optional-try_zh/</link>
      <pubDate>Mon, 08 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/0230-flatten-optional-try_zh/</guid>
      <description>提案: SE-0230 作者: BJ Homer 审查管理员: John McCall 状态: 已实现 (Swift 5) 实现: apple/swift#16942 审查: (论坛帖子) (验收)  介绍 Swift 中的 try? 语句目前很容易引入嵌套可选（译者注：嵌套可选即类似 var foo: String?? 可选的可选类型）。而用户难以推断嵌套可选的产生原因，所以 Swift 尝试避免在一些常见情况下产生嵌套可选。
该文档提议给予 try? 与其它常见的 Swift 功能中相同的可选摊平行为（译者注：可选摊平即将可选类型的值去掉可选的一层），来避免常见的嵌套可选。
Swift-evolution 帖子: 使 try? 与可选链摊平协同工作
动机 目前，使用 try? 非常容易产生嵌套的 Optional 类型。虽然构建嵌套可选是被允许的，但这通常并非是开发者所希望的。
Swift 拥有许多机制来避免意外创建嵌套可选。比如：
// 注意 as? 是如何可以无视被转换的值是否是可选类型的，其总是产生了相同的类型 let x = nonOptionalValue() as? MyType // x 是 &#39;MyType?&#39; 类型 let y = optionalValue() as? MyType // y 是 &#39;MyType?</description>
    </item>
    
    <item>
      <title>618 买买买 - 买家秀</title>
      <link>/posts/2019/shopping_618_show/</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/shopping_618_show/</guid>
      <description> Preface 首先让大家感受一下技术博客的衰落（逃，自从在 V2EX 简单地回复了一句我的购物清单链接，博客的浏览量暴增 10,000% +，可以看下图感受下～ 😅
下面我将把陆续到货的东西晒单给大家，虽然我也想开个 B 站录点视频，但没有器材，不会剪辑，大家可以简单看看 - -（~~反响好的话我可以考虑 &amp;hellip; 呸，需求写完了吗？又做梦呢？）
百乐笔 西数 Type-C 4T 移动硬盘 Kindle 全家福 TESTV 套餐 办公椅  🤨 几十块的「地摊货」真的有必要晒单？
是的，首次拍摄 vlog，练练手！B 站链接请戳 👉 av56153142，也可以直接看 👇
  Apple Watch 🌈 表带  av57162876
  Reference  618 买买买 - 这个 618 我都买了啥？  </description>
    </item>
    
    <item>
      <title>618 买买买 - 这个 618 我都买了啥？</title>
      <link>/posts/2019/shopping_618/</link>
      <pubDate>Sat, 15 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/shopping_618/</guid>
      <description>Preface 为了让大家窥（zhong）探（cao）我 618 都败（Buy）了什么，特此总结一份清单，方便给大家参考（手动滑稽 🌝。
话说发表那条带有本文链接的回复之后，昨天看了下网站的访问数据，流量瞬间暴增 11,900%&amp;hellip; 果然写技术博客是没前途的。所以是不是可以考虑等这些东西到货，再发一贴开箱贴呢？然后再发到 V2 上～
 薅羊毛宣言：一切为了优惠而不考虑实际需求的消费，都是反撸。
以下订单统计日期均从 2019 年 6 月 1 日起直到 618 当天，目前快递在慢慢到货。我将在另外一篇中进行晒单：戳这里跳转～。
 京东 自从前几年开通了 Plus 会员，和东哥做了兄弟，日常生活所需基本上都交给了东哥。配送快，服务稳，支持价格保护，售后放心，是我和东哥当兄弟看重的几点。
   日期 名称 个数 总价 备注     6.1 美的洗碗机 M1（赠品：只换不修服务、水卫仕洗涤块）+ 全保修 4 年 1 1699-700+139-10=999+129 「秒杀价」购入；「全保修」是在到货前补购的；寄给父母的   6.1 汤臣倍健蛋白粉（赠品：B 族维生素片、摇摇杯） 1 186-10-1.7-57.18-22.37=94.75 Apple Pay 立减优惠未计入总价；寄给父母的   6.1 百乐笑脸钢笔 M 尖 * 1 + 百乐 P500 中性笔 * 1 + 百乐钢笔上墨器 * 1 + 百乐 6 支装墨囊 + 百乐笑脸钢笔 F 尖 * 1 - 174.</description>
    </item>
    
    <item>
      <title>iOS 中的关联对象</title>
      <link>/posts/2019/associated_objects_in_ios/</link>
      <pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/associated_objects_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-05-18 首次提交 objc4-750 -    Preface 提到 iOS 中的关联对象，即 Associated Objects，又可以算是一项利用 Runtime 的「黑魔法」。然而作为初学者，很难从其名称联想到是为谁关联对象，以及是如何关联对象的，那么今天就来一起研究下 iOS 中的关联对象是什么、怎么用、以及为什么。
What 虽然这部分的官方文档已经「年久失修」，不过我们仍然简单看一下官方的概括：
 Associative References
Associative references, available starting in OS X v10.6, simulate the addition of object instance variables to an existing class. Using associative references, you can add storage to an object without modifying the class declaration. This may be useful if you do not have access to the source code for the class, or if for binary-compatibility reasons you cannot alter the layout of the object.</description>
    </item>
    
    <item>
      <title>将 Obj-C 代码翻译为 C/C&#43;&#43; 代码</title>
      <link>/posts/2019/obj-c_to_c&#43;&#43;/</link>
      <pubDate>Fri, 17 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/obj-c_to_c&#43;&#43;/</guid>
      <description>Date Notes     2019-06-15 增加常用参数列表   2019-05-17 首次提交    Solution ➜ ~ clang --version Apple LLVM version 10.0.0 (clang-1000.11.45.5) Target: x86_64-apple-darwin18.2.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin  Xcode 中，C/C++/Obj-C/C++ 的编译器是 clang，其通过 -rewrite-objc 参数可以将 Obj-C 代码翻译为 C++ 代码，即 clang -rewrite-objc main.m -o main.cpp；也可以结合 xcrun -sdk 命令设置编译所基于的 SDK。
   Options Usage     -arch arm64 指定编译架构   -framework UIKit 依赖 UIKit 框架   -fobjc-arc 使用 ARC（自动引用计数）模式   -fobjc-runtime=ios-8.</description>
    </item>
    
    <item>
      <title>谈谈我的家庭保险计划</title>
      <link>/posts/2019/insurance_plan/</link>
      <pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/insurance_plan/</guid>
      <description>Date Notes     2019-05-14 首次提交    前言 曾经我也和很多人一样，都认为「保险」是坑人的。但后来经过一番研究，保险也确实很有必要，当然，我们都不希望保险真正被用到。这一篇就简单罗列下我为自己和家人目前配置的保险计划。
后续的更新也将会补充至此。
配置 本人  缺失寿险、终身重疾险、意外险
    名称 类别 平台 价格 推荐指数     好医保 · 长期医疗 医疗险 支付宝 149 元每年 🌟🌟🌟   药神保 · 抗癌计划保障（基础版） 医疗险 微信 1 元每月 🌟🌟🌟🌟🌟   微医保 · 重疾险 重疾险 微信 约 28 元每月 🌟   - - - 共计约 509 元每年 -   微车保 · 驾乘意外险（福利版） 意外险 微信 0 -   相互宝 非保险 支付宝 - 🌟🌟🌟🌟    父母  缺失意外险</description>
    </item>
    
    <item>
      <title>[译]在 Objective-C API 中指定可空性</title>
      <link>/posts/2019/nullability_in_obj-c/</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/nullability_in_obj-c/</guid>
      <description>作者 原文链接     Apple Inc. Designating Nullability in Objective-C APIs    使用可空性（Nullability）标志或标志一块区域，以控制将 Objective-C 声明导入 Swift 中的方式。
 框架：  Swift 标准库   概览 在 Objective-C 中，常用可以为空的指针来和对象的引用打交道，这（个空）就是 Objective-C 中的 nil。在 Swift 中，所有值——包括对象实例——都被确保为非空（Non-null）。取而代之，表示一个可能丢失的值可以将其包裹在可选（Optional）类型中。当我们需要表示一个值的丢失，可以使用 nil 值。
我们可以在 Objective-C 的代码中标示声明，以指示一个实例是否可以有空（Null）或 nil 值。这些标志改变了 Swift 如何导入声明（的方式）。举个 Swift 如何导入未标示声明的例子，如下：
@interface MyList : NSObject - (MyListItem *)itemWithName:(NSString *)name; - (NSString *)nameForItem:(MyListItem *)item; @property (copy) NSArray&amp;lt;MyListItem *&amp;gt; *allItems; @end  Swift 导入了每个对象实例的参数、返回值、以及作为隐式包裹可选的属性（译者注：隐式包裹即 Type!</description>
    </item>
    
    <item>
      <title>Swift/Obj-C 混编项目升级 Swift 5.0 踩坑</title>
      <link>/posts/2019/swift_4_to_5/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/swift_4_to_5/</guid>
      <description>Date Note     2019-05-08 Swift 4.2 -&amp;gt; 5.0   2019-07-08 完善内容    Preface 在 ABI 稳定前，每次 Swift 升级都是一个比较「痛苦」的体验。这次笔者花费约总共一天时间将 Swift/Obj-C 混编项目升级到 Swift 5.0，其中还是有一些踩坑经验值得分享的。
Xcode 为了适配 Swift 5.0，首先需要安装 Xcode 10.2。而我们不能完全抛弃 Xcode 10.1，毕竟在未完全转换到 Swift 5.0 的过渡阶段仍然需要使用。因此我们可以将本地的 Xcode 更名为 Xcode-10.1，再在 https://developer.apple.com/download/more/ 检索 Xcode 下载 10.2 版本即可。
 ⚠️ 为了防止类似 XcodeGhost 事件再次发生，建议从该官方渠道或 App Store 直接下载。
 为了便于区分，我们将新的 Xcode 命名为 Xcode-10.2，并打开、同意安装 Xcode Command Line Tools。由于我们目前安装了两个 Xcode，如果需要命令行执行 swift 或 xcodebuild 等命令，可以使用 xcode-select 来进行切换不同版本。</description>
    </item>
    
    <item>
      <title>[译]URL 加载系统</title>
      <link>/posts/2019/url_loading_system/</link>
      <pubDate>Mon, 06 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/url_loading_system/</guid>
      <description>作者 原文链接     Apple Inc. URL Loading System    使用标准互联网协议与 URL 交互，并和服务器通信。
 框架：  Foundation   概览 URL 加载系统通过标准协议比如 HTTPS 或自建协议提供对 URL 标识资源的访问。加载过程是异步的，所以 App 可以保持响应并当数据到达或出错时进行处理。
使用 URLSession 实例可以创建一个或多个 URLSessionTask 实例，来抓取并返回数据给 App、下载文件、或者上传数据和文件到远程地址。使用 URLSessionConfiguration 对象可以配置会话（Session），可以控制类似如何使用缓存和 Cookie 的行为、以及是否允许蜂窝网络连接。
一个会话可以重复地创建任务。举个例子，浏览器可能有分隔的会话以区分普通和隐私浏览，隐私会话将不缓存数据。图 1 展示了不同配置的两种会话可以创建许多任务。
 默认浏览：URLSession [默认配置] -&amp;gt; URLSessionDataTask 隐私浏览：URLSession [临时配置] -&amp;gt; URLSessionDataTask  为了接收定期的更新（或错误），每个会话都与一个代理关联。默认代理将调用提供的回调 Block；如果选择提供自定义的代理，该 Block 不再调用。
通过配置 App 运行在后台时的会话，即可当 App 被挂起时，系统可以代替其下载数据并唤起 App 以分发结果。</description>
    </item>
    
    <item>
      <title>《编写高质量 iOS 与 OS X 代码的 52 个有效方法》阅读笔记</title>
      <link>/posts/2019/effective_obj-c_2.0_notes/</link>
      <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/effective_obj-c_2.0_notes/</guid>
      <description>Book ISBN Notes     编写高质量 iOS 与 OS X 代码的 52 个有效方法 9787111451297 -   Date Num. Xcode   2019-05 1-3 10.2.1   2019-06 4 10.2.1   2019-07 5-9 10.2.1    熟悉 Objective-C 了解 Objective-C 语言的起源  消息结构（Message Structure）的语言，运行时执行的代码由运行环境决定；函数调用（Function Calling）的语言，运行时所执行的代码由编译器决定，对于多态，则按照虚函数表（Virtual Method Table）寻找。 运行时组件（Runtime Component） 本质上是一种与开发者所编写代码相链接的「动态库（Dynamic Library），这样的好处是只需要更新运行时组件（无需重新编译）即可提升程序性能。 Obj-C 是 C 的超集。 Obj-C 中的对象所占内存总是分配在堆空间（Heap Stack）；而指向对象的指针所占内存总是分配在栈帧（Stack Frame）中。 堆中的内存需要程序员自己管理，栈中的内存会在其栈帧弹出（Pop）时自动清理。 创建对象相比创建结构体（C 结构体）需要额外开销，例如分配和释放堆内存等。  // ⚠️ 由于 Obj-C 中的字符串（NSString）略有特殊，此处并未使用书中的 NSString 作为范例 // 对象本身被分配在堆上；obj1 &amp;amp; obj2 被分配在栈上 NSObject *obj1 = [[NSObject alloc] init]; NSObject *obj2 = obj1; // (lldb) p obj1 // (NSObject *) $0 = 0x00000001005092b0 // (lldb) p obj2 // (NSObject *) $1 = 0x00000001005092b0 // (lldb) p &amp;amp;obj1 // (NSObject **) $2 = 0x00007ffeefbff508 // (lldb) p &amp;amp;obj2 // (NSObject **) $3 = 0x00007ffeefbff500  在类的头文件中尽量少引入其他头文件  当需要知道有一个类的存在时，而不关心其内部细节时，可以使用向前声明（Forward Declaring）告知编译器，即可以在 .</description>
    </item>
    
    <item>
      <title>iOS 中的 &#43;initialize 方法</title>
      <link>/posts/2019/&#43;initialize_in_ios/</link>
      <pubDate>Sun, 21 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/&#43;initialize_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-04-21 首次提交 objc4-750 -   2019-05-01 补充细节 - Initialize_Demo    Preface 在 iOS 中，经常与 +load 相提并论的一个方法便是 +initialize。从方法名来看，它的作用是进行初始化，但不同于平时使用的 init，+initialize 是一个类方法。那么它的本质到底是什么呢？
为了更好地叙述 +initialize 的特点，本文部分描述尝试与 +load 方法对比，建议阅读本文前先阅读「iOS 中的 +load 方法」。
What // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { + (void)initialize; }  Obj-C 中的 +initialize 方法指的是 NSObject 中的 + (void)initialize 类方法。官方文档中的 +initialize 如下：
 Initializes the class before it receives its first message.</description>
    </item>
    
    <item>
      <title>iOS 中的 &#43;load 方法</title>
      <link>/posts/2019/&#43;load_in_ios/</link>
      <pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/&#43;load_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-04-20 首次提交 objc4-750 Load_Obj-C_Demo    Preface 在 iOS 开发中，我们经常会使用 +load 方法来做一些在 main 函数之前的操作，比如方法交换（Method Swizzle）等。那么 +load 到底是如何被调用的呢？
What // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { + (void)load; }  Obj-C 中的 +load 方法指的是 NSObject 中的 + (void)load 类方法。官方文档中的 +load 如下：
 Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</description>
    </item>
    
    <item>
      <title>iOS 中的 Category</title>
      <link>/posts/2019/category_in_ios/</link>
      <pubDate>Sat, 13 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/category_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-04-16 优化结构 - -   2019-04-13 首次提交 objc4-750、xnu-4903.221.2 Category in iOS    Preface iOS 中的 Category 中文常译作分类、类别（为表述统一，本文将使用 Category 特指该技术）。我们经常会使用 Category 来对一个类进行扩展，使得在不破坏主类结构的同时可以具备更多的功能；也可以使用 Category 对一个类进行拆分，使得其结构更加清晰条理。本文将从 What - How - Why 谈谈 iOS 中 Category。
What 什么是 Category 呢？
Category 是 Obj-C 语言中所提供的一项功能，它可以为 Obj-C 类添加额外的属性、方法，也可以遵守其他协议。
Xcode 中已经为 Category 已经提供了模版来建立，只需要指定 Category 的名称以及被添加 Category 类名即可。当然，我们也可以手动来自己建立，Category 的语法与类的声明与实现比较类似：
@interface Foo (Bar) &amp;lt;SomeProtocol&amp;gt; - (void)foo; @end @implementation Foo (Bar) - (void)foo {} - (void)someMethodFromProtocol {} @end  How Category 通常都有哪些用处呢？</description>
    </item>
    
    <item>
      <title>Obj-C &amp; Swift 的类型内省与反射</title>
      <link>/posts/2019/type_introspection_and_reflection/</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/type_introspection_and_reflection/</guid>
      <description>Date Notes Swift Demo     2019-04-08 首次提交 4.2 Type Introspection and Reflection    Preface 许多编程语言中都有类型内省（又称自省，Introspection）和反射（Reflection）这两个概念，本文将探讨一下 Obj-C 和 Swift 中类型内省和反射的相关概念与具体使用。
What 维基百科中对于类型内省定义如下：
 In computing, type introspection is the ability of a program to examine the type or properties of an object at runtime. Some programming languages possess this capability.
Introspection should not be confused with reflection, which goes a step further and is the ability for a program to manipulate the values, meta-data, properties and/or functions of an object at runtime.</description>
    </item>
    
    <item>
      <title>Xcode 中的 Link Map 文件</title>
      <link>/posts/2019/link_map_file_in_xcode/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/link_map_file_in_xcode/</guid>
      <description>Date Notes Xcode Swift     2019-07-28 增加目录导图，折叠过长内容 - -   2019-04-16 增加 Swift 项目 10.1 4.2   2019-04-01 首次提交 10.1 -    Preface Link Map File，译作链接映射文件（下文将称 Link Map 文件）。Xcode 在构建可执行文件之前，需要先编译为目标文件（Object File），并链接所需要的其他库，那么 Link Map 文件就记录了链接器（Linker）在链接过程中产生的一些信息，本文将谈谈这个文件的构成。
What Xcode 中默认是不会将 Link Map 文件在构建时暴露出来的，需要我们手动在「Build Settings」-「Write Link Map File」-「Yes」打开该写入该文件的设置。这样当我们再次编译项目，默认就可以在 ~/Library/Developer/Xcode/DerivedData/&amp;lt;TARGET_NAME&amp;gt;-&amp;lt;Random_ID&amp;gt;/Build/Intermediates.noindex/&amp;lt;TARGET_NAME&amp;gt;.build/Debug-&amp;lt;Device_Type&amp;gt;/&amp;lt;TARGET_NAME&amp;gt;.build/&amp;lt;TARGET_NAME&amp;gt;-LinkMap-normal-&amp;lt;Arch&amp;gt;.txt 中找到。如有更改 Link Map 文件路径的需求也可以在「Path to Link Map File」中更改。
举个例子，我的 DemoiOS 项目（Obj-C）中 Link Map 文件的完整路径为：/Users/kingcos/Library/Developer/Xcode/DerivedData/DemoiOS-hifhuapijabsaxgpelrpiwhbzlqv/Build/Intermediates.noindex/DemoiOS.build/Debug-iphonesimulator/DemoiOS.build/DemoiOS-LinkMap-normal-x86_64.txt。</description>
    </item>
    
    <item>
      <title>Obj-C 中实例变量和类的访问控制</title>
      <link>/posts/2019/ivar_access_control_in_obj-c/</link>
      <pubDate>Sat, 30 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/ivar_access_control_in_obj-c/</guid>
      <description>Date Notes     2019-06-14 增加 man nm 截图   2019-04-29 完善 @package   2019-03-30 gcc, clang; macOS 10.14.2    Preface Obj-C 中的实例变量，即 Instance Variables，简称为 ivar。在面向对象的概念中，一个类的对外暴露决定了其所提供的能力，对子类则需要提供一定的扩展性，但有些时候我们不希望外界甚至子类知道一些细节，这时就用到了访问控制（Access Control）。在 C++、Java、Swift 等大多数高级语言中都有这样的概念，这次就来谈谈 Obj-C 中实例变量和类的访问控制。
访问控制修饰符 @public @interface Computer : NSObject { @public NSString *_name; } @end @implementation Computer @end Computer *cpt = [[Computer alloc] init]; cpt-&amp;gt;_name = @&amp;quot;My PC&amp;quot;; NSLog(@&amp;quot;%@&amp;quot;, cpt-&amp;gt;_name); // OUTPUT: // My PC  声明为 @public 的实例变量是访问控制中开放范围最大的，其允许外界可以直接访问到（当然，前提是引入包含该类的头文件）。需要注意的是，在类声明中的属性（@property），系统会自动为我们创建一个 _ 开头的实例变量，这个实例变量的可见程度也默认 @public。</description>
    </item>
    
    <item>
      <title>iOS 中的 KVC</title>
      <link>/posts/2019/kvc_in_ios/</link>
      <pubDate>Mon, 25 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/kvc_in_ios/</guid>
      <description>Date Notes     2019-03-25 首次提交    Preface KVC，即 Key-Value Coding，译作键值编码（下文简称 KVC）。当对象兼容 KVC 时，可以通过统一的 API 访问对象中某个键对应的属性值。Cocoa 中的许多功能都依赖 KVC，比如，KVO、Cocoa 绑定机制、Core Data、以及 AppleScript 等。本文将主要探讨 KVC 及其本质相关，关于其它的内容可参考文末的「Reference」。
Basics How #import &amp;lt;Foundation/Foundation.h&amp;gt; @interface Speaker : NSObject @property (nonatomic) int volume; @end @implementation Speaker @end @interface Computer : NSObject @property (nonatomic) NSString *name; @property (nonatomic) NSArray *speakers; @end @implementation Computer @end int main(int argc, const char * argv[]) { @autoreleasepool { Computer *cpt = [[Computer alloc] init]; // ➡️ 通过 setter 设置 [cpt setName:@&amp;quot;My Mac 1&amp;quot;]; // ➡️ 通过 getter 读取 NSLog(@&amp;quot;name from getter - %@&amp;quot;, [cpt name]); // ➡️ 通过 setValue:forKey: 设置 [cpt setValue:@&amp;quot;My Mac 2&amp;quot; forKey:@&amp;quot;name&amp;quot;]; // ➡️ 通过 valueForKey: 读取 NSLog(@&amp;quot;name from KVC - %@&amp;quot;, [cpt valueForKey:@&amp;quot;name&amp;quot;]); Speaker *s1 = [[Speaker alloc] init]; s1.</description>
    </item>
    
    <item>
      <title>Obj-C 中的重载与重写</title>
      <link>/posts/2019/override_and_overload_in_obj-c/</link>
      <pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/override_and_overload_in_obj-c/</guid>
      <description>Date Platform     2019-03-20 macOS 10.14.2    Preface 重载（Overload）和重写（Override）是面向对象语言中十分基本的两个概念，本文将谈谈 Obj-C 中的重载与重写。
重载  In some programming languages, function overloading or method overloading is the ability to create multiple functions of the same name with different implementations. Calls to an overloaded function will run a specific implementation of that function appropriate to the context of the call, allowing one function call to perform different tasks depending on context.</description>
    </item>
    
    <item>
      <title>Obj-C 中的对象</title>
      <link>/posts/2019/objects_in_obj-c/</link>
      <pubDate>Mon, 18 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/objects_in_obj-c/</guid>
      <description>Date Notes Source Code     2019-03-18 首次提交 objc4-750    对象的分类 Obj-C 中的对象，主要有三种，实例对象（Instance Object）、类对象（Class Object）、以及元类对象（Meta-class Object）。类对象和元类对象的类型均为 Class，即 typedef struct objc_class *Class;，所以它们的结构其实是一致的，只是存放的内容不同。
定义一个继承自 NSObject 的 Computer 类，方便后续的 Demo。
// EDdeviceProtocol 协议 @protocol EDdeviceProtocol - (void)powerOn; @end // Computer 类，继承自 NSObject，遵守 EDdeviceProtocol @interface Computer : NSObject &amp;lt;EDdeviceProtocol&amp;gt; { // 成员变量 @public int _memorySize; int _diskSize; } // 属性 @property (copy) NSString *model; // 实例方法 - (void)print:(NSString *)content; // 类方法 + (NSString *)arch; @end @implementation Computer - (void)print:(NSString *)content { NSLog(@&amp;quot;Print Content: %@&amp;quot;, content); } // 协议方法 - (void)powerOn { NSLog(@&amp;quot;Start.</description>
    </item>
    
    <item>
      <title>iOS 中的 KVO</title>
      <link>/posts/2019/kvo_in_ios/</link>
      <pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/kvo_in_ios/</guid>
      <description>Date Notes     2019-03-13 首次提交    Preface KVO 即 Key-Value Observing，译作键值监听（下文简称 KVO），通常用于监听对象的某个特定属性值的变化。本文将由浅入深，谈谈 iOS 中的 KVO。
How #import &amp;quot;ViewController.h&amp;quot; @interface Computer : NSObject @property (nonatomic, assign) int buttonClickTimes; @end @implementation Computer @end @interface ViewController () @property (nonatomic, strong) Computer *cpt; @end @implementation ViewController - (Computer *)cpt { if (!_cpt) { _cpt = [[Computer alloc] init]; // ➡️ 为 cpt 属性的键路径 buttonClickTimes 增加监听者 self（该控制器） // options 决定监听者将同时接收到新值和旧值 // context 决定附带的上下文信息「ViewController-buttonClickTimes」。 [_cpt addObserver:self forKeyPath:@&amp;quot;buttonClickTimes&amp;quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@&amp;quot;ViewController-buttonClickTimes&amp;quot;]; } return _cpt; } - (void)dealloc { // ➡️ 在监听者销毁前将其移除 [self.</description>
    </item>
    
    <item>
      <title>iOS 中的 NSObject</title>
      <link>/posts/2019/nsobject_in_ios/</link>
      <pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/nsobject_in_ios/</guid>
      <description>Date Notes Source Code     2019-03-13 首次提交 objc4-750、libmalloc-166.220.1、glibc-2.29    NSObject 实例对象的大小 // NSObject Obj-C -&amp;gt; C NSObject_IMPL struct NSObject_IMPL { Class isa; }; // 指向 objc_class 结构体的指针 typedef struct objc_class *Class;  将 Obj-C 源码通过 clang -rewrite-objc 翻译为 C++（其实大部分为 C），可以发现 Obj-C 中的 NSObject 类其实就是 C 中的 NSObject_IMPL 结构体，其中只有一个成员变量，即 isa。isa 的类型是 Class，本质是一个指向 objc_class 结构体的指针。在 64 位系统中，指针占用 8 个字节（Byte），即 NSObject 的实例对象大小应该为 8 个字节。我们也可以尝试用 C 语言中的 sizeof() 运算符来证明这一点：</description>
    </item>
    
    <item>
      <title>iOS 多线程技术实践之 pthreads</title>
      <link>/posts/2019/multithread_techs_in_ios-1/</link>
      <pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/multithread_techs_in_ios-1/</guid>
      <description>Date Notes Swift Xcode     2019-03-08 首次提交 4.2 10.1     在 iOS 中的多线程（Multithreading）技术通常有以下几种实现方式：pthreads、NSThread、GCD、NSOperation。首先，我们来一起看一看 pthreads。
 Preface  POSIX Threads, usually referred to as pthreads, is an execution model that exists independently from a language, as well as a parallel execution model. It allows a program to control multiple different flows of work that overlap in time. Each flow of work is referred to as a thread, and creation and control over these flows is achieved by making calls to the POSIX Threads API.</description>
    </item>
    
    <item>
      <title>Objective-C 与 Swift 桥接中的坑</title>
      <link>/posts/2019/obj-c_swift_bridge_tips/</link>
      <pubDate>Thu, 17 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/obj-c_swift_bridge_tips/</guid>
      <description>Date Notes     2019-01-17 添加「Optional 与 Nullability」
添加「NSNotificationName 与 Notification.Name」    Preface Objective-C 与 Swift 的混编是全面转向 Swift 中的必经之路，本篇即是这一过程中的踩坑「真实」记录。
Optional 与 Nullability  Swift 4.2  在大多数项目中，我们都是在中途决定转向 Swift，Swift 中比较核心且常见的概念便是 Optional，可选类型，而这与 Obj-C 中的概念不大相同。在 Swift 中使用 Obj-C 桥接的属性（特别是 Block）时，尤其要注意：Obj-C 默认属性将被转换为隐式解包类型（SomeClass!），而在 Swift 中这代表开发者要保证值不为 nil，编译器将不再提示。当属性是 Block 时，若直接调用了为 nil 的 Closure 时，将会出现崩溃。
   Obj-C Usage Swift     nullable 可空 SomeClass?   nonnull 不可空 SomeClass   null_unspecified 未指定是否可空（默认） SomeClass!</description>
    </item>
    
    <item>
      <title>2018 年「终」总结</title>
      <link>/posts/2018/year_plan/</link>
      <pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/year_plan/</guid>
      <description>今天是 2018 年 12 月 10 日，一年前的昨天，我从家里坐高铁到达了北京。还记得那天晚上，两个同学来火车站接我，我们一起坐公交去他们在昌平沙河的培训宿舍。一天的奔波加上本来就晕车的我，在公交行驶过高速后就难受的不行，不得不下车休息片刻。
不像刚到上海的时候，没有工作的压力，充满着一些生活的气息。而来到北京就是为了实习，为了工作。虽然目的性更强，但也让我不得不更快地融入这个环境，而没时间去慢慢感受。我是北方人，北京更加令我熟悉，但却总感觉不如上海能带给我的新鲜感。从在北科的宿舍到确定现在住的地方，我一共搬了四次家，最终选择了公司附近但价格相对较高的房间。虽然房租已经逼近当时我的实习工资，但这一年我认为这个投资还是非常值得的，毕竟时间的价值更难以衡量。
在北京实习的日子里，去北大参加了比赛，又回到学校拍了毕业照，再辗转到长沙比赛，又去武汉听了音乐会，回了趟家，最后又返回了北京，正式加入了现在的团队。
在北大的比赛，让我感受到我和这些名校学生的差距并没有想象中的遥不可及，当然我不是说差距不明显而是觉得自己有了信心。当然我也羡慕他们拥有如此丰富的资源，也坚定了我会再去读研的决心。虽然比赛最后的名次并不是很靠前，但和北大学长学姐、北航浙大学弟的这次友谊和合作，令我倍感幸运。
北大比赛结束的第二天，我便一早乘坐高铁回学校，准备再见见大学的同学们，拍拍毕业照。班长为了等我，特意将聚餐时间往后推迟了一日。所以很遗憾有些同学因为工作等原因提早回去，只得有缘再见。在大学的四年里，我担任学委，和大学同学们的相处甚至要好过于高中同学。当然，不得不说毕业聚餐后发生了一些事情，也许是这辈子都不会忘记的事情吧&amp;hellip;虽然学校只是个很普通的二本，这四年也发生了很多事情，但一些老师和这些同学们却让我不后悔来到这里。
要想放下一些事情，就得让自己忙起来。忙完大学生涯最后的篇章，便又启程去了长沙，这次的比赛地点是在长沙的超算中心。说实话，这次的比赛因为没有很好的构思，只能很简单地做了个 Demo，效果也非常一般。这次的比赛是面向华中地区，相较于在上海和北京的比赛，能明显感受到一些差距，但也越发发现这类比赛的作品其实存在着很高的重复性。最后因为赶音乐会的时间紧迫，没能在长沙逗留一段时间，仅有的一丝印象也是一座非常干净、轻松的城市。
离开长沙，坐上高铁，奔向武汉。去武汉的理由很简单，只是在复旦比赛认识的队友多买了一张音乐会的票，于是就随他去了。因为通宵比赛，加上路途奔波，我已经非常疲倦，但这次音乐会对于我个人感受至深。我们还年轻，生活不应该只是对着电脑、手机，生活纵然有不易，但也是如此的丰富多彩。也没有来得及注意武汉，但确实也是一座非常发达的城市。
享受完音乐会，便又马不停蹄地踏上回家之途。其实原本打算是直接回北京，但想到工作之后回家似乎就不那么自由，便还是决定回家一趟。出门久了才知道，什么都抵挡不过父母做的一顿饭，只是这次在家呆不了太久，便又要踏上北上之途。
回京之旅和以往不同，是因为买到了比高铁还要便宜的机票，人生中第一次乘坐了飞机。可能洛阳坐飞机的人并不多，飞机也并没有我想象中那么大，不过飞机起飞加速时的推背感却让我感到很过瘾。
这一年真的是非常丰富的一年，除了上面这一段游记，年初的时候在北京陪韩国留学放假回来的好友在北京玩了几天，看了升旗，逛了故宫，也了解了航天与航空的差异（笑）；在北京去了 Apple Store，和北京的小朋友一起上了 Today at Apple，感受了苹果新的零售哲学；六月中旬去了清华，和来上科大宣讲的外籍教授一对一讨论了 Robotistic（机器人学），也认识了上科大优秀的博士生；第一次正式加入一家公司；主动和团队里的人去美团总部交流技术；在新员工培训中拿到了第一名；周末和同学第一次爬了长城；第一次被拉去蹦了野生迪&amp;hellip;
当然，一年再怎么精彩，也依然会有遗憾。对于那些可以在未来弥补的遗憾，就放在之后的计划中吧，对于那些无法弥补的，就让它过去吧。感谢 2018 年，也感谢这一年遇到的所有人，辗转多地也遇到很多可爱的人。最后，也感谢自己。幸运，总是留给有准备的人。2019，加油！
V.
提笔于 2018.12.10，完结于 2018.12.11 晚；北京
后记 原本以为 2018 年就会如此过去，却没曾想到在最后一周又发生了很多事情。倒数第二周的周末，听闻公司「优化」的消息，又一次下载了脉脉。传言言之凿凿，又加上我还未转正，简直是「性价比」之选。其实工作了一年，确实感觉辛苦，不如学生时代的自由和悠闲。虽然有了所得，但失去的更多。所以如果被「优化」，我就准备先回学校把驾照考完，再去想想自己真正热爱的事情，其实我一直有想法要亲自打造一款产品，那么我想就是时候去做了。
当然，结果是我并没有被「优化」，打造产品的计划又被耽搁了，而让我痛心的是和我一起入职的好几个小伙伴们被「优化」。工作这一年，越发认识到社会上的人久而久之都会变得「油腻」，而这些刚从校园里出来的孩子们却没有社会上的浮躁气息，失去这些同事实在令我可惜。真心希望他们能找到更好的去处，也希望我们友谊长存，也希望我自己能保持初心。
2018 年从实习，到公司被收购，入职，涨薪，裁员，这些经历都让我学习到很多。其实这种「优化」和个人能力的相关性很低，而和个人所在的业务关联性很大。之前总是天真地以为技术是唯一，其实现在才发现，技术只是基本功，个人的能力绝不能仅仅只在技术能力上体现，而是需要全方位的修炼。
2018 年总归要过去，虽然在 2018 年的尾巴上又重新加回了一位好友，也简单地聊了几句，但深感有些事情却再也不会回去了。
Yesterday is history, tomorrow is a mystery, today is God&amp;rsquo;s gift, that&amp;rsquo;s why we call it the present. - Joan Rivers
V.
后记于 2019.01.03 午</description>
    </item>
    
    <item>
      <title>[译]为 App 执行一次性设置</title>
      <link>/posts/2018/performing_one-time_setup_for_your_app/</link>
      <pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/performing_one-time_setup_for_your_app/</guid>
      <description>作者 原文链接     Apple Inc. Performing One-Time Setup for Your App    确保 App 环境被正确配置。
 框架  UIKit   概览 当用户第一次启动 App，我们可能希望通过一些一次性任务预备 App 环境。举个例子，可能想要：
 从服务器下载必要的数据。 从 App 包（bundle）中拷贝文档模版或可修改的数据文件至一个可写入的目录。 为用户配置默认偏好设置。 设置用户账户或获取其他必要数据。  在 App 代理的 application(_:willFinishLaunchingWithOptions:) 或 application(_:didFinishLaunchingWithOptions:) 方法中执行任何一次性任务。当非必需用户输入时，绝不要因任务阻塞 App 的主线程。取而代之，使用调度队列（dispatch queue）异步开启任务，当 App 完成启动时，让其运行在后台。对于那些必需用户输入的任务，在 application(_:didFinishLaunchingWithOptions:) 方法中作出用户界面的改变。
在合适的位置安放文件 App 拥有其自身包含的目录来保存文件，我们也应当总是将 App 特定的文件放在 ~/Library 的子目录中。特别地，将以下文件保存在 ~/Library 的子目录：
 ~/Library/Application Support/ —— 保存想要备份用户的其他内容的 App 特定文件（可以根据需要创建自定义的子目录。）使用该目录保存数据文件，配置文件，文档模版，等等。 ~/Library/Caches/ —— 保存便于重复产生或下载的临时文件。  使用 FileManager 的 urls(for:in:) 方法获得 App 容器的目录 URL。</description>
    </item>
    
    <item>
      <title>[译]关于 App 启动顺序</title>
      <link>/posts/2018/about_the_app_launch_sequence/</link>
      <pubDate>Fri, 16 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/about_the_app_launch_sequence/</guid>
      <description>作者 原文链接     Apple Inc. About the App Launch Sequence    学习在启动时的代码执行顺序。
 框架  UIKit   概览 一个 App 的启动需要经过许多复杂的步骤，其中大部分由 UIKit 自动处理。在启动过程中，UIKit 会调用 App 代理中的方法，因此我们可以执行自定义的任务。图中的步骤展示了从 App 启动的时间开始直到被认为初始化完成的过程。
 由用户显式或系统隐式启动 App。 Xcode 提供的 main 函数调用 UIKit 的 UIApplicationMain(_:_:_:_:) 函数。 UIApplicationMain(_:_:_:_:) 函数创建 UIApplication 对象和 App 代理。 UIKit 从主 storyboard 或 nib 文件加载 App 的默认界面。 UIKit 调用 App 代理的 application(_:willFinishLaunchingWithOptions:) 方法。 UIKit 执行状态恢复（state restoration），即调用 App 代理和视图控制器中的额外的方法。 UIKit 调用 App 代理的 application(_:didFinishLaunchingWithOptions:) 方法。  当初始化完成，系统将 App 转到激活（前台）状态或后台状态。当 App 转到激活状态，其窗口出现在屏幕上，并开始响应用户交互。当 App 转到后台状态，其窗口保持隐藏，并在被暂停前运行极短的时间。</description>
    </item>
    
    <item>
      <title>谈谈 iOS 中的 dyld_shared_cache</title>
      <link>/posts/2018/dyld_shared_cache/</link>
      <pubDate>Sun, 14 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/dyld_shared_cache/</guid>
      <description>Date Notes Source Code     2019-06-11 更新 Shortcut 相关 -   2018-12-12 补充 dyld_shared_cache 路径来源 system_cmds-805.220.1   2018-10-14 首次提交 dyld-551.4    What iOS &amp;amp; macOS 作为操作系统，其中内置了许多系统库（Library）。dyld_shared_cache，即动态库共享缓存。自 iOS 3.1 后，所有系统动态库被集合成一个 dyld_shared_cache 文件，以提升性能。当然，macOS 也有 dyld_shared_cache，比较特别的是可以通过 update_dyld_shared_cache 更新。
How 为了研究 dyld_shared_cache，首先要找到其存在的路径。可以在 Apple 开源的 system_cmds 中 dyld_shared_cache.c 文件中发现，其分别存放在 macOS 和 iOS 中的路径。
macOS 上的 dyld_shared_cache 和 iOS 不太相同，每种架构额外对应了一种 .map 文件。因为本文着重在于 iOS，读者想要了解 macOS 相关可以在 system_cmds 中自行检索。</description>
    </item>
    
    <item>
      <title>使用 usbmuxd 连接 iPhone</title>
      <link>/posts/2018/usbmuxd/</link>
      <pubDate>Sat, 08 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/usbmuxd/</guid>
      <description>macOS iOS libimobiledevice/usbmuxd     10.13.6 9.0.1 (Jailbroken) v1.0.8    What usbmuxd 全称「USB Multiplexing Daemon」，即 USB 多路传输驻留程序。当 Mac/PC 与 iPhone 之间使用 USB 数据线连接时，iTunes 与 iPhone 间的通信交流便是通过 usbmuxd 服务。usbmuxd 通过给定的端口号和 localhost 建立 TCP 连接。
在 Mac 端，是由「/System/Library/PrivateFrameworks/MobileDevice.framework/Resources/usbmuxd」处理，并通过 launchd 启动。其将会在「/var/run/usbmuxd」创建一个 UNIX Domain Socket（UNIX 域套接字），usbmuxd 将监听 USB 接口的 iPhone 连接。当 iPhone 在正常模式下连接，其将会连接到该 iPhone，并将开始转发通过「/var/run/usbmuxd」接收到的请求。
Solution  通过 usbmuxd 用 USB 代替 Wi-Fi 转发 SSH 请求。
  这里注意选择 1.</description>
    </item>
    
    <item>
      <title>Xcode 10 beta 趟坑</title>
      <link>/posts/2018/xcode_10_beta/</link>
      <pubDate>Wed, 25 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/xcode_10_beta/</guid>
      <description>Xcode macOS     10 beta 2 10.14 beta 2    $(TeamIdentifierPrefix)  Xcode 10 已知 Bug，无法自动替换。  Workaround  可以手动将 entitlements 文件的 Pass Type ID 值设置为 mobileversion 文件中com.apple.developer.pass-type-identifiers 对应值。  libstdc++  Xcode 10 取消了内置支持的 libstdc++ 库，需等待某些第三方 SDK 修复。  Workaround  手动将 Xcode 9（/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib）中的库 libstdc++.6.tbd &amp;amp; libstdc++.6.0.9.tbd 复制到 Xcode 10（/Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib）。  SWIFT_UNAVALIABLE  在 Obj-C 中调用 Swift 子类的 Obj-C 父类的构造器，提示 Unavaliable，由 Xcode 生成的 *-Swift.</description>
    </item>
    
    <item>
      <title>在 macOS 上进行直播推流</title>
      <link>/posts/2018/livestreaming_on_macos/</link>
      <pubDate>Sun, 22 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/livestreaming_on_macos/</guid>
      <description>Date Platform Software     2018.07.22 macOS 10.14 beta 4 OBS Studio, Soundflower   2019.03.30 macOS 10.14.4 -     由于更换了电脑，上次好不容易折腾的配置也都无从参考，这次尽力把整个配置过程，以及音频输入输出的部分完善。直播推流使用了 OBS Studio，直播平台为 Bilibili。
欢迎来围观我的 B 站直播间：https://live.bilibili.com/7900407。
 Solution Basic setup  使用「Homebrew」安装 OBS
brew cask install obs    安装期间可以在 Bilibili 申请开通直播，并获取需要的 RTMP 地址以及直播码   打开「OBS」-「Preference」-「流」   在「URL」和「流名称」分别填写 Bilibili 提供的 RTMP 地址以及直播码 回到主界面为默认的场景添加来源，常用的是「显示捕获」（即完全把自己能看到推流出去）以及「窗口捕获」（即只把选中的窗口推流出去） 点击「开始推流」即可开始直播  Audio  使用「Homebrew」安装 Soundflower</description>
    </item>
    
    <item>
      <title>将树莓派作为 AirPlay 音频服务器</title>
      <link>/posts/2018/airplay_on_pi/</link>
      <pubDate>Sun, 22 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/airplay_on_pi/</guid>
      <description>Raspberry Pi Platform juhovh/shairplay     3 B Raspbian 4.14 765148f98f343b3b9911cc05504ac276cfc44c26    Info 树莓派是个很容易吃灰的设备，配置太低，又弃之可惜。何不作为 AirPlay 来解放你的有线音箱呢？
Solution  SSH 或直接在树莓派的终端中运行以下命令，关于 SSH、VNC、替换源等操作请自行搜索。
 Basic setup  安装依赖
sudo apt-get install autoconf automake libtool sudo apt-get install libltdl-dev libao-dev libavahi-compat-libdnssd-dev sudo apt-get install avahi-daemon  编译安装
cd ~/Desktop mkdir AirPlay cd AirPlay git clone https://github.com/juhovh/shairplay.git cd shairplay ./autogen.sh ./configure make sudo make install  启动</description>
    </item>
    
    <item>
      <title>iOS 开发问题解决集锦</title>
      <link>/posts/2018/ios_dev_issue_list/</link>
      <pubDate>Tue, 10 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/ios_dev_issue_list/</guid>
      <description>Unable to boot device in current state: Creating  Xcode: 9.4.1 macOS: 10.13 在使用模拟器或者 xcodebuild test 时可能会出现此问题。  Solution  使用 xcrun simctl list 命令列出所有模拟器机型，用 xcrun simctl erase UDID 还原相应的设备，重试即可。 下面是一个 Python 3 脚本，可以使用 python erase_simulators.py -d &#39;DEVICE_TYPE&#39; 来直接还原相应设备类型的所有设备。  # -*- coding: utf-8 -*- import argparse import subprocess import re def erase_device(device): status, output = subprocess.getstatusoutput(&#39;xcrun simctl list | grep \&#39;&#39; + device + &#39; (\&#39;&#39;) if status == 0: outputs = output.</description>
    </item>
    
    <item>
      <title>[译]起底 SourceKit</title>
      <link>/posts/2018/uncovering_sourcekit/</link>
      <pubDate>Sun, 08 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/uncovering_sourcekit/</guid>
      <description>作者 发表时间 原文链接     JP Simard 20140706 https://www.jpsim.com/uncovering-sourcekit/     为了支持一门奇特的新编程语言（译者注：即 Swift），漂亮的实时 IDE 特性，以及令人印象深刻的跨语言协同性（译者注：即 Swift 与 Obj-C），Apple 不得不开发一些新的底层工具。这里我们将专注于 SourceKit，Xcode 背后的功臣。
 什么是 SourceKit？ SourceKit 是一套工具集，使得大多数 Swift 源代码层面的操作特性得以支持，例如源代码解析、语法高亮、排版（typesetting）、自动补全、跨语言头文件生成，等等。
架构 传统上，Xcode 在运行时跑着其编译器（Clang），即意味着编译器将可能在任何时候崩溃，IDE 同样。
更有甚者，Xcode 容易唤起编译器进行成千上万次解析、高亮、以及排版源代码，所有这一切都在用户键入「⌘ + B」之前。这是因为不像大多数编辑器（Vim/Sublime/&amp;hellip;），Xcode 并不使用正则表达式解析源代码，而是使用 Clang 强大的（也更加复杂的）解析器（parser）和标记器（tokenizer）。
庆幸的是，Xcode 6 中的 Swift 移除了该特性1，合并所有源代码操作特性至一个独立的进程，并和 Xcode 通过 XPC 交流：sourcekitd。无论 Xcode 6 何时加载任何 Swift 代码，该 XPC 守护进程将被启动。
Xcode 如何使用 SourceKit 因为 SourceKit 是一个私有且无文档的工具，我们需要获得一些小点子来学习如何使用它。通过设定 SOURCEKIT_LOGGING2 环境变量，Xcode 将记录 SourceKit 与 stdout 间的通信，允许我们观察到它们的实时通信。这就是如何发现本文中的许多命令。</description>
    </item>
    
    <item>
      <title>iOS 项目持续集成实践（一）</title>
      <link>/posts/2018/ci_practice_in_ios-1/</link>
      <pubDate>Sat, 07 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/ci_practice_in_ios-1/</guid>
      <description>Preface 一个软件工程项目从编写、到测试、再最终交付到用户通常有很多重复且固定的步骤。虽然作为开发者，我们的核心任务是编写代码，而这些其他的步骤却也不能忽视，持续集成（Continuous Integration）则可以帮助开发者完成这些琐碎的事务，提升团队的开发效率与质量。
本文将主要介绍持续集成是什么，以及其中的好处。当然，您可能也注意到了标题后面「（一）」，没错，持续集成并非一篇文章可以概括，笔者希望尽可能将目前团队中使用到的和持续集成相关的内容进行总结，目的是为了让大家一起思考如何让持续集成更好地服务我们开发。当然，限于笔者能力，文中不免出现遗漏，也望读者能够批评和指出。
What 持续集成，译自 Continuous Integration，简称 CI（在下文中，将统一使用该英文简称）。在 Wikipedia 中，也有针对 CI 特别详细且专业的介绍。简而言之，当开发者通过版本控制系统（例如 Git）提交了代码，CI 系统将为其自动执行构建、分析、测试等服务，当前面的服务一致通过，其也能直接将产品部署到生产环境，而后进入下一个循环。其中每一步都将自动触发、执行，结果也将会自动反馈回开发者。正如下图所示，CI 的重点在于 C——持续。
Why &amp;amp; Why not 那么为什么需要 CI 呢？相比于传统的先开发，再测试，后上线的模式有哪些好处呢？在团队使用 CI 这段时间中，得出了以下主要两个好处：
 及时发现错误。CI 并不能消除错误，但 CI 将发现错误的时机尽可能地提前，所以也更加节省时间来改正错误。当开发者提交代码至代码仓库时，其对于代码的熟悉程度是最高的。如果这个时候尽可能的纠正一些错误或不当，开发者将能很快注意到并将错误改正，避免了由于时间或者团队中其他人对于代码的修改所导致的问题，提升了开发效率。 自动化。市面上的 CI 平台都给了开发者比较高的自由度，能够执行脚本或命令。因此很多自动化的操作都可以制定好，来自动化地执行，节省开发者的时间。  如果这两个显而易见的好处还不足以说服，可以参考文末 Reference 中 EKATERINA NOVOSELTSEVA 的文章。那么 CI 会不会也存在什么难处呢？
 跨技术栈。CI 并不特定于前端或者后端，CI 通常根据不同的平台而有很多不同，包括配置的方法、使用的语言、自由度等等。CI 又和 Docker 的发展有一定的关系，因此跨技术栈可能让一些团队望而却步。不过好的是，DevOps（Development &amp;amp; Operations）也在国内渐渐兴起，越来越被重视。 跨平台。这里所指的平台是指代码托管平台、CI 平台、以及部署平台。在公司开始时，可能并不能轻易考虑到后续的发展，因此在原有平台加入 CI 可能需要跨平台的协作。对于一些「黑盒」的平台，有时便难以很好的集成。不过，现在 Git 的两大平台 GitHub 和 GitLab 都很重视且支持 CI 平台，也便于开发者使用。  如果后面两个问题并没有阻挠你，那么就开始尝试 CI 吧～
How CI 并不依赖于某种特定的技术栈，其属于一种编程范式。但是，具体谈及如何实践，这就需要结合不同的工具和业务，进行定制。</description>
    </item>
    
    <item>
      <title>Zen of Git</title>
      <link>/posts/2019/zen_of_git/</link>
      <pubDate>Wed, 13 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/zen_of_git/</guid>
      <description> Preface 在现代软件开发的团队协作中，版本控制系统（Version Control System）必不可少，而 Git 已成为绝大多数的团队首选。本文将简单谈谈 Git 相关的工作流、工具链等，以及背后的思考、权衡，当然对于不同的团队，其选择侧重会略有不同，也欢迎大家互相交流。
Workflow Branch Model Rollback Toolchain GitLab Bitbucket Webhook </description>
    </item>
    
    <item>
      <title>Supervisor 的安装与基本使用</title>
      <link>/posts/2018/supervisor/</link>
      <pubDate>Sun, 06 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/supervisor/</guid>
      <description>Platform Supervisor     macOS 10.13.4 3.3.4   Raspbian 4.14 3.3.1    Info Supervisor 是 Linux/UNIX 下的一个由 Python 编写的进程管理工具，可以很方便的用来启动、重启、关闭进程。
Solution Installation macOS  使用 HomeBrew 安装
brew install supervisor   Raspbian (Linux) sudo apt-get install supervisor  Usage  安装完成后，可以在查看该默认配置，但并非所有配置项均必须定义，可根据自己需要进行配置 macOS  ; macOS - /etc/supervisord.conf [supervisord] http_port=/var/tmp/supervisor.sock ; (default is to run a UNIX domain socket server) ;http_port=127.0.0.1:9001 ; (alternately, ip_address:port specifies AF_INET) ;sockchmod=0700 ; AF_UNIX socketmode (AF_INET ignore, default 0700) ;sockchown=nobody.</description>
    </item>
    
    <item>
      <title>使用 Homebrew 安装 Jenkins</title>
      <link>/posts/2018/jenkins_by_homebrew/</link>
      <pubDate>Sun, 06 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/jenkins_by_homebrew/</guid>
      <description>Platform Notes     macOS 10.13.4 Jenkins 2.114 &amp;amp; Java 8    Solution  安装 Homebrew  /usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;   安装 Jenkins  brew install jenkins   运行 Jenkins  # 当前窗口启动（关闭窗口则关闭 Jenkins） # $JENKINS_VERSION_CODE 为版本号，$PORT 为 Jenkins Web 页面端口号 # java -jar /usr/local/Cellar/jenkins/$JENKINS_VERSION_CODE/libexec/jenkins.war --httpPort=$PORT java -jar /usr/local/Cellar/jenkins/$JENKINS_VERSION_CODE/libexec/jenkins.war --httpPort=8080 # 后台启动（关闭窗口无影响） # $OUTPUT_FILENAME 为终端输出内容存放的文件名 # nohup java -jar /usr/local/Cellar/jenkins/$JENKINS_VERSION_CODE/libexec/jenkins.</description>
    </item>
    
    <item>
      <title>使用 Homebrew 安装 MySQL</title>
      <link>/posts/2018/mysql_by_homebrew/</link>
      <pubDate>Sun, 06 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/mysql_by_homebrew/</guid>
      <description>Platform Notes     macOS 10.13.4 MySQL 5.7.21    Solution  安装 Homebrew  /usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;   安装 MySQL（注意观察可能有错误信息，比如 brew link 失败，可能要先在相应文件夹下开启「写」权限后再手动尝试）  brew install mysql   开启 MySQL 服务  # 现在启动，并加入自启动 brew services start mysql # 后台启动 mysql.server start   连接 MySQL（默认端口为 3306）  mysql -uroot   创建用户并授权  -- CREATE USER &#39;USERNAME&#39;@&#39;HOST_NAME&#39; IDENTIFIED BY &#39;PASSWORD&#39;; CREATE USER &#39;temp_user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;1234&#39;; -- GRANT PRIVILEGE ON DATABASE_NAME.</description>
    </item>
    
    <item>
      <title>简单管理多版本 JDK</title>
      <link>/posts/2018/jdk_multiple_versions/</link>
      <pubDate>Sun, 06 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/jdk_multiple_versions/</guid>
      <description>    Platform Notes     macOS 10.13.4 JDK 8 &amp;amp; 9    Solution  安装 JDK 8 &amp;amp; 9（其他版本同理） vim ~/.zsh_rc（这里使用的是 BashShell，其他 Shell 自行替换） 文末追加：  # Java export JAVA_8_HOME=$(/usr/libexec/java_home -v1.8) export JAVA_9_HOME=$(/usr/libexec/java_home -v9) # Default for Java 8 export JAVA_HOME=$JAVA_8_HOME alias java9=&#39;export JAVA_HOME=$JAVA_9_HOME&#39; alias java8=&#39;export JAVA_HOME=$JAVA_8_HOME&#39;   切换版本：java8 / java9 检查版本：java -version  Extension  jenv  </description>
    </item>
    
    <item>
      <title>在 Swift 中对集合类型元素的弱引用</title>
      <link>/posts/2018/weakly_collections/</link>
      <pubDate>Thu, 08 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/weakly_collections/</guid>
      <description>Date Notes Swift Xcode     2018-03-15 更新部分表述，并将题目扩展至集合类型 4.0 9.2   2018-03-08 首次提交 4.0 9.2    Preface 为了方便下述 Demo，这里定义一个 Pencil 类，并会使用 func CFGetRetainCount(_ cf: CoreFoundation.CFTypeRef!) -&amp;gt; CFIndex 方法，即传入一个 CFTypeRef 类型的对象即可获取其引用计数。什么是 CFTypeRef？查阅官方文档即可得知 typealias CFTypeRef = AnyObject，所以 CFTypeRef 其实就是 AnyObject。而 AnyObject 又是所有类隐含遵守的协议。
class Pencil { var type: String var price: Double init(_ type: String, _ price: Double) { self.type = type self.price = price } } CFGetRetainCount(Pencil(&amp;quot;2B&amp;quot;, 1.</description>
    </item>
    
    <item>
      <title>Swift 中的 @autoclosure</title>
      <link>/posts/2018/swift_autoclosure/</link>
      <pubDate>Sat, 13 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/swift_autoclosure/</guid>
      <description>Date Notes Swift Xcode Source Code     2018-04-05 更新并明确源代码所用版本 4.1 9.3 Swift 4.1 Release   2018-01-13 首次提交 4.0.3 9.2 -    What  Closures are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.
— The Swift Programming Language (Swift 4.</description>
    </item>
    
    <item>
      <title>WWDC17 - 819 Designing for a Global Audience</title>
      <link>/posts/2017/wwdc-17-819/</link>
      <pubDate>Mon, 03 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/wwdc-17-819/</guid>
      <description>Date Notes     2017-07-03 首次提交     WWDC 2017 是苹果开发者大会的 2017 版。Session 822 简要介绍了为什么要将 App 为全球受众适配，以及其中的一些注意点。
 Why  更好的用户体验（Better user experience）
 不要仅仅止步于言语和插图不冒犯用户。  拓展机遇（Expansion opportunities）
  How  制定计划（Make a plan）
 制定下一个将要适配的国家和语言，可以参考 iTunes Connect 中的一些信息。  识别用户（Identify users）
 考虑交流（Think about communication）
 重要优先（Prioritize important localization work）
  语言  替代语（Substitutions） 部分翻译（Partial translation）
 头部，标题（Headings, titles） 关键性的指导（Critical instructions） 关键词（Keywords） 错误信息（Error messages）  非正式用语（Informal language）</description>
    </item>
    
    <item>
      <title>WWDC17 - 822 App Icon Design</title>
      <link>/posts/2017/wwdc-17-822/</link>
      <pubDate>Mon, 03 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/wwdc-17-822/</guid>
      <description>    Date Notes     2017-07-03 首次提交     WWDC 2017 是苹果开发者大会的 2017 版。Session 822 简要介绍了设计 App 的图标（Icon）时需要注意的点。
 图标设计  象征（Metaphor）
 即人们可以根据图标所联想的事物。  简约（Simplicity）
 清晰简约，可读性强。  连接（Connection）
 图标是用户和应用的桥梁，要有趣，有启发性。  家系（Lineage）
 图标的改变要慎重，有一致性。   设计过程  唯一（Unique）
 在应用的分类中脱颖而出。  体验（Experiment）
 开始可以手绘，也可以与他人共同体验。  测试（Test）
 在桌面，文件夹，设置中测试图标的效果。  耐心（Patience）
  Reference  WWDC 17 - 822 App Icon Design  </description>
    </item>
    
    <item>
      <title>WWDC17 - 102 Platform State of the Union</title>
      <link>/posts/2017/wwdc-17-102/</link>
      <pubDate>Sun, 02 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/wwdc-17-102/</guid>
      <description>Date Notes Swift Xcode     2017-07-02 首次提交 4.0 beta 9.0 beta     WWDC 2017 是苹果开发者大会的 2017 版，今年的更新很多，而且涉及多种平台，开发工具，以及 Swift 语言本身。102 这场演讲涉及了新系统以及新工具中的 features，但没有过多深入。因为后续还有更加独立的 Session 可供我们学习，查看，所以本文仅涉及本人认为需要的内容。关于 Metal 2 和 VR 距离我个人能力所及较远，本文也没有提及。
 macOS  macOS High Sierra 将是最后一个支持 32 位程序的 macOS 版本。 App Store 64 位 App: 2018.01 新 App 务必支持；2018.07 所有 App 务必支持。  Playground 2.0  将集成 API 文档，且支持 AR。  Xcode 9  支持 Swift，Objective-C，C/C++ 重构。 构建速度加快，打包后体积更小。  String  String 在 Swift 4.</description>
    </item>
    
    <item>
      <title>WWDC17 - 823 Designing Glyphs</title>
      <link>/posts/2017/wwdc-17-823/</link>
      <pubDate>Sun, 02 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/wwdc-17-823/</guid>
      <description>Date Notes     2017-07-02 首次提交     WWDC 2017 是苹果开发者大会的 2017 版。Session 823 简要介绍了 Glyph（字形，符号等）的设计原则等。
 Glyph &amp;amp; Icon  Glyph 是单色的，可以用代码（程序化）添加颜色。 Icon 是彩色的，高渲染的资源文件。  高效的 Glyph 设计原则  简化的形式（Simplified form） 统一的象征（Universal symbology）
 在不同的语言环境，生活环境都能清晰无歧义辨识的标志  上下文中可读性高（Quickly readable in context）
  Glyph 在系统中的使用场景  macOS
 Menu bars Tool bars Touch bar  iOS
 Tab bars List views Quick menu (3D Touch) 要比应用内部更大且更重   Glyph 的设计考量  视觉重心（Optical weight）</description>
    </item>
    
    <item>
      <title>浅谈 iOS 应用启动过程</title>
      <link>/posts/2017/ios_app_start_up/</link>
      <pubDate>Tue, 28 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/ios_app_start_up/</guid>
      <description>Date Notes Swift Xcode     2017-05-26 CS193p UIApplication 3.1 8.3.2   2017-03-28 首次提交 3.0 8.2.1    Preface 首先要感谢没故事的卓同学大大送的泊学会员，在泊学学了几节课，了解了很多不同角度的 iOS 开发知识。这篇文章就启发自其 iOS 101 中的一个纯手工的 Single View Application 一文。但本文将更加深入的叙述了启动过程，且实现均为 Swift 3.0。
本文对应的 Demo 可以在：https://github.com/kingcos/SingleViewAppManually-Demo 查看、下载。
Manually or Storyboard main.m in Objective-C Single View Application
#import &amp;lt;UIKit/UIKit.h&amp;gt; #import &amp;quot;AppDelegate.h&amp;quot; int main(int argc, char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } }   自从 Storyboard 诞生以来，关于纯代码、Xib、以及 Storyboard 的选择就在 iOS 开发圈中炸开了锅。这里不会探讨各种姿势的优劣，只是可能很多和我一样的初学者，从一开始就被 Storyboard 先入为主。加上方便灵活的拖控件，自然而然就可能没有机会去思考一个 iOS 应用是如何启动起来的。加上 Swift 的诞生，使得整个项目的初始结构得到了更大的简化（少了 main.</description>
    </item>
    
    <item>
      <title>从 0 开始使用 Docker 快速搭建 Hadoop 集群环境</title>
      <link>/posts/2017/docker_for_hadoop/</link>
      <pubDate>Mon, 27 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/docker_for_hadoop/</guid>
      <description>Date Notes Hadoop Other     2017-03-27 首次提交 2.7.2 Docker CE, IntelliJ IDEA 2016.3    Preface 自从学习 iOS/Swift 以来，就没有太多时间分配给 Java 专业课，毕竟我不是个三心二用还能样样学好的人。不过作为大三的专业课，分布式计算技术还是有去上课的，毕竟不能最后挂科吧 :]
曾有人说，「开发一个项目，至少有 50% 时间在配置环境」。确实，在折腾了三周的课时之后，我才按照老师给的详细步骤配置好 Hadoop 的环境。尽管如此，由于种种原因，班里仍有很多同学还没有配置好 Hadoop 的环境，导致课程一直停滞。在偶然中，我想到了 Docker，Docker 这个词我至少在半年前已经听说（当然，恕我孤陋寡闻，Docker 早在 13 年即发行），但一直没有去了解和使用。时至今日，我对 Docker 的了解也十分少，简单的来说，Docker 是一种容器（Container）管理工具，通过 Docker 我们可以配置可移植的环境，方便发布。Docker 基于 Linux，但也提供了 macOS 和 Windows 桌面版，方便在我们的本地机器测试、使用。
虽然本文是一个小白向的文章，但下载和安装的过程也不会在本文涉及。一是官方网站必然提供了相应的教程，纯粹的翻译毫无意义；二是下载和安装可能随着后续更新发生略微的区别，而本文只着眼于配置 Hadoop 集群环境的搭建。
不过由于个人对 Hadoop 和 Docker 的了解甚少，如有错误，希望指出，我会学习、改正。
Linux  Info: Ubuntu 16.10 x64   Docker 本身就是基于 Linux 的，所以首先以我的一台服务器做实验。虽然最后跑 wordcount 已经由于内存不足而崩掉，但是之前的过程还是可以参考的。</description>
    </item>
    
    <item>
      <title>探究 UIViewController 生命周期</title>
      <link>/posts/2017/uiviewcontroller_life_cycle/</link>
      <pubDate>Fri, 10 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/uiviewcontroller_life_cycle/</guid>
      <description>Date Notes Swift Xcode     2017-03-10 首次提交 3.0 8.2.1    前言 对象的生命周期一直是开发者所需要关心的，教授 CS193p 的老师 Paul 也详细的讲述了 UIViewController 的生命周期。为了记述这一过程，故作此文。由于 Xcode 提供了纯代码和 Storyboard（Xib 同理）两种布局 UI 的方式，因此初始化部分略有不同。
为了方便观察，我创建了一个 BaseViewController，继承自原本的 UIViewController，重写其中的生命周期方法，并让后续新的控制器继承自该控制器，以便观察。
本文对应的 Demo 可以在 https://github.com/kingcos/UIViewController-UIView-LifecycleDemo 查看、下载。
Initialization Storyboard  OUTPUT:
 init(coder:) awakeFromNib()   init(coder:)  当使用 Storyboard 时，控制器的构造器为 init(coder:)。 该构造器为必需构造器，如果重写其他构造器，则必须重写该构造器。 该构造器为可失败构造器，即有可能构造失败，返回 nil。 该方法来源自 NSCoding 协议，而 UIViewController 遵从这一协议。 该方法被调用意味着控制器有可能（并非一定）在未来会显示。 在控制器生命周期中，该方法只会被调用一次。  awakeFromNib()  当使用 Storyboard 时，该方法会被调用。 当调用该方法时，将保证所有的 outlet 和 action 连接已经完成。 该方法内部必须调用父类该方法，虽然默认实现为空，但 UIKit 中许多类的该方法为非空。 由于控制器中对象的初始化顺序不能确定，所以构造器中不应该向其他对象发送消息，而应当在 awakeFromNib() 中安全地发送。 通常使用 awakeFromNib() 可以进行在设计时无法完成的必要额外设置。  Code  OUTPUT: - init(nibName:bundle:) - NibName: nil, Bundle: nil</description>
    </item>
    
    <item>
      <title>Swift 中的 Selector</title>
      <link>/posts/2017/swift_selector/</link>
      <pubDate>Tue, 31 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/swift_selector/</guid>
      <description>Date Notes Swift Xcode     2017-01-31 首次发布（简书 &amp;amp; 掘金） 3.0 8.2.1    Preface  Focus，即专注。笔者希望可以尽力将一些不是那么透彻的点透过 Demo 和 Source Code 而看到其本质。由于国内软件开发仍很大程度依赖国外的语言、知识，所以该博客中的术语将使用英文表述，除非一些特别统一的词汇或整段翻译时将使用中文，但也会在首次提及时标注英文。笔者英文水平有限，这样的目的也是尽可能减少歧义，但在其中不免有所错误，遗漏，还请大家多多批评、指正。
本文及更新会首发于笔者的 GitHub 的 Perspective 仓库：https://github.com/kingcos/Perspective，欢迎 Star 🌟。
 What 常用纯代码来开发的同学都应该比较熟悉这个方法：
func addTarget(_ target: Any?, action: Selector, for controlEvents: UIControlEvents)  Selector 源自 Objective-C，例如 SEL 类型，以及 @selector() 方法选择器。Swift 中也兼容了这个概念，不过随着 Swift 的迭代，Selector 的一些写法也出现了很大的变化。比较遗憾的是，官方文档对于 Selector 没有介绍。
因此只能自己总结一下 Swift 3.0 中的 Selector，便有利于自己理解，也便于以后的参考。注：以下 Demo 中的 cyanButton 是用 StoryBoard 拖拽的。</description>
    </item>
    
    <item>
      <title>浅谈 Swift 中的属性（Property）</title>
      <link>/posts/2016/swift_properties/</link>
      <pubDate>Wed, 26 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/2016/swift_properties/</guid>
      <description>Date Notes Swift Xcode     2017-04-27 扩充 #延迟存储属性# 部分并新增 #devxoul/Then# 3.1 8.3.2   2016-10-26 首次提交 3.0 8.1 Beta 3    前言 Swift 中的属性分为存储属性与计算属性，存储属性即为我们平时常用的属性，可以直接赋值使用，而计算属性不直接存储值，而是根据其他（存储）属性计算得来的值。
在其他面向对象的编程语言中，例如 Java 和 Objective-C 中，get 和 set 方法提供了统一、规范的接口，可以使得外部访问或设置对象的私有属性，而不破坏封装性，也可以很好的控制权限（选择性实现 get 或 set 方法）。而 Swift 中似乎并没有见到类似的 get 和 set 方法，而 Swift 使用了一种名为属性观察器的概念来解决该问题。
本文简单介绍下 Swift 中的这两种属性，以及属性观察器。
延迟存储属性  存储属性使用广泛，即是类或结构体中的变量或常量，可以直接赋初始值，也可以修改其初始值（仅指变量）。 延迟存储属性是指第一次使用到该变量再进行运算（这里的运算不能依赖其他成员属性，但可以使用静态／类属性）。 延迟存储属性必须声明为 var 变量，因为其属性值在对象实例化前可能无法得到，而常量必须在初始化完成前拥有初始值。 在 Swift 中，可以将消耗性能才能得到的值作为延迟存储属性，即懒加载。 全局的常量和变量也是延迟存储属性，但不需要显式声明为 lazy（不支持 Playground）。  Demo  这里假定在 ViewController.</description>
    </item>
    
    <item>
      <title>Git/GitHub－Note</title>
      <link>/posts/2015/depr_gitgithub-notes/</link>
      <pubDate>Tue, 24 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_gitgithub-notes/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
The things U must know about Git/GitHub.
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>如何解决 MySQL 中文数据问题</title>
      <link>/posts/2015/depr_mysqlqa/</link>
      <pubDate>Wed, 18 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_mysqlqa/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
These tips are just backup for myself.
If something was wrong, please tell me.
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>iDay-11.12 ~ 12.20</title>
      <link>/posts/2015/depr_idaily/</link>
      <pubDate>Fri, 13 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_idaily/</guid>
      <description>本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。
This article is archived from my previous blog, so the content maybe have changed now.
  2015.11.12  现在已是 11 月 13 日凌晨 0: 30 分左右，我一个人还在电脑旁。宿舍的其他人都睡了，这次是真的睡，没有什么人玩手机。
很早之前想在博客上加一个 Time Line 的功能但是没有深究，因为我不想在微博上大放厥词（可能言重了吧，毕竟我只是想督促自己），可能会在未来尝试加上吧&amp;hellip; 这种类似日记的形式我想坚持下去。
不知怎么回事，感觉这学期时间过得飞快，我还没做几期电台，Swift 还没学多少，Java 也没看了，数据结构也放下了，我又不玩游戏，我的时间去哪里了？这已经是第十周了，还有两周专业课结课，接着四级考试，再几周全部结课，到放寒假大概不到两个月。
大概计划下未来几周吧，毕竟我是个爱列计划的人，感觉这样会有信心：
 四级词汇视频至少过 2 遍，可以选择空余时间观看； 四级词汇背诵笔记，高频，单词书，这个主要依靠不需要听课的一些课上学习； 编程方面，必须看完 J4A，数据结构，Swift 书可以暂缓。  至于本周：
 J4A 看完，做完笔记 四级词汇视频刷完第一遍，搞定笔记，开始第二轮 填坑电台！！！ 数据结构实验三  今年必须要做出点东西来，四级也必须要过，我已经感觉到自己碌碌无为了，虽然自我感觉并没有玩多少，但是学的不多，效率也低。新开辟了 English 分类，未来可能将整理的笔记上传，方便自己学习。
Fight!!!
Good night, strangers.
by V. 2015.11.13 00:40 NY
 2015.11.13  现在是 13 日晚上 23:45，卓越班群里有两个大神再吹今后要学的东西。说实话，我个人没听懂很多名词，惭愧。</description>
    </item>
    
    <item>
      <title>Java 程序语言设计小作业</title>
      <link>/posts/2015/depr_javawf/</link>
      <pubDate>Wed, 28 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_javawf/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
Java 代码——在 URL 使用 SAX 解析 XML
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>What Have I Learnt From This Chapter</title>
      <link>/posts/2015/depr_cs-c2-bcc/</link>
      <pubDate>Tue, 13 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_cs-c2-bcc/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
NIT Excellent Engineer Program.
Thanks for Thomas.
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>The Second Half of 2015 Plan</title>
      <link>/posts/2015/depr_the-2nd-half-year-plan/</link>
      <pubDate>Tue, 22 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_the-2nd-half-year-plan/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
计划还是要有的，万一完成了呢？
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Learning Swift 2.1 - Note &amp; Code</title>
      <link>/posts/2015/depr_swift-2/</link>
      <pubDate>Sat, 19 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_swift-2/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
Based on
[The Swift Programming Language](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/)
Swift 2 Edition
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>初学 Java 4 Android - Note &amp; Code</title>
      <link>/posts/2015/depr_j4a/</link>
      <pubDate>Sun, 13 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_j4a/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
源自《[Java 4 Android](http://study.163.com/course/courseMain.htm?courseId=201001)》-- [Mars](http://www.marschen.com/portal.php)
如有错误，希望指出。
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Tapole 记（下）</title>
      <link>/posts/2015/depr_1st-tapole_3/</link>
      <pubDate>Fri, 21 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_1st-tapole_3/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
已经不记得自己的眼睛是何时近视的了，
架在鼻上，挂在耳边，放在眼前的眼镜已经和我离不开了。
Tapole 的最终产品终于来到，这样一款非数码产品的开箱体验会是什么呢...
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Tapole 记（中）</title>
      <link>/posts/2015/depr_1st-tapole_2/</link>
      <pubDate>Sun, 16 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_1st-tapole_2/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
已经不记得自己的眼睛是何时近视的了，
架在鼻上，挂在耳边，放在眼前的眼镜已经和我离不开了。
Tapole 免费试戴的镜架到了，让我们一起来看看吧...
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Tapole 记（上）</title>
      <link>/posts/2015/depr_1st-tapole_1/</link>
      <pubDate>Sun, 09 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_1st-tapole_1/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
已经不记得自己的眼睛是何时近视的了，
架在鼻上，挂在耳边，放在眼前的眼镜已经和我离不开了。
作为一名普通消费者加天秤座，来跟我一起看看网上配镜前的纠结吧...
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>寻找下一个地球</title>
      <link>/posts/2015/depr_finding-another-earth/</link>
      <pubDate>Sat, 01 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_finding-another-earth/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
人类在宇宙中是如此的渺小，却又如此的幸运。这个蓝色星球承载着我们的一切。
宇宙如此广袤，地球绝不是孑然一身，让我们跟着 NASA，寻找下一个地球...
*本文摘自 NASA 官方网站的一篇题为“[Finding Another Earth](http://www.nasa.gov/jpl/finding-another-earth)”的文章，经本人翻译放出。*
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>这一年，我，去哪里了...</title>
      <link>/posts/2015/depr_where-did-i-go/</link>
      <pubDate>Thu, 23 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_where-did-i-go/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
这篇文章原本计划给某些人看的，不过，这里还不想被人发现，还是等更好的时候吧。
文笔不好，从小写作难，情商低，大家小心被吓着。
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 编程代码风格指南</title>
      <link>/posts/2015/depr_cpp_style_guide/</link>
      <pubDate>Fri, 17 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_cpp_style_guide/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;PS: 为本文标题增加空格 &amp;amp; 内容表格格式修复&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;前言：
本文翻译自&lt;a href=&#34;http://geosoft.no/development/cppstyle.html&#34;&gt;C++ Programming Style Guidelines原文地址&lt;/a&gt;
参考资料：Google机翻
本文仅供参考，如有错误希望指出。如有侵权，会立即删除，决不用于商业用途。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>2015 年 3 月苹果发布会后感</title>
      <link>/posts/2015/depr_apple-conference_03/</link>
      <pubDate>Sat, 04 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_apple-conference_03/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
Apple Watch, new MacBook...
Designed by Apple 还有哪些亮点呢？
让我们谈谈这次的 Apple 发布会吧。
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Count On Me 歌词翻译</title>
      <link>/posts/2015/depr_count-on-me/</link>
      <pubDate>Fri, 03 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_count-on-me/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
Count On Me 是一首很暖心的歌（原唱 Bruno Mars）。
Connie Talbot 的翻唱的却充满童真，
让我们一起欣赏下吧～
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>The First Half of 2015 Plan</title>
      <link>/posts/2015/depr_the-1st-half-year-plan/</link>
      <pubDate>Sat, 21 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_the-1st-half-year-plan/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
计划还是要有的，万一完成了呢？
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>王自如对话 Moto 总裁 Rick Osterloh</title>
      <link>/posts/2015/depr_moto/</link>
      <pubDate>Sun, 01 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_moto/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
Moto回来了。
这次的回归是否能使它在国内的市场涅磐重生？
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>How To Choose A P.C. In 2014?</title>
      <link>/posts/2014/depr_how-to-choose-pc/</link>
      <pubDate>Mon, 09 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>/posts/2014/depr_how-to-choose-pc/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
本文的一些观点略有过时。
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>How To Choose A Phone In 2014?</title>
      <link>/posts/2014/depr_how-to-choose-phone/</link>
      <pubDate>Mon, 09 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>/posts/2014/depr_how-to-choose-phone/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
本文在此留存使用，
对于现在想找我推荐手机的，
答案只有 iPhone。
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>骑车回家幻想记</title>
      <link>/posts/2013/depr_dreaming-in-the-way/</link>
      <pubDate>Fri, 26 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>/posts/2013/depr_dreaming-in-the-way/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
高中每周往返于学校与家之间的路上的那段时光，
聆听了这座城市聒噪，
思考过许多的无意义，
文字无法记起那一段路程，更无法承受我对这里的爱。
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>仅以此文献给高班和总统</title>
      <link>/posts/2013/depr_only-fot-gyylmb/</link>
      <pubDate>Sat, 06 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>/posts/2013/depr_only-fot-gyylmb/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote class=&#34;blockquote-center&#34;&gt;
有些人始终只能存在于记忆之中，
这...也许是为了未来的重逢吧...
此文最早由本人发表于萌面大道吧，
为留存以纪念后转于此。
&lt;/blockquote&gt;</description>
    </item>
    
  </channel>
</rss>