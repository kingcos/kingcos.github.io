<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Learning Swift 2.1 - Note &amp; Code :: iBlog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content=" Êú¨Êñá‰∏∫Â∑≤ÂΩíÊ°£ÁöÑÂéÜÂè≤ÂçöÂÆ¢ÂÜÖÂÆπÔºåÂÖ∂ÂÜÖÂÆπÂèØËÉΩÈöèÁùÄÊó∂Èó¥ÂèëÁîüÂ∑≤ÁªèÊîπÂèò„ÄÇ
This article is archived from my previous blog, so the content maybe have changed now.
 Based on [The Swift Programming Language](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/) Swift 2 Edition "/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2015/depr_swift-2/" />


<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/green.css">



<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="/img/favicon/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Learning Swift 2.1 - Note &amp; Code :: iBlog ‚Äî " />
<meta name="twitter:description" content=" Êú¨Êñá‰∏∫Â∑≤ÂΩíÊ°£ÁöÑÂéÜÂè≤ÂçöÂÆ¢ÂÜÖÂÆπÔºåÂÖ∂ÂÜÖÂÆπÂèØËÉΩÈöèÁùÄÊó∂Èó¥ÂèëÁîüÂ∑≤ÁªèÊîπÂèò„ÄÇ
This article is archived from my previous blog, so the content maybe have changed now.
 Based on [The Swift Programming Language](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/) Swift 2 Edition " />
<meta name="twitter:site" content="/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Learning Swift 2.1 - Note &amp; Code :: iBlog ‚Äî ">
<meta property="og:description" content=" Êú¨Êñá‰∏∫Â∑≤ÂΩíÊ°£ÁöÑÂéÜÂè≤ÂçöÂÆ¢ÂÜÖÂÆπÔºåÂÖ∂ÂÜÖÂÆπÂèØËÉΩÈöèÁùÄÊó∂Èó¥ÂèëÁîüÂ∑≤ÁªèÊîπÂèò„ÄÇ
This article is archived from my previous blog, so the content maybe have changed now.
 Based on [The Swift Programming Language](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/) Swift 2 Edition " />
<meta property="og:url" content="/posts/2015/depr_swift-2/" />
<meta property="og:site_name" content="Learning Swift 2.1 - Note &amp; Code" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2015-09-19 00:00:00 &#43;0000 UTC" />











</head>
<body class="">


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    iBlog
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About &amp; AMA</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About &amp; AMA</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/2015/depr_swift-2/">Learning Swift 2.1 - Note &amp; Code</a></h1>
  <div class="post-meta">
    <span class="post-date">
      2015-09-19
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/deprecated/">Deprecated</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    <blockquote>
<p>Êú¨Êñá‰∏∫Â∑≤ÂΩíÊ°£ÁöÑÂéÜÂè≤ÂçöÂÆ¢ÂÜÖÂÆπÔºåÂÖ∂ÂÜÖÂÆπÂèØËÉΩÈöèÁùÄÊó∂Èó¥ÂèëÁîüÂ∑≤ÁªèÊîπÂèò„ÄÇ<br>This article is archived from my previous blog, so the content maybe have changed now.</p>
</blockquote>

<hr />

<blockquote class="blockquote-center">
Based on
[The Swift Programming Language](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/)
Swift 2 Edition
</blockquote>

<blockquote>
<p>Intro:
This document couldn&rsquo;t be absolutely correct.
Please tell me about the mistakes.
Skip <em>Welcome to Swift</em>.</p>
</blockquote>

<p><strong>Info:</strong></p>

<ul>
<li>Mac OS X 10.11</li>
<li>Xcode 7+ (<a href="https://developer.apple.com/downloads/">From HERE</a>)</li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/">The Swift Programming Language Swift 2 Edition (From iBooks)</a></li>
<li><a href="https://developer.apple.com/library/ios/navigation/#">Apple Developer</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/swift/">The Swift Programming Language (Swift 2) ‰∏≠ÊñáÁâà</a></li>
</ul>

<hr />

<h2 id="language-guide">Language Guide</h2>

<hr />

<h3 id="enumerations">Enumerations</h3>

<p>Enumerations in Swift are first-class types in their own right. They adopt many features traditionally supported only by classes, such as computed properties to provide additional information about the enumeration‚Äôs current value, and instance methods to provide functionality related to the values the enumeration represents. Enumerations can also define initializers to provide an initial member value; can be extended to expand their functionality beyond their original implementation; and can conform to protocols to provide standard functionality.</p>

<h4 id="enumeration-syntax-matching-enumeration-values-with-a-switch-statement">Enumeration Syntax &amp;&amp; Matching Enumeration Values with a Switch Statement</h4>

<p>In the <code>CompassPoint</code> example above, <code>North</code>, <code>South</code>, <code>East</code> and <code>West</code> do <em>not</em> implicitly equal <code>0</code>, <code>1</code>, <code>2</code> and <code>3</code>. Instead, the different enumeration members are fully-fledged values in their own right, with an explicitly-defined type of <code>CompassPoint</code>.</p>

<p>In Swift, their names (such as <code>CompassPoint</code>) should start with a capital letter.</p>

<pre><code class="language-swift">enum bestWebsites {
    case v2ex, dgtle, sspai, maimieng
}

var bw = bestWebsites.v2ex
bw = .maimieng
switch bw {
case .v2ex:
    print(&quot;Way to explore.&quot;)
case .dgtle:
    print(&quot;About digtle life.&quot;)
case .sspai:
    print(&quot;About news of iOS &amp; Android.&quot;)
case .maimieng:
    print(&quot;My blog&quot;)
}
</code></pre>

<h4 id="associated-values">Associated Values</h4>

<pre><code class="language-swift">enum Apple {
    case hardware(String, Int, String)
    case software(String, Int)
}

var product2015 = Apple.hardware(&quot;iPhone&quot;, 5288, &quot;16 G&quot;)
product2015 = .software(&quot;Apple Music&quot;, 10)

switch product2015 {
case .hardware(let productName, let price, let deviceRom):
    print(&quot;The device name is \(productName), the price is \(price), the device rom is \(deviceRom).&quot;)
case var .software(productName, feesPerMonth):
    print(&quot;The software name is \(productName), the fees per month is \(feesPerMonth)¬•.&quot;)
}

// DISPLAY:
// The software name is Apple Music, the fees per month is 10¬•.
</code></pre>

<h4 id="raw-values">Raw Values</h4>

<p>Associated values are set when you create a new constant or variable based on one of the enumeration‚Äôs members, and can be different each time you do so.</p>

<pre><code class="language-swift">enum platformOfProgrammingLanguage: String {
    case Android =  &quot;Java&quot;
    case iOS = &quot;Swift&quot;
}
</code></pre>

<h4 id="implicitly-assigned-raw-values-initializing-from-a-raw-value">Implicitly Assigned Raw Values &amp; Initializing from a Raw Value</h4>

<pre><code class="language-swift">enum platformOfProgrammingLanguage: String {
    case Android
    case iOS
}

print(platformOfProgrammingLanguage.iOS.rawValue)
print(platformOfProgrammingLanguage(rawValue: &quot;C++&quot;))

// DISPLAY:
// iOS
// nil
</code></pre>

<h4 id="recursive-enumerations">Recursive Enumerations</h4>

<pre><code class="language-swift">
</code></pre>

<hr />

<h3 id="closures">Closures</h3>

<p>Global functions are closures that have a name and do not capture any values.
Nested functions are closures that have a name and can capture values from their enclosing function.
Closure expressions are unnamed closures written in a lightweight(<code>adj.ËΩª‰æøÁöÑ</code>) syntax that can capture values from their surrounding context.</p>

<h4 id="closure-expressions">Closure Expressions</h4>

<pre><code class="language-swift">let website = [&quot;v2ex&quot;, &quot;maimieng&quot;, &quot;apple&quot;, &quot;github&quot;]
</code></pre>

<h5 id="the-sort-method">The Sort Method</h5>

<pre><code class="language-swift">func test1(s1: String, s2: String) -&gt; Bool {
    return s1 &gt; s2
}

print(website.sort(test1))

// DISPLAY:
// [&quot;v2ex&quot;, &quot;maimieng&quot;, &quot;github&quot;, &quot;apple&quot;]
</code></pre>

<h5 id="closure-expression-syntax">Closure Expression Syntax</h5>

<p><code>{ (parameters) -&gt; returnType in statements }</code></p>

<pre><code class="language-swift">var p = website.sort({ (s1: String, s2: String) -&gt; Bool in
    return s1 &gt; s2
})
</code></pre>

<h5 id="inferring-type-from-context">Inferring Type From Context</h5>

<pre><code class="language-swift">var p = website.sort( { s1, s2 in return s1 &gt; s2 } )```

##### Implicit Returns from Single-Expression Closures

```swift
var p = website.sort( { s1, s2 in s1 &gt; s2 } )
</code></pre>

<h5 id="shorthand-argument-names">Shorthand Argument Names</h5>

<pre><code class="language-swift">var p = website.sort( { $0 &gt; $1 } )
</code></pre>

<h5 id="operator-functions">Operator Functions</h5>

<pre><code class="language-swift">var p = website.sort(&gt;)
</code></pre>

<h4 id="trailing-v-Ë∑üË∏™-closures">Trailing(<code>v.Ë∑üË∏™</code>) Closures</h4>

<pre><code class="language-swift">var p = website.sort() { $0 &gt; $1 }

var q = website.sort { $0 &gt; $1 }
</code></pre>

<pre><code class="language-swift">let digitNames = [
    0: &quot;Zero&quot;, 1: &quot;One&quot;, 2: &quot;Two&quot;,   3: &quot;Three&quot;, 4: &quot;Four&quot;,
    5: &quot;Five&quot;, 6: &quot;Six&quot;, 7: &quot;Seven&quot;, 8: &quot;Eight&quot;, 9: &quot;Nine&quot;
]
let numbers = [16, 58, 510]

var s = numbers.map {
    (var number) -&gt; String in
    var output = &quot;&quot;
    while number &gt; 0 {
        output = digitNames[number % 10]! + output
        number /= 10
    }
    return output
}

print(s)

// DISPLAY:
// [&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]
</code></pre>

<h4 id="capturing-values-closures-are-reference-types">Capturing Values &amp; Closures Are Reference Types</h4>

<pre><code class="language-swift">func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int {
    var runningTotal = 0
    func incrementor() -&gt; Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementor
}
let incrementByTen = makeIncrementor(forIncrement: 10)
let incrementBySeven = makeIncrementor(forIncrement: 7)
let alsoIncrementByTen = incrementByTen

print(makeIncrementor(forIncrement: 10)())
print(makeIncrementor(forIncrement: 10)())
print(incrementByTen())
print(incrementByTen())

print(incrementBySeven())
print(incrementBySeven())

print(incrementByTen())

print(alsoIncrementByTen())

// DISPLAY:
// 10
// 10
// 10
// 20
// 7
// 14
// 30
// 40
</code></pre>

<h4 id="autoclosures">Autoclosures</h4>

<p><strong>DIFFICULT TO UNDERSTAND!</strong></p>

<p>An autoclosure lets you delay evaluation, because the code inside isn‚Äôt run until you call the closure.</p>

<pre><code class="language-swift">var customersInLine = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]
let nextCustomer = { customersInLine.removeAtIndex(0) }
print(customersInLine.count)

print(&quot;Now serving \(nextCustomer())!&quot;)
print(customersInLine.count)

func serveNextCustomer(customer: () -&gt; String) {
    print(&quot;Now serving \(customer())!&quot;)
}
serveNextCustomer( { customersInLine.removeAtIndex(0) } )
print(customersInLine.count)

func serveNextCustomer(@autoclosure customer: () -&gt; String) {
    print(&quot;Now serving \(customer())!&quot;)
}
serveNextCustomer(customersInLine.removeAtIndex(0))
print(customersInLine.count)

var customerClosures: [() -&gt; String] = []
func collectCustomerClosures(@autoclosure(escaping) customer: () -&gt; String) {
    customerClosures.append(customer)
}
collectCustomerClosures(customersInLine.removeAtIndex(0))
collectCustomerClosures(customersInLine.removeAtIndex(0))

print(&quot;Collected \(customerClosures.count) closures.&quot;)

for customerClosure in customerClosures {
    print(&quot;Now serving \(customerClosure())!&quot;)
}

// DISPLAY:
// 5
// Now serving Chris!
// 4
// Now serving Alex!
// 3
// Now serving Ewa!
// 2
// Collected 2 closures.
// Now serving Barry!
// Now serving Daniella!
</code></pre>

<hr />

<h3 id="functions">Functions</h3>

<h4 id="defining-and-calling-functions">Defining and Calling Functions</h4>

<pre><code class="language-swift">func website(a: String) -&gt; String {
    return &quot;http://&quot; + a + &quot;.com&quot;
}

print(website(&quot;maimieng&quot;))

// DISPLAY:
// http://maimieng.com
</code></pre>

<h4 id="function-parameters-and-return-values">Function Parameters and Return Values</h4>

<h5 id="functions-without-parameters">Functions Without Parameters</h5>

<pre><code class="language-swift">func sayHelloWorld() -&gt; String {
    return &quot;hello, world&quot;
}
print(sayHelloWorld())

// DISPLAY:
// hello, world
</code></pre>

<h4 id="functions-with-multiple-parameters">Functions With Multiple Parameters</h4>

<p>When calling a function with more than one parameter, any argument after the first is <strong>labeled</strong> according to its corresponding parameter name.</p>

<pre><code class="language-swift">func swap(a: Int, b: Int) -&gt; (Int, Int) {
    return (b, a)
}

print(swap(1, b: 2))

// DISPLAY:
// (2, 1)
</code></pre>

<h5 id="functions-without-return-values">Functions Without Return Values</h5>

<pre><code class="language-swift">func spell(s: String) {
    for c in s.characters {
        print(c)
    }
}

print(spell(&quot;iOS&quot;))

// DISPLAY:
// i
// O
// S
// ()

func count(s: String) -&gt; Int {
    return s.characters.count
}

func c(s: String) {
    count(s)
}

print(count(&quot;Swift&quot;))
print(c(&quot;Swift&quot;))

// DISPLAY:
// 5
// ()
</code></pre>

<h5 id="functions-with-multiple-return-values-optional-tuple-return-types">Functions with Multiple Return Values &amp; Optional Tuple Return Types</h5>

<pre><code class="language-swift">func findMinMax(array: [Int]) -&gt; (min: Int, max: Int)? {
    if array.isEmpty { return nil }
    var cMin = array[0]
    var cMax = array[0]
    for value in array[1..&lt;array.count] {
        if value &lt; cMin {
            cMin = value
        } else if value &gt; cMax {
            cMax = value
        }
    }
    return (cMin, cMax)
}

print(findMinMax([3, 1, 4, 1, 5, 9]))
print(findMinMax([]))

// DISPLAY:
// Optional((1, 9))
// nil
</code></pre>

<h4 id="function-parameter-names">Function Parameter Names</h4>

<h5 id="specifying-external-parameter-names">Specifying External Parameter Names</h5>

<p>If you provide an external parameter name for a parameter, that external name must <em>always</em> be used when you call the function.</p>

<pre><code class="language-swift">func sayHello(to person: String, and anotherPerson: String) -&gt; String {
    return &quot;Hello \(person) and \(anotherPerson)!&quot;
}
print(sayHello(to: &quot;Bill&quot;, and: &quot;Ted&quot;))

// DISPLAY:
// Hello Bill and Ted!
</code></pre>

<h5 id="omitting-external-parameter-names">Omitting External Parameter Names</h5>

<p>Because the first parameter omits its external parameter name by default, explicitly writing an underscore is extraneous(<code>adj.Êó†ÂÖ≥ÁöÑ</code>).</p>

<pre><code class="language-swift">func someFunction(firstParameterName: Int, _ secondParameterName: Int) {
}
someFunction(1, 2)
</code></pre>

<h5 id="default-parameter-values">Default Parameter Values</h5>

<pre><code class="language-swift">func test(a: Int = 1) {
    print(a)
}

test()
test(5)

// DISPLAY:
// 1
// 5
</code></pre>

<h5 id="variadic-adj-ÂèØÂèòÁöÑ-parameters">Variadic(<code>adj.ÂèØÂèòÁöÑ</code>) Parameters</h5>

<p>A function may have at most one variadic parameter.</p>

<pre><code class="language-swift">func total(numbers: Double...) -&gt; Double {
    var t: Double = 0
    for n in numbers {
        t += n
    }
    return t / Double(numbers.count)
}
print(total(1, 2, 3, 4, 5))
print(total(3, 8.25, 18.75))

// DISPLAY:
// 3.0
// 10.0
</code></pre>

<h5 id="constant-and-variable-parameters">Constant and Variable Parameters</h5>

<pre><code class="language-swift">func website(var s: String) -&gt; String {
    s += &quot;.com&quot;
    return s
}

print(website(&quot;maimieng&quot;))

// DISPLAY:
// maimieng.com
</code></pre>

<h5 id="in-out-parameters">In-Out Parameters</h5>

<p>In-out parameters cannot have default values, and variadic parameters cannot be marked as <code>inout</code>. If you mark a parameter as <code>inout</code>, it cannot also be marked as <code>var</code> or <code>let</code>.</p>

<pre><code class="language-swift">func swap(inout a: Int, inout b: Int) {
    let t = a
    a = b
    b = t
}

var a = 1
var b = 2
swap(&amp;a, &amp;b)

print(&quot;(\(a), \(b))&quot;)

// DISPLAY:
// (2, 1)
</code></pre>

<h4 id="function-types">Function Types</h4>

<h5 id="using-function-types">Using Function Types</h5>

<pre><code class="language-swift">func total(a: Int, _ b: Int) -&gt; Int {
    return a + b
}

var t: (Int, Int) -&gt; Int = total
var tl = total

print(t(1, 1))
print(tl(2, 2))

// DISPLAY:
// 2
// 4
</code></pre>

<h5 id="function-types-as-parameter-types">Function Types as Parameter Types</h5>

<pre><code class="language-swift">func total(a: Int, _ b: Int) -&gt; Int {
    return a + b
}

func printT(total: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) {
    print(total(a, b))
}

printT(total, 1, 1)

// DISPLAY:
// 2
</code></pre>

<h5 id="function-types-as-return-types">Function Types as Return Types</h5>

<pre><code class="language-swift">func com(var a: String) -&gt; String {
    a += &quot;.com&quot;
    return a
}

func http(a: String) -&gt; String {
    let b = &quot;http://&quot; + a
    return b
}

func website(a: String) -&gt; String {
    if !a.hasPrefix(&quot;http://&quot;) {
        return http(a)
    }
    if !a.hasSuffix(&quot;.com&quot;) {
        return com(a)
    }
    return &quot;CORRECT&quot;
}

print(website(&quot;http://maimieng&quot;))

// DISPLAY:
// http://maimieng.com
</code></pre>

<h4 id="nested-functions">Nested Functions</h4>

<p>Nested functions are hidden from the outside world by default, but can still be called and used by their enclosing function. An enclosing function can also return one of its nested functions to allow the nested function to be used in another scope.</p>

<pre><code class="language-swift">func website(a: String) -&gt; String {
    
    func http(a: String) -&gt; String {
        let b = &quot;http://&quot; + a
        return b
    }
    
    func com(var a: String) -&gt; String {
        a += &quot;.com&quot;
        return a
    }
    
    if !a.hasPrefix(&quot;http://&quot;) {
        return http(a)
    }
    if !a.hasSuffix(&quot;.com&quot;) {
        return com(a)
    }
    return &quot;CORRECT&quot;
}

print(website(&quot;http://maimieng&quot;))

// DISPLAY:
// http://maimieng.com
</code></pre>

<hr />

<h3 id="control-flow">Control Flow</h3>

<h4 id="for-loops">For Loops</h4>

<h5 id="for-in-for">For-In &amp; For</h5>

<pre><code class="language-swift">// 1...9 equals to 1..&lt;10
for i in 1...9 {
    for j in 1...9 {
        if (i &gt;= j) {
            print(&quot;\(j) * \(i) = \(i * j) &quot;, terminator: &quot;&quot;)
        }
    }
    print(&quot;&quot;)
}
// DISPLAY:
// 1 * 1 = 1 
// 1 * 2 = 2 2 * 2 = 4 
// 1 * 3 = 3 2 * 3 = 6 3 * 3 = 9 
// 1 * 4 = 4 2 * 4 = 8 3 * 4 = 12 4 * 4 = 16 
// 1 * 5 = 5 2 * 5 = 10 3 * 5 = 15 4 * 5 = 20 5 * 5 = 25 
// 1 * 6 = 6 2 * 6 = 12 3 * 6 = 18 4 * 6 = 24 5 * 6 = 30 6 * 6 = 36 
// 1 * 7 = 7 2 * 7 = 14 3 * 7 = 21 4 * 7 = 28 5 * 7 = 35 6 * 7 = 42 7 * 7 = 49 
// 1 * 8 = 8 2 * 8 = 16 3 * 8 = 24 4 * 8 = 32 5 * 8 = 40 6 * 8 = 48 7 * 8 = 56 8 * 8 = 64 
// 1 * 9 = 9 2 * 9 = 18 3 * 9 = 27 4 * 9 = 36 5 * 9 = 45 6 * 9 = 54 7 * 9 = 63 8 * 9 = 72 9 * 9 = 81 
</code></pre>

<pre><code class="language-swift">var i = 0
for _ in 1...5 {
    print(i++)
}

for var a = 0; a &lt; 3; a++ {
    print(a)
}

// DISPLAY:
// 0
// 1
// 2
// 3
// 4
// 0
// 1
// 2
</code></pre>

<h4 id="while-loops">While Loops</h4>

<h5 id="while-repeat-while">While &amp; Repeat-While</h5>

<pre><code class="language-swift">var i = 0
while (i++ &lt; 3) {
    print(i)
}

var i = 0
repeat {
    print(i)
} while (i++ &lt; 3)

// DISPLAY:
// 1
// 2
// 3
// 0
// 1
// 2
// 3
</code></pre>

<h4 id="conditional-statements">Conditional Statements</h4>

<h5 id="if">If</h5>

<p>Omitted.</p>

<h5 id="switch">Switch</h5>

<pre><code class="language-swift">let c: Character = &quot;i&quot;
switch c {
    case &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;:
    print(&quot;c is a vowel.&quot;)
    default:
    print(&quot;c is not a vowel.&quot;)
}
</code></pre>

<h6 id="no-implicit-fallthrough">No Implicit Fallthrough</h6>

<p>Omitted.</p>

<h6 id="interval-matching">Interval Matching</h6>

<pre><code class="language-swift">let a = 123
switch a {
    case 1...9:
    print(&quot;a is small.&quot;)
    case 10...99:
    print(&quot;a is medium.&quot;)
    case 100...199:
    print(&quot;a is big.&quot;)
    default:
    print(&quot;a is not sure.&quot;)
}

// DISPLAY:
// a is big.
</code></pre>

<h6 id="tuples">Tuples</h6>

<pre><code class="language-swift">let cs = (1, 1)
switch cs {
case (0, 0):
    print(&quot;(0, 0) is center.&quot;)
case (_, 0):
    print(&quot;(\(cs.0), 0)&quot;)
case (0, _):
    print(&quot;(0, \(cs.1))&quot;)
case (-2...2, -2...2):
    print(&quot;(\(cs.0), \(cs.1)) is inside.&quot;)
default:
    print(&quot;(\(cs.0), \(cs.1)) is not sure.&quot;)
}

// DISPLAY:
// (1, 1) is inside.
</code></pre>

<h6 id="value-bindings">Value Bindings</h6>

<pre><code class="language-swift">let cs = (2, 1)
switch cs {
case (let x, 0):
    print(&quot;\(x)&quot;)
case (0, let y):
    print(&quot;\(y)&quot;)
case let (x, y):
    print(&quot;(\(x), \(y))&quot;)
}

// DISPLAY:
// (2, 1)
</code></pre>

<h6 id="where">Where</h6>

<pre><code class="language-swift">let cs = (1, -1)
switch cs {
case let (x, y) where x == y:
    print(&quot;(\(x), \(y)) x == y&quot;)
case let (x, y) where x == -y:
    print(&quot;(\(x), \(y)) x == -y&quot;)
case let (x, y):
    print(&quot;(\(x), \(y))&quot;)
}

// DISPLAY:
// (1, -1) x == -y
</code></pre>

<h4 id="control-transfer-statements">Control Transfer Statements</h4>

<h5 id="continue-break">Continue &amp; Break</h5>

<p>Like C, omitted.</p>

<h5 id="fallthrough">Fallthrough</h5>

<p>Like C.</p>

<pre><code class="language-swift">let i = 5
var d = &quot;The number \(i) is&quot;
switch i {
case 2, 3, 5, 7, 11, 13, 17, 19:
    d += &quot; a prime number, and also&quot;
    fallthrough
default:
    d += &quot; an integer.&quot;
}
print(d)

// DISPLAY:
// The number 5 is a prime number, and also an integer.
</code></pre>

<h5 id="labeled-statements">Labeled Statements</h5>

<p><code>label name: while condition { statements }</code> in <code>switch</code> &amp; <code>while</code></p>

<h4 id="early-exit">Early Exit</h4>

<pre><code class="language-swift">func test() {
    let d = [&quot;hello&quot;: &quot;hi&quot;]
    guard d.isEmpty else {
        print(&quot;c isn't empty.&quot;)
        return
    }
}
test()

// DISPLAY:
// c isn't empty.
</code></pre>

<h4 id="checking-api-availability">Checking API Availability</h4>

<p>![3]()</p>

<pre><code class="language-swift">if #available(iOS 9, *) {
    print(&quot;Yes&quot;)
} else {
    print(&quot;No&quot;)
}

// DISPLAY:
// Yes
</code></pre>

<hr />

<h3 id="collection-types">Collection Types</h3>

<p>![1]()</p>

<p>Swift provides three primary <em>collection types</em>, known as arrays, sets, and dictionaries, for storing collections of values.
1. Arrays are ordered collections of values.
2. Sets are unordered collections of unique values.
3. Dictionaries are unordered collections of key-value associations.</p>

<p>Arrays, sets, and dictionaries in Swift are always clear about the types of values and keys that they can store. This means that you cannot insert a value of the wrong type into a collection by mistake. It also means you can be confident about the type of values you will retrieve from a collection.</p>

<p>Swift‚Äôs array, set, and dictionary types are implemented as <em>generic(<code>adj.ËåÉÂûã</code>) collections</em>.</p>

<h4 id="mutability-n-ÊòìÂèòÊÄß-of-collections">Mutability(<code>n.ÊòìÂèòÊÄß</code>) of Collections</h4>

<p>If you create an array, a set, or a dictionary, and assign it to a variable, the collection that is created will be <em>mutable</em>. This means that you can change (or <em>mutate</em>) the collection after it is created by adding, removing, or changing items in the collection. If you assign an array, a set, or a dictionary to a constant, that collection is immutable, and its size and contents cannot be changed.</p>

<p>It is good practice to create immutable collections in all cases where the collection does not need to change. Doing so enables the Swift compiler to optimize the performance of the collections you create.</p>

<h4 id="arrays">Arrays</h4>

<p>Swift‚Äôs <code>Array</code> type is bridged to Foundation‚Äôs <code>NSArray</code> class.</p>

<h5 id="array-type-shorthand-n-ÈÄüËÆ∞-syntax">Array Type Shorthand(<code>n.ÈÄüËÆ∞</code>) Syntax</h5>

<p><code>Array&lt;Element&gt;</code> &amp; <code>[Element]</code></p>

<h5 id="creating-an-empty-array">Creating an Empty Array</h5>

<pre><code class="language-swift">var a = [Int]()
print(a.count)

a.append(3)
print(a)
a = []
print(a,count)

// DISPLAY:
// 0
// [3]
// 0
</code></pre>

<h5 id="creating-an-array-with-a-default-value">Creating an Array with a Default Value</h5>

<pre><code class="language-swift">var a = [Double](count: 3, repeatedValue: 0)
print(a)

// DISPLAY:
// [0.0, 0.0, 0.0]
</code></pre>

<h5 id="creating-an-array-by-adding-two-arrays-together">Creating an Array by Adding Two Arrays Together</h5>

<pre><code class="language-swift">var a = [Double](count: 3, repeatedValue: 0)
var b = [Double](count: 2, repeatedValue: 1.5)
var c = b + a
print(c)

// DISPLAY:
// [1.5, 1.5, 0.0, 0.0, 0.0]
</code></pre>

<h5 id="creating-an-array-with-an-array-literal">Creating an Array with an Array Literal</h5>

<pre><code class="language-swift">var s: [String] = [&quot;mai&quot;, &quot;mieng&quot;]
var str = [&quot;mai&quot;, &quot;mieng&quot;]
if s == str {
    print(&quot;s == str&quot;)
}

// DISPLAY:
// s == str
</code></pre>

<h5 id="accessing-and-modifying-an-array">Accessing and Modifying an Array</h5>

<pre><code class="language-swift">var s: [String] = [&quot;mai&quot;, &quot;mieng&quot;]

print(s.count)
print(s.isEmpty)

s.append(&quot;.com&quot;)
s += [&quot;v2ex&quot;, &quot;.com&quot;]

s[3] = &quot;sspai&quot;
print(s[3])

s[3...4] = []
print(s)

s.insert(&quot;http://&quot;, atIndex: 0)
print(s)


print(s.removeAtIndex(0))
print(s.removeLast())

print(s)

// DISPLAY:
// 2
// false
// sspai
// [&quot;mai&quot;, &quot;mieng&quot;, &quot;.com&quot;]
// [&quot;http://&quot;, &quot;mai&quot;, &quot;mieng&quot;, &quot;.com&quot;]
// http://
// .com
// [&quot;mai&quot;, &quot;mieng&quot;]
</code></pre>

<h5 id="iterating-v-ÈáçÂ§ç-over-an-array">Iterating(<code>v.ÈáçÂ§ç</code>) Over an Array</h5>

<pre><code class="language-swift">var s: [String] = [&quot;mai&quot;, &quot;mieng&quot;]

for str in s {
    print(str)
}

for (index, value) in s.enumerate() {
    print(&quot;(\(index), \(value))&quot;)
}

// DISPLAY:
// mai
// mieng
// (0, mai)
// (1, mieng)
</code></pre>

<h4 id="sets">Sets</h4>

<p>A <em>set</em> stores distinct values of the same type in a collection with no defined ordering. You can use a set instead of an array when the order of items is not important, or when you need to ensure that an item only appears once.</p>

<p>Swift‚Äôs <code>Set</code> type is bridged to Foundation‚Äôs <code>NSSet</code> class.</p>

<h5 id="hash-values-for-set-types">Hash Values for Set Types</h5>

<p>Omitted.</p>

<h5 id="set-type-syntax">Set Type Syntax</h5>

<p><code>Set&lt;Element&gt;</code></p>

<h5 id="creating-and-initializing-an-empty-set">Creating and Initializing an Empty Set</h5>

<pre><code class="language-swift">var s = Set&lt;Character&gt;()
print(s.count)

s.insert(&quot;!&quot;)
print(s.count)

s = []
print(s.count)

// DISPLAY:
// 0
// 1
// 0
</code></pre>

<h5 id="creating-a-set-with-an-array-literal">Creating a Set with an Array Literal</h5>

<pre><code class="language-swift">var s: Set&lt;Int&gt; = [1, 2, 3, 4]
var set: Set = [&quot;mai&quot;, &quot;mieng&quot;]
</code></pre>

<h5 id="accessing-and-modifying-a-set">Accessing and Modifying a Set</h5>

<pre><code class="language-swift">var s: Set = [1, 2, 3, 4]
print(s.count)

if !s.isEmpty {
    print(&quot;s is empty.&quot;);
}

s.insert(5)
print(s.count)

print(s.remove(3))

print(s.remove(3))

s.removeAll()
print(s.count)

if s.contains(3) {
    print(&quot;s contains 3.&quot;)
} else {
    print(&quot;s doesn't contain 3.&quot;)
}

// DISPLAY:
// 4
// s is empty.
// 5
// Optional(3)
// nil
// 0
// s doesn't contain 3
</code></pre>

<h5 id="iterating-over-a-set">Iterating Over a Set</h5>

<pre><code class="language-swift">var s: Set = [1, 2, 3, 4]

for set in s {
    print(&quot;\(set)&quot;)
}

for set in s.sort() {
    print(&quot;\(set)&quot;)
}

// DISPLAY:
// 2
// 3
// 1
// 4
// 1
// 2
// 3
// 4
</code></pre>

<h4 id="performing-set-operations">Performing Set Operations</h4>

<h5 id="fundamental-set-operations">Fundamental Set Operations</h5>

<p>![2]()</p>

<pre><code class="language-swift">var a: Set = [1, 2, 3, 4, 5]
var b: Set = [2, 4, 6]
var c: Set = [1, 3, 5]

print(a.exclusiveOr(b).sort())
print(a.intersect(c).sort())
print(b.union(c).sort())

print(a.subtract(b).sort())
print(b.subtract(a).sort())

// DISPLAY:
// [1, 3, 5, 6]
// [1, 3, 5]
// [1, 2, 3, 4, 5, 6]
// [1, 3, 5]
// [6]
</code></pre>

<h5 id="set-membership-and-equality">Set Membership and Equality</h5>

<pre><code class="language-swift">var a: Set = [&quot;üòÇ&quot;, &quot;üòä&quot;]
var b: Set = [&quot;üòä&quot;, &quot;üòÑ&quot;]
var c: Set = [&quot;üòÇ&quot;]

print(a == b)
print(c.isSubsetOf(a))
print(a.isSupersetOf(a))

print(c.isDisjointWith(b))
print(c.isStrictSubsetOf(a))
print(a.isStrictSubsetOf(a))

print(a.isStrictSupersetOf(c))
print(a.isStrictSupersetOf(a))

// DISPLAY:
// false
// true
// true
// true
// true
// false
// true
// false
</code></pre>

<h4 id="dictionaries">Dictionaries</h4>

<p>Swift‚Äôs <code>Dictionary</code> type is bridged to Foundation‚Äôs <code>NSDictionary</code> class.</p>

<h5 id="dictionary-type-shorthand-syntax">Dictionary Type Shorthand Syntax</h5>

<p><code>Dictionary&lt;Key, Value&gt;</code> &amp; <code>[Key: Value]</code></p>

<h5 id="creating-an-empty-dictionary">Creating an Empty Dictionary</h5>

<pre><code class="language-swift">var d = [Int: String]()

d[404] = &quot;not found&quot;
print(d.count)

d = [:]
print(d.count)

// DISPLAY:
// 1
// 0
</code></pre>

<h5 id="creating-a-dictionary-with-a-dictionary-literal">Creating a Dictionary with a Dictionary Literal</h5>

<pre><code class="language-swift">var d: [Int: String] = [404: &quot;not found&quot;, 502: &quot;bad gateway&quot;]
var dy = [&quot;height&quot;: 180, &quot;weight&quot;: 60]
</code></pre>

<h5 id="accessing-and-modifying-a-dictionary">Accessing and Modifying a Dictionary</h5>

<pre><code class="language-swift">var dy = [&quot;height&quot;: 180, &quot;weight&quot;: 60]

print(dy.count)

dy[&quot;wage&quot;] = 0
print(dy)

dy[&quot;height&quot;] = 185
print(dy)

print(dy.updateValue(65, forKey: &quot;weight&quot;))

dy[&quot;wage&quot;] = nil
print(dy)

print(dy.removeValueForKey(&quot;age&quot;))

// DISPLAY:
// 2
// [&quot;height&quot;: 180, &quot;weight&quot;: 60, &quot;wage&quot;: 0]
// [&quot;height&quot;: 185, &quot;weight&quot;: 60, &quot;wage&quot;: 0]
// Optional(60)
// [&quot;height&quot;: 185, &quot;weight&quot;: 65]
// nil
</code></pre>

<h5 id="iterating-over-a-dictionary">Iterating Over a Dictionary</h5>

<p>To iterate over the keys or values of a dictionary in a specific order, use the <code>sort()</code> method on its <code>keys</code> or <code>values</code> property.</p>

<pre><code class="language-swift">var dy = [&quot;age&quot;: 20, &quot;height&quot;: 180, &quot;weight&quot;: 60, &quot;wage&quot;: 0]

for (des, value) in dy {
    print(&quot;(&quot; + des + &quot;, \(value))&quot;)
}

for des in dy.keys {
    print(des)
}

for value in dy.values {
    print(value)
}

var dyDes = [String](dy.keys)
var dyValue = [Int](dy.values)

// DISPLAY:
// (height, 180)
// (age, 20)
// (weight, 60)
// (wage, 0)
// height
// age
// weight
// wage
// 180
// 20
// 60
// 0

// ---
for d in dy.enumerate() {
    print(d)
}
// ---
// DISPLAY:
// (0, (&quot;height&quot;, 180))
// (1, (&quot;age&quot;, 20))
// (2, (&quot;weight&quot;, 60))
// (3, (&quot;wage&quot;, 0))
</code></pre>

<hr />

<h3 id="strings-and-characters">Strings and Characters</h3>

<p>Swift‚Äôs <code>String</code> type is bridged with Foundation‚Äôs <code>NSString</code> class. If you are working with the Foundation framework in Cocoa, the entire <code>NSString</code> API is available to call on any <code>String</code> value you create when type cast to <code>NSString</code>, as described in AnyObject. You can also use a <code>String</code> value with any API that requires an <code>NSString</code> instance.</p>

<h4 id="string-literals-n-Â≠óÈù¢Èáè">String Literals(<code>n.Â≠óÈù¢Èáè</code>)</h4>

<pre><code class="language-swift">let testString = &quot;maimieng&quot;
</code></pre>

<h4 id="initializing-an-empty-string">Initializing an Empty String</h4>

<pre><code class="language-swift">var s = &quot;&quot;
var str = String()
s = &quot;hello&quot;
if Str.isEmpty {
    Str = &quot;hi&quot;
}
print(s + &quot; &quot; + str)

var Str: String
Str = &quot;&quot; // Initialize
if Str.isEmpty {
    Str = &quot;Hi!&quot;
}
print(Str)
// DISPLAY:
// hello hi
// Hi!
</code></pre>

<h4 id="string-mutability-n-ÊòìÂèòÊÄß">String Mutability(<code>n.ÊòìÂèòÊÄß</code>)</h4>

<pre><code class="language-swift">var myWebsite = &quot;maimieng&quot;
myWebsite += &quot;.com&quot;
</code></pre>

<h4 id="strings-are-value-types">Strings Are Value Types</h4>

<p>Behind the scenes, Swift‚Äôs compiler optimizes(<code>v.‰ºòÂåñ</code>) string usage so that actual copying takes place only when absolutely necessary. This means you always get great performance when working with strings as value types.</p>

<h4 id="working-with-characters">Working with Characters</h4>

<pre><code class="language-swift">for c in &quot;Laugh: üòÇ&quot;.characters {
    print(c)
}
let testCharacter: Character = &quot;.&quot;
var charArray: [Character] = [&quot;s&quot;, &quot;w&quot;, &quot;i&quot;, &quot;f&quot;, &quot;t&quot;]
print(charArray)
print(String(charArray))
// DISPLAY:
// L
// a
// u
// g
// h
// :
//  
// üòÇ
// [&quot;s&quot;, &quot;w&quot;, &quot;i&quot;, &quot;f&quot;, &quot;t&quot;]
// swift
</code></pre>

<h4 id="concatenating-n-ËøûÊé•-strings-and-characters">Concatenating(<code>n.ËøûÊé•</code>) Strings and Characters</h4>

<p>You can‚Äôt append a <code>String</code> or <code>Character</code> to an existing <code>Character</code> variable, because a <code>Character</code> value must contain a single character only.</p>

<pre><code class="language-swift">var a = &quot;mai&quot;
var b = &quot;mieng&quot;
var c: Character = &quot;.&quot;
var d = a + b
a += b
d.append(c)
print(a)
print(d)
// DISPLAY:
// maimieng
// maimieng.
</code></pre>

<h4 id="string-interpolation-n-ÊèíÂÖ•">String Interpolation(<code>n.ÊèíÂÖ•</code>)</h4>

<p>The expressions you write inside parentheses(<code>n.ÂúÜÊã¨Âè∑</code>) within an interpolated(<code>adj.ÊèíÂÖ•ÁöÑ</code>) string cannot contain an unescaped double quote (<code>&quot;</code>) or backslash (<code>\</code>), and cannot contain a <em>carriage return(<code>ÂõûËΩ¶</code>)</em> or <em>line feed(<code>Êç¢Ë°å</code>)</em>.</p>

<pre><code class="language-swift">let multiplier = 3
let message = &quot;\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)&quot;
print(message)
// DISPLAY:
// 3 times 2.5 is 7.5
</code></pre>

<h4 id="unicode">Unicode</h4>

<p>Swift‚Äôs <code>String</code> and <code>Character</code> types are fully Unicode-compliant, as described in this section.</p>

<h5 id="unicode-scalars-n-Ê†áÈáè">Unicode Scalars(<code>n.Ê†áÈáè</code>)</h5>

<p>Behind the scenes, Swift‚Äôs native <code>String</code> type is built from Unicode scalar values. A Unicode scalar is a unique(<code>adj.ÂîØ‰∏ÄÁöÑ</code>) 21-bit number for a character or modifier(<code>n.‰øÆÈ•∞Á¨¶</code>), such as <code>U+0061</code> for <code>LATIN(adj.Êãâ‰∏ÅÁöÑ) SMALL LETTER A</code> (<code>&quot;a&quot;</code>), or <code>U+1F425</code> for <code>FRONT-FACING BABY CHICK</code> (<code>&quot;üê•&quot;</code>).</p>

<blockquote>
<p>NOTE
A Unicode scalar is any Unicode code point in the range <code>U+0000</code> to <code>U+D7FF</code> inclusive(<code>adj.ÂåÖÊã¨ÁöÑ</code>) or <code>U+E000</code> to <code>U+10FFFF</code> inclusive. Unicode scalars do <strong>not</strong> include the Unicode surrogate(<code>n.Êõø‰ª£ÂìÅ</code>) pair code points, which are the code points in the range <code>U+D800</code> to <code>U+DFFF</code> inclusive.</p>
</blockquote>

<p>Note that <strong>not</strong> all 21-bit Unicode scalars are assigned to a character‚Äîsome scalars are reserved for future assignment. Scalars that have been assigned to a character typically also have a name, such as <code>LATIN SMALL LETTER A</code> and <code>FRONT-FACING BABY CHICK</code> in the examples above.</p>

<h5 id="special-characters-in-string-literals">Special Characters in String Literals</h5>

<p>String literals can include the following special characters:
- The escaped special characters <code>\0</code> (null character), <code>\\</code> (backslash), <code>\t</code> (horizontal(<code>adj.Ê∞¥Âπ≥ÁöÑ</code>) tab), <code>\n</code> (line feed), <code>\r</code> (carriage return), <code>\&quot;</code> (double quote) and <code>\'</code> (single quote)
- An arbitrary(<code>adj.Ê≠¶Êñ≠ÁöÑ</code>) Unicode scalar, written as <code>\u{n}</code>, where <code>n</code> is a 1‚Äì8 digit hexadecimal number with a value equal to a valid Unicode code point</p>

<p>The code below shows four examples of these special characters. The <code>wiseWords</code> constant contains two escaped double quote characters. The <code>dollarSign</code>, <code>blackHeart</code>, and <code>sparklingHeart</code> constants demonstrate the Unicode scalar format:</p>

<pre><code class="language-swift">let wiseWords = &quot;\&quot;Imagination is more important than knowledge\&quot; - Einstein&quot;
let dollarSign = &quot;\u{24}&quot;
let blackHeart = &quot;\u{2665}&quot;
let sparklingHeart = &quot;\u{1F496}&quot;
print(wiseWords)
print(dollarSign)
print(blackHeart)
print(sparklingHeart)
// DISPLAY:
// &quot;Imagination is more important than knowledge&quot; - Einstein
// $
// ‚ô•
// üíñ
</code></pre>

<h5 id="extended-grapheme-n-Â≠óÂΩ¢-clusters-n-Áæ§ÈõÜ">Extended Grapheme(<code>n.Â≠óÂΩ¢</code>) Clusters(<code>n.Áæ§ÈõÜ</code>)</h5>

<p>Every instance of Swift‚Äôs <code>Character</code> type represents a single extended grapheme cluster. An extended grapheme cluster is a sequence of one or more Unicode scalars that (when combined) produce a single human-readable character.</p>

<p>Here‚Äôs an example. The letter <code>√©</code> can be represented as the single Unicode scalar <code>√©</code> (<code>LATIN SMALL LETTER E WITH ACUTE(n.ÈáçËØª)</code>, or <code>U+00E9</code>). However, the same letter can also be represented as a pair of scalars‚Äîa standard letter <code>e</code> (<code>LATIN SMALL LETTER E</code>, or <code>U+0065</code>), followed by the <code>COMBINING ACUTE ACCENT</code> scalar (<code>U+0301</code>). The <code>COMBINING ACUTE ACCENT</code> scalar is graphically applied to the scalar that precedes(<code>v.‰ºòÂÖà</code>) it, turning an <code>e</code> into an <code>√©</code> when it is rendered(<code>v.Êàê‰∏∫</code>) by a Unicode-aware text-rendering system.</p>

<p>In both cases, the letter <code>√©</code> is represented as a single Swift Character value that represents an extended grapheme cluster. In the first case, the cluster contains a single scalar; in the second case, it is a cluster of two scalars:</p>

<pre><code class="language-swift">let eAcute: Character = &quot;\u{E9}&quot;
let combinedEAcute: Character = &quot;\u{65}\u{301}&quot;
print(eAcute)
print(combinedEAcute)
// DISPLAY:
// √©
// √©
</code></pre>

<p>Extended grapheme clusters are a flexible way to represent many complex script characters as a single Character value. For example, Hangul(<code>n.Èü©ËØ≠</code>) syllables(<code>n.Èü≥ËäÇ</code>) from the Korean alphabet can be represented as either a precomposed(<code>adj.È¢ÑÂÖàÊûÑÊàêÁöÑ</code>) or decomposed(<code>adj.Â∑≤ÂàÜËß£ÁöÑ</code>) sequence. Both of these representations qualify as a single Character value in Swift:</p>

<pre><code class="language-swift">let precomposed: Character = &quot;\u{D55C}&quot;
let decomposed: Character = &quot;\u{1112}\u{1161}\u{11AB}&quot;
print(precomposed)
print(decomposed)
// DISPLAY:
// Ìïú
// Ìïú
</code></pre>

<p>Extended grapheme clusters enable scalars for enclosing marks (such as <code>COMBINING ENCLOSING CIRCLE</code>, or <code>U+20DD</code>) to enclose other Unicode scalars as part of a single Character value:</p>

<pre><code class="language-swift">let enclosedEAcute: Character = &quot;\u{E9}\u{20DD}&quot;
print(enclosedEAcute)
// DISPLAY:
// √©‚Éù
</code></pre>

<p>Unicode scalars for regional indicator symbols can be combined in pairs to make a single <code>Character</code> value, such as this combination of <code>REGIONAL INDICATOR SYMBOL LETTER U</code> (<code>U+1F1FA</code>) and <code>REGIONAL INDICATOR SYMBOL LETTER S</code> (<code>U+1F1F8</code>):</p>

<pre><code class="language-swift">let regionalIndicatorForUS: Character = &quot;\u{1F1FA}\u{1F1F8}&quot;
print(regionalIndicatorForUS)
// DISPLAY:
// üá∫üá∏
</code></pre>

<h4 id="counting-characters">Counting Characters</h4>

<p>Note that Swift‚Äôs use of extended grapheme clusters for <code>Character</code> values means that string concatenation and modification may not always affect a string‚Äôs character count.</p>

<blockquote>
<p>NOTE
Extended grapheme clusters can be composed of one or more Unicode scalars. This means that different characters‚Äîand different representations of the same character‚Äîcan require different amounts of memory to store. Because of this, characters in Swift do not each take up the same amount of memory within a string‚Äôs representation. As a result, the number of characters in a string cannot be calculated without iterating(<code>v.ÈÅçÂéÜ</code>) through the string to determine its extended grapheme cluster boundaries. If you are working with particularly long string values, be aware that the <code>characters</code> property must iterate over the Unicode scalars in the entire string in order to determine the characters for that string.</p>

<p>The count of the characters returned by the <code>characters</code> property is not always the same as the length property of an <code>NSString</code> that contains the same characters. The length of an <code>NSString</code> is based on the number of 16-bit code units within the string‚Äôs UTF-16 representation and not the number of Unicode extended grapheme clusters within the string.</p>
</blockquote>

<pre><code class="language-swift">let myWebsite = &quot;ÊàëÁöÑÁΩëÂùÄÊòØÔºömaimieng.com üòÇ&quot;
print(myWebsite.characters.count)
// DISPLAY:
// 20

var enclosedEAcute = &quot;\u{E9}&quot;
print(enclosedEAcute.characters.count)
enclosedEAcute += &quot;\u{20DD}&quot;
print(enclosedEAcute.characters.count)
// DISPLAY:
// 1
// 1
</code></pre>

<h4 id="accessing-and-modifying-a-string">Accessing and Modifying a String</h4>

<h5 id="string-indices-n-Á¥¢Âºï">String Indices(<code>n.Á¥¢Âºï</code>)</h5>

<pre><code class="language-swift">let myWebsite = &quot;maimieng.com&quot;
print(myWebsite[myWebsite.startIndex])
print(myWebsite[myWebsite.endIndex.predecessor()])
print(myWebsite[myWebsite.startIndex.successor()])

var index = myWebsite.startIndex.advancedBy(8)
print(myWebsite[index])

for index in myWebsite.characters.indices {
    print(&quot;\(myWebsite[index])&quot;, terminator: &quot;_&quot;)
}

// DISPLAY:
// m
// m
// a
// .
// m_a_i_m_i_e_n_g_._c_o_m_

// INCORRECT CODE:
// print(myWebsite[myWebsite.endIndex - 1])
// The 'endIndex' isn't type 'int' but 'index'.
// print(myWebsite[myWebsite.endIndex])
// print(myWebsite[myWebsite.startIndex.predecessor()])
// Runtime error: Beyond the string's range.
</code></pre>

<h5 id="inserting-and-removing">Inserting and Removing</h5>

<pre><code class="language-swift">var myWebsite = &quot;maimiengcom&quot;
myWebsite.insert(&quot;.&quot;, atIndex: myWebsite.startIndex.advancedBy(8))
print(myWebsite)

myWebsite.insertContentsOf(&quot;http://&quot;.characters, at: myWebsite.startIndex)
print(myWebsite)

myWebsite.removeAtIndex(myWebsite.endIndex.advancedBy(-4))
print(myWebsite)

let range = myWebsite.endIndex.advancedBy(-3)..&lt;myWebsite.endIndex
myWebsite.removeRange(range)
print(myWebsite)

// DISPLAY:
// maimieng.com
// http://maimieng.com
// http://maimiengcom
// http://maimieng
</code></pre>

<h4 id="comparing-strings">Comparing Strings</h4>

<h5 id="string-and-character-equality">String and Character Equality</h5>

<p>String and character comparisons in Swift are <em>not</em> locale-sensitive(<code>adj.Êú¨Âú∞ÊïèÊÑüÁöÑ</code>).(ÊÑèÊÄùÊòØ Swift ‰∏≠ÁöÑÂ≠óÁ¨¶ÂíåÂ≠óÁ¨¶‰∏≤Êó†ËÆ∫Âú®Âì™‰∏™ËØ≠Ë®ÄÂå∫ÂüüÔºåÂÖ∂Ë°®Áé∞ÂíåÂäüËÉΩÈÉΩÊòØÁõ∏ÂêåÁöÑ)</p>

<p><code>==</code> &amp; <code>!=</code>:</p>

<pre><code class="language-swift">var a = &quot;hello&quot;
var b = &quot;hello&quot;

if a == b {
    print(&quot;a == b&quot;)
}
// DISPLAY:
// a == b
</code></pre>

<p>Two <code>String</code> values (or two Character values) are considered equal if their extended grapheme clusters are <em>canonically(<code>adv.ÊåâÊ†áÂáÜÂú∞</code>) equivalent</em>. Extended grapheme clusters are canonically equivalent if they have the same linguistic(<code>adj.ËØ≠Ë®ÄÂ≠¶ÁöÑ</code>) meaning and appearance, even if they are composed from different Unicode scalars behind the scenes.</p>

<p>For example, <code>LATIN SMALL LETTER E WITH ACUTE</code> (<code>U+00E9</code>) is canonically equivalent to <code>LATIN SMALL LETTER E</code> (<code>U+0065</code>) followed by <code>COMBINING ACUTE ACCENT</code> (<code>U+0301</code>). Both of these extended grapheme clusters are valid ways to represent the character <code>√©</code>, and so they are considered to be canonically equivalent:</p>

<pre><code class="language-swift">let eAcuteQuestion = &quot;\u{E9}&quot;

let combinedEAcuteQuestion = &quot;\u{65}\u{301}&quot;

if eAcuteQuestion == combinedEAcuteQuestion {
    print(eAcuteQuestion + &quot; == &quot; + combinedEAcuteQuestion)
}
// DISPLAY:
// √© == eÃÅ
</code></pre>

<p>Conversely, <code>LATIN CAPITAL LETTER A</code> (<code>U+0041</code>, or <code>&quot;A&quot;</code>), as used in English, is <em>not</em> equivalent to <code>CYRILLIC CAPITAL LETTER A</code> (<code>U+0410</code>, or <code>&quot;–ê&quot;</code>), as used in Russian. The characters are visually similar, but do not have the same linguistic meaning:</p>

<pre><code class="language-swift">let latinCapitalLetterA:Character = &quot;\u{41}&quot;

let cyrillicCapitalLetterA:Character = &quot;\u{0410}&quot;

if latinCapitalLetterA != cyrillicCapitalLetterA {
    var a = &quot;&quot;, b = &quot;&quot;
    a.append(cyrillicCapitalLetterA)
    b.append(latinCapitalLetterA)
    print(a + &quot; != &quot; + b)
}
// DISPLAY:
// –ê != A
</code></pre>

<h5 id="prefix-and-suffix-equality">Prefix and Suffix Equality</h5>

<p>The <code>hasPrefix(_:)</code> and <code>hasSuffix(_:)</code> methods perform a character-by-character canonical equivalence comparison between the extended grapheme clusters in each string.</p>

<pre><code class="language-swift">let iPhone = [
    &quot;2007: iPhone&quot;,
    &quot;2008: iPhone 3G&quot;,
    &quot;2009: iPhone 3GS&quot;,
    &quot;2010: iPhone 4&quot;,
    &quot;2011: iPhone 4s&quot;,
    &quot;2012: iPhone 5&quot;,
    &quot;2013: iPhone 5c&quot;,
    &quot;2013: iPhone 5s&quot;,
    &quot;2014: iPhone 6&quot;,
    &quot;2014: iPhone 6 Plus&quot;,
    &quot;2015: iPhone 6s&quot;,
    &quot;2015: iPhone 6s Plus&quot;
]

var hasC = 0
var in2015 = 0
for i in iPhone {
    if i.hasSuffix(&quot;c&quot;) {
        hasC++
    }
    if i.hasPrefix(&quot;2015&quot;) {
        in2015++
    }
}
print(hasC)
print(in2015)

// DISPLAY:
// 1
// 2
</code></pre>

<h4 id="unicode-representations-of-strings">Unicode Representations of Strings</h4>

<p>Omitted.</p>

<hr />

<h3 id="basic-operators">Basic Operators</h3>

<h4 id="terminology-n-ÊúØËØ≠">Terminology(<code>n.ÊúØËØ≠</code>)</h4>

<p>Unary(<code>adj.‰∏ÄÂÖÉÁöÑ</code>), binary(<code>adj.‰∫åÂÖÉÁöÑ</code>), or ternary(<code>adj.‰∏âÂÖÉÁöÑ</code>) operators.</p>

<pre><code class="language-swift">int a = 10
int b = -a

a ? b : c
</code></pre>

<h4 id="assignment-operator">Assignment Operator</h4>

<p>Assignment operator does <strong>not return</strong> a value.</p>

<pre><code class="language-swift">let a = 10
var v = 5
v = a

let (x, y) = (1, 2)
print(&quot;(\(x), \(y))&quot;)
// DISPLAY:
// (1, 2)

// if (x = y) {
// 	...	
// }
// Bug: 
// x = y does not return a value.
</code></pre>

<h4 id="arithmetic-n-ÁÆóÊúØ-operators">Arithmetic(<code>n.ÁÆóÊúØ</code>) Operators</h4>

<pre><code class="language-swift">let a = 1
let b = 5

var c: Int
c = a + b
print(c)

c = a - b
print(c)

c = a * b
print(c)

var d = Double(a) / Double(b)
print(d)
// DISPLAY:
// 6
// -4
// 5
// 0.2
</code></pre>

<h5 id="remainder-n-Ê±Ç‰Ωô-operator">Remainder(<code>n.Ê±Ç‰Ωô</code>) Operator</h5>

<p>To determine the answer for <code>a % b</code>, the <code>%</code> operator calculates the following equation and returns remainder as its output:</p>

<p><code>a = (b x some multiplier) + remainder</code></p>

<pre><code class="language-swift">var a = 2
var b = 5
var c = -4

print(a % b)
print(c % b)

// DISPLAY:
// 2
// -4
</code></pre>

<h5 id="floating-point-remainder-calculations">Floating-Point Remainder Calculations</h5>

<pre><code class="language-swift">var d = 0.3
var e = 0.8

print(e % d)
// DISPLAY:
// 0.2
</code></pre>

<h5 id="increment-and-decrement-operators">Increment and Decrement Operators</h5>

<pre><code class="language-swift">var a = 1
print(a++)
print(++a)
// DISPLAY:
// 1
// 3
</code></pre>

<h5 id="unary-minus-operator-unary-plus-operator">Unary Minus Operator &amp; Unary Plus Operator</h5>

<pre><code class="language-swift">var a = -1
a = -a
print(a)
print(+a)
// DISPLAY:
// 1
// 1
</code></pre>

<h4 id="compound-adj-Â§çÂêàÁöÑ-assignment-operators">Compound(<code>adj.Â§çÂêàÁöÑ</code>) Assignment Operators</h4>

<pre><code class="language-swift">print(1 == 5)
print(1 != 5)
print(1 &gt;= 5)
print(1 &lt;= 5)
print(2 &gt; 3)
print(2 &lt; 3)
// DISPLAY:
// false
// true
// false
// true
// false
// true
</code></pre>

<h4 id="ternary-conditional-operator">Ternary Conditional Operator</h4>

<pre><code class="language-swift">let a = true
let b = a ? 1 : 0
print(b)

let c: Int
if a {
    c = 1
} else {
    c = 0
}
print(c)
// DISPLAY:
// 1
// 1
</code></pre>

<h4 id="nil-coalescing-n-ÂêàÂπ∂-operator">Nil Coalescing(<code>n.ÂêàÂπ∂</code>) Operator</h4>

<p>The <code>nil</code> coalescing operator (<code>a ?? b</code>) unwraps an optional <code>a</code> if it contains a value, or returns a default value <code>b</code> if a is <code>nil</code>.</p>

<p>The expression <code>a</code> is always of an optional type.
The expression <code>b</code> must match the type that is stored inside <code>a</code>.</p>

<pre><code class="language-swift">let defaultGreeting = &quot;Hello!&quot;
var myGreeting: String?
print(myGreeting ?? defaultGreeting)
myGreeting = &quot;Hi!&quot;
print(myGreeting ?? defaultGreeting)
// DISPLAY:
// Hello!
// Hi!
</code></pre>

<h4 id="range-operators">Range Operators</h4>

<h5 id="closed-range-operator-half-open-range-operator">Closed Range Operator &amp; Half-Open Range Operator</h5>

<p><code>for-in</code> loop:</p>

<p>The closed range operator (<code>a...b</code>) defines <code>a</code> range that runs from <code>a</code> to <code>b</code>, and includes the values <code>a</code> and <code>b</code>.
The half-open range operator (<code>a..&lt;b</code>) defines <code>a</code> range that runs from <code>a</code> to <code>b</code>, but does <strong>not</strong> include <code>b</code>.</p>

<pre><code class="language-swift">// 1...9 equals to 1..&lt;10
for i in 1...9 {
    for j in 1...9 {
        if (i &gt;= j) {
            print(&quot;\(j) * \(i) = \(i * j) &quot;, terminator: &quot;&quot;)
        }
    }
    print(&quot;&quot;)
}
// DISPLAY:
// 1 * 1 = 1 
// 1 * 2 = 2 2 * 2 = 4 
// 1 * 3 = 3 2 * 3 = 6 3 * 3 = 9 
// 1 * 4 = 4 2 * 4 = 8 3 * 4 = 12 4 * 4 = 16 
// 1 * 5 = 5 2 * 5 = 10 3 * 5 = 15 4 * 5 = 20 5 * 5 = 25 
// 1 * 6 = 6 2 * 6 = 12 3 * 6 = 18 4 * 6 = 24 5 * 6 = 30 6 * 6 = 36 
// 1 * 7 = 7 2 * 7 = 14 3 * 7 = 21 4 * 7 = 28 5 * 7 = 35 6 * 7 = 42 7 * 7 = 49 
// 1 * 8 = 8 2 * 8 = 16 3 * 8 = 24 4 * 8 = 32 5 * 8 = 40 6 * 8 = 48 7 * 8 = 56 8 * 8 = 64 
// 1 * 9 = 9 2 * 9 = 18 3 * 9 = 27 4 * 9 = 36 5 * 9 = 45 6 * 9 = 54 7 * 9 = 63 8 * 9 = 72 9 * 9 = 81 
</code></pre>

<h4 id="logical-operators">Logical Operators</h4>

<h5 id="logical-not-operator">Logical NOT Operator</h5>

<pre><code class="language-swift">let a = true
if !a {
    print(&quot;true&quot;)
} else {
    print(&quot;false&quot;)
}
// DISPLAY:
// false
</code></pre>

<h5 id="logical-and-operator-logical-or-operator">Logical AND Operator &amp; Logical OR Operator</h5>

<pre><code class="language-swift">let a = true
let b = false

if a &amp;&amp; b {
    print(&quot;true&quot;)
} else if (a || b) {
    print(&quot;false&quot;)
}
// DISPLAY:
// false
</code></pre>

<h5 id="combining-logical-operators">Combining Logical Operators</h5>

<p>The Swift logical operators <code>&amp;&amp;</code> and <code>||</code> are left-associative, meaning that compound expressions with multiple logical operators evaluate the leftmost subexpression first.</p>

<pre><code class="language-swift">let a = true
let b = !a // false
let c = a &amp;&amp; b // false
let d = a || b // true
if a &amp;&amp; b || c &amp;&amp; d {
    print(&quot;true&quot;)
} else {
    print(&quot;false&quot;)
}
// DISPLAY:
// false
</code></pre>

<h5 id="explicit-adj-ÊòéÁ°ÆÁöÑ-parentheses-n-Â∞èÊã¨Âè∑">Explicit(<code>adj.ÊòéÁ°ÆÁöÑ</code>) Parentheses(<code>n.Â∞èÊã¨Âè∑</code>)</h5>

<pre><code class="language-swift">let a = true
let b = !a // false
let c = a &amp;&amp; b // false
let d = a || b // true
if (a || b) &amp;&amp; (c || d) {
    print(&quot;true&quot;)
} else {
    print(&quot;false&quot;)
}
// DISPLAY:
// true
</code></pre>

<hr />

<h3 id="the-basics">The Basics</h3>

<h4 id="constants-and-variables">Constants and Variables</h4>

<h5 id="declaring-constants-and-variables">Declaring Constants and Variables</h5>

<pre><code class="language-swift">var i = 3
var Pi = 3.14, c = &quot;V&quot;

let myWebsite = &quot;maimieng.com&quot;
</code></pre>

<h5 id="type-annotations">Type Annotations</h5>

<pre><code class="language-swift">var sumOfStu: Int
var newColor, silver, gold, space_gray: String
newColor = &quot;Rose Gold&quot;
</code></pre>

<h5 id="naming-constants-and-variables">Naming Constants and Variables</h5>

<pre><code class="language-swift">let œÄ = 3.14
let üòÇ = &quot;Â§ßÁ¨ë&quot;
var ÁΩëÁ´ô = &quot;maimieng&quot;

ÁΩëÁ´ô += &quot;.com&quot;

let `let` = 1

// INCORRECT CODE:
// œÄ = 3
// R: œÄ is a constant that can't change its value.
</code></pre>

<h5 id="printing-constants-and-variables">Printing Constants and Variables</h5>

<pre><code class="language-swift">var myMac = &quot;MacBook Pro&quot;
let myMacSize = 13
print(myMac + &quot; \(myMacSize)&quot;)
// DISPLAY:
// MacBook Pro 13
</code></pre>

<h4 id="comments">Comments</h4>

<pre><code class="language-swift">// Comment of one line.

/* Comment around several lines. */
</code></pre>

<h4 id="semicolons">Semicolons</h4>

<pre><code class="language-swift">let Sem = &quot;;&quot;; print(Sem)
// DISPLAY:
// ;
</code></pre>

<h4 id="integers">Integers</h4>

<h5 id="integer-bounds-n-ËåÉÂõ¥">Integer Bounds(<code>n.ËåÉÂõ¥</code>)</h5>

<pre><code class="language-swift">let minValue = Int64.min
let maxValue = UInt8.max
</code></pre>

<h5 id="int">Int</h5>

<p>On a 32-bit platform, <code>Int</code> is the same size as <code>Int32</code>.
On a 64-bit platform, <code>Int</code> is the same size as <code>Int64</code>.</p>

<h5 id="uint">UInt</h5>

<p>On a 32-bit platform, <code>UInt</code> is the same size as <code>UInt32</code>.
On a 64-bit platform, <code>UInt</code> is the same size as <code>UInt64</code>.</p>

<p><em><code>Int</code> is preferred.</em></p>

<h4 id="floating-point-numbers">Floating-Point Numbers</h4>

<p><code>Double</code> represents a 64-bit floating-point number.
<code>Float</code> represents a 32-bit floating-point number.</p>

<p><em><code>Double</code> is preferred.</em></p>

<p><code>Double</code> has a precision(<code>n.ÊòéÁ°Æ</code>) of at least <strong>15</strong> decimal digits.
<code>Float</code> can be as little as <strong>6</strong> decimal digits.</p>

<h4 id="type-safety-and-type-inference">Type Safety and Type Inference</h4>

<pre><code class="language-swift">let myPi = 3 + 0.14
// myPi is a double value.
</code></pre>

<h4 id="numeric-adj-Êï∞ÂÄºÂûãÁöÑ-literals">Numeric(<code>adj.Êï∞ÂÄºÂûãÁöÑ</code>) Literals</h4>

<p>A <em>decimal</em> number, with no prefix
A <em>binary</em> number, with a <code>0b</code> prefix
An <em>octal(<code>adj.ÂÖ´ËøõÂà∂ÁöÑ</code>)</em> number, with a <code>0o</code> prefix
A <em>hexadecimal(<code>adj.ÂçÅÂÖ≠ËøõÂà∂ÁöÑ</code>)</em> number, with a <code>0x</code> prefix</p>

<pre><code class="language-swift">var myAge = 20
var binaryAge = 0b10100
var octalAge = 0o24
var hexadecimalAge = 0x14

let velocityOfLight = 3e9
let testNum = 0xFp-2
// testNum = 3.75

var moreThanOneThousand = 001_000.102_4
</code></pre>

<h4 id="numeric-type-conversion">Numeric Type Conversion</h4>

<h5 id="integer-conversion">Integer Conversion</h5>

<pre><code class="language-swift">// INCORRECT CODE:
// var tooBig: UInt8 = UInt8.max + 1
// R: Beyond the range of UInt8.

var a: Int16 = 250
var b: Int8 = -1
var c = a + Int16(b)

// INCORRECT CODE:
// var d = a + b
// R: a &amp; b are not the same type.
// var e = Int8(a) + b
// R: It's not safe to convert type from Int16 to Int8.
</code></pre>

<h5 id="integer-and-floating-point-conversion">Integer and Floating-Point Conversion</h5>

<pre><code class="language-swift">var a = 0.5
var b = 2
var c = a + Double(b)
// c's value is 2.5.
var d = Int(a) + b
// d's value is 2.
var e = 2 + 0.5
// INCORRECT CODE:
// var f = a + b
// R: a &amp; b are not the same type.
</code></pre>

<h4 id="type-aliases">Type Aliases</h4>

<pre><code class="language-swift">typealias ElementType = Int
var a: ElementType
a = 5
</code></pre>

<h4 id="booleans">Booleans</h4>

<pre><code class="language-swift">let iAmAGoodMan = true
if iAmAGoodMan {
    print(&quot;You, too.&quot;)
} else {
    print(&quot;You're wrong.&quot;)
}
if 2 &gt;= 1 {
	print(&quot;We are good at math.&quot;)
}
// INCORRECT CODE:
// if 1 {
// 	...
// }
// R: The boolean values are only &quot;true&quot; &amp; &quot;false&quot;.
</code></pre>

<h4 id="tuples-1">Tuples</h4>

<pre><code class="language-swift">let http404Error = (404, &quot;Not Found&quot;)
let (statusCode, _) = http404Error
var stuInfo = (stuNum: 1415925, stuName: &quot;V&quot;)
print(http404Error.0)
print(statusCode)
print(&quot;The status code is \(statusCode).&quot;)
print(&quot;The student number is \(stuInfo.stuNum).&quot;)
// DISPLAY:
// 404
// 404
// The status code is 404.
// The student number is 1415925.
</code></pre>

<h4 id="optionals">Optionals</h4>

<h5 id="nil-n-Êó†"><code>nil</code>(<code>n.Êó†</code>)</h5>

<pre><code class="language-swift">var moneyOfMine: Int? = 500
moneyOfMine = nil
</code></pre>

<h5 id="if-statements-and-forced-unwrapping">If Statements and Forced Unwrapping</h5>

<p>We can access its underlying(<code>n.‰Ωç‰∫éÂÖ∂‰∏ã</code>) value by adding an exclamation(<code>n.ÊÑüÂèπ</code>) mark (<code>!</code>) to the end of the optional‚Äôs name.</p>

<pre><code class="language-swift">var mySaving: Int? = 1000
if mySaving != nil {
    print(&quot;I still have ¬•\(mySaving!).&quot;)
} else {
    print(&quot;My saving is nil.&quot;)
}
// DISPLAY:
// I still have ¬• 1000.
</code></pre>

<h5 id="optional-binding">Optional Binding</h5>

<pre><code class="language-swift">let possibleNumber = &quot;123&quot;
let impossibleNumber = &quot;maimieng&quot;
if let actualNumber = Int(possibleNumber) {
    print(&quot;\(possibleNumber) has an integer value.&quot;)
}
if let actualNumber = Int(impossibleNumber) {
    print(&quot;\(impossibleNumber) has an integer value.&quot;)
} else {
    print(&quot;\(impossibleNumber) could not be converted to an integer.&quot;)
}
// DISPLAY:
// 123 has an integer value.
// maimieng could not be converted to an integer.

if let firstNumber = Int(&quot;4&quot;), secondNumber = Int(&quot;42&quot;) where firstNumber &lt; secondNumber {
    print(&quot;\(firstNumber) &lt; \(secondNumber)&quot;)
}
// DISPLAY:
// 4 &lt; 42
</code></pre>

<p>We can include multiple optional bindings in a single <code>if</code> statement and use a <code>where</code> clause(<code>n.ÂàÜÂè•</code>) to check for a Boolean condition.</p>

<h5 id="implicitly-unwrapped-optionals">Implicitly Unwrapped Optionals</h5>

<pre><code class="language-swift">let possibleString: String? = &quot;An optional string.&quot;
let forcedString: String = possibleString!

let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;
let implicitString: String = assumedString

if possibleString != nil {
    print(possibleString!)
}

if assumedString != nil {
    print(assumedString)
}
// DISPLAY:
// An optional string.
// An implicitly unwrapped optional string.

if let definiteString = possibleString {
    print(definiteString)
}

if let definiteString = assumedString {
    print(definiteString)
}
// DISPLAY:
// An optional string.
// An implicitly unwrapped optional string.
</code></pre>

<p>Do not use an implicitly(<code>adv.Âê´ËìÑÂú∞</code>) unwrapped(<code>v.Ëß£ÂåÖ</code>) optional when there is a possibility of a variable becoming <code>nil</code> at a later point. Always use a normal optional type if you need to check for a <code>nil</code> value during the lifetime of a variable.</p>

<h4 id="error-handling">Error Handling</h4>

<p>If no error is thrown(<code>v.ÊäõÂá∫</code>), the <code>eatASandwich()</code> function is called. If an error is thrown and it matches the <code>Error.OutOfCleanDishes</code> case, then the <code>washDishes()</code> function will be called. If an error is thrown and it matches the <code>Error.MissingIngredients</code> case, then the <code>buyGroceries(_:)</code> function is called with the associated <code>[String]</code> value captured(<code>v.ÊçïËé∑</code>) by the <code>catch</code> pattern.</p>

<pre><code class="language-swift">func makeASandwich() throws {
    // ...
}

do {
    try makeASandwich()
    eatASandwich()
} catch Error.OutOfCleanDishes {
    washDishes()
} catch Error.MissingIngredients(let ingredients) {
    buyGroceries(ingredients)
}
// This code is just an example.
</code></pre>

<p>A <code>do</code> statement creates a new containing scope, which allows errors to be propagated(<code>v.‰º†ÈÄÅ</code>) to one or more <code>catch</code> clauses.</p>

<h4 id="assertions-n-Êñ≠Ë®Ä">Assertions(<code>n.Êñ≠Ë®Ä</code>)</h4>

<h5 id="debugging-with-assertions">Debugging with Assertions</h5>

<pre><code class="language-swift">let myAge = -1
assert(myAge &gt;= 0, &quot;Age should be bigger t WRONG han 0.&quot;)
// Bug: 
// assertion failed: Age should be bigger than 0.: file /Users/MaiMieng/Documents/test1/main.swift, line 12
(lldb) 
</code></pre>

<h5 id="when-to-use-assertions">When to Use Assertions</h5>

<p>An integer subscript(<code>adj.‰∏ãÊ†áÁöÑ</code>) index is passed to a custom subscript implementation, but the subscript index value could be too low or too high.
A value is passed to a function, but an invalid value means that the function cannot fulfill(<code>v.ÂÆûÁé∞</code>) its task.
An optional value is currently <code>nil</code>, but a non-nil value is essential(<code>adj.Âü∫Êú¨ÁöÑ</code>) for subsequent(<code>adj.ÈöèÂêéÁöÑ</code>) code to execute(<code>v.ËøêË°å</code>) successfully.</p>
  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span
        class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      <span class="button previous">
        <a href="/posts/2015/depr_the-2nd-half-year-plan/">
          <span class="button__icon">‚Üê</span>
          <span class="button__text">The Second Half of 2015 Plan</span>
        </a>
      </span>
      
      
      <span class="button next">
        <a href="/posts/2015/depr_j4a/">
          <span class="button__text">ÂàùÂ≠¶ Java 4 Android - Note &amp; Code</span>
          <span class="button__icon">‚Üí</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo="kingcos/kingcos.github.io"
            issue-term="pathname"
            label="comments"
            theme="github-dark"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>¬© 2019 ¬∑ <a href="http://github.com/kingcos">kingcos</a></span>
      </div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>





  
</div>

</body>
</html>
