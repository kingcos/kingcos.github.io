<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>Learning Swift 2.1 - Note &amp; Code :: iBlog — github.com/kingcos</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content=" 本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。
This article is archived from my previous blog, so the content maybe have changed now.
 Based on [The Swift Programming Language](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/) Swift 2 Edition "/>
<meta name="keywords" content="ios,swift,objective-c,obj-c,objc,oc,geek,python,ruby,golang,go,apple,mac"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2015/depr_swift-2/" />





<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Learning Swift 2.1 - Note &amp; Code"/>
<meta name="twitter:description" content="本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now."/>



<meta property="og:title" content="Learning Swift 2.1 - Note &amp; Code" />
<meta property="og:description" content="本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2015/depr_swift-2/" />
<meta property="article:published_time" content="2015-09-19T00:00:00+00:00" />
<meta property="article:modified_time" content="2015-09-19T00:00:00+00:00" /><meta property="og:site_name" content="iBlog" />






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">iBlog</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About &amp; AMA</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About &amp; AMA</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="post">
    <h2 class="post-title"><a href="/posts/2015/depr_swift-2/">Learning Swift 2.1 - Note &amp; Code</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            2015-09-19
        </span>
      
      
      
        <span class="post-read-time">— 33 min read</span>
      
    </div>

    
      <span class="post-tags">
        
          #<a href="/tags/deprecated/">Deprecated</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      <blockquote>
<p>本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。<br>This article is archived from my previous blog, so the content maybe have changed now.</p>
</blockquote>

<hr />

<blockquote class="blockquote-center">
Based on
[The Swift Programming Language](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/)
Swift 2 Edition
</blockquote>

<blockquote>
<p>Intro:
This document couldn&rsquo;t be absolutely correct.
Please tell me about the mistakes.
Skip <em>Welcome to Swift</em>.</p>
</blockquote>

<p><strong>Info:</strong></p>

<ul>
<li>Mac OS X 10.11</li>
<li>Xcode 7+ (<a href="https://developer.apple.com/downloads/">From HERE</a>)</li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/">The Swift Programming Language Swift 2 Edition (From iBooks)</a></li>
<li><a href="https://developer.apple.com/library/ios/navigation/#">Apple Developer</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/swift/">The Swift Programming Language (Swift 2) 中文版</a></li>
</ul>

<hr />

<h2 id="language-guide">Language Guide</h2>

<hr />

<h3 id="enumerations">Enumerations</h3>

<p>Enumerations in Swift are first-class types in their own right. They adopt many features traditionally supported only by classes, such as computed properties to provide additional information about the enumeration’s current value, and instance methods to provide functionality related to the values the enumeration represents. Enumerations can also define initializers to provide an initial member value; can be extended to expand their functionality beyond their original implementation; and can conform to protocols to provide standard functionality.</p>

<h4 id="enumeration-syntax-matching-enumeration-values-with-a-switch-statement">Enumeration Syntax &amp;&amp; Matching Enumeration Values with a Switch Statement</h4>

<p>In the <code>CompassPoint</code> example above, <code>North</code>, <code>South</code>, <code>East</code> and <code>West</code> do <em>not</em> implicitly equal <code>0</code>, <code>1</code>, <code>2</code> and <code>3</code>. Instead, the different enumeration members are fully-fledged values in their own right, with an explicitly-defined type of <code>CompassPoint</code>.</p>

<p>In Swift, their names (such as <code>CompassPoint</code>) should start with a capital letter.</p>

<pre><code class="language-swift">enum bestWebsites {
    case v2ex, dgtle, sspai, maimieng
}

var bw = bestWebsites.v2ex
bw = .maimieng
switch bw {
case .v2ex:
    print(&quot;Way to explore.&quot;)
case .dgtle:
    print(&quot;About digtle life.&quot;)
case .sspai:
    print(&quot;About news of iOS &amp; Android.&quot;)
case .maimieng:
    print(&quot;My blog&quot;)
}
</code></pre>

<h4 id="associated-values">Associated Values</h4>

<pre><code class="language-swift">enum Apple {
    case hardware(String, Int, String)
    case software(String, Int)
}

var product2015 = Apple.hardware(&quot;iPhone&quot;, 5288, &quot;16 G&quot;)
product2015 = .software(&quot;Apple Music&quot;, 10)

switch product2015 {
case .hardware(let productName, let price, let deviceRom):
    print(&quot;The device name is \(productName), the price is \(price), the device rom is \(deviceRom).&quot;)
case var .software(productName, feesPerMonth):
    print(&quot;The software name is \(productName), the fees per month is \(feesPerMonth)¥.&quot;)
}

// DISPLAY:
// The software name is Apple Music, the fees per month is 10¥.
</code></pre>

<h4 id="raw-values">Raw Values</h4>

<p>Associated values are set when you create a new constant or variable based on one of the enumeration’s members, and can be different each time you do so.</p>

<pre><code class="language-swift">enum platformOfProgrammingLanguage: String {
    case Android =  &quot;Java&quot;
    case iOS = &quot;Swift&quot;
}
</code></pre>

<h4 id="implicitly-assigned-raw-values-initializing-from-a-raw-value">Implicitly Assigned Raw Values &amp; Initializing from a Raw Value</h4>

<pre><code class="language-swift">enum platformOfProgrammingLanguage: String {
    case Android
    case iOS
}

print(platformOfProgrammingLanguage.iOS.rawValue)
print(platformOfProgrammingLanguage(rawValue: &quot;C++&quot;))

// DISPLAY:
// iOS
// nil
</code></pre>

<h4 id="recursive-enumerations">Recursive Enumerations</h4>

<pre><code class="language-swift">
</code></pre>

<hr />

<h3 id="closures">Closures</h3>

<p>Global functions are closures that have a name and do not capture any values.
Nested functions are closures that have a name and can capture values from their enclosing function.
Closure expressions are unnamed closures written in a lightweight(<code>adj.轻便的</code>) syntax that can capture values from their surrounding context.</p>

<h4 id="closure-expressions">Closure Expressions</h4>

<pre><code class="language-swift">let website = [&quot;v2ex&quot;, &quot;maimieng&quot;, &quot;apple&quot;, &quot;github&quot;]
</code></pre>

<h5 id="the-sort-method">The Sort Method</h5>

<pre><code class="language-swift">func test1(s1: String, s2: String) -&gt; Bool {
    return s1 &gt; s2
}

print(website.sort(test1))

// DISPLAY:
// [&quot;v2ex&quot;, &quot;maimieng&quot;, &quot;github&quot;, &quot;apple&quot;]
</code></pre>

<h5 id="closure-expression-syntax">Closure Expression Syntax</h5>

<p><code>{ (parameters) -&gt; returnType in statements }</code></p>

<pre><code class="language-swift">var p = website.sort({ (s1: String, s2: String) -&gt; Bool in
    return s1 &gt; s2
})
</code></pre>

<h5 id="inferring-type-from-context">Inferring Type From Context</h5>

<pre><code class="language-swift">var p = website.sort( { s1, s2 in return s1 &gt; s2 } )```

##### Implicit Returns from Single-Expression Closures

</code></pre>

<p>swift
var p = website.sort( { s1, s2 in s1 &gt; s2 } )</p>

<pre><code>
##### Shorthand Argument Names

</code></pre>

<p>swift
var p = website.sort( { $0 &gt; $1 } )</p>

<pre><code>
##### Operator Functions

</code></pre>

<p>swift
var p = website.sort(&gt;)</p>

<pre><code>
#### Trailing(`v.跟踪`) Closures

</code></pre>

<p>swift
var p = website.sort() { $0 &gt; $1 }</p>

<p>var q = website.sort { $0 &gt; $1 }</p>

<pre><code>
</code></pre>

<p>swift
let digitNames = [
    0: &ldquo;Zero&rdquo;, 1: &ldquo;One&rdquo;, 2: &ldquo;Two&rdquo;,   3: &ldquo;Three&rdquo;, 4: &ldquo;Four&rdquo;,
    5: &ldquo;Five&rdquo;, 6: &ldquo;Six&rdquo;, 7: &ldquo;Seven&rdquo;, 8: &ldquo;Eight&rdquo;, 9: &ldquo;Nine&rdquo;
]
let numbers = [16, 58, 510]</p>

<p>var s = numbers.map {
    (var number) -&gt; String in
    var output = &ldquo;&rdquo;
    while number &gt; 0 {
        output = digitNames[number % 10]! + output
        number /= 10
    }
    return output
}</p>

<p>print(s)</p>

<p>// DISPLAY:
// [&ldquo;OneSix&rdquo;, &ldquo;FiveEight&rdquo;, &ldquo;FiveOneZero&rdquo;]</p>

<pre><code>
#### Capturing Values &amp; Closures Are Reference Types

</code></pre>

<p>swift
func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int {
    var runningTotal = 0
    func incrementor() -&gt; Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementor
}
let incrementByTen = makeIncrementor(forIncrement: 10)
let incrementBySeven = makeIncrementor(forIncrement: 7)
let alsoIncrementByTen = incrementByTen</p>

<p>print(makeIncrementor(forIncrement: 10)())
print(makeIncrementor(forIncrement: 10)())
print(incrementByTen())
print(incrementByTen())</p>

<p>print(incrementBySeven())
print(incrementBySeven())</p>

<p>print(incrementByTen())</p>

<p>print(alsoIncrementByTen())</p>

<p>// DISPLAY:
// 10
// 10
// 10
// 20
// 7
// 14
// 30
// 40</p>

<pre><code>
#### Autoclosures

**DIFFICULT TO UNDERSTAND!**

An autoclosure lets you delay evaluation, because the code inside isn’t run until you call the closure.

</code></pre>

<p>swift
var customersInLine = [&ldquo;Chris&rdquo;, &ldquo;Alex&rdquo;, &ldquo;Ewa&rdquo;, &ldquo;Barry&rdquo;, &ldquo;Daniella&rdquo;]
let nextCustomer = { customersInLine.removeAtIndex(0) }
print(customersInLine.count)</p>

<p>print(&ldquo;Now serving (nextCustomer())!&ldquo;)
print(customersInLine.count)</p>

<p>func serveNextCustomer(customer: () -&gt; String) {
    print(&ldquo;Now serving (customer())!&ldquo;)
}
serveNextCustomer( { customersInLine.removeAtIndex(0) } )
print(customersInLine.count)</p>

<p>func serveNextCustomer(@autoclosure customer: () -&gt; String) {
    print(&ldquo;Now serving (customer())!&ldquo;)
}
serveNextCustomer(customersInLine.removeAtIndex(0))
print(customersInLine.count)</p>

<p>var customerClosures: [() -&gt; String] = []
func collectCustomerClosures(@autoclosure(escaping) customer: () -&gt; String) {
    customerClosures.append(customer)
}
collectCustomerClosures(customersInLine.removeAtIndex(0))
collectCustomerClosures(customersInLine.removeAtIndex(0))</p>

<p>print(&ldquo;Collected (customerClosures.count) closures.&ldquo;)</p>

<p>for customerClosure in customerClosures {
    print(&ldquo;Now serving (customerClosure())!&ldquo;)
}</p>

<p>// DISPLAY:
// 5
// Now serving Chris!
// 4
// Now serving Alex!
// 3
// Now serving Ewa!
// 2
// Collected 2 closures.
// Now serving Barry!
// Now serving Daniella!</p>

<pre><code>
---

### Functions

#### Defining and Calling Functions

</code></pre>

<p>swift
func website(a: String) -&gt; String {
    return &ldquo;http://&rdquo; + a + &ldquo;.com&rdquo;
}</p>

<p>print(website(&ldquo;maimieng&rdquo;))</p>

<p>// DISPLAY:
// <a href="http://maimieng.com">http://maimieng.com</a></p>

<pre><code>
#### Function Parameters and Return Values

##### Functions Without Parameters

</code></pre>

<p>swift
func sayHelloWorld() -&gt; String {
    return &ldquo;hello, world&rdquo;
}
print(sayHelloWorld())</p>

<p>// DISPLAY:
// hello, world</p>

<pre><code>
#### Functions With Multiple Parameters

When calling a function with more than one parameter, any argument after the first is **labeled** according to its corresponding parameter name. 

</code></pre>

<p>swift
func swap(a: Int, b: Int) -&gt; (Int, Int) {
    return (b, a)
}</p>

<p>print(swap(1, b: 2))</p>

<p>// DISPLAY:
// (2, 1)</p>

<pre><code>
##### Functions Without Return Values

</code></pre>

<p>swift
func spell(s: String) {
    for c in s.characters {
        print&copy;
    }
}</p>

<p>print(spell(&ldquo;iOS&rdquo;))</p>

<p>// DISPLAY:
// i
// O
// S
// ()</p>

<p>func count(s: String) -&gt; Int {
    return s.characters.count
}</p>

<p>func c(s: String) {
    count(s)
}</p>

<p>print(count(&ldquo;Swift&rdquo;))
print(c(&ldquo;Swift&rdquo;))</p>

<p>// DISPLAY:
// 5
// ()</p>

<pre><code>
##### Functions with Multiple Return Values &amp; Optional Tuple Return Types

</code></pre>

<p>swift
func findMinMax(array: [Int]) -&gt; (min: Int, max: Int)? {
    if array.isEmpty { return nil }
    var cMin = array[0]
    var cMax = array[0]
    for value in array[1..<array.count] {
        if value < cMin {
            cMin = value
        } else if value > cMax {
            cMax = value
        }
    }
    return (cMin, cMax)
}</p>

<p>print(findMinMax([3, 1, 4, 1, 5, 9]))
print(findMinMax([]))</p>

<p>// DISPLAY:
// Optional((1, 9))
// nil</p>

<pre><code>
#### Function Parameter Names

##### Specifying External Parameter Names

If you provide an external parameter name for a parameter, that external name must *always* be used when you call the function.

</code></pre>

<p>swift
func sayHello(to person: String, and anotherPerson: String) -&gt; String {
    return &ldquo;Hello (person) and (anotherPerson)!&rdquo;
}
print(sayHello(to: &ldquo;Bill&rdquo;, and: &ldquo;Ted&rdquo;))</p>

<p>// DISPLAY:
// Hello Bill and Ted!</p>

<pre><code>
##### Omitting External Parameter Names

Because the first parameter omits its external parameter name by default, explicitly writing an underscore is extraneous(`adj.无关的`).

</code></pre>

<p>swift
func someFunction(firstParameterName: Int, _ secondParameterName: Int) {
}
someFunction(1, 2)</p>

<pre><code>
##### Default Parameter Values

</code></pre>

<p>swift
func test(a: Int = 1) {
    print(a)
}</p>

<p>test()
test(5)</p>

<p>// DISPLAY:
// 1
// 5</p>

<pre><code>
##### Variadic(`adj.可变的`) Parameters

A function may have at most one variadic parameter.

</code></pre>

<p>swift
func total(numbers: Double&hellip;) -&gt; Double {
    var t: Double = 0
    for n in numbers {
        t += n
    }
    return t / Double(numbers.count)
}
print(total(1, 2, 3, 4, 5))
print(total(3, 8.25, 18.75))</p>

<p>// DISPLAY:
// 3.0
// 10.0</p>

<pre><code>
##### Constant and Variable Parameters

</code></pre>

<p>swift
func website(var s: String) -&gt; String {
    s += &ldquo;.com&rdquo;
    return s
}</p>

<p>print(website(&ldquo;maimieng&rdquo;))</p>

<p>// DISPLAY:
// maimieng.com</p>

<pre><code>
##### In-Out Parameters

In-out parameters cannot have default values, and variadic parameters cannot be marked as `inout`. If you mark a parameter as `inout`, it cannot also be marked as `var` or `let`.

</code></pre>

<p>swift
func swap(inout a: Int, inout b: Int) {
    let t = a
    a = b
    b = t
}</p>

<p>var a = 1
var b = 2
swap(&amp;a, &amp;b)</p>

<p>print(&ldquo;((a), (b))&ldquo;)</p>

<p>// DISPLAY:
// (2, 1)</p>

<pre><code>
#### Function Types

##### Using Function Types

</code></pre>

<p>swift
func total(a: Int, _ b: Int) -&gt; Int {
    return a + b
}</p>

<p>var t: (Int, Int) -&gt; Int = total
var tl = total</p>

<p>print(t(1, 1))
print(tl(2, 2))</p>

<p>// DISPLAY:
// 2
// 4</p>

<pre><code>
##### Function Types as Parameter Types

</code></pre>

<p>swift
func total(a: Int, _ b: Int) -&gt; Int {
    return a + b
}</p>

<p>func printT(total: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) {
    print(total(a, b))
}</p>

<p>printT(total, 1, 1)</p>

<p>// DISPLAY:
// 2</p>

<pre><code>
##### Function Types as Return Types

</code></pre>

<p>swift
func com(var a: String) -&gt; String {
    a += &ldquo;.com&rdquo;
    return a
}</p>

<p>func http(a: String) -&gt; String {
    let b = &ldquo;http://&rdquo; + a
    return b
}</p>

<p>func website(a: String) -&gt; String {
    if !a.hasPrefix(&ldquo;http://&ldquo;) {
        return http(a)
    }
    if !a.hasSuffix(&ldquo;.com&rdquo;) {
        return com(a)
    }
    return &ldquo;CORRECT&rdquo;
}</p>

<p>print(website(&ldquo;<a href="http://maimieng&quot;)">http://maimieng&quot;)</a>)</p>

<p>// DISPLAY:
// <a href="http://maimieng.com">http://maimieng.com</a></p>

<pre><code>
#### Nested Functions

Nested functions are hidden from the outside world by default, but can still be called and used by their enclosing function. An enclosing function can also return one of its nested functions to allow the nested function to be used in another scope.


</code></pre>

<p>swift
func website(a: String) -&gt; String {</p>

<pre><code>func http(a: String) -&gt; String {
    let b = &quot;http://&quot; + a
    return b
}

func com(var a: String) -&gt; String {
    a += &quot;.com&quot;
    return a
}

if !a.hasPrefix(&quot;http://&quot;) {
    return http(a)
}
if !a.hasSuffix(&quot;.com&quot;) {
    return com(a)
}
return &quot;CORRECT&quot;
</code></pre>

<p>}</p>

<p>print(website(&ldquo;<a href="http://maimieng&quot;)">http://maimieng&quot;)</a>)</p>

<p>// DISPLAY:
// <a href="http://maimieng.com">http://maimieng.com</a></p>

<pre><code>
---

### Control Flow

#### For Loops

##### For-In &amp; For

</code></pre>

<p>swift
// 1&hellip;9 equals to 1..<10
for i in 1...9 {
    for j in 1...9 {
        if (i >= j) {
            print(&rdquo;(j) * (i) = (i * j) &ldquo;, terminator: &ldquo;&rdquo;)
        }
    }
    print(&ldquo;&rdquo;)
}
// DISPLAY:
// 1 * 1 = 1
// 1 * 2 = 2 2 * 2 = 4
// 1 * 3 = 3 2 * 3 = 6 3 * 3 = 9
// 1 * 4 = 4 2 * 4 = 8 3 * 4 = 12 4 * 4 = 16
// 1 * 5 = 5 2 * 5 = 10 3 * 5 = 15 4 * 5 = 20 5 * 5 = 25
// 1 * 6 = 6 2 * 6 = 12 3 * 6 = 18 4 * 6 = 24 5 * 6 = 30 6 * 6 = 36
// 1 * 7 = 7 2 * 7 = 14 3 * 7 = 21 4 * 7 = 28 5 * 7 = 35 6 * 7 = 42 7 * 7 = 49
// 1 * 8 = 8 2 * 8 = 16 3 * 8 = 24 4 * 8 = 32 5 * 8 = 40 6 * 8 = 48 7 * 8 = 56 8 * 8 = 64
// 1 * 9 = 9 2 * 9 = 18 3 * 9 = 27 4 * 9 = 36 5 * 9 = 45 6 * 9 = 54 7 * 9 = 63 8 * 9 = 72 9 * 9 = 81</p>

<pre><code>
</code></pre>

<p>swift
var i = 0
for _ in 1&hellip;5 {
    print(i++)
}</p>

<p>for var a = 0; a &lt; 3; a++ {
    print(a)
}</p>

<p>// DISPLAY:
// 0
// 1
// 2
// 3
// 4
// 0
// 1
// 2</p>

<pre><code>
#### While Loops

##### While &amp; Repeat-While

</code></pre>

<p>swift
var i = 0
while (i++ &lt; 3) {
    print(i)
}</p>

<p>var i = 0
repeat {
    print(i)
} while (i++ &lt; 3)</p>

<p>// DISPLAY:
// 1
// 2
// 3
// 0
// 1
// 2
// 3</p>

<pre><code>
#### Conditional Statements

##### If

Omitted.

##### Switch

</code></pre>

<p>swift
let c: Character = &ldquo;i&rdquo;
switch c {
    case &ldquo;a&rdquo;, &ldquo;e&rdquo;, &ldquo;i&rdquo;, &ldquo;o&rdquo;, &ldquo;u&rdquo;:
    print(&ldquo;c is a vowel.&rdquo;)
    default:
    print(&ldquo;c is not a vowel.&rdquo;)
}</p>

<pre><code>
###### No Implicit Fallthrough

Omitted.

###### Interval Matching

</code></pre>

<p>swift
let a = 123
switch a {
    case 1&hellip;9:
    print(&ldquo;a is small.&rdquo;)
    case 10&hellip;99:
    print(&ldquo;a is medium.&rdquo;)
    case 100&hellip;199:
    print(&ldquo;a is big.&rdquo;)
    default:
    print(&ldquo;a is not sure.&rdquo;)
}</p>

<p>// DISPLAY:
// a is big.</p>

<pre><code>
###### Tuples

</code></pre>

<p>swift
let cs = (1, 1)
switch cs {
case (0, 0):
    print(&ldquo;(0, 0) is center.&rdquo;)
case (_, 0):
    print(&ldquo;((cs.0), 0)&ldquo;)
case (0, _):
    print(&ldquo;(0, (cs.1))&ldquo;)
case (-2&hellip;2, -2&hellip;2):
    print(&ldquo;((cs.0), (cs.1)) is inside.&ldquo;)
default:
    print(&ldquo;((cs.0), (cs.1)) is not sure.&ldquo;)
}</p>

<p>// DISPLAY:
// (1, 1) is inside.</p>

<pre><code>
###### Value Bindings

</code></pre>

<p>swift
let cs = (2, 1)
switch cs {
case (let x, 0):
    print(&rdquo;(x)&ldquo;)
case (0, let y):
    print(&rdquo;(y)&ldquo;)
case let (x, y):
    print(&ldquo;((x), (y))&ldquo;)
}</p>

<p>// DISPLAY:
// (2, 1)</p>

<pre><code>
###### Where

</code></pre>

<p>swift
let cs = (1, -1)
switch cs {
case let (x, y) where x == y:
    print(&ldquo;((x), (y)) x == y&rdquo;)
case let (x, y) where x == -y:
    print(&ldquo;((x), (y)) x == -y&rdquo;)
case let (x, y):
    print(&ldquo;((x), (y))&ldquo;)
}</p>

<p>// DISPLAY:
// (1, -1) x == -y</p>

<pre><code>
#### Control Transfer Statements

##### Continue &amp; Break

Like C, omitted.

##### Fallthrough

Like C.

</code></pre>

<p>swift
let i = 5
var d = &ldquo;The number (i) is&rdquo;
switch i {
case 2, 3, 5, 7, 11, 13, 17, 19:
    d += &ldquo; a prime number, and also&rdquo;
    fallthrough
default:
    d += &ldquo; an integer.&rdquo;
}
print(d)</p>

<p>// DISPLAY:
// The number 5 is a prime number, and also an integer.</p>

<pre><code>
##### Labeled Statements

`label name: while condition { statements }` in `switch` &amp; `while`

#### Early Exit

</code></pre>

<p>swift
func test() {
    let d = [&ldquo;hello&rdquo;: &ldquo;hi&rdquo;]
    guard d.isEmpty else {
        print(&ldquo;c isn&rsquo;t empty.&rdquo;)
        return
    }
}
test()</p>

<p>// DISPLAY:
// c isn&rsquo;t empty.</p>

<pre><code>
#### Checking API Availability

![3]()

</code></pre>

<p>swift
if #available(iOS 9, *) {
    print(&ldquo;Yes&rdquo;)
} else {
    print(&ldquo;No&rdquo;)
}</p>

<p>// DISPLAY:
// Yes</p>

<pre><code>
---

### Collection Types

![1]()

Swift provides three primary *collection types*, known as arrays, sets, and dictionaries, for storing collections of values.
1. Arrays are ordered collections of values. 
2. Sets are unordered collections of unique values. 
3. Dictionaries are unordered collections of key-value associations.

Arrays, sets, and dictionaries in Swift are always clear about the types of values and keys that they can store. This means that you cannot insert a value of the wrong type into a collection by mistake. It also means you can be confident about the type of values you will retrieve from a collection.

Swift’s array, set, and dictionary types are implemented as *generic(`adj.范型`) collections*. 

#### Mutability(`n.易变性`) of Collections

If you create an array, a set, or a dictionary, and assign it to a variable, the collection that is created will be *mutable*. This means that you can change (or *mutate*) the collection after it is created by adding, removing, or changing items in the collection. If you assign an array, a set, or a dictionary to a constant, that collection is immutable, and its size and contents cannot be changed.

It is good practice to create immutable collections in all cases where the collection does not need to change. Doing so enables the Swift compiler to optimize the performance of the collections you create.

#### Arrays

Swift’s `Array` type is bridged to Foundation’s `NSArray` class.

##### Array Type Shorthand(`n.速记`) Syntax

`Array&lt;Element&gt;` &amp; `[Element]`

##### Creating an Empty Array

</code></pre>

<p>swift
var a = [Int]()
print(a.count)</p>

<p>a.append(3)
print(a)
a = []
print(a,count)</p>

<p>// DISPLAY:
// 0
// [3]
// 0</p>

<pre><code>
##### Creating an Array with a Default Value

</code></pre>

<p>swift
var a = <a href="count: 3, repeatedValue: 0">Double</a>
print(a)</p>

<p>// DISPLAY:
// [0.0, 0.0, 0.0]</p>

<pre><code>
##### Creating an Array by Adding Two Arrays Together

</code></pre>

<p>swift
var a = <a href="count: 3, repeatedValue: 0">Double</a>
var b = <a href="count: 2, repeatedValue: 1.5">Double</a>
var c = b + a
print&copy;</p>

<p>// DISPLAY:
// [1.5, 1.5, 0.0, 0.0, 0.0]</p>

<pre><code>
##### Creating an Array with an Array Literal

</code></pre>

<p>swift
var s: [String] = [&ldquo;mai&rdquo;, &ldquo;mieng&rdquo;]
var str = [&ldquo;mai&rdquo;, &ldquo;mieng&rdquo;]
if s == str {
    print(&ldquo;s == str&rdquo;)
}</p>

<p>// DISPLAY:
// s == str</p>

<pre><code>
##### Accessing and Modifying an Array

</code></pre>

<p>swift
var s: [String] = [&ldquo;mai&rdquo;, &ldquo;mieng&rdquo;]</p>

<p>print(s.count)
print(s.isEmpty)</p>

<p>s.append(&ldquo;.com&rdquo;)
s += [&ldquo;v2ex&rdquo;, &ldquo;.com&rdquo;]</p>

<p>s[3] = &ldquo;sspai&rdquo;
print(s[3])</p>

<p>s[3&hellip;4] = []
print(s)</p>

<p>s.insert(&ldquo;http://&ldquo;, atIndex: 0)
print(s)</p>

<p>print(s.removeAtIndex(0))
print(s.removeLast())</p>

<p>print(s)</p>

<p>// DISPLAY:
// 2
// false
// sspai
// [&ldquo;mai&rdquo;, &ldquo;mieng&rdquo;, &ldquo;.com&rdquo;]
// [&ldquo;http://&ldquo;, &ldquo;mai&rdquo;, &ldquo;mieng&rdquo;, &ldquo;.com&rdquo;]
// http://
// .com
// [&ldquo;mai&rdquo;, &ldquo;mieng&rdquo;]</p>

<pre><code>
##### Iterating(`v.重复`) Over an Array

</code></pre>

<p>swift
var s: [String] = [&ldquo;mai&rdquo;, &ldquo;mieng&rdquo;]</p>

<p>for str in s {
    print(str)
}</p>

<p>for (index, value) in s.enumerate() {
    print(&ldquo;((index), (value))&ldquo;)
}</p>

<p>// DISPLAY:
// mai
// mieng
// (0, mai)
// (1, mieng)</p>

<pre><code>
#### Sets

A *set* stores distinct values of the same type in a collection with no defined ordering. You can use a set instead of an array when the order of items is not important, or when you need to ensure that an item only appears once.

Swift’s `Set` type is bridged to Foundation’s `NSSet` class.

##### Hash Values for Set Types

Omitted.

##### Set Type Syntax

`Set&lt;Element&gt;`

##### Creating and Initializing an Empty Set

</code></pre>

<p>swift
var s = Set<Character>()
print(s.count)</p>

<p>s.insert(&ldquo;!&rdquo;)
print(s.count)</p>

<p>s = []
print(s.count)</p>

<p>// DISPLAY:
// 0
// 1
// 0</p>

<pre><code>
##### Creating a Set with an Array Literal

</code></pre>

<p>swift
var s: Set<Int> = [1, 2, 3, 4]
var set: Set = [&ldquo;mai&rdquo;, &ldquo;mieng&rdquo;]</p>

<pre><code>
##### Accessing and Modifying a Set

</code></pre>

<p>swift
var s: Set = [1, 2, 3, 4]
print(s.count)</p>

<p>if !s.isEmpty {
    print(&ldquo;s is empty.&rdquo;);
}</p>

<p>s.insert(5)
print(s.count)</p>

<p>print(s.remove(3))</p>

<p>print(s.remove(3))</p>

<p>s.removeAll()
print(s.count)</p>

<p>if s.contains(3) {
    print(&ldquo;s contains 3.&rdquo;)
} else {
    print(&ldquo;s doesn&rsquo;t contain 3.&rdquo;)
}</p>

<p>// DISPLAY:
// 4
// s is empty.
// 5
// Optional(3)
// nil
// 0
// s doesn&rsquo;t contain 3</p>

<pre><code>
##### Iterating Over a Set

</code></pre>

<p>swift
var s: Set = [1, 2, 3, 4]</p>

<p>for set in s {
    print(&rdquo;(set)&ldquo;)
}</p>

<p>for set in s.sort() {
    print(&rdquo;(set)&ldquo;)
}</p>

<p>// DISPLAY:
// 2
// 3
// 1
// 4
// 1
// 2
// 3
// 4</p>

<pre><code>
#### Performing Set Operations

##### Fundamental Set Operations

![2]()

</code></pre>

<p>swift
var a: Set = [1, 2, 3, 4, 5]
var b: Set = [2, 4, 6]
var c: Set = [1, 3, 5]</p>

<p>print(a.exclusiveOr(b).sort())
print(a.intersect&copy;.sort())
print(b.union&copy;.sort())</p>

<p>print(a.subtract(b).sort())
print(b.subtract(a).sort())</p>

<p>// DISPLAY:
// [1, 3, 5, 6]
// [1, 3, 5]
// [1, 2, 3, 4, 5, 6]
// [1, 3, 5]
// [6]</p>

<pre><code>
##### Set Membership and Equality

</code></pre>

<p>swift
var a: Set = [&ldquo;😂&rdquo;, &ldquo;😊&rdquo;]
var b: Set = [&ldquo;😊&rdquo;, &ldquo;😄&rdquo;]
var c: Set = [&ldquo;😂&rdquo;]</p>

<p>print(a == b)
print(c.isSubsetOf(a))
print(a.isSupersetOf(a))</p>

<p>print(c.isDisjointWith(b))
print(c.isStrictSubsetOf(a))
print(a.isStrictSubsetOf(a))</p>

<p>print(a.isStrictSupersetOf&copy;)
print(a.isStrictSupersetOf(a))</p>

<p>// DISPLAY:
// false
// true
// true
// true
// true
// false
// true
// false</p>

<pre><code>
#### Dictionaries

Swift’s `Dictionary` type is bridged to Foundation’s `NSDictionary` class.

##### Dictionary Type Shorthand Syntax

`Dictionary&lt;Key, Value&gt;` &amp; `[Key: Value]`

##### Creating an Empty Dictionary

</code></pre>

<p>swift
var d = [Int: String]()</p>

<p>d[404] = &ldquo;not found&rdquo;
print(d.count)</p>

<p>d = [:]
print(d.count)</p>

<p>// DISPLAY:
// 1
// 0</p>

<pre><code>
##### Creating a Dictionary with a Dictionary Literal

</code></pre>

<p>swift
var d: [Int: String] = [404: &ldquo;not found&rdquo;, 502: &ldquo;bad gateway&rdquo;]
var dy = [&ldquo;height&rdquo;: 180, &ldquo;weight&rdquo;: 60]</p>

<pre><code>
##### Accessing and Modifying a Dictionary

</code></pre>

<p>swift
var dy = [&ldquo;height&rdquo;: 180, &ldquo;weight&rdquo;: 60]</p>

<p>print(dy.count)</p>

<p>dy[&ldquo;wage&rdquo;] = 0
print(dy)</p>

<p>dy[&ldquo;height&rdquo;] = 185
print(dy)</p>

<p>print(dy.updateValue(65, forKey: &ldquo;weight&rdquo;))</p>

<p>dy[&ldquo;wage&rdquo;] = nil
print(dy)</p>

<p>print(dy.removeValueForKey(&ldquo;age&rdquo;))</p>

<p>// DISPLAY:
// 2
// [&ldquo;height&rdquo;: 180, &ldquo;weight&rdquo;: 60, &ldquo;wage&rdquo;: 0]
// [&ldquo;height&rdquo;: 185, &ldquo;weight&rdquo;: 60, &ldquo;wage&rdquo;: 0]
// Optional(60)
// [&ldquo;height&rdquo;: 185, &ldquo;weight&rdquo;: 65]
// nil</p>

<pre><code>
##### Iterating Over a Dictionary

To iterate over the keys or values of a dictionary in a specific order, use the `sort()` method on its `keys` or `values` property.

</code></pre>

<p>swift
var dy = [&ldquo;age&rdquo;: 20, &ldquo;height&rdquo;: 180, &ldquo;weight&rdquo;: 60, &ldquo;wage&rdquo;: 0]</p>

<p>for (des, value) in dy {
    print(&ldquo;(&rdquo; + des + &ldquo;, (value))&ldquo;)
}</p>

<p>for des in dy.keys {
    print(des)
}</p>

<p>for value in dy.values {
    print(value)
}</p>

<p>var dyDes = <a href="dy.keys">String</a>
var dyValue = <a href="dy.values">Int</a></p>

<p>// DISPLAY:
// (height, 180)
// (age, 20)
// (weight, 60)
// (wage, 0)
// height
// age
// weight
// wage
// 180
// 20
// 60
// 0</p>

<p>// &mdash;
for d in dy.enumerate() {
    print(d)
}
// &mdash;
// DISPLAY:
// (0, (&ldquo;height&rdquo;, 180))
// (1, (&ldquo;age&rdquo;, 20))
// (2, (&ldquo;weight&rdquo;, 60))
// (3, (&ldquo;wage&rdquo;, 0))</p>

<pre><code>
---

### Strings and Characters

Swift’s `String` type is bridged with Foundation’s `NSString` class. If you are working with the Foundation framework in Cocoa, the entire `NSString` API is available to call on any `String` value you create when type cast to `NSString`, as described in AnyObject. You can also use a `String` value with any API that requires an `NSString` instance.

#### String Literals(`n.字面量`)

</code></pre>

<p>swift
let testString = &ldquo;maimieng&rdquo;</p>

<pre><code>
#### Initializing an Empty String

</code></pre>

<p>swift
var s = &ldquo;&rdquo;
var str = String()
s = &ldquo;hello&rdquo;
if Str.isEmpty {
    Str = &ldquo;hi&rdquo;
}
print(s + &ldquo; &rdquo; + str)</p>

<p>var Str: String
Str = &ldquo;&rdquo; // Initialize
if Str.isEmpty {
    Str = &ldquo;Hi!&rdquo;
}
print(Str)
// DISPLAY:
// hello hi
// Hi!</p>

<pre><code>
#### String Mutability(`n.易变性`)

</code></pre>

<p>swift
var myWebsite = &ldquo;maimieng&rdquo;
myWebsite += &ldquo;.com&rdquo;</p>

<pre><code>
#### Strings Are Value Types

Behind the scenes, Swift’s compiler optimizes(`v.优化`) string usage so that actual copying takes place only when absolutely necessary. This means you always get great performance when working with strings as value types.

#### Working with Characters

</code></pre>

<p>swift
for c in &ldquo;Laugh: 😂&rdquo;.characters {
    print&copy;
}
let testCharacter: Character = &ldquo;.&rdquo;
var charArray: [Character] = [&ldquo;s&rdquo;, &ldquo;w&rdquo;, &ldquo;i&rdquo;, &ldquo;f&rdquo;, &ldquo;t&rdquo;]
print(charArray)
print(String(charArray))
// DISPLAY:
// L
// a
// u
// g
// h
// :
//<br />
// 😂
// [&ldquo;s&rdquo;, &ldquo;w&rdquo;, &ldquo;i&rdquo;, &ldquo;f&rdquo;, &ldquo;t&rdquo;]
// swift</p>

<pre><code>
#### Concatenating(`n.连接`) Strings and Characters

You can’t append a `String` or `Character` to an existing `Character` variable, because a `Character` value must contain a single character only.

</code></pre>

<p>swift
var a = &ldquo;mai&rdquo;
var b = &ldquo;mieng&rdquo;
var c: Character = &ldquo;.&rdquo;
var d = a + b
a += b
d.append&copy;
print(a)
print(d)
// DISPLAY:
// maimieng
// maimieng.</p>

<pre><code>
#### String Interpolation(`n.插入`)

The expressions you write inside parentheses(`n.圆括号`) within an interpolated(`adj.插入的`) string cannot contain an unescaped double quote (`&quot;`) or backslash (`\`), and cannot contain a *carriage return(`回车`)* or *line feed(`换行`)*.

</code></pre>

<p>swift
let multiplier = 3
let message = &ldquo;(multiplier) times 2.5 is (Double(multiplier) * 2.5)&rdquo;
print(message)
// DISPLAY:
// 3 times 2.5 is 7.5</p>

<pre><code>
#### Unicode

Swift’s `String` and `Character` types are fully Unicode-compliant, as described in this section.

##### Unicode Scalars(`n.标量`)

Behind the scenes, Swift’s native `String` type is built from Unicode scalar values. A Unicode scalar is a unique(`adj.唯一的`) 21-bit number for a character or modifier(`n.修饰符`), such as `U+0061` for `LATIN(adj.拉丁的) SMALL LETTER A` (`&quot;a&quot;`), or `U+1F425` for `FRONT-FACING BABY CHICK` (`&quot;🐥&quot;`).

&gt; NOTE
A Unicode scalar is any Unicode code point in the range `U+0000` to `U+D7FF` inclusive(`adj.包括的`) or `U+E000` to `U+10FFFF` inclusive. Unicode scalars do **not** include the Unicode surrogate(`n.替代品`) pair code points, which are the code points in the range `U+D800` to `U+DFFF` inclusive.

Note that **not** all 21-bit Unicode scalars are assigned to a character—some scalars are reserved for future assignment. Scalars that have been assigned to a character typically also have a name, such as `LATIN SMALL LETTER A` and `FRONT-FACING BABY CHICK` in the examples above.

##### Special Characters in String Literals

String literals can include the following special characters:
- The escaped special characters `\0` (null character), `\\` (backslash), `\t` (horizontal(`adj.水平的`) tab), `\n` (line feed), `\r` (carriage return), `\&quot;` (double quote) and `\'` (single quote)
- An arbitrary(`adj.武断的`) Unicode scalar, written as `\u{n}`, where `n` is a 1–8 digit hexadecimal number with a value equal to a valid Unicode code point

The code below shows four examples of these special characters. The `wiseWords` constant contains two escaped double quote characters. The `dollarSign`, `blackHeart`, and `sparklingHeart` constants demonstrate the Unicode scalar format:

</code></pre>

<p>swift
let wiseWords = &ldquo;\&ldquo;Imagination is more important than knowledge\&rdquo; - Einstein&rdquo;
let dollarSign = &ldquo;\u{24}&rdquo;
let blackHeart = &ldquo;\u{2665}&rdquo;
let sparklingHeart = &ldquo;\u{1F496}&rdquo;
print(wiseWords)
print(dollarSign)
print(blackHeart)
print(sparklingHeart)
// DISPLAY:
// &ldquo;Imagination is more important than knowledge&rdquo; - Einstein
// $
// ♥
// 💖</p>

<pre><code>
##### Extended Grapheme(`n.字形`) Clusters(`n.群集`)

Every instance of Swift’s `Character` type represents a single extended grapheme cluster. An extended grapheme cluster is a sequence of one or more Unicode scalars that (when combined) produce a single human-readable character.

Here’s an example. The letter `é` can be represented as the single Unicode scalar `é` (`LATIN SMALL LETTER E WITH ACUTE(n.重读)`, or `U+00E9`). However, the same letter can also be represented as a pair of scalars—a standard letter `e` (`LATIN SMALL LETTER E`, or `U+0065`), followed by the `COMBINING ACUTE ACCENT` scalar (`U+0301`). The `COMBINING ACUTE ACCENT` scalar is graphically applied to the scalar that precedes(`v.优先`) it, turning an `e` into an `é` when it is rendered(`v.成为`) by a Unicode-aware text-rendering system.

In both cases, the letter `é` is represented as a single Swift Character value that represents an extended grapheme cluster. In the first case, the cluster contains a single scalar; in the second case, it is a cluster of two scalars:

</code></pre>

<p>swift
let eAcute: Character = &ldquo;\u{E9}&rdquo;
let combinedEAcute: Character = &ldquo;\u{65}\u{301}&rdquo;
print(eAcute)
print(combinedEAcute)
// DISPLAY:
// é
// é</p>

<pre><code>
Extended grapheme clusters are a flexible way to represent many complex script characters as a single Character value. For example, Hangul(`n.韩语`) syllables(`n.音节`) from the Korean alphabet can be represented as either a precomposed(`adj.预先构成的`) or decomposed(`adj.已分解的`) sequence. Both of these representations qualify as a single Character value in Swift:

</code></pre>

<p>swift
let precomposed: Character = &ldquo;\u{D55C}&rdquo;
let decomposed: Character = &ldquo;\u{1112}\u{1161}\u{11AB}&rdquo;
print(precomposed)
print(decomposed)
// DISPLAY:
// 한
// 한</p>

<pre><code>
Extended grapheme clusters enable scalars for enclosing marks (such as `COMBINING ENCLOSING CIRCLE`, or `U+20DD`) to enclose other Unicode scalars as part of a single Character value:

</code></pre>

<p>swift
let enclosedEAcute: Character = &ldquo;\u{E9}\u{20DD}&rdquo;
print(enclosedEAcute)
// DISPLAY:
// é⃝</p>

<pre><code>
Unicode scalars for regional indicator symbols can be combined in pairs to make a single `Character` value, such as this combination of `REGIONAL INDICATOR SYMBOL LETTER U` (`U+1F1FA`) and `REGIONAL INDICATOR SYMBOL LETTER S` (`U+1F1F8`):

</code></pre>

<p>swift
let regionalIndicatorForUS: Character = &ldquo;\u{1F1FA}\u{1F1F8}&rdquo;
print(regionalIndicatorForUS)
// DISPLAY:
// 🇺🇸</p>

<pre><code>
#### Counting Characters

Note that Swift’s use of extended grapheme clusters for `Character` values means that string concatenation and modification may not always affect a string’s character count.

&gt; NOTE
Extended grapheme clusters can be composed of one or more Unicode scalars. This means that different characters—and different representations of the same character—can require different amounts of memory to store. Because of this, characters in Swift do not each take up the same amount of memory within a string’s representation. As a result, the number of characters in a string cannot be calculated without iterating(`v.遍历`) through the string to determine its extended grapheme cluster boundaries. If you are working with particularly long string values, be aware that the `characters` property must iterate over the Unicode scalars in the entire string in order to determine the characters for that string.

&gt; The count of the characters returned by the `characters` property is not always the same as the length property of an `NSString` that contains the same characters. The length of an `NSString` is based on the number of 16-bit code units within the string’s UTF-16 representation and not the number of Unicode extended grapheme clusters within the string.

</code></pre>

<p>swift
let myWebsite = &ldquo;我的网址是：maimieng.com 😂&rdquo;
print(myWebsite.characters.count)
// DISPLAY:
// 20</p>

<p>var enclosedEAcute = &ldquo;\u{E9}&rdquo;
print(enclosedEAcute.characters.count)
enclosedEAcute += &ldquo;\u{20DD}&rdquo;
print(enclosedEAcute.characters.count)
// DISPLAY:
// 1
// 1</p>

<pre><code>
#### Accessing and Modifying a String

##### String Indices(`n.索引`)

</code></pre>

<p>swift
let myWebsite = &ldquo;maimieng.com&rdquo;
print(myWebsite[myWebsite.startIndex])
print(myWebsite[myWebsite.endIndex.predecessor()])
print(myWebsite[myWebsite.startIndex.successor()])</p>

<p>var index = myWebsite.startIndex.advancedBy(8)
print(myWebsite[index])</p>

<p>for index in myWebsite.characters.indices {
    print(&rdquo;(myWebsite[index])&ldquo;, terminator: &ldquo;_&ldquo;)
}</p>

<p>// DISPLAY:
// m
// m
// a
// .
// m_a_i_m_i_e_n<em>g</em>._c_o<em>m</em></p>

<p>// INCORRECT CODE:
// print(myWebsite[myWebsite.endIndex - 1])
// The &lsquo;endIndex&rsquo; isn&rsquo;t type &lsquo;int&rsquo; but &lsquo;index&rsquo;.
// print(myWebsite[myWebsite.endIndex])
// print(myWebsite[myWebsite.startIndex.predecessor()])
// Runtime error: Beyond the string&rsquo;s range.</p>

<pre><code>
##### Inserting and Removing

</code></pre>

<p>swift
var myWebsite = &ldquo;maimiengcom&rdquo;
myWebsite.insert(&ldquo;.&rdquo;, atIndex: myWebsite.startIndex.advancedBy(8))
print(myWebsite)</p>

<p>myWebsite.insertContentsOf(&ldquo;http://&ldquo;.characters, at: myWebsite.startIndex)
print(myWebsite)</p>

<p>myWebsite.removeAtIndex(myWebsite.endIndex.advancedBy(-4))
print(myWebsite)</p>

<p>let range = myWebsite.endIndex.advancedBy(-3)..&lt;myWebsite.endIndex
myWebsite.removeRange(range)
print(myWebsite)</p>

<p>// DISPLAY:
// maimieng.com
// <a href="http://maimieng.com">http://maimieng.com</a>
// <a href="http://maimiengcom">http://maimiengcom</a>
// <a href="http://maimieng">http://maimieng</a></p>

<pre><code>
#### Comparing Strings

##### String and Character Equality

String and character comparisons in Swift are *not* locale-sensitive(`adj.本地敏感的`).(意思是 Swift 中的字符和字符串无论在哪个语言区域，其表现和功能都是相同的)

`==` &amp; `!=`:

</code></pre>

<p>swift
var a = &ldquo;hello&rdquo;
var b = &ldquo;hello&rdquo;</p>

<p>if a == b {
    print(&ldquo;a == b&rdquo;)
}
// DISPLAY:
// a == b</p>

<pre><code>
Two `String` values (or two Character values) are considered equal if their extended grapheme clusters are *canonically(`adv.按标准地`) equivalent*. Extended grapheme clusters are canonically equivalent if they have the same linguistic(`adj.语言学的`) meaning and appearance, even if they are composed from different Unicode scalars behind the scenes.

For example, `LATIN SMALL LETTER E WITH ACUTE` (`U+00E9`) is canonically equivalent to `LATIN SMALL LETTER E` (`U+0065`) followed by `COMBINING ACUTE ACCENT` (`U+0301`). Both of these extended grapheme clusters are valid ways to represent the character `é`, and so they are considered to be canonically equivalent:

</code></pre>

<p>swift
let eAcuteQuestion = &ldquo;\u{E9}&rdquo;</p>

<p>let combinedEAcuteQuestion = &ldquo;\u{65}\u{301}&rdquo;</p>

<p>if eAcuteQuestion == combinedEAcuteQuestion {
    print(eAcuteQuestion + &ldquo; == &rdquo; + combinedEAcuteQuestion)
}
// DISPLAY:
// é == é</p>

<pre><code>
Conversely, `LATIN CAPITAL LETTER A` (`U+0041`, or `&quot;A&quot;`), as used in English, is *not* equivalent to `CYRILLIC CAPITAL LETTER A` (`U+0410`, or `&quot;А&quot;`), as used in Russian. The characters are visually similar, but do not have the same linguistic meaning:

</code></pre>

<p>swift
let latinCapitalLetterA:Character = &ldquo;\u{41}&rdquo;</p>

<p>let cyrillicCapitalLetterA:Character = &ldquo;\u{0410}&rdquo;</p>

<p>if latinCapitalLetterA != cyrillicCapitalLetterA {
    var a = &ldquo;&rdquo;, b = &ldquo;&rdquo;
    a.append(cyrillicCapitalLetterA)
    b.append(latinCapitalLetterA)
    print(a + &ldquo; != &rdquo; + b)
}
// DISPLAY:
// А != A</p>

<pre><code>
##### Prefix and Suffix Equality

The `hasPrefix(_:)` and `hasSuffix(_:)` methods perform a character-by-character canonical equivalence comparison between the extended grapheme clusters in each string.

</code></pre>

<p>swift
let iPhone = [
    &ldquo;2007: iPhone&rdquo;,
    &ldquo;2008: iPhone 3G&rdquo;,
    &ldquo;2009: iPhone 3GS&rdquo;,
    &ldquo;2010: iPhone 4&rdquo;,
    &ldquo;2011: iPhone 4s&rdquo;,
    &ldquo;2012: iPhone 5&rdquo;,
    &ldquo;2013: iPhone 5c&rdquo;,
    &ldquo;2013: iPhone 5s&rdquo;,
    &ldquo;2014: iPhone 6&rdquo;,
    &ldquo;2014: iPhone 6 Plus&rdquo;,
    &ldquo;2015: iPhone 6s&rdquo;,
    &ldquo;2015: iPhone 6s Plus&rdquo;
]</p>

<p>var hasC = 0
var in2015 = 0
for i in iPhone {
    if i.hasSuffix(&ldquo;c&rdquo;) {
        hasC++
    }
    if i.hasPrefix(&ldquo;2015&rdquo;) {
        in2015++
    }
}
print(hasC)
print(in2015)</p>

<p>// DISPLAY:
// 1
// 2</p>

<pre><code>
#### Unicode Representations of Strings

Omitted.

---

### Basic Operators

#### Terminology(`n.术语`)


Unary(`adj.一元的`), binary(`adj.二元的`), or ternary(`adj.三元的`) operators.

</code></pre>

<p>swift
int a = 10
int b = -a</p>

<p>a ? b : c</p>

<pre><code>
#### Assignment Operator

Assignment operator does **not return** a value.

</code></pre>

<p>swift
let a = 10
var v = 5
v = a</p>

<p>let (x, y) = (1, 2)
print(&ldquo;((x), (y))&ldquo;)
// DISPLAY:
// (1, 2)</p>

<p>// if (x = y) {
//  &hellip;
// }
// Bug:
// x = y does not return a value.</p>

<pre><code>
#### Arithmetic(`n.算术`) Operators

</code></pre>

<p>swift
let a = 1
let b = 5</p>

<p>var c: Int
c = a + b
print&copy;</p>

<p>c = a - b
print&copy;</p>

<p>c = a * b
print&copy;</p>

<p>var d = Double(a) / Double(b)
print(d)
// DISPLAY:
// 6
// -4
// 5
// 0.2</p>

<pre><code>
##### Remainder(`n.求余`) Operator

To determine the answer for `a % b`, the `%` operator calculates the following equation and returns remainder as its output:

`a = (b x some multiplier) + remainder`

</code></pre>

<p>swift
var a = 2
var b = 5
var c = -4</p>

<p>print(a % b)
print(c % b)</p>

<p>// DISPLAY:
// 2
// -4</p>

<pre><code>
##### Floating-Point Remainder Calculations

</code></pre>

<p>swift
var d = 0.3
var e = 0.8</p>

<p>print(e % d)
// DISPLAY:
// 0.2</p>

<pre><code>
##### Increment and Decrement Operators

</code></pre>

<p>swift
var a = 1
print(a++)
print(++a)
// DISPLAY:
// 1
// 3</p>

<pre><code>
##### Unary Minus Operator &amp; Unary Plus Operator

</code></pre>

<p>swift
var a = -1
a = -a
print(a)
print(+a)
// DISPLAY:
// 1
// 1</p>

<pre><code>
#### Compound(`adj.复合的`) Assignment Operators

</code></pre>

<p>swift
print(1 == 5)
print(1 != 5)
print(1 &gt;= 5)
print(1 &lt;= 5)
print(2 &gt; 3)
print(2 &lt; 3)
// DISPLAY:
// false
// true
// false
// true
// false
// true</p>

<pre><code>
#### Ternary Conditional Operator

</code></pre>

<p>swift
let a = true
let b = a ? 1 : 0
print(b)</p>

<p>let c: Int
if a {
    c = 1
} else {
    c = 0
}
print&copy;
// DISPLAY:
// 1
// 1</p>

<pre><code>
#### Nil Coalescing(`n.合并`) Operator

The `nil` coalescing operator (`a ?? b`) unwraps an optional `a` if it contains a value, or returns a default value `b` if a is `nil`. 

The expression `a` is always of an optional type.
The expression `b` must match the type that is stored inside `a`.

</code></pre>

<p>swift
let defaultGreeting = &ldquo;Hello!&rdquo;
var myGreeting: String?
print(myGreeting ?? defaultGreeting)
myGreeting = &ldquo;Hi!&rdquo;
print(myGreeting ?? defaultGreeting)
// DISPLAY:
// Hello!
// Hi!</p>

<pre><code>
#### Range Operators

##### Closed Range Operator &amp; Half-Open Range Operator

`for-in` loop:

The closed range operator (`a...b`) defines `a` range that runs from `a` to `b`, and includes the values `a` and `b`.
The half-open range operator (`a..&lt;b`) defines `a` range that runs from `a` to `b`, but does **not** include `b`. 

</code></pre>

<p>swift
// 1&hellip;9 equals to 1..<10
for i in 1...9 {
    for j in 1...9 {
        if (i >= j) {
            print(&rdquo;(j) * (i) = (i * j) &ldquo;, terminator: &ldquo;&rdquo;)
        }
    }
    print(&ldquo;&rdquo;)
}
// DISPLAY:
// 1 * 1 = 1
// 1 * 2 = 2 2 * 2 = 4
// 1 * 3 = 3 2 * 3 = 6 3 * 3 = 9
// 1 * 4 = 4 2 * 4 = 8 3 * 4 = 12 4 * 4 = 16
// 1 * 5 = 5 2 * 5 = 10 3 * 5 = 15 4 * 5 = 20 5 * 5 = 25
// 1 * 6 = 6 2 * 6 = 12 3 * 6 = 18 4 * 6 = 24 5 * 6 = 30 6 * 6 = 36
// 1 * 7 = 7 2 * 7 = 14 3 * 7 = 21 4 * 7 = 28 5 * 7 = 35 6 * 7 = 42 7 * 7 = 49
// 1 * 8 = 8 2 * 8 = 16 3 * 8 = 24 4 * 8 = 32 5 * 8 = 40 6 * 8 = 48 7 * 8 = 56 8 * 8 = 64
// 1 * 9 = 9 2 * 9 = 18 3 * 9 = 27 4 * 9 = 36 5 * 9 = 45 6 * 9 = 54 7 * 9 = 63 8 * 9 = 72 9 * 9 = 81</p>

<pre><code>
#### Logical Operators

##### Logical NOT Operator

</code></pre>

<p>swift
let a = true
if !a {
    print(&ldquo;true&rdquo;)
} else {
    print(&ldquo;false&rdquo;)
}
// DISPLAY:
// false</p>

<pre><code>
##### Logical AND Operator &amp; Logical OR Operator

</code></pre>

<p>swift
let a = true
let b = false</p>

<p>if a &amp;&amp; b {
    print(&ldquo;true&rdquo;)
} else if (a || b) {
    print(&ldquo;false&rdquo;)
}
// DISPLAY:
// false</p>

<pre><code>
##### Combining Logical Operators

The Swift logical operators `&amp;&amp;` and `||` are left-associative, meaning that compound expressions with multiple logical operators evaluate the leftmost subexpression first.

</code></pre>

<p>swift
let a = true
let b = !a // false
let c = a &amp;&amp; b // false
let d = a || b // true
if a &amp;&amp; b || c &amp;&amp; d {
    print(&ldquo;true&rdquo;)
} else {
    print(&ldquo;false&rdquo;)
}
// DISPLAY:
// false</p>

<pre><code>
##### Explicit(`adj.明确的`) Parentheses(`n.小括号`)

</code></pre>

<p>swift
let a = true
let b = !a // false
let c = a &amp;&amp; b // false
let d = a || b // true
if (a || b) &amp;&amp; (c || d) {
    print(&ldquo;true&rdquo;)
} else {
    print(&ldquo;false&rdquo;)
}
// DISPLAY:
// true</p>

<pre><code>
---

### The Basics

#### Constants and Variables

##### Declaring Constants and Variables

</code></pre>

<p>swift
var i = 3
var Pi = 3.14, c = &ldquo;V&rdquo;</p>

<p>let myWebsite = &ldquo;maimieng.com&rdquo;</p>

<pre><code>
##### Type Annotations

</code></pre>

<p>swift
var sumOfStu: Int
var newColor, silver, gold, space_gray: String
newColor = &ldquo;Rose Gold&rdquo;</p>

<pre><code>
##### Naming Constants and Variables

</code></pre>

<p>swift
let π = 3.14
let 😂 = &ldquo;大笑&rdquo;
var 网站 = &ldquo;maimieng&rdquo;</p>

<p>网站 += &ldquo;.com&rdquo;</p>

<p>let <code>let</code> = 1</p>

<p>// INCORRECT CODE:
// π = 3
// R: π is a constant that can&rsquo;t change its value.</p>

<pre><code>
##### Printing Constants and Variables

</code></pre>

<p>swift
var myMac = &ldquo;MacBook Pro&rdquo;
let myMacSize = 13
print(myMac + &ldquo; (myMacSize)&ldquo;)
// DISPLAY:
// MacBook Pro 13</p>

<pre><code>
#### Comments

</code></pre>

<p>swift
// Comment of one line.</p>

<p>/* Comment around several lines. */</p>

<pre><code>
#### Semicolons

</code></pre>

<p>swift
let Sem = &ldquo;;&rdquo;; print(Sem)
// DISPLAY:
// ;</p>

<pre><code>
#### Integers

##### Integer Bounds(`n.范围`)

</code></pre>

<p>swift
let minValue = Int64.min
let maxValue = UInt8.max</p>

<pre><code>
##### Int

On a 32-bit platform, `Int` is the same size as `Int32`.
On a 64-bit platform, `Int` is the same size as `Int64`.

##### UInt

On a 32-bit platform, `UInt` is the same size as `UInt32`.
On a 64-bit platform, `UInt` is the same size as `UInt64`.

*`Int` is preferred.*

#### Floating-Point Numbers

`Double` represents a 64-bit floating-point number.
`Float` represents a 32-bit floating-point number.

*`Double` is preferred.*

`Double` has a precision(`n.明确`) of at least **15** decimal digits.
`Float` can be as little as **6** decimal digits.

#### Type Safety and Type Inference

</code></pre>

<p>swift
let myPi = 3 + 0.14
// myPi is a double value.</p>

<pre><code>
#### Numeric(`adj.数值型的`) Literals

A *decimal* number, with no prefix
A *binary* number, with a `0b` prefix
An *octal(`adj.八进制的`)* number, with a `0o` prefix
A *hexadecimal(`adj.十六进制的`)* number, with a `0x` prefix

</code></pre>

<p>swift
var myAge = 20
var binaryAge = 0b10100
var octalAge = 0o24
var hexadecimalAge = 0x14</p>

<p>let velocityOfLight = 3e9
let testNum = 0xFp-2
// testNum = 3.75</p>

<p>var moreThanOneThousand = 001_000.102_4</p>

<pre><code>
#### Numeric Type Conversion

##### Integer Conversion

</code></pre>

<p>swift
// INCORRECT CODE:
// var tooBig: UInt8 = UInt8.max + 1
// R: Beyond the range of UInt8.</p>

<p>var a: Int16 = 250
var b: Int8 = -1
var c = a + Int16(b)</p>

<p>// INCORRECT CODE:
// var d = a + b
// R: a &amp; b are not the same type.
// var e = Int8(a) + b
// R: It&rsquo;s not safe to convert type from Int16 to Int8.</p>

<pre><code>
##### Integer and Floating-Point Conversion

</code></pre>

<p>swift
var a = 0.5
var b = 2
var c = a + Double(b)
// c&rsquo;s value is 2.5.
var d = Int(a) + b
// d&rsquo;s value is 2.
var e = 2 + 0.5
// INCORRECT CODE:
// var f = a + b
// R: a &amp; b are not the same type.</p>

<pre><code>
#### Type Aliases

</code></pre>

<p>swift
typealias ElementType = Int
var a: ElementType
a = 5</p>

<pre><code>
#### Booleans

</code></pre>

<p>swift
let iAmAGoodMan = true
if iAmAGoodMan {
    print(&ldquo;You, too.&rdquo;)
} else {
    print(&ldquo;You&rsquo;re wrong.&rdquo;)
}
if 2 &gt;= 1 {
    print(&ldquo;We are good at math.&rdquo;)
}
// INCORRECT CODE:
// if 1 {
//  &hellip;
// }
// R: The boolean values are only &ldquo;true&rdquo; &amp; &ldquo;false&rdquo;.</p>

<pre><code>
#### Tuples

</code></pre>

<p>swift
let http404Error = (404, &ldquo;Not Found&rdquo;)
let (statusCode, _) = http404Error
var stuInfo = (stuNum: 1415925, stuName: &ldquo;V&rdquo;)
print(http404Error.0)
print(statusCode)
print(&ldquo;The status code is (statusCode).&ldquo;)
print(&ldquo;The student number is (stuInfo.stuNum).&ldquo;)
// DISPLAY:
// 404
// 404
// The status code is 404.
// The student number is 1415925.</p>

<pre><code>
#### Optionals

##### `nil`(`n.无`)

</code></pre>

<p>swift
var moneyOfMine: Int? = 500
moneyOfMine = nil</p>

<pre><code>
##### If Statements and Forced Unwrapping

We can access its underlying(`n.位于其下`) value by adding an exclamation(`n.感叹`) mark (`!`) to the end of the optional’s name. 

</code></pre>

<p>swift
var mySaving: Int? = 1000
if mySaving != nil {
    print(&ldquo;I still have ¥(mySaving!).&ldquo;)
} else {
    print(&ldquo;My saving is nil.&rdquo;)
}
// DISPLAY:
// I still have ¥ 1000.</p>

<pre><code>
##### Optional Binding

</code></pre>

<p>swift
let possibleNumber = &ldquo;123&rdquo;
let impossibleNumber = &ldquo;maimieng&rdquo;
if let actualNumber = Int(possibleNumber) {
    print(&rdquo;(possibleNumber) has an integer value.&ldquo;)
}
if let actualNumber = Int(impossibleNumber) {
    print(&rdquo;(impossibleNumber) has an integer value.&ldquo;)
} else {
    print(&rdquo;(impossibleNumber) could not be converted to an integer.&ldquo;)
}
// DISPLAY:
// 123 has an integer value.
// maimieng could not be converted to an integer.</p>

<p>if let firstNumber = Int(&ldquo;4&rdquo;), secondNumber = Int(&ldquo;42&rdquo;) where firstNumber &lt; secondNumber {
    print(&rdquo;(firstNumber) &lt; (secondNumber)&ldquo;)
}
// DISPLAY:
// 4 &lt; 42</p>

<pre><code>
We can include multiple optional bindings in a single `if` statement and use a `where` clause(`n.分句`) to check for a Boolean condition.

##### Implicitly Unwrapped Optionals

</code></pre>

<p>swift
let possibleString: String? = &ldquo;An optional string.&rdquo;
let forcedString: String = possibleString!</p>

<p>let assumedString: String! = &ldquo;An implicitly unwrapped optional string.&rdquo;
let implicitString: String = assumedString</p>

<p>if possibleString != nil {
    print(possibleString!)
}</p>

<p>if assumedString != nil {
    print(assumedString)
}
// DISPLAY:
// An optional string.
// An implicitly unwrapped optional string.</p>

<p>if let definiteString = possibleString {
    print(definiteString)
}</p>

<p>if let definiteString = assumedString {
    print(definiteString)
}
// DISPLAY:
// An optional string.
// An implicitly unwrapped optional string.</p>

<pre><code>
Do not use an implicitly(`adv.含蓄地`) unwrapped(`v.解包`) optional when there is a possibility of a variable becoming `nil` at a later point. Always use a normal optional type if you need to check for a `nil` value during the lifetime of a variable.

#### Error Handling

If no error is thrown(`v.抛出`), the `eatASandwich()` function is called. If an error is thrown and it matches the `Error.OutOfCleanDishes` case, then the `washDishes()` function will be called. If an error is thrown and it matches the `Error.MissingIngredients` case, then the `buyGroceries(_:)` function is called with the associated `[String]` value captured(`v.捕获`) by the `catch` pattern.

</code></pre>

<p>swift
func makeASandwich() throws {
    // &hellip;
}</p>

<p>do {
    try makeASandwich()
    eatASandwich()
} catch Error.OutOfCleanDishes {
    washDishes()
} catch Error.MissingIngredients(let ingredients) {
    buyGroceries(ingredients)
}
// This code is just an example.</p>

<pre><code>
A `do` statement creates a new containing scope, which allows errors to be propagated(`v.传送`) to one or more `catch` clauses.

#### Assertions(`n.断言`)

##### Debugging with Assertions

</code></pre>

<p>swift
let myAge = -1
assert(myAge &gt;= 0, &ldquo;Age should be bigger t WRONG han 0.&rdquo;)
// Bug:
// assertion failed: Age should be bigger than 0.: file /Users/MaiMieng/Documents/test1/main.swift, line 12
(lldb)
```</p>

<h5 id="when-to-use-assertions">When to Use Assertions</h5>

<p>An integer subscript(<code>adj.下标的</code>) index is passed to a custom subscript implementation, but the subscript index value could be too low or too high.
A value is passed to a function, but an invalid value means that the function cannot fulfill(<code>v.实现</code>) its task.
An optional value is currently <code>nil</code>, but a non-nil value is essential(<code>adj.基本的</code>) for subsequent(<code>adj.随后的</code>) code to execute(<code>v.运行</code>) successfully.</p>
    </div>
    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>
        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="/posts/2015/depr_the-2nd-half-year-plan/">
                <span class="button__icon">←</span>
                <span class="button__text">The Second Half of 2015 Plan</span>
              </a>
            </span>
          
          
            <span class="button next">
              <a href="/posts/2015/depr_j4a/">
                <span class="button__text">初学 Java 4 Android - Note &amp; Code</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    

    

    
    
    <div>
      <div id="github-comment">
      </div>

      <script type="text/javascript">
        function getUtterances(isDark) {
          var utterances = document.createElement('script');
          utterances.type = 'text/javascript';
          utterances.async = true;
          utterances.setAttribute('issue-term', "pathname")
          utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
          utterances.setAttribute('label', "comments")
          isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
          utterances.crossorigin = 'anonymous';
          utterances.src = 'https://utteranc.es/client.js';

          return utterances
        }

        var themeToggle = document.querySelector(".theme-toggle")
        themeToggle.addEventListener("click", function () {
          var getTheme = window.localStorage && window.localStorage.getItem("theme")
          var divNode = document.getElementById('github-comment')
          while(divNode.hasChildNodes()) {
            divNode.removeChild(divNode.firstChild);
          }
          
          
          

          
          
          
          
          
          
          document.getElementById('github-comment').appendChild(getUtterances(getTheme !== "dark"))
        })

        var getTheme = window.localStorage && window.localStorage.getItem("theme")
        document.getElementById('github-comment').appendChild(getUtterances(getTheme === "dark"))
      </script>
    </div>
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">Powered by github.com/kingcos</div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </body>
</html>
