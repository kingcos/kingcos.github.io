<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>浅尝 objc_msgSend :: iBlog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Refers.     2019-07-20 首次提交 objc4-750.1   2019-08-20 整理结构，未完待续 -    Preface Obj-C 中方法调用的本质是消息发送机制，即 [foo bar] 是向 foo 对象发送一条 bar 的消息，而消息发送就是通过 objc_msgSend 所进行的。那么这次本文就简单窥探一下 objc_msgSend 吧。
Why 在开始之前，先思考以下为什么 Obj-C 中方法调用的本质是 objc_msgSend 呢？
我们创建一个使用 Obj-C 的 iOS 项目，如下在「ViewController」中添加一个按钮，并在按钮的点击事件中创建一个 Obj-C 对象，再调用其方法：
#import &amp;quot;ViewController.h&amp;quot; @interface Foo : NSObject - (void)bar; @end @implementation Foo - (void)bar {} @end @interface ViewController () @end @implementation ViewController - (IBAction)clickOnButton:(UIButton *)sender { Foo *foo = [[Foo alloc] init]; [foo bar]; // 🔴 Breakpoint } @end  我们将断点打在 [foo bar]; 一行，启动程序并点击按钮。在 Xcode 的控制台多次输入 si（Step Into）即可最终跳转到 objc_msgSend："/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/objc_msgsend/" />


<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/green.css">



<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="/img/favicon/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="浅尝 objc_msgSend :: iBlog — " />
<meta name="twitter:description" content="Date Notes Refers.     2019-07-20 首次提交 objc4-750.1   2019-08-20 整理结构，未完待续 -    Preface Obj-C 中方法调用的本质是消息发送机制，即 [foo bar] 是向 foo 对象发送一条 bar 的消息，而消息发送就是通过 objc_msgSend 所进行的。那么这次本文就简单窥探一下 objc_msgSend 吧。
Why 在开始之前，先思考以下为什么 Obj-C 中方法调用的本质是 objc_msgSend 呢？
我们创建一个使用 Obj-C 的 iOS 项目，如下在「ViewController」中添加一个按钮，并在按钮的点击事件中创建一个 Obj-C 对象，再调用其方法：
#import &amp;quot;ViewController.h&amp;quot; @interface Foo : NSObject - (void)bar; @end @implementation Foo - (void)bar {} @end @interface ViewController () @end @implementation ViewController - (IBAction)clickOnButton:(UIButton *)sender { Foo *foo = [[Foo alloc] init]; [foo bar]; // 🔴 Breakpoint } @end  我们将断点打在 [foo bar]; 一行，启动程序并点击按钮。在 Xcode 的控制台多次输入 si（Step Into）即可最终跳转到 objc_msgSend：" />
<meta name="twitter:site" content="/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="浅尝 objc_msgSend :: iBlog — ">
<meta property="og:description" content="Date Notes Refers.     2019-07-20 首次提交 objc4-750.1   2019-08-20 整理结构，未完待续 -    Preface Obj-C 中方法调用的本质是消息发送机制，即 [foo bar] 是向 foo 对象发送一条 bar 的消息，而消息发送就是通过 objc_msgSend 所进行的。那么这次本文就简单窥探一下 objc_msgSend 吧。
Why 在开始之前，先思考以下为什么 Obj-C 中方法调用的本质是 objc_msgSend 呢？
我们创建一个使用 Obj-C 的 iOS 项目，如下在「ViewController」中添加一个按钮，并在按钮的点击事件中创建一个 Obj-C 对象，再调用其方法：
#import &amp;quot;ViewController.h&amp;quot; @interface Foo : NSObject - (void)bar; @end @implementation Foo - (void)bar {} @end @interface ViewController () @end @implementation ViewController - (IBAction)clickOnButton:(UIButton *)sender { Foo *foo = [[Foo alloc] init]; [foo bar]; // 🔴 Breakpoint } @end  我们将断点打在 [foo bar]; 一行，启动程序并点击按钮。在 Xcode 的控制台多次输入 si（Step Into）即可最终跳转到 objc_msgSend：" />
<meta property="og:url" content="/posts/2019/objc_msgsend/" />
<meta property="og:site_name" content="浅尝 objc_msgSend" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-07-20 00:00:00 &#43;0000 UTC" />











</head>
<body class="">


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    iBlog
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About &amp; AMA</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About &amp; AMA</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/2019/objc_msgsend/">浅尝 objc_msgSend</a></h1>
  <div class="post-meta">
    <span class="post-date">
      2019-07-20
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/focus/">Focus</a>&nbsp;
    
    #<a href="/tags/ios/">iOS</a>&nbsp;
    
    #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
    
    #<a href="/tags/">🚧</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Refers.</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2019-07-20</td>
<td align="center">首次提交</td>
<td align="center"><a href="https://opensource.apple.com/tarballs/objc4/">objc4-750.1</a></td>
</tr>

<tr>
<td align="center">2019-08-20</td>
<td align="center">整理结构，未完待续</td>
<td align="center">-</td>
</tr>
</tbody>
</table>

<p><img src="/img/2019/objc_msgsend/0.png" alt="0" /></p>

<h2 id="preface">Preface</h2>

<p>Obj-C 中方法调用的本质是消息发送机制，即 <code>[foo bar]</code> 是向 <code>foo</code> 对象发送一条 <code>bar</code> 的消息，而消息发送就是通过 <code>objc_msgSend</code> 所进行的。那么这次本文就简单窥探一下 <code>objc_msgSend</code> 吧。</p>

<h2 id="why">Why</h2>

<p>在开始之前，先思考以下为什么 Obj-C 中方法调用的本质是 <code>objc_msgSend</code> 呢？</p>

<p>我们创建一个使用 Obj-C 的 iOS 项目，如下在「ViewController」中添加一个按钮，并在按钮的点击事件中创建一个 Obj-C 对象，再调用其方法：</p>

<pre><code class="language-objectivec">#import &quot;ViewController.h&quot;

@interface Foo : NSObject
- (void)bar;
@end

@implementation Foo
- (void)bar {}
@end

@interface ViewController ()
@end

@implementation ViewController

- (IBAction)clickOnButton:(UIButton *)sender {
    Foo *foo = [[Foo alloc] init];

    [foo bar]; // 🔴 Breakpoint
}

@end
</code></pre>

<p>我们将断点打在 <code>[foo bar];</code> 一行，启动程序并点击按钮。在 Xcode 的控制台多次输入 <code>si</code>（Step Into）即可最终跳转到 <code>objc_msgSend</code>：</p>

<p><img src="/img/2019/objc_msgsend/3.png" alt="3" /></p>

<p>或者我们也可以使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc ViewController.m -o foo.cpp</code> 将 Obj-C 翻译为 C/C++ 代码：</p>

<pre><code class="language-objectivec">static void _I_ViewController_clickOnButton_(ViewController * self, SEL _cmd, UIButton *sender) {
    Foo *foo = ((Foo *(*)(id, SEL))(void *)objc_msgSend)((id)((Foo *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;Foo&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));

    // objc_msgSend(foo, sel_registerName(&quot;bar&quot;))
    ((void (*)(id, SEL))(void *)objc_msgSend)((id)foo, sel_registerName(&quot;bar&quot;));
}
</code></pre>

<p>综上，我们可以说 Obj-C 中方法调用的本质即是 <code>objc_msgSend</code>。</p>

<h2 id="steps">Steps</h2>

<p><code>objc_msgSend</code> 总共分为消息发送、动态方法解析、以及消息转发三大部分，下面就依次来研究一下。</p>

<h3 id="消息发送">消息发送</h3>

<p><code>objc_msgSend</code> 中的第一个部分是消息发送，即对消息接收者发送一条方法消息，当接收者可以处理消息时将执行相应的方法，无法处理时则进入下一步骤。</p>

<p>在 Apple 开源的 objc4 源码中，我们似乎只能在「message.h」中找到 <code>objc_msgSend</code> 的声明：</p>

<pre><code class="language-c">// message.h

/**
 * Sends a message with a simple return value to an instance of a class.
 * 发送一个带有简易返回值的消息到一个类的实例。
 *
 * @param self A pointer to the instance of the class that is to receive the message.
 *             指向接收消息者实例的指针。
 * @param op The selector of the method that handles the message.
 *           处理消息的选择器。
 * @param ...
 *   A variable argument list containing the arguments to the method.
 *   包含方法参数的可变参数列表。
 *
 * @return The return value of the method.
 *         方法的返回值。
 *
 * @note When it encounters a method call, the compiler generates a call to one of the
 *  functions \c objc_msgSend, \c objc_msgSend_stret, \c objc_msgSendSuper, or \c objc_msgSendSuper_stret.
 *  Messages sent to an object’s superclass (using the \c super keyword) are sent using \c objc_msgSendSuper;
 *  other messages are sent using \c objc_msgSend. Methods that have data structures as return values
 *  are sent using \c objc_msgSendSuper_stret and \c objc_msgSend_stret.
 * 注意：当遇到方法调用时，编译器会生成对 objc_msgSend、objc_msgSend_stret、objc_msgSendSuper、objc_msgSendSuper_stret 四个函数之一的调用。
 * 到达对象父类（使用 super 关键字）的消息通过 objc_msgSendSuper 发送；其它消息则通过 objc_msgSend 发送。
 * 返回值为结构体的消息通过 objc_msgSendSuper_stret 或 objc_msgSend_stret 发送。
 *
 */
OBJC_EXPORT id _Nullable
objc_msgSend(id _Nullable self, SEL _Nonnull op, ...)
    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);
</code></pre>

<p>这里 <code>objc_msgSend</code> 将消息接收者（即对象）作为第一个参数，将消息（即方法选择器）作为第二个参数，并将方法的参数追加在参数列表的最后。那么方法的具体实现在哪里呢？其实 <code>objc_msgSend</code> 是由汇编语言编写的，原因有两点：<strong>一是对性能的极致追求，每一条汇编指令都对应一条机器指令，使用汇编便于针对不同架构的 CPU 优化每一条指令的速度</strong>；<strong>二是 C 语言无法实现一个保存未知参数且支持跳转到任一函数指针处的函数（引自 <a href="https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html">Dissecting objc_msgSend on ARM64 - Mike Ash</a>）</strong>。</p>

<p><img src="/img/2019/objc_msgsend/1.png" alt="1" /></p>

<p>在分析 <code>objc_msgSend</code> 前，我们首先要知道 Obj-C 的消息发送本质属于<strong>动态绑定（Dynamic Binding）</strong>，而非 C 语言常用的静态绑定。动态绑定意味着只有在运行时才能确定真正被调用的函数；而静态绑定在编译时即可确定（不考虑内联函数的前提下），编译器会直接生成调用函数的指令，函数地址就被硬编码在指令当中。</p>

<blockquote>
<p><strong>Tips - 内联（Inline）函数</strong></p>

<p>建议编译器对函数进行内联扩展，即建议编译器将指定的函数体直接插入到每一处调用该函数的地方（注：「建议」指具体是否进行内联需要看编译器本身）。</p>
</blockquote>

<p>因此对于动态绑定的语言来说，其方法查找的速度一定是慢于静态绑定的。Obj-C 会将方法查找的结果缓存在一个快速映射表中（Fast Map），当后续发送同样的消息时即可得到更快得执行。根据这个快慢，消息发送的代码被分为两个部分：其一是快速路径（Fast Path），这一部分由汇编语言实现；其二是慢速路径（Slow Path），由 C 语言实现。当没有缓存时，将调用 C 语言代码来处理。</p>

<p>由于代码的跳转很难直接在代码中标注，我将其核心流程抽象为下图，由于原图较大，可根据需要放大来看：</p>

<p>当然，源码还是有些枯燥，不过我们可以尝试分析以下几个特定的用例。</p>

<h4 id="当接收者为-nil-时">当接收者为 <code>nil</code> 时</h4>

<p>当接收者为 <code>nil</code> 时，即 <code>[foo bar]</code> 中的 <code>foo</code> 为 <code>nil</code>：</p>

<pre><code class="language-objectivec">- (IBAction)clickOnButton:(UIButton *)sender {
    Foo *foo = [[Foo alloc] init];

    // 将接收者置为 nil
    foo = nil;
    [foo bar];
}
</code></pre>

<p>在 Xcode 中 <code>si</code> 执行即可看到具体的汇编代码跳转：</p>

<pre><code class="language-asm">libobjc.A.dylib`objc_msgSend:
    0x192bd8180 &lt;+0&gt;:   cmp    x0, #0x0                  ; =0x0
    0x192bd8184 &lt;+4&gt;:   b.le   0x192bd81f8               ; &lt;+120&gt;
    ; ...
    0x192bd81f8 &lt;+120&gt;: b.eq   0x192bd8230               ; &lt;+176&gt;
    ; ...
    0x192bd8230 &lt;+176&gt;: mov    x1, #0x0
    0x192bd8234 &lt;+180&gt;: movi   d0, #0000000000000000
    0x192bd8238 &lt;+184&gt;: movi   d1, #0000000000000000
    0x192bd823c &lt;+188&gt;: movi   d2, #0000000000000000
    0x192bd8240 &lt;+192&gt;: movi   d3, #0000000000000000
    0x192bd8244 &lt;+196&gt;: ret
</code></pre>

<p><img src="/img/2019/objc_msgsend/4.png" alt="4" /></p>

<hr />

<p>在理解上面汇编代码的同时，需要了解 Obj-C 中对象内部的 <code>cache_t</code> 即缓存的内部结构：</p>

<pre><code class="language-cpp">// objc-runtime-new.h
#if __LP64__
typedef uint32_t mask_t;  // x86_64 &amp; arm64 asm are less efficient with 16-bits
#else
typedef uint16_t mask_t;
#endif

struct cache_t {
    struct bucket_t *_buckets;
    mask_t _mask;
    mask_t _occupied;

public:
    struct bucket_t *buckets();
    mask_t mask();
    mask_t occupied();
    void incrementOccupied();
    void setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask);
    void initializeToEmpty();

    mask_t capacity();
    bool isConstantEmptyCache();
    bool canBeFreed();

    static size_t bytesForCapacity(uint32_t cap);
    static struct bucket_t * endMarker(struct bucket_t *b, uint32_t cap);

    void expand();
    void reallocate(mask_t oldCapacity, mask_t newCapacity);
    struct bucket_t * find(cache_key_t key, id receiver);

    static void bad_cache(id receiver, SEL sel, Class isa) __attribute__((noreturn));
};

struct bucket_t {
private:
    // IMP-first is better for arm64e ptrauth and no worse for arm64.
    // SEL-first is better for armv7* and i386 and x86_64.
#if __arm64__
    MethodCacheIMP _imp;
    cache_key_t _key;
#else
    cache_key_t _key;
    MethodCacheIMP _imp;
#endif

public:
    inline cache_key_t key() const { return _key; }
    inline IMP imp() const { return (IMP)_imp; }
    inline void setKey(cache_key_t newKey) { _key = newKey; }
    inline void setImp(IMP newImp) { _imp = newImp; }

    void set(cache_key_t newKey, IMP newImp);
};
</code></pre>

<ul>
<li>C 语言使用静态绑定（Static Binding）来进行函数调用，在编译时刻就能决定运行时所应调用的函数，即在不考虑内联下，会直接生成调用函数的指令，函数地址则被硬编码在指令中。</li>

<li><p>C 语言中使用函数指针进行调用则属于动态绑定（Dynamic Binding），所要调用的函数在运行时才能确定。</p>

<pre><code class="language-c">// objc_msgSend 的原型：
// id self：接收者本身
// SEL cmd：方法选择器本身
// ...：cmd 方法的参数（可变参数函数）
void objc_msgSend(id self, SEL cmd, ...)
</code></pre></li>

<li><p>Obj-C 中的方法使用动态绑定调用。</p></li>

<li><p>Obj-C 对象方法查找顺序：本类的类对象方法列表中查找同名方法（分类 Category 中的方法会合并到类的方法列表中，根据后编译更靠前，会被先找到） -&gt; 若没有找到，则根据 <code>superclass</code> 指针向父类的类对象方法列表中查找，直到查找基类 <code>NSObject</code> 的类对象中也没有则进行消息转发（Message Forwarding）。</p></li>

<li><p><code>objc_msgSend</code> 会将方法的匹配的结果缓存在类对象的 <code>cache_t cache;</code> 中，优化之后查找相同方法的速度，但仍慢于静态绑定，不过也不至于是瓶颈；如果对查找速度极致追求则可使用纯 C 函数。</p></li>

<li><p>边界情况：</p>

<ul>
<li><code>objc_msgSend_stret</code>：如果待发送的消息要返回结构体，那么可交由此函数处理。只有当 CPU 的寄存器能够容纳得下消息返回类型时，这个函数才能处理此消息。若是返回值无法容纳于 CPU 寄存器中（比如返回的结构体太大了），那么就交由另一个函数执行派发。此时，那个函数会通过分配在栈上的某个变量来处理消息所返回的结构体。</li>
<li><code>objc_msgSend_fpret</code>：如果消息返回的是浮点数，那么可交由此函数处理。在某些结构的 CPU 中调用函数时，需要对「浮点数寄存器（Floating-Point Register）」做特殊处理，也就是说，通常所用的 <code>objc_msgSend</code> 在这种情况下并不合适。这个函数是为了处理 x86 等架构 CPU 中某些令人稍觉惊讶的奇怪状况。（不会使用在 ARM 64 架构中）</li>
<li><code>objc_msgSendSuper</code>：如果要给父类发送消息，例如 <code>[super message:parameter]</code>，那么就交由此函数处理。也有另外两个与 <code>objc_msgSend_stret</code> 和 <code>objc_msgSend_fpret</code> 等效的函数，用于处理发给 <code>super</code> 的相应的消息。</li>
</ul></li>

<li><p>Obj-C 对象的每个方法都可以视为简单的 C 函数，其原型为：<code>&lt;return_type&gt; Class_selector(id self, SEL _cmd, ...)</code>。</p></li>

<li><p>Obj-C 每个类中都有以上原型函数表，<code>objc_msgSend</code> 等函数通过该表寻找应该执行的方法并跳至其实现（原型与 <code>objc_msgSend</code> 函数类似是为了利用尾调用优化 Tail-Call Optimization 技术，简化跳至实现的操作）。</p></li>

<li><p>如果某个函数的最后一项操作是调用另外一个函数，那么就可以运用「尾调用优化」技术。编译器会生成调转至另一函数所需的指令码，而且不会向调用堆栈中推入新的「栈帧 Frame Stack」。只有当某函数的最后一个操作仅仅是调用其他函数而不会将其返回值另作他用时，才能执行「尾调用优化」。如果不这样的话，每次调用 Obj-C 方法之前都需要需要为 <code>objc_msgSend</code> 准备栈帧（可以在栈追踪 Stack Trace）中看到这种栈帧）。此外，若是不优化，还会过早地发生「栈溢出（Stack Overflow）」现象。</p></li>
</ul>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html">Dissecting objc_msgSend on ARM64 - Mike Ash</a></li>
<li><a href="http://infocenter.arm.com/help/index.jsp">ARM Software development tools - arm.com</a></li>

<li><p><a href="https://stackoverflow.com/questions/27353096/1b-and-1f-in-gnu-assembly">1b and 1f in GNU assembly - StackOverflow</a></p>

<pre><code class="language-lldb">(lldb) register read
General Purpose Registers:
    x0 = 0x0000000280ecc0e0
    x1 = 0x0000000102adcd50  &quot;bar&quot;
    x2 = 0x0000000000000000
    x3 = 0x0000000280ecc0f0
    x4 = 0x0000000283ec8000
    x5 = 0x0000000283ec8000
    x6 = 0x0000000000000000
    x7 = 0x0000000000000403
    x8 = 0x000001a102adcda9 (0x0000000102adcda9) (void *)0xd80000000102adcd
    x9 = 0x0000000000000000
   x10 = 0x0000000000000002
   x11 = 0x00000002819b8c28
   x12 = 0x0000000000000002
   x13 = 0x0000000000000000
   x14 = 0x00000000000000c6
   x15 = 0x0000000000000000
   x16 = 0x000000018efdd1e8  libsystem_malloc.dylib`calloc
   x17 = 0x000000018f00af84  libobjc.A.dylib`-[NSObject init]
   x18 = 0x0000000000000000
   x19 = 0x0000000283ec8000
   x20 = 0x00000001030092b0
   x21 = 0x0000000102adac97  &quot;clickOnButton:&quot;
   x22 = 0x0000000103105570
   x23 = 0x0000000102adac97  &quot;clickOnButton:&quot;
   x24 = 0x00000001d63996f0  UIKitCore`UIApp
   x25 = 0x0000000000000000
   x26 = 0x00000001c638e570
   x27 = 0x00000002802cb330
   x28 = 0x0000000103105570
    fp = 0x000000016d329420
    lr = 0x0000000102ada804  msgSend`-[ViewController clickOnButton:] + 96 at ViewController.m:33:16
    sp = 0x000000016d3293f0
    pc = 0x0000000102ada810  msgSend`-[ViewController clickOnButton:] + 108 at ViewController.m:35:6
  cpsr = 0x40000000
</code></pre></li>
</ul>

  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span
        class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      <span class="button previous">
        <a href="/posts/2019/const_static_extern_in_cpp/">
          <span class="button__icon">←</span>
          <span class="button__text">C/C&#43;&#43; 中的 const、static &amp; extern</span>
        </a>
      </span>
      
      
      <span class="button next">
        <a href="/posts/2019/0230-flatten-optional-try_zh/">
          <span class="button__text">[译]摊平由「try?」造成的嵌套可选</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo="kingcos/kingcos.github.io"
            issue-term="pathname"
            label="comments"
            theme="github-dark"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2019 · <a href="http://github.com/kingcos">kingcos</a></span>
      </div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>





  
</div>

</body>
</html>
