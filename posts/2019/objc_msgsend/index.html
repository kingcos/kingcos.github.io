<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>浅尝 objc_msgSend :: iBlog — github.com/kingcos</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Refers.     2019-07-20 首次提交 objc4-750.1   2019-08-31 整理结构，未完待续 Obj-C 中的对象 - kingcos    Preface Obj-C 中方法调用的本质是消息发送机制，即 [foo bar] 是向 foo 对象发送一条 bar 的消息，而消息发送就是通过 objc_msgSend 所进行的。那么这次本文就简单窥探一下 objc_msgSend 吧。
Why 在开始之前，先思考以下为什么 Obj-C 中方法调用的本质是 objc_msgSend 呢？
我们创建一个使用 Obj-C 的 iOS 项目，如下在 ViewController 中添加一个按钮，并在按钮的点击事件中创建一个 Obj-C 对象，再调用其方法：
#import &amp;quot;ViewController.h&amp;quot; @interface Foo : NSObject - (void)bar; @end @implementation Foo - (void)bar {} @end @interface ViewController () @end @implementation ViewController - (IBAction)clickOnButton:(UIButton *)sender { Foo *foo = [[Foo alloc] init]; [foo bar]; // 🔴 Breakpoint } @end  我们将断点打在 [foo bar]; 一行，启动程序并点击按钮。在 Xcode 的控制台多次输入 si（Step Into）即可最终跳转到 objc_msgSend："/>
<meta name="keywords" content="ios,swift,objective-c,obj-c,objc,oc,geek,python,ruby,golang,go,apple,mac"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/objc_msgsend/" />





<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="浅尝 objc_msgSend"/>
<meta name="twitter:description" content="Obj-C 中方法调用的本质是消息发送机制，即 `[foo bar]` 是向 `foo` 对象发送一条 `bar` 的消息，而消息发送就是通过 `objc_msgSend` 所进行的。那么这次本文就简单窥探一下 `objc_msgSend` 吧。"/>



<meta property="og:title" content="浅尝 objc_msgSend" />
<meta property="og:description" content="Obj-C 中方法调用的本质是消息发送机制，即 `[foo bar]` 是向 `foo` 对象发送一条 `bar` 的消息，而消息发送就是通过 `objc_msgSend` 所进行的。那么这次本文就简单窥探一下 `objc_msgSend` 吧。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2019/objc_msgsend/" />
<meta property="article:published_time" content="2019-08-24T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-08-24T00:00:00+00:00" /><meta property="og:site_name" content="iBlog" />






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">iBlog</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="post">
    <h2 class="post-title"><a href="/posts/2019/objc_msgsend/">浅尝 objc_msgSend</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            2019-08-24
        </span>
      
      
      
        <span class="post-read-time">— 5 min read</span>
      
    </div>

    
      <span class="post-tags">
        
          #<a href="/tags/focus/">Focus</a>&nbsp;
        
          #<a href="/tags/ios/">iOS</a>&nbsp;
        
          #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
        
          #<a href="/tags//">🚧</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Refers.</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2019-07-20</td>
<td align="center">首次提交</td>
<td align="center"><a href="https://opensource.apple.com/tarballs/objc4/">objc4-750.1</a></td>
</tr>

<tr>
<td align="center">2019-08-31</td>
<td align="center">整理结构，未完待续</td>
<td align="center"><a href="../objects_in_obj-c/">Obj-C 中的对象 - kingcos</a></td>
</tr>
</tbody>
</table>

<p><img src="/img/2019/objc_msgsend/0.png" alt="0" /></p>

<h2 id="preface">Preface</h2>

<p>Obj-C 中方法调用的本质是消息发送机制，即 <code>[foo bar]</code> 是向 <code>foo</code> 对象发送一条 <code>bar</code> 的消息，而消息发送就是通过 <code>objc_msgSend</code> 所进行的。那么这次本文就简单窥探一下 <code>objc_msgSend</code> 吧。</p>

<h2 id="why">Why</h2>

<p>在开始之前，先思考以下为什么 Obj-C 中方法调用的本质是 <code>objc_msgSend</code> 呢？</p>

<p>我们创建一个使用 Obj-C 的 iOS 项目，如下在 <code>ViewController</code> 中添加一个按钮，并在按钮的点击事件中创建一个 Obj-C 对象，再调用其方法：</p>

<pre><code class="language-objectivec">#import &quot;ViewController.h&quot;

@interface Foo : NSObject
- (void)bar;
@end

@implementation Foo
- (void)bar {}
@end

@interface ViewController ()
@end

@implementation ViewController

- (IBAction)clickOnButton:(UIButton *)sender {
    Foo *foo = [[Foo alloc] init];

    [foo bar]; // 🔴 Breakpoint
}

@end
</code></pre>

<p>我们将断点打在 <code>[foo bar];</code> 一行，启动程序并点击按钮。在 Xcode 的控制台多次输入 <code>si</code>（Step Into）即可最终跳转到 <code>objc_msgSend</code>：</p>

<p><img src="/img/2019/objc_msgsend/3.png" alt="3" /></p>

<p>或者我们也可以使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc ViewController.m -o foo.cpp</code> 将 Obj-C 代码翻译为 C/C++：</p>

<pre><code class="language-objectivec">static void _I_ViewController_clickOnButton_(ViewController * self, SEL _cmd, UIButton *sender) {
    Foo *foo = ((Foo *(*)(id, SEL))(void *)objc_msgSend)((id)((Foo *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;Foo&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));

    // objc_msgSend(foo, sel_registerName(&quot;bar&quot;))
    ((void (*)(id, SEL))(void *)objc_msgSend)((id)foo, sel_registerName(&quot;bar&quot;));
}
</code></pre>

<p>综上，我们可以说 Obj-C 中方法调用的本质即是 <code>objc_msgSend</code>。</p>

<h2 id="steps">Steps</h2>

<p><code>objc_msgSend</code> 总共分为消息发送、动态方法解析、以及消息转发三大部分，下面我们就依次来研究一下。</p>

<h3 id="消息发送">消息发送</h3>

<p><code>objc_msgSend</code> 中的第一个部分是消息发送，即对消息接收者发送一条方法消息，当接收者可以处理消息时将执行相应的方法，无法处理时则进入下一步骤。</p>

<h4 id="where-why">Where &amp; Why</h4>

<p>在 Apple 开源的 objc4 源码中，我们似乎只能在「message.h」中找到 <code>objc_msgSend</code> 的声明，其将消息接收者（即对象）作为第一个参数，将消息（即方法选择器）作为第二个参数，并将方法的参数追加在参数列表的最后：</p>

<pre><code class="language-c">// message.h

/**
 * Sends a message with a simple return value to an instance of a class.
 * 发送一个带有简易返回值的消息到一个类的实例。
 *
 * @param self A pointer to the instance of the class that is to receive the message.
 *             指向接收消息者实例的指针。
 * @param op The selector of the method that handles the message.
 *           处理消息的选择器。
 * @param ...
 *   A variable argument list containing the arguments to the method.
 *   包含方法参数的可变参数列表。
 *
 * @return The return value of the method.
 *         方法的返回值。
 *
 * @note When it encounters a method call, the compiler generates a call to one of the
 *  functions \c objc_msgSend, \c objc_msgSend_stret, \c objc_msgSendSuper, or \c objc_msgSendSuper_stret.
 *  Messages sent to an object’s superclass (using the \c super keyword) are sent using \c objc_msgSendSuper;
 *  other messages are sent using \c objc_msgSend. Methods that have data structures as return values
 *  are sent using \c objc_msgSendSuper_stret and \c objc_msgSend_stret.
 * 注意：当遇到方法调用时，编译器会生成对 objc_msgSend、objc_msgSend_stret、objc_msgSendSuper、objc_msgSendSuper_stret 四个函数之一的调用。
 * 到达对象父类（使用 super 关键字）的消息通过 objc_msgSendSuper 发送；其它消息则通过 objc_msgSend 发送。
 * 返回值为结构体的消息通过 objc_msgSendSuper_stret 或 objc_msgSend_stret 发送。
 *
 */
OBJC_EXPORT id _Nullable
objc_msgSend(id _Nullable self, SEL _Nonnull op, ...)
    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);
</code></pre>

<p><img src="/img/2019/objc_msgsend/1.png" alt="1" /></p>

<p>而 <code>objc_msgSend</code> 的具体实现是由汇编语言编写的，原因有两点：</p>

<ol>
<li>对性能的极致追求，每一条汇编指令都对应一条机器指令，使用汇编便于针对不同架构的 CPU 优化每一条指令的速度；</li>
<li>C 语言无法实现一个保存未知参数且支持跳转到任一函数指针处的函数（引自 <a href="https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html">Dissecting objc_msgSend on ARM64 - Mike Ash</a>）。</li>
</ol>

<!-- Obj-C 的消息发送本质属于**动态绑定（Dynamic Binding）**，而非 C 语言常用的静态绑定。动态绑定意味着只有在运行时才能确定真正被调用的函数；而静态绑定在编译时即可确定（不考虑内联函数的前提下），编译器会直接生成调用函数的指令，函数地址就被硬编码在指令当中。

> **Tips - 内联（Inline）函数**
>
> 建议编译器对函数进行内联扩展，即建议编译器将指定的函数体直接插入到每一处调用该函数的地方（注：「建议」指具体是否进行内联需要看编译器本身）。

因此对于动态绑定的语言来说，其方法查找的速度一定是慢于静态绑定的。Obj-C 会将方法查找的结果缓存在一个快速映射表中（Fast Map），当后续发送同样的消息时即可得到更快得执行。根据这个快慢，消息发送的代码被分为两个部分：其一是快速路径（Fast Path），这一部分由汇编语言实现；其二是慢速路径（Slow Path），由 C 语言实现。当没有缓存时，将调用 C 语言代码来处理。 -->

<p>由于 <code>objc_msgSend</code> 整个流程比较复杂，我将其分为多个用例，逐个分析。</p>

<h4 id="当接收者为-nil-时">当接收者为 <code>nil</code> 时</h4>

<p>当接收者为 <code>nil</code> 时，即 <code>[foo bar]</code> 中的 <code>foo</code> 为 <code>nil</code>：</p>

<pre><code class="language-objectivec">- (IBAction)clickOnButton:(UIButton *)sender {
    Foo *foo = [[Foo alloc] init];

    // 将接收者置为 nil
    foo = nil;
    [foo bar];
}

// LLDB:
// 进入 objc_msgSend 后可以尝试使用 LLDB 命令读取 x0 寄存器中存储的值
// (lldb) register read x0
//       x0 = 0x0000000000000000
</code></pre>

<p><img src="/img/2019/objc_msgsend/4.png" alt="4" /></p>

<p>在 Xcode 中 <code>si</code> 执行即可看到具体的汇编代码跳转，也与上图的源码分析一致：</p>

<pre><code class="language-asm">libobjc.A.dylib`objc_msgSend:
    0x192bd8180 &lt;+0&gt;:   cmp    x0, #0x0                  ; =0x0
    0x192bd8184 &lt;+4&gt;:   b.le   0x192bd81f8               ; &lt;+120&gt;
    ; ...
    0x192bd81f8 &lt;+120&gt;: b.eq   0x192bd8230               ; &lt;+176&gt;
    ; ...
    0x192bd8230 &lt;+176&gt;: mov    x1, #0x0
    0x192bd8234 &lt;+180&gt;: movi   d0, #0000000000000000
    0x192bd8238 &lt;+184&gt;: movi   d1, #0000000000000000
    0x192bd823c &lt;+188&gt;: movi   d2, #0000000000000000
    0x192bd8240 &lt;+192&gt;: movi   d3, #0000000000000000
    0x192bd8244 &lt;+196&gt;: ret
</code></pre>

<h4 id="当未命中缓存时">当未命中缓存时</h4>

<p><img src="/img/2019/objc_msgsend/5.png" alt="5" /></p>

<h4 id="当命中缓存时">当命中缓存时</h4>

<h4 id="support-indexed-isa"><code>SUPPORT_INDEXED_ISA</code></h4>

<p><code>SUPPORT_INDEXED_ISA</code>，即是否支持索引化 isa 我们可以在源码中找到这段定义的宏：</p>

<pre><code class="language-objectivec">// objc-config.h

// Define SUPPORT_INDEXED_ISA=1 on platforms that store the class in the isa
// field as an index into a class table.
// 在将类存储在 isa 域中并作为类表索引的平台上定义 SUPPORT_INDEXED_ISA=1。
// Note, keep this in sync with any .s files which also define it.
// Be sure to edit objc-abi.h as well.
#if __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)
#   define SUPPORT_INDEXED_ISA 1
#else
#   define SUPPORT_INDEXED_ISA 0
#endif
</code></pre>

<p>比较简单的验证方式是我们可以直接在指定真机运行的代码中尝试获取最终的值：</p>

<pre><code class="language-objectivec">#if __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)
#   define SUPPORT_INDEXED_ISA 1
#else
#   define SUPPORT_INDEXED_ISA 0
#endif

// Use of undeclared identifier '__ARM_ARCH_7K__'
// NSLog(@&quot;%d&quot;, __ARM_ARCH_7K__);
NSLog(@&quot;%d&quot;, __arm64__);           // 1
NSLog(@&quot;%d&quot;, __LP64__);            // 1
NSLog(@&quot;%d&quot;, SUPPORT_INDEXED_ISA); // 0
</code></pre>

<p>当然，我还是要细究一下。</p>

<p><code>__ARM_ARCH_7K__</code> 根据名称可以得出是定义在目标为 ARM 7k 架构 CPU 的代码中的标志宏。我们可以在 LLVM 开源的「ARM.cpp」找到其定义：</p>

<pre><code class="language-cpp">// ARM.cpp

// Unfortunately, __ARM_ARCH_7K__ is now more of an ABI descriptor. The CPU
// happens to be Cortex-A7 though, so it should still get __ARM_ARCH_7A__.
if (getTriple().isWatchABI())
  Builder.defineMacro(&quot;__ARM_ARCH_7K__&quot;, &quot;2&quot;);
</code></pre>

<p><code>__arm64__</code> 即是定义在目标为 ARM 64 架构 CPU 的代码中；<code>__LP64__</code> 则意味着 Long Pointer，该标志宏为 <code>1</code> 的代码中 <code>long int</code> 和指针类型（指针中存储的是内存地址，也即内存地址）的长度为 64 位（8 字节），<code>int</code> 为 32 位（4 字节）。</p>

<p>综上，在 iOS 的真机设备中，<code>SUPPORT_INDEXED_ISA</code> 的值最终为 <code>0</code>。</p>

<hr />

<p>在理解上面汇编代码的同时，需要了解 Obj-C 中对象内部的 <code>cache_t</code> 即缓存的内部结构：</p>

<pre><code class="language-cpp">// objc-runtime-new.h
#if __LP64__
typedef uint32_t mask_t;  // x86_64 &amp; arm64 asm are less efficient with 16-bits
#else
typedef uint16_t mask_t;
#endif

struct cache_t {
    struct bucket_t *_buckets;
    mask_t _mask;
    mask_t _occupied;

public:
    struct bucket_t *buckets();
    mask_t mask();
    mask_t occupied();
    void incrementOccupied();
    void setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask);
    void initializeToEmpty();

    mask_t capacity();
    bool isConstantEmptyCache();
    bool canBeFreed();

    static size_t bytesForCapacity(uint32_t cap);
    static struct bucket_t * endMarker(struct bucket_t *b, uint32_t cap);

    void expand();
    void reallocate(mask_t oldCapacity, mask_t newCapacity);
    struct bucket_t * find(cache_key_t key, id receiver);

    static void bad_cache(id receiver, SEL sel, Class isa) __attribute__((noreturn));
};

struct bucket_t {
private:
    // IMP-first is better for arm64e ptrauth and no worse for arm64.
    // SEL-first is better for armv7* and i386 and x86_64.
#if __arm64__
    MethodCacheIMP _imp;
    cache_key_t _key;
#else
    cache_key_t _key;
    MethodCacheIMP _imp;
#endif

public:
    inline cache_key_t key() const { return _key; }
    inline IMP imp() const { return (IMP)_imp; }
    inline void setKey(cache_key_t newKey) { _key = newKey; }
    inline void setImp(IMP newImp) { _imp = newImp; }

    void set(cache_key_t newKey, IMP newImp);
};
</code></pre>

<ul>
<li>C 语言使用静态绑定（Static Binding）来进行函数调用，在编译时刻就能决定运行时所应调用的函数，即在不考虑内联下，会直接生成调用函数的指令，函数地址则被硬编码在指令中。</li>

<li><p>C 语言中使用函数指针进行调用则属于动态绑定（Dynamic Binding），所要调用的函数在运行时才能确定。</p>

<pre><code class="language-c">// objc_msgSend 的原型：
// id self：接收者本身
// SEL cmd：方法选择器本身
// ...：cmd 方法的参数（可变参数函数）
void objc_msgSend(id self, SEL cmd, ...)
</code></pre></li>

<li><p>Obj-C 中的方法使用动态绑定调用。</p></li>

<li><p>Obj-C 对象方法查找顺序：本类的类对象方法列表中查找同名方法（分类 Category 中的方法会合并到类的方法列表中，根据后编译更靠前，会被先找到） -&gt; 若没有找到，则根据 <code>superclass</code> 指针向父类的类对象方法列表中查找，直到查找基类 <code>NSObject</code> 的类对象中也没有则进行消息转发（Message Forwarding）。</p></li>

<li><p><code>objc_msgSend</code> 会将方法的匹配的结果缓存在类对象的 <code>cache_t cache;</code> 中，优化之后查找相同方法的速度，但仍慢于静态绑定，不过也不至于是瓶颈；如果对查找速度极致追求则可使用纯 C 函数。</p></li>

<li><p>边界情况：</p>

<ul>
<li><code>objc_msgSend_stret</code>：如果待发送的消息要返回结构体，那么可交由此函数处理。只有当 CPU 的寄存器能够容纳得下消息返回类型时，这个函数才能处理此消息。若是返回值无法容纳于 CPU 寄存器中（比如返回的结构体太大了），那么就交由另一个函数执行派发。此时，那个函数会通过分配在栈上的某个变量来处理消息所返回的结构体。</li>
<li><code>objc_msgSend_fpret</code>：如果消息返回的是浮点数，那么可交由此函数处理。在某些结构的 CPU 中调用函数时，需要对「浮点数寄存器（Floating-Point Register）」做特殊处理，也就是说，通常所用的 <code>objc_msgSend</code> 在这种情况下并不合适。这个函数是为了处理 x86 等架构 CPU 中某些令人稍觉惊讶的奇怪状况。（不会使用在 ARM 64 架构中）</li>
<li><code>objc_msgSendSuper</code>：如果要给父类发送消息，例如 <code>[super message:parameter]</code>，那么就交由此函数处理。也有另外两个与 <code>objc_msgSend_stret</code> 和 <code>objc_msgSend_fpret</code> 等效的函数，用于处理发给 <code>super</code> 的相应的消息。</li>
</ul></li>

<li><p>Obj-C 对象的每个方法都可以视为简单的 C 函数，其原型为：<code>&lt;return_type&gt; Class_selector(id self, SEL _cmd, ...)</code>。</p></li>

<li><p>Obj-C 每个类中都有以上原型函数表，<code>objc_msgSend</code> 等函数通过该表寻找应该执行的方法并跳至其实现（原型与 <code>objc_msgSend</code> 函数类似是为了利用尾调用优化 Tail-Call Optimization 技术，简化跳至实现的操作）。</p></li>

<li><p>如果某个函数的最后一项操作是调用另外一个函数，那么就可以运用「尾调用优化」技术。编译器会生成调转至另一函数所需的指令码，而且不会向调用堆栈中推入新的「栈帧 Frame Stack」。只有当某函数的最后一个操作仅仅是调用其他函数而不会将其返回值另作他用时，才能执行「尾调用优化」。如果不这样的话，每次调用 Obj-C 方法之前都需要需要为 <code>objc_msgSend</code> 准备栈帧（可以在栈追踪 Stack Trace）中看到这种栈帧）。此外，若是不优化，还会过早地发生「栈溢出（Stack Overflow）」现象。</p></li>
</ul>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html">Dissecting objc_msgSend on ARM64 - Mike Ash</a></li>
<li><a href="http://infocenter.arm.com/help/index.jsp">ARM Software development tools - arm.com</a></li>
<li><a href="https://stackoverflow.com/questions/27353096/1b-and-1f-in-gnu-assembly">1b and 1f in GNU assembly - StackOverflow</a></li>
<li><a href="https://clang.llvm.org/doxygen/Basic_2Targets_2ARM_8cpp_source.html">ARM.cpp - clang</a></li>
<li><a href="https://www.ibm.com/support/knowledgecenter/zh/SSXVZZ_13.1.0/com.ibm.xlcpp131.linux.doc/getstart/predef_macro_v10v12.html">预定义宏 - IBM</a></li>
<li><a href="../objects_in_obj-c/">Obj-C 中的对象 - kingcos</a></li>
</ul>

    </div>
    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>
        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="/posts/2019/swift_tips_in_reverse/">
                <span class="button__icon">←</span>
                <span class="button__text">SwiftTips in Reverse</span>
              </a>
            </span>
          
          
            <span class="button next">
              <a href="/posts/2019/isa_in_objc/">
                <span class="button__text">Obj-C 中的 isa 指针</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    

    

    
    
    <div>
      <div id="github-comment">
      </div>

      <script type="text/javascript">
        function getUtterances(isDark) {
          var utterances = document.createElement('script');
          utterances.type = 'text/javascript';
          utterances.async = true;
          utterances.setAttribute('issue-term', "pathname")
          utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
          utterances.setAttribute('label', "comments")
          isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
          utterances.crossorigin = 'anonymous';
          utterances.src = 'https://utteranc.es/client.js';

          return utterances
        }

        var themeToggle = document.querySelector(".theme-toggle")
        themeToggle.addEventListener("click", function () {
          var getTheme = window.localStorage && window.localStorage.getItem("theme")
          var divNode = document.getElementById('github-comment')
          while(divNode.hasChildNodes()) {
            divNode.removeChild(divNode.firstChild);
          }
          
          
          

          
          
          
          
          
          
          document.getElementById('github-comment').appendChild(getUtterances(getTheme !== "dark"))
        })

        var getTheme = window.localStorage && window.localStorage.getItem("theme")
        document.getElementById('github-comment').appendChild(getUtterances(getTheme === "dark"))
      </script>
    </div>
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">Powered by github.com/kingcos</div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </body>
</html>
