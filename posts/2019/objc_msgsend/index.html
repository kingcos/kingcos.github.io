<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>æµ…å° objc_msgSend :: iBlog</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Refers.     2019-07-20 é¦–æ¬¡æäº¤ objc4-750.1   2019-09-07 å®Œæˆã€Œç¼“å­˜ã€åŠ¨æ€æ–¹æ³•è§£æã€ç­‰éƒ¨åˆ† Obj-C ä¸­çš„å¯¹è±¡ - kingcos   2019-10-21 è¡¥å……ã€ŠEffective Objective-C 2.0ã€‹ç›¸å…³å†…å®¹ ã€Šç¼–å†™é«˜è´¨é‡ iOS ä¸ OS X ä»£ç çš„ 52 ä¸ªæœ‰æ•ˆæ–¹æ³•ã€‹é˜…è¯»ç¬”è®° - kingcos    Preface Obj-C ä¸­æ–¹æ³•è°ƒç”¨çš„æœ¬è´¨æ˜¯æ¶ˆæ¯å‘é€æœºåˆ¶ï¼Œå³ [foo bar] æ˜¯å‘ foo å¯¹è±¡å‘é€ä¸€æ¡ bar çš„æ¶ˆæ¯ï¼Œè€Œæ¶ˆæ¯å‘é€å°±æ˜¯é€šè¿‡ objc_msgSend æ‰€è¿›è¡Œçš„ã€‚é‚£ä¹ˆè¿™æ¬¡æœ¬æ–‡å°±ç®€å•çª¥æ¢ä¸€ä¸‹ objc_msgSend å§ã€‚
Why åœ¨å¼€å§‹ä¹‹å‰ï¼Œå…ˆæ€è€ƒä»¥ä¸‹ä¸ºä»€ä¹ˆ Obj-C ä¸­æ–¹æ³•è°ƒç”¨çš„æœ¬è´¨æ˜¯ objc_msgSend å‘¢ï¼Ÿ
æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªä½¿ç”¨ Obj-C çš„ iOS é¡¹ç›®ï¼Œå¦‚ä¸‹åœ¨ ViewController ä¸­æ·»åŠ ä¸€ä¸ªæŒ‰é’®ï¼Œå¹¶åœ¨æŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶ä¸­åˆ›å»ºä¸€ä¸ª Obj-C å¯¹è±¡ï¼Œå†è°ƒç”¨å…¶æ–¹æ³•ï¼š"/>
<meta name="keywords" content="kingcos.me,maimieng.comios,swift,objective-c,obj-c,objc,oc,geek,python,ruby,golang,go,apple,mac"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/objc_msgsend/" />





<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="æµ…å° objc_msgSend"/>
<meta name="twitter:description" content="Obj-C ä¸­æ–¹æ³•è°ƒç”¨çš„æœ¬è´¨æ˜¯æ¶ˆæ¯å‘é€æœºåˆ¶ï¼Œå³ `[foo bar]` æ˜¯å‘ `foo` å¯¹è±¡å‘é€ä¸€æ¡ `bar` çš„æ¶ˆæ¯ï¼Œè€Œæ¶ˆæ¯å‘é€å°±æ˜¯é€šè¿‡ `objc_msgSend` æ‰€è¿›è¡Œçš„ã€‚é‚£ä¹ˆè¿™æ¬¡æœ¬æ–‡å°±ç®€å•çª¥æ¢ä¸€ä¸‹ `objc_msgSend` å§ã€‚"/>



<meta property="og:title" content="æµ…å° objc_msgSend" />
<meta property="og:description" content="Obj-C ä¸­æ–¹æ³•è°ƒç”¨çš„æœ¬è´¨æ˜¯æ¶ˆæ¯å‘é€æœºåˆ¶ï¼Œå³ `[foo bar]` æ˜¯å‘ `foo` å¯¹è±¡å‘é€ä¸€æ¡ `bar` çš„æ¶ˆæ¯ï¼Œè€Œæ¶ˆæ¯å‘é€å°±æ˜¯é€šè¿‡ `objc_msgSend` æ‰€è¿›è¡Œçš„ã€‚é‚£ä¹ˆè¿™æ¬¡æœ¬æ–‡å°±ç®€å•çª¥æ¢ä¸€ä¸‹ `objc_msgSend` å§ã€‚" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2019/objc_msgsend/" />
<meta property="article:published_time" content="2019-10-21T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-10-21T00:00:00+00:00" /><meta property="og:site_name" content="iBlog" />






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">kingcos.me</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="post">
    <h2 class="post-title"><a href="/posts/2019/objc_msgsend/">æµ…å° objc_msgSend</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            2019-10-21
        </span>
      
      
      
        <span class="post-read-time">â€” 20 min read</span>
      
    </div>

    
      <span class="post-tags">
        
          #<a href="/tags/focus/">Focus</a>&nbsp;
        
          #<a href="/tags/ios/">iOS</a>&nbsp;
        
          #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
        
          #<a href="/tags//">ğŸš§</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Refers.</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2019-07-20</td>
<td align="center">é¦–æ¬¡æäº¤</td>
<td align="center"><a href="https://opensource.apple.com/tarballs/objc4/">objc4-750.1</a></td>
</tr>

<tr>
<td align="center">2019-09-07</td>
<td align="center">å®Œæˆã€Œç¼“å­˜ã€åŠ¨æ€æ–¹æ³•è§£æã€ç­‰éƒ¨åˆ†</td>
<td align="center"><a href="../objects_in_obj-c/">Obj-C ä¸­çš„å¯¹è±¡ - kingcos</a></td>
</tr>

<tr>
<td align="center">2019-10-21</td>
<td align="center">è¡¥å……ã€ŠEffective Objective-C 2.0ã€‹ç›¸å…³å†…å®¹</td>
<td align="center"><a href="../effective_obj-c_2.0_notes/">ã€Šç¼–å†™é«˜è´¨é‡ iOS ä¸ OS X ä»£ç çš„ 52 ä¸ªæœ‰æ•ˆæ–¹æ³•ã€‹é˜…è¯»ç¬”è®° - kingcos</a></td>
</tr>
</tbody>
</table>

<p><img src="/img/2019/objc_msgsend/0.png" alt="0" /></p>

<h2 id="preface">Preface</h2>

<p>Obj-C ä¸­æ–¹æ³•è°ƒç”¨çš„æœ¬è´¨æ˜¯æ¶ˆæ¯å‘é€æœºåˆ¶ï¼Œå³ <code>[foo bar]</code> æ˜¯å‘ <code>foo</code> å¯¹è±¡å‘é€ä¸€æ¡ <code>bar</code> çš„æ¶ˆæ¯ï¼Œè€Œæ¶ˆæ¯å‘é€å°±æ˜¯é€šè¿‡ <code>objc_msgSend</code> æ‰€è¿›è¡Œçš„ã€‚é‚£ä¹ˆè¿™æ¬¡æœ¬æ–‡å°±ç®€å•çª¥æ¢ä¸€ä¸‹ <code>objc_msgSend</code> å§ã€‚</p>

<h2 id="why">Why</h2>

<p>åœ¨å¼€å§‹ä¹‹å‰ï¼Œå…ˆæ€è€ƒä»¥ä¸‹ä¸ºä»€ä¹ˆ Obj-C ä¸­æ–¹æ³•è°ƒç”¨çš„æœ¬è´¨æ˜¯ <code>objc_msgSend</code> å‘¢ï¼Ÿ</p>

<p>æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªä½¿ç”¨ Obj-C çš„ iOS é¡¹ç›®ï¼Œå¦‚ä¸‹åœ¨ <code>ViewController</code> ä¸­æ·»åŠ ä¸€ä¸ªæŒ‰é’®ï¼Œå¹¶åœ¨æŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶ä¸­åˆ›å»ºä¸€ä¸ª Obj-C å¯¹è±¡ï¼Œå†è°ƒç”¨å…¶æ–¹æ³•ï¼š</p>

<pre><code class="language-objectivec">#import &quot;ViewController.h&quot;

@interface Foo : NSObject
- (void)bar;
@end

@implementation Foo
- (void)bar {}
@end

@interface ViewController ()
@end

@implementation ViewController

- (IBAction)clickOnButton:(UIButton *)sender {
    Foo *foo = [[Foo alloc] init];

    [foo bar]; // ğŸ”´ Breakpoint
}

@end
</code></pre>

<p>æˆ‘ä»¬å°†æ–­ç‚¹æ‰“åœ¨ <code>[foo bar];</code> ä¸€è¡Œï¼Œå¯åŠ¨ç¨‹åºå¹¶ç‚¹å‡»æŒ‰é’®ã€‚åœ¨ Xcode çš„æ§åˆ¶å°å¤šæ¬¡è¾“å…¥ <code>si</code>ï¼ˆStep Intoï¼‰å³å¯æœ€ç»ˆè·³è½¬åˆ° <code>objc_msgSend</code>ï¼š</p>

<p><img src="/img/2019/objc_msgsend/3.png" alt="3" /></p>

<p>æˆ–è€…æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc ViewController.m -o foo.cpp</code> å°† Obj-C ä»£ç ç¿»è¯‘ä¸º C/C++ï¼š</p>

<pre><code class="language-objectivec">static void _I_ViewController_clickOnButton_(ViewController * self, SEL _cmd, UIButton *sender) {
    Foo *foo = ((Foo *(*)(id, SEL))(void *)objc_msgSend)((id)((Foo *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;Foo&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));

    // objc_msgSend(foo, sel_registerName(&quot;bar&quot;))
    ((void (*)(id, SEL))(void *)objc_msgSend)((id)foo, sel_registerName(&quot;bar&quot;));
}
</code></pre>

<p>ç»¼ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥è¯´ Obj-C ä¸­æ–¹æ³•è°ƒç”¨çš„æœ¬è´¨å³æ˜¯ <code>objc_msgSend</code>ã€‚</p>

<h2 id="steps">Steps</h2>

<p><code>objc_msgSend</code> æ€»å…±åˆ†ä¸ºæ¶ˆæ¯å‘é€ã€åŠ¨æ€æ–¹æ³•è§£æã€ä»¥åŠæ¶ˆæ¯è½¬å‘ä¸‰å¤§éƒ¨åˆ†ï¼Œä¸‹é¢æˆ‘ä»¬å°±ä¾æ¬¡æ¥ç ”ç©¶ä¸€ä¸‹ã€‚</p>

<h3 id="æ¶ˆæ¯å‘é€">æ¶ˆæ¯å‘é€</h3>

<p><code>objc_msgSend</code> ä¸­çš„ç¬¬ä¸€ä¸ªéƒ¨åˆ†æ˜¯æ¶ˆæ¯å‘é€ï¼Œå³å¯¹æ¶ˆæ¯æ¥æ”¶è€…å‘é€ä¸€æ¡æ–¹æ³•æ¶ˆæ¯ï¼Œå½“æ¥æ”¶è€…å¯ä»¥å¤„ç†æ¶ˆæ¯æ—¶å°†æ‰§è¡Œç›¸åº”çš„æ–¹æ³•ï¼Œæ— æ³•å¤„ç†æ—¶åˆ™è¿›å…¥ä¸‹ä¸€æ­¥éª¤ã€‚</p>

<h4 id="where-why">Where &amp; Why</h4>

<p>åœ¨ Apple å¼€æºçš„ objc4 æºç ä¸­ï¼Œæˆ‘ä»¬ä¼¼ä¹åªèƒ½åœ¨ã€Œmessage.hã€ä¸­æ‰¾åˆ° <code>objc_msgSend</code> çš„å£°æ˜ï¼Œå…¶å°†æ¶ˆæ¯æ¥æ”¶è€…ï¼ˆå³å¯¹è±¡ï¼‰ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå°†æ¶ˆæ¯ï¼ˆå³æ–¹æ³•é€‰æ‹©å™¨ï¼‰ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°ï¼Œå¹¶å°†æ–¹æ³•çš„å‚æ•°è¿½åŠ åœ¨å‚æ•°åˆ—è¡¨çš„æœ€åï¼š</p>

<pre><code class="language-c">// message.h

/**
 * Sends a message with a simple return value to an instance of a class.
 * å‘é€ä¸€ä¸ªå¸¦æœ‰ç®€æ˜“è¿”å›å€¼çš„æ¶ˆæ¯åˆ°ä¸€ä¸ªç±»çš„å®ä¾‹ã€‚
 *
 * @param self A pointer to the instance of the class that is to receive the message.
 *             æŒ‡å‘æ¥æ”¶æ¶ˆæ¯è€…å®ä¾‹çš„æŒ‡é’ˆã€‚
 * @param op The selector of the method that handles the message.
 *           å¤„ç†æ¶ˆæ¯çš„é€‰æ‹©å™¨ã€‚
 * @param ...
 *   A variable argument list containing the arguments to the method.
 *   åŒ…å«æ–¹æ³•å‚æ•°çš„å¯å˜å‚æ•°åˆ—è¡¨ã€‚
 *
 * @return The return value of the method.
 *         æ–¹æ³•çš„è¿”å›å€¼ã€‚
 *
 * @note When it encounters a method call, the compiler generates a call to one of the
 *  functions \c objc_msgSend, \c objc_msgSend_stret, \c objc_msgSendSuper, or \c objc_msgSendSuper_stret.
 *  Messages sent to an objectâ€™s superclass (using the \c super keyword) are sent using \c objc_msgSendSuper;
 *  other messages are sent using \c objc_msgSend. Methods that have data structures as return values
 *  are sent using \c objc_msgSendSuper_stret and \c objc_msgSend_stret.
 * æ³¨æ„ï¼šå½“é‡åˆ°æ–¹æ³•è°ƒç”¨æ—¶ï¼Œç¼–è¯‘å™¨ä¼šç”Ÿæˆå¯¹ objc_msgSendã€objc_msgSend_stretã€objc_msgSendSuperã€objc_msgSendSuper_stret å››ä¸ªå‡½æ•°ä¹‹ä¸€çš„è°ƒç”¨ã€‚
 * åˆ°è¾¾å¯¹è±¡çˆ¶ç±»ï¼ˆä½¿ç”¨ super å…³é”®å­—ï¼‰çš„æ¶ˆæ¯é€šè¿‡ objc_msgSendSuper å‘é€ï¼›å…¶å®ƒæ¶ˆæ¯åˆ™é€šè¿‡ objc_msgSend å‘é€ã€‚
 * è¿”å›å€¼ä¸ºç»“æ„ä½“çš„æ¶ˆæ¯é€šè¿‡ objc_msgSendSuper_stret æˆ– objc_msgSend_stret å‘é€ã€‚
 *
 */
OBJC_EXPORT id _Nullable
objc_msgSend(id _Nullable self, SEL _Nonnull op, ...)
    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);
</code></pre>

<p><img src="/img/2019/objc_msgsend/1.png" alt="1" /></p>

<p>è€Œ <code>objc_msgSend</code> çš„å…·ä½“å®ç°æ˜¯ç”±æ±‡ç¼–è¯­è¨€ç¼–å†™çš„ï¼ŒåŸå› æœ‰ä¸¤ç‚¹ï¼š</p>

<ol>
<li>å¯¹æ€§èƒ½çš„æè‡´è¿½æ±‚ï¼Œå› ä¸ºæ¯ä¸€æ¡æ±‡ç¼–æŒ‡ä»¤éƒ½å¯¹åº”ä¸€æ¡æœºå™¨æŒ‡ä»¤ï¼Œä½¿ç”¨æ±‡ç¼–å¯ä¾¿äºé’ˆå¯¹ä¸åŒæ¶æ„çš„ CPU ä¼˜åŒ–æ¯ä¸€æ¡æŒ‡ä»¤çš„é€Ÿåº¦ï¼›</li>
<li>C è¯­è¨€æ— æ³•å®ç°ä¸€ä¸ªä¿å­˜æœªçŸ¥å‚æ•°ä¸”æ”¯æŒè·³è½¬åˆ°ä»»ä¸€å‡½æ•°æŒ‡é’ˆå¤„çš„å‡½æ•°ï¼Œå¯¹äº C æ¥è¯´æ²¡æœ‰å¿…è¦çš„ç‰¹æ€§æ¥è¡¨ç¤ºï¼ˆå¼•è‡ª <a href="https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html">Dissecting objc_msgSend on ARM64 - Mike Ash</a>ï¼‰ã€‚</li>
</ol>

<p>ç”±äº <code>objc_msgSend</code> æ•´ä¸ªæµç¨‹æ¯”è¾ƒå¤æ‚ï¼Œä¸‹é¢æˆ‘å°†å°è¯•æŠŠæµç¨‹åˆ†è§£ä¸ºå¤šä¸ªç”¨ä¾‹ï¼Œé€ä¸ªåˆ†æã€‚</p>

<h4 id="å½“æ¥æ”¶è€…ä¸º-nil-æ—¶">å½“æ¥æ”¶è€…ä¸º <code>nil</code> æ—¶</h4>

<p>å½“æ¥æ”¶è€…ä¸º <code>nil</code> æ—¶ï¼Œå³ <code>[foo bar]</code> ä¸­çš„ <code>foo</code> ä¸º <code>nil</code>ï¼š</p>

<pre><code class="language-objectivec">- (IBAction)clickOnButton:(UIButton *)sender {
    Foo *foo = [[Foo alloc] init];

    // å°†æ¥æ”¶è€…ç½®ä¸º nil
    foo = nil;
    [foo bar];
}

// LLDB:
// è¿›å…¥ objc_msgSend åå¯ä»¥å°è¯•ä½¿ç”¨ LLDB å‘½ä»¤è¯»å– x0 å¯„å­˜å™¨ä¸­å­˜å‚¨çš„å€¼
// (lldb) register read x0
//       x0 = 0x0000000000000000
</code></pre>

<p>æˆ‘ä»¬ä» <code>ENTRY _objc_msgSend</code> çš„ç¬¬ä¸€æ¡è¯­å¥ <code>cmp p0, #0</code> å¼€å§‹ï¼š</p>

<p><img src="/img/2019/objc_msgsend/4.png" alt="4" /></p>

<p>åœ¨ Xcode ä¸­ <code>si</code> æ‰§è¡Œå³å¯çœ‹åˆ°å…·ä½“çš„æ±‡ç¼–ä»£ç è·³è½¬ï¼Œä¹Ÿä¸ä¸Šå›¾çš„æºç åˆ†æä¸€è‡´ï¼š</p>

<pre><code class="language-asm">libobjc.A.dylib`objc_msgSend:
    0x192bd8180 &lt;+0&gt;:   cmp    x0, #0x0                  ; =0x0
    0x192bd8184 &lt;+4&gt;:   b.le   0x192bd81f8               ; &lt;+120&gt;
    ; ...
    0x192bd81f8 &lt;+120&gt;: b.eq   0x192bd8230               ; &lt;+176&gt;
    ; ...
    0x192bd8230 &lt;+176&gt;: mov    x1, #0x0
    0x192bd8234 &lt;+180&gt;: movi   d0, #0000000000000000
    0x192bd8238 &lt;+184&gt;: movi   d1, #0000000000000000
    0x192bd823c &lt;+188&gt;: movi   d2, #0000000000000000
    0x192bd8240 &lt;+192&gt;: movi   d3, #0000000000000000
    0x192bd8244 &lt;+196&gt;: ret
</code></pre>

<h4 id="æ–¹æ³•ç¼“å­˜">æ–¹æ³•ç¼“å­˜</h4>

<pre><code class="language-cpp">struct objc_class : objc_object {
    // Class ISA;
    Class superclass;
    // â¬‡ï¸ æ–¹æ³•ç¼“å­˜
    cache_t cache;             // formerly cache pointer and vtable
    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags
};
</code></pre>

<p>åœ¨ <a href="../objects_in_obj-c/">Obj-C ä¸­çš„å¯¹è±¡</a>ä¸€æ–‡ä¸­ï¼Œæˆ‘ä»¬ç®€å•äº†è§£äº† Obj-C ä¸­ç±»å’Œå…ƒç±»å¯¹è±¡çš„ç»“æ„ï¼Œå…¶ä¸­çš„ <code>cache_t cache;</code> æ˜¯æ–¹æ³•ç¼“å­˜ã€‚é‚£ä¹ˆä¸ºä»€ä¹ˆéœ€è¦ç¼“å­˜å‘¢ï¼Ÿ</p>

<p>Obj-C çš„æ¶ˆæ¯å‘é€æœ¬è´¨å±äº<strong>åŠ¨æ€ç»‘å®šï¼ˆDynamic Bindingï¼‰</strong>ï¼Œè€Œé C è¯­è¨€å¸¸ç”¨çš„é™æ€ç»‘å®šï¼ˆStatic Bindingï¼‰ã€‚åŠ¨æ€ç»‘å®šæ„å‘³ç€åªæœ‰åœ¨è¿è¡Œæ—¶æ‰èƒ½ç¡®å®šçœŸæ­£è¢«è°ƒç”¨çš„å‡½æ•°ï¼›è€Œé™æ€ç»‘å®šåœ¨ç¼–è¯‘æ—¶å³å¯ç¡®å®šï¼ˆä¸è€ƒè™‘å†…è”å‡½æ•°çš„å‰æä¸‹ï¼‰ï¼Œç¼–è¯‘å™¨ä¼šç›´æ¥ç”Ÿæˆè°ƒç”¨å‡½æ•°çš„æŒ‡ä»¤ï¼Œå‡½æ•°åœ°å€å°±è¢«ç¡¬ç¼–ç åœ¨æŒ‡ä»¤å½“ä¸­ã€‚</p>

<blockquote>
<p><strong>Tips - å†…è”ï¼ˆInlineï¼‰å‡½æ•°</strong></p>

<p>å»ºè®®ç¼–è¯‘å™¨å¯¹å‡½æ•°è¿›è¡Œå†…è”æ‰©å±•ï¼Œå³å»ºè®®ç¼–è¯‘å™¨å°†æŒ‡å®šçš„å‡½æ•°ä½“ç›´æ¥æ’å…¥åˆ°æ¯ä¸€å¤„è°ƒç”¨è¯¥å‡½æ•°çš„åœ°æ–¹ï¼ˆæ³¨ï¼šã€Œå»ºè®®ã€æŒ‡å…·ä½“æ˜¯å¦è¿›è¡Œå†…è”éœ€è¦çœ‹ç¼–è¯‘å™¨æœ¬èº«ï¼‰ã€‚</p>
</blockquote>

<p>å› æ­¤å¯¹äºåŠ¨æ€ç»‘å®šçš„è¯­è¨€æ¥è¯´ï¼Œå…¶æ–¹æ³•æŸ¥æ‰¾çš„é€Ÿåº¦ä¸€å®šæ˜¯æ…¢äºé™æ€ç»‘å®šçš„ã€‚ä¸ºäº†æé«˜æ•ˆç‡ï¼ŒObj-C ä¼šå°†æ–¹æ³•æŸ¥æ‰¾çš„ç»“æœç¼“å­˜åœ¨ <code>cache_t cache;</code> ä¸­ï¼Œå½“åç»­å‘é€åŒæ ·çš„æ¶ˆæ¯æ—¶å³å¯å¾—åˆ°æ›´å¿«å¾—æ‰§è¡Œã€‚</p>

<pre><code class="language-cpp">// _uint32_t.h

typedef unsigned int uint32_t;

// _uintptr_t.h

typedef unsigned long           uintptr_t;

// objc-ptrauth.h

using MethodCacheIMP = IMP;

// objc-runtime-new.h

#if __LP64__
typedef uint32_t mask_t;  // x86_64 &amp; arm64 asm are less efficient with 16-bits
#else
typedef uint16_t mask_t;
#endif
typedef uintptr_t cache_key_t;

struct bucket_t {
private:
    // IMP-first is better for arm64e ptrauth and no worse for arm64.
    // SEL-first is better for armv7* and i386 and x86_64.
#if __arm64__
    MethodCacheIMP _imp;
    cache_key_t _key;
#else
    cache_key_t _key;
    MethodCacheIMP _imp;
#endif

    // ...
};

struct cache_t {
    struct bucket_t *_buckets;
    mask_t _mask;
    mask_t _occupied;

    // ...
};
</code></pre>

<p><code>cache_t</code> ç»“æ„ä½“ä¸­å­˜å‚¨äº†æŒ‡å‘ <code>bucket_t</code> ç»“æ„ä½“ï¼ˆæ•°ç»„ï¼‰çš„æŒ‡é’ˆã€<code>_mask</code>ï¼ˆè¡¨ç¤ºæ•£åˆ—è¡¨å®¹é‡ - 1ï¼Œè¯¦è§ä¸‹æ–‡æºç ï¼‰ã€ä»¥åŠ <code>_occupied</code>ï¼ˆè¡¨ç¤ºå·²ç¼“å­˜æ–¹æ³•çš„æ•°é‡ï¼‰ã€‚<code>bucket_t</code> å³ç¼“å­˜æ–¹æ³•çš„æ•£åˆ—è¡¨ï¼Œæ–¹æ³•åå°†ä½œä¸ºé”®ï¼Œ<code>IMP</code> å³æ–¹æ³•çš„å†…å­˜åœ°å€å°†ä½œä¸ºå€¼ã€‚</p>

<h4 id="å½“æœªå‘½ä¸­ç¼“å­˜æ—¶">å½“æœªå‘½ä¸­ç¼“å­˜æ—¶</h4>

<p>æ–¹æ³•çš„é¦–æ¬¡è°ƒç”¨æˆ–é‡åˆ°ç¼“å­˜æ‰©å®¹åæ— æ³•å‘½ä¸­ç¼“å­˜ï¼Œå°†è¿›å…¥ C å‡½æ•°ä¸­æœç´¢ï¼Œå¹¶åœ¨æ‰¾åˆ°æ–¹æ³•åç¼“å­˜åœ¨è°ƒç”¨è€…æœ¬èº«çš„ç¼“å­˜ä¸­ã€‚å› æ­¤æˆ‘ä»¬ä»ä» <code>cmp p0, #0</code> å¼€å§‹ï¼Œä½†è¿™æ¬¡æ¥æ”¶è€…å¹¶é <code>nil</code> æ‰€ä»¥ä¸ä¼šè·³å…¥åˆ¤ç©ºåˆ†æ”¯ï¼š</p>

<p><img src="/img/2019/objc_msgsend/5.png" alt="5" /></p>

<p>åˆ°è¾¾ <code>bl __class_lookupMethodAndLoadCache3</code> åå°†è·³å…¥ C å‡½æ•° <code>_class_lookupMethodAndLoadCache3</code> ä¸­ï¼š</p>

<pre><code class="language-cpp">// objc-runtime-new.mm

/***********************************************************************
* _class_lookupMethodAndLoadCache.
* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().
* ä»…ä¾›è°ƒåº¦ç¨‹åºæ‰€ä½¿ç”¨çš„æ–¹æ³•æŸ¥æ‰¾ã€‚å…¶å®ƒä»£ç åº”å½“ä½¿ç”¨ lookUpImp()ã€‚
* This lookup avoids optimistic cache scan because the dispatcher
* already tried that.
* æ­¤æŸ¥æ‰¾å¯é¿å…ä¹è§‚ç¼“å­˜æ‰«æï¼Œå› ä¸ºè°ƒåº¦ç¨‹åºå·²ç»å°è¯•äº†æ­¤æ“ä½œã€‚
**********************************************************************/
IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)
{
    // â¬‡ï¸ æŸ¥æ‰¾ IMP æˆ–è½¬å‘
    return lookUpImpOrForward(cls, sel, obj,
                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);
}

/***********************************************************************
* lookUpImpOrForward.
* The standard IMP lookup.
* æ ‡å‡† IMP æŸ¥æ‰¾ã€‚
* initialize==NO tries to avoid +initialize (but sometimes fails)
* initialize==NO å°è¯•é¿å…è°ƒç”¨ +initializeï¼ˆä½†æœ‰æ—¶ä¼šå¤±è´¥ï¼‰
* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)
* cache==NO è·³è¿‡ä¹è§‚è§£é”æŸ¥æ‰¾ï¼ˆä½†åœ¨å…¶å®ƒåœ°æ–¹ä½¿ç”¨ç¼“å­˜ï¼‰
* Most callers should use initialize==YES and cache==YES.
* å¤§å¤šæ•°è°ƒç”¨è€…åº”å½“ä½¿ç”¨ initialize==YES å’Œ cache==YESã€‚
* inst is an instance of cls or a subclass thereof, or nil if none is known.
* inst æ˜¯ cls æˆ–å…¶å­ç±»çš„å®ä¾‹ï¼Œè‹¥æœªçŸ¥åˆ™ä¸º nilã€‚
*   If cls is an un-initialized metaclass then a non-nil inst is faster.
*   å¦‚æœ cls æ˜¯æœªåˆå§‹åŒ–çš„å…ƒç±»ï¼Œé‚£ä¹ˆéç©º inst å°†æ›´å¿«ã€‚
* May return _objc_msgForward_impcache. IMPs destined for external use
*   must be converted to _objc_msgForward or _objc_msgForward_stret.
* å¯èƒ½ä¼šè¿”å› _objc_msgForward_impcacheã€‚è¢«æŒ‡å®šå¤–éƒ¨ä½¿ç”¨çš„ IMP å¿…é¡»è½¬æ¢ä¸º _objc_msgForward æˆ– _objc_msgForward_stretã€‚
*   If you don't want forwarding at all, use lookUpImpOrNil() instead.
*   å¦‚æœä¸ä½ éœ€è¦ä»»ä½•è½¬å‘ï¼Œä½¿ç”¨ lookUpImpOrNil() ä»£æ›¿ã€‚
**********************************************************************/
IMP lookUpImpOrForward(Class cls, SEL sel, id inst,
                       bool initialize, bool cache, bool resolver)
{
    IMP imp = nil;
    bool triedResolver = NO;

    runtimeLock.assertUnlocked();

    // Optimistic cache lookup
    // cache ä¸º NOï¼Œè·³è¿‡
    if (cache) {
        imp = cache_getImp(cls, sel);
        if (imp) return imp;
    }

    // runtimeLock is held during isRealized and isInitialized checking
    // to prevent races against concurrent realization.

    // runtimeLock is held during method search to make
    // method-lookup + cache-fill atomic with respect to method addition.
    // Otherwise, a category could be added but ignored indefinitely because
    // the cache was re-filled with the old value after the cache flush on
    // behalf of the category.

    runtimeLock.lock();
    checkIsKnownClass(cls);

    // è‹¥ç±»æœªå®åŒ–ï¼Œåˆ™è¿›è¡Œå®åŒ–
    if (!cls-&gt;isRealized()) {
        realizeClass(cls);
    }

    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) {
        runtimeLock.unlock();
        _class_initialize (_class_getNonMetaClass(cls, inst));
        runtimeLock.lock();
        // If sel == initialize, _class_initialize will send +initialize and
        // then the messenger will send +initialize again after this
        // procedure finishes. Of course, if this is not being called
        // from the messenger then it won't happen. 2778172
    }


 retry:
    runtimeLock.assertLocked();

    // Try this class's cache.

    // â¬‡ï¸ å†æ¬¡å°è¯•ä»ç¼“å­˜ä¸­å– IMPï¼ˆæ±‡ç¼–ï¼‰
    imp = cache_getImp(cls, sel);
    // å–åˆ°äº†åˆ™ç»“æŸ
    if (imp) goto done;

    // Try this class's method lists.
    {
        // â¬‡ï¸ æ ¹æ® SEL è·å–æœ¬ç±»çš„æ–¹æ³•
        Method meth = getMethodNoSuper_nolock(cls, sel);
        if (meth) {
            // â¬‡ï¸ å¦‚æœè·å–åˆ°æ–¹æ³•äº†ï¼Œåˆ™å¡«å……ç¼“å­˜ï¼Œå¹¶è¿”å› IMP
            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);
            imp = meth-&gt;imp;
            goto done;
        }
    }

    // Try superclass caches and method lists.
    {
        unsigned attempts = unreasonableClassCount();
        // å¦‚æœæœ¬ç±»æ‰¾ä¸åˆ°ï¼Œåˆ™å»çˆ¶ç±»ï¼ˆçˆ¶ç±»çš„çˆ¶ç±»ï¼‰ä¸­æŸ¥æ‰¾
        for (Class curClass = cls-&gt;superclass;
             curClass != nil;
             curClass = curClass-&gt;superclass)
        {
            // Halt if there is a cycle in the superclass chain.
            if (--attempts == 0) {
                _objc_fatal(&quot;Memory corruption in class list.&quot;);
            }

            // Superclass cache.
            // åœ¨çˆ¶ç±»ç¼“å­˜ä¸­æ‰¾
            imp = cache_getImp(curClass, sel);
            if (imp) {
                if (imp != (IMP)_objc_msgForward_impcache) {
                    // Found the method in a superclass. Cache it in this class.
                    // çˆ¶ç±»ä¸­æ‰¾åˆ°äº†ï¼Œåˆ™åœ¨æœ¬ç±»ç¼“å­˜å¹¶è¿”å› IMP
                    log_and_fill_cache(cls, imp, sel, inst, curClass);
                    goto done;
                }
                else {
                    // âš ï¸ çˆ¶ç±»çš„æ–¹æ³•è½¬å‘å…¥å£ï¼Œåœæ­¢å¾ªç¯
                    // Found a forward:: entry in a superclass.
                    // Stop searching, but don't cache yet; call method
                    // resolver for this class first.
                    break;
                }
            }

            // Superclass method list.
            // çˆ¶ç±»ç¼“å­˜æœªæ‰¾åˆ°ï¼Œåˆ™åœ¨çˆ¶ç±»çš„æ–¹æ³•åˆ—è¡¨ä¸­æŸ¥æ‰¾
            Method meth = getMethodNoSuper_nolock(curClass, sel);
            if (meth) {
                // æ‰¾åˆ°åˆ™åœ¨æœ¬ç±»ç¼“å­˜
                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);
                imp = meth-&gt;imp;
                goto done;
            }
        }
    }

    // No implementation found. Try method resolver once.
    // IMP æ‰¾ä¸åˆ°ï¼Œåˆ™è¿›å…¥æ–¹æ³•åŠ¨æ€è§£æä¸€æ¬¡ã€‚è¯¦è§ä¸‹æ–‡ã€ŒåŠ¨æ€æ–¹æ³•è§£æã€ä¸€èŠ‚ã€‚
    if (resolver  &amp;&amp;  !triedResolver) {
        runtimeLock.unlock();
        _class_resolveMethod(cls, sel, inst);
        runtimeLock.lock();
        // Don't cache the result; we don't hold the lock so it may have
        // changed already. Re-do the search from scratch instead.
        // æ ‡è®°ä¸º YES
        triedResolver = YES;
        goto retry;
    }

    // No implementation found, and method resolver didn't help.
    // Use forwarding.
    // å®ç°æ— æ³•æ‰¾åˆ°ï¼Œæ–¹æ³•è§£ææ— æ•ˆï¼Œå°è¯•æ–¹æ³•è½¬å‘ã€‚

    imp = (IMP)_objc_msgForward_impcache;
    cache_fill(cls, sel, imp, inst);

 done:
    runtimeLock.unlock();

    return imp;
}

static method_t *
getMethodNoSuper_nolock(Class cls, SEL sel)
{
    runtimeLock.assertLocked();

    assert(cls-&gt;isRealized());
    // fixme nil cls?
    // fixme nil sel?

    for (auto mlists = cls-&gt;data()-&gt;methods.beginLists(),
              end = cls-&gt;data()-&gt;methods.endLists();
         mlists != end;
         ++mlists)
    {
        // â¬‡ï¸ åœ¨æ–¹æ³•åˆ—è¡¨ä¸­æŸ¥æ‰¾æ–¹æ³•
        method_t *m = search_method_list(*mlists, sel);
        if (m) return m;
    }

    return nil;
}

/***********************************************************************
* getMethodNoSuper_nolock
* fixme
* Locking: runtimeLock must be read- or write-locked by the caller
**********************************************************************/
static method_t *search_method_list(const method_list_t *mlist, SEL sel)
{
    int methodListIsFixedUp = mlist-&gt;isFixedUp();
    int methodListHasExpectedSize = mlist-&gt;entsize() == sizeof(method_t);

    if (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, 1)) {
        // åœ¨å·²æ’åºçš„æ–¹æ³•åˆ—è¡¨ä¸­æŸ¥æ‰¾
        return findMethodInSortedMethodList(sel, mlist);
    } else {
        // Linear search of unsorted method list
        // çº¿æ€§æŸ¥æ‰¾æœªæ’åºæ–¹æ³•åˆ—è¡¨
        for (auto&amp; meth : *mlist) {
            if (meth.name == sel) return &amp;meth;
        }
    }

#if DEBUG
    // sanity-check negative results
    if (mlist-&gt;isFixedUp()) {
        for (auto&amp; meth : *mlist) {
            if (meth.name == sel) {
                _objc_fatal(&quot;linear search worked when binary search did not&quot;);
            }
        }
    }
#endif

    return nil;
}

/***********************************************************************
* log_and_fill_cache
* Log this method call. If the logger permits it, fill the method cache.
* è®°å½•è¯¥æ–¹æ³•è°ƒç”¨ã€‚å¦‚æœè®°å½•å™¨å…è®¸ï¼Œå¡«å……æ–¹æ³•ç¼“å­˜ã€‚
* cls is the method whose cache should be filled.
* æ–¹æ³•åº”å½“å¡«å……åœ¨ cls çš„ç¼“å­˜ä¸­ã€‚
* implementer is the class that owns the implementation in question.
* implementer æŒ‡æ‹¥æœ‰ç›¸å…³å®ç°çš„ç±»ã€‚
**********************************************************************/
static void
log_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer)
{
#if SUPPORT_MESSAGE_LOGGING
    if (objcMsgLogEnabled) {
        bool cacheIt = logMessageSend(implementer-&gt;isMetaClass(),
                                      cls-&gt;nameForLogging(),
                                      implementer-&gt;nameForLogging(),
                                      sel);
        if (!cacheIt) return;
    }
#endif
    // â¬‡ï¸ å¡«å……ç¼“å­˜
    cache_fill (cls, sel, imp, receiver);
}

// objc-cache.mm

void cache_fill(Class cls, SEL sel, IMP imp, id receiver)
{
#if !DEBUG_TASK_THREADS
    mutex_locker_t lock(cacheUpdateLock);
    // â¬‡ï¸ å¡«å……ç¼“å­˜
    cache_fill_nolock(cls, sel, imp, receiver);
#else
    _collecting_in_critical();
    return;
#endif
}

static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)
{
    cacheUpdateLock.assertLocked();

    // Never cache before +initialize is done
    // è‹¥ç±»æœªåˆå§‹åŒ–ï¼Œåˆ™è¿”å›
    if (!cls-&gt;isInitialized()) return;

    // Make sure the entry wasn't added to the cache by some other thread
    // before we grabbed the cacheUpdateLock.
    // è‹¥ç¼“å­˜ä¸­å·²å­˜åœ¨ï¼Œåˆ™è¿”å›
    if (cache_getImp(cls, sel)) return;

    cache_t *cache = getCache(cls);
    // â¬‡ï¸ è·å–ç¼“å­˜ keyï¼Œæœ¬è´¨å³ SEL
    cache_key_t key = getKey(sel);

    // Use the cache as-is if it is less than 3/4 full
    // å¦‚æœå°äºç­‰äº 3/4 æ»¡ï¼Œåˆ™ä½¿ç”¨ç¼“å­˜
    // newOccupied ä¸ºå½“å‰å ç”¨æ•° + 1
    mask_t newOccupied = cache-&gt;occupied() + 1;
    // capacity ä¸ºå®¹é‡ï¼ˆmask + 1 æˆ– 0ï¼‰
    mask_t capacity = cache-&gt;capacity();
    if (cache-&gt;isConstantEmptyCache()) {
        // ç¼“å­˜ä¸ºç©º
        // Cache is read-only. Replace it.
        // é‡æ–°åˆ†é…å†…å­˜
        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);
    }
    else if (newOccupied &lt;= capacity / 4 * 3) {
        // Cache is less than 3/4 full. Use it as-is.
        // ç¼“å­˜å·²å ç”¨æ¯”ä¾‹å°äºç­‰äº 3/4ï¼Œåˆ™ä½¿ç”¨
    }
    else {
        // Cache is too full. Expand it.
        // â¬‡ï¸ å¤§äº 3/4 åˆ™å…ˆæ‰©å®¹ã€‚
        cache-&gt;expand();
    }

    // Scan for the first unused slot and insert there.
    // æ‰«æé¦–ä¸ªæœªä½¿ç”¨çš„é—´éš™å¹¶æ’å…¥ã€‚
    // There is guaranteed to be an empty slot because the
    // minimum size is 4 and we resized at 3/4 full.
    // èƒ½å¤Ÿè¢«ç¡®ä¿æœ‰ç©ºé—´éš™æ˜¯å› ä¸ºæœ€å°å¤§å°ä¸º 4ï¼Œå¹¶é‡è°ƒä¸º 3/4 æ»¡ã€‚
    // â¬‡ï¸ æŸ¥æ‰¾è¦å­˜å…¥çš„ bucket_t
    bucket_t *bucket = cache-&gt;find(key, receiver);
    // key ä¸ºç©ºï¼Œåˆ™ä¸ºæ–°å ç”¨ç¼“å­˜ï¼Œå ç”¨æ•°éœ€è‡ªå¢
    if (bucket-&gt;key() == 0) cache-&gt;incrementOccupied();
    // å­˜å…¥ bucket
    bucket-&gt;set(key, imp);
}

mask_t cache_t::capacity()
{
    return mask() ? mask()+1 : 0;
}

cache_key_t getKey(SEL sel)
{
    assert(sel);
    // å°† SEL å¼ºè½¬ä¸º cache_key_t ç±»å‹
    return (cache_key_t)sel;
}

// ğŸŒŸ æ ¹æ® key æŸ¥æ‰¾ bucket_t
bucket_t * cache_t::find(cache_key_t k, id receiver)
{
    assert(k != 0);

    // b ä¸º buckets æ•°ç»„é¦–åœ°å€
    bucket_t *b = buckets();
    mask_t m = mask();
    // begin ä¸ºæ–¹æ³•åœ¨æ•£åˆ—è¡¨çš„ç´¢å¼•
    mask_t begin = cache_hash(k, m);
    // ä»ç´¢å¼•å¼€å§‹éå†
    mask_t i = begin;
    do {
        // å¦‚æœè¯¥ç´¢å¼•å¯¹åº”çš„ bucket_t ä¸­çš„ keyï¼ˆSELï¼‰å¯¹åº”äº†æˆ‘ä»¬æŸ¥æ‰¾çš„ keyï¼ˆå³å·²å­˜åœ¨ï¼‰æˆ–ä¸ºç©º
        // åˆ™ä»£è¡¨å½“å‰ bucket_t å¯æ’å…¥
        if (b[i].key() == 0  ||  b[i].key() == k) {
            return &amp;b[i];
        }
        // ç´¢å¼•å†²çªï¼Œåˆ™è¿›å…¥å½“å‰ç´¢å¼•çš„ä¸‹ä¸€æ ¼
    } while ((i = cache_next(i, m)) != begin);

    // hack
    Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache));
    cache_t::bad_cache(receiver, (SEL)k, cls);
}

// Class points to cache. SEL is key. Cache buckets store SEL+IMP.
// Caches are never built in the dyld shared cache.

static inline mask_t cache_hash(cache_key_t key, mask_t mask)
{
    // key &amp; mask è·å¾—ç´¢å¼•
    return (mask_t)(key &amp; mask);
}

static inline mask_t cache_next(mask_t i, mask_t mask) {
    return (i+1) &amp; mask;
}

// ç¼“å­˜æ‰©å®¹
void cache_t::expand()
{
    cacheUpdateLock.assertLocked();

    uint32_t oldCapacity = capacity();
    // æ‰©å®¹å¤§å°ä¸ºåŸç©ºé—´ 2 å€ï¼ˆè‹¥åŸä¸ºç©ºï¼Œåˆ™æ‰©å®¹ä¸ºåˆå§‹å¤§å°ï¼‰
    uint32_t newCapacity = oldCapacity ? oldCapacity*2 : INIT_CACHE_SIZE;

    if ((uint32_t)(mask_t)newCapacity != newCapacity) {
        // mask overflow - can't grow further
        // fixme this wastes one bit of mask
        newCapacity = oldCapacity;
    }

    reallocate(oldCapacity, newCapacity);
}

/* Initial cache bucket count. INIT_CACHE_SIZE must be a power of two. */
enum {
    INIT_CACHE_SIZE_LOG2 = 2,
    // å·¦ç§» 2 ä½ï¼Œä¸º 4
    INIT_CACHE_SIZE      = (1 &lt;&lt; INIT_CACHE_SIZE_LOG2)
};
</code></pre>

<p>å¦‚ä¸Šï¼Œæ¶ˆæ¯å‘é€çš„ä»£ç è¢«åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼šå…¶ä¸€æ˜¯å¿«é€Ÿè·¯å¾„ï¼ˆFast Pathï¼‰ï¼Œè¿™ä¸€éƒ¨åˆ†ç”±æ±‡ç¼–è¯­è¨€å®ç°ï¼›å…¶äºŒæ˜¯æ…¢é€Ÿè·¯å¾„ï¼ˆSlow Pathï¼‰ï¼Œç”± C è¯­è¨€å®ç°ã€‚å½“æœªå‘½ä¸­ç¼“å­˜æ—¶ï¼Œå°†è°ƒç”¨ C è¯­è¨€ä»£ç æ¥æŸ¥æ‰¾æ–¹æ³•åˆ—è¡¨ï¼Œå¹¶ç¼“å­˜æ–¹æ³•ã€‚</p>

<h4 id="å½“å‘½ä¸­ç¼“å­˜æ—¶">å½“å‘½ä¸­ç¼“å­˜æ—¶</h4>

<p>å½“æ–¹æ³•è¢«å†æ¬¡è°ƒç”¨æ—¶ï¼Œå°†å¯ä»¥å‘½ä¸­ç¼“å­˜å¾—ä»¥å¿«é€Ÿæ‰§è¡Œï¼š</p>

<p><img src="/img/2019/objc_msgsend/6.png" alt="6" /></p>

<h4 id="support-indexed-isa"><code>SUPPORT_INDEXED_ISA</code></h4>

<p><code>SUPPORT_INDEXED_ISA</code>ï¼Œå³æ˜¯å¦æ”¯æŒç´¢å¼•åŒ– isa æˆ‘ä»¬å¯ä»¥åœ¨æºç ä¸­æ‰¾åˆ°è¿™æ®µå®šä¹‰çš„å®ï¼š</p>

<pre><code class="language-objectivec">// objc-config.h

// Define SUPPORT_INDEXED_ISA=1 on platforms that store the class in the isa
// field as an index into a class table.
// åœ¨å°†ç±»å­˜å‚¨åœ¨ isa åŸŸä¸­å¹¶ä½œä¸ºç±»è¡¨ç´¢å¼•çš„å¹³å°ä¸Šå®šä¹‰ SUPPORT_INDEXED_ISA=1ã€‚
// Note, keep this in sync with any .s files which also define it.
// Be sure to edit objc-abi.h as well.
#if __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)
#   define SUPPORT_INDEXED_ISA 1
#else
#   define SUPPORT_INDEXED_ISA 0
#endif
</code></pre>

<p>æ¯”è¾ƒç®€å•çš„éªŒè¯æ–¹å¼æ˜¯æˆ‘ä»¬å¯ä»¥ç›´æ¥åœ¨æŒ‡å®šçœŸæœºè¿è¡Œçš„ä»£ç ä¸­å°è¯•è·å–æœ€ç»ˆçš„å€¼ï¼š</p>

<pre><code class="language-objectivec">#if __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)
#   define SUPPORT_INDEXED_ISA 1
#else
#   define SUPPORT_INDEXED_ISA 0
#endif

// Use of undeclared identifier '__ARM_ARCH_7K__'
// NSLog(@&quot;%d&quot;, __ARM_ARCH_7K__);
NSLog(@&quot;%d&quot;, __arm64__);           // 1
NSLog(@&quot;%d&quot;, __LP64__);            // 1
NSLog(@&quot;%d&quot;, SUPPORT_INDEXED_ISA); // 0
</code></pre>

<p>å½“ç„¶ï¼Œæˆ‘è¿˜æ˜¯è¦ç»†ç©¶ä¸€ä¸‹ã€‚</p>

<p><code>__ARM_ARCH_7K__</code> æ ¹æ®åç§°å¯ä»¥å¾—å‡ºæ˜¯å®šä¹‰åœ¨ç›®æ ‡ä¸º ARM 7k æ¶æ„ CPU çš„ä»£ç ä¸­çš„æ ‡å¿—å®ã€‚æˆ‘ä»¬å¯ä»¥åœ¨ LLVM å¼€æºçš„ã€ŒARM.cppã€æ‰¾åˆ°å…¶å®šä¹‰ï¼š</p>

<pre><code class="language-cpp">// ARM.cpp

// Unfortunately, __ARM_ARCH_7K__ is now more of an ABI descriptor. The CPU
// happens to be Cortex-A7 though, so it should still get __ARM_ARCH_7A__.
if (getTriple().isWatchABI())
  Builder.defineMacro(&quot;__ARM_ARCH_7K__&quot;, &quot;2&quot;);
</code></pre>

<p><code>__arm64__</code> å³æ˜¯å®šä¹‰åœ¨ç›®æ ‡ä¸º ARM 64 æ¶æ„ CPU çš„ä»£ç ä¸­ï¼›<code>__LP64__</code> åˆ™æ„å‘³ç€ Long Pointerï¼Œè¯¥æ ‡å¿—å®ä¸º <code>1</code> çš„ä»£ç ä¸­ <code>long int</code> å’ŒæŒ‡é’ˆç±»å‹ï¼ˆæŒ‡é’ˆä¸­å­˜å‚¨çš„æ˜¯å†…å­˜åœ°å€ï¼Œä¹Ÿå³å†…å­˜åœ°å€ï¼‰çš„é•¿åº¦ä¸º 64 ä½ï¼ˆ8 å­—èŠ‚ï¼‰ï¼Œ<code>int</code> ä¸º 32 ä½ï¼ˆ4 å­—èŠ‚ï¼‰ã€‚</p>

<p>ç»¼ä¸Šï¼Œåœ¨ iOS çš„çœŸæœºè®¾å¤‡ä¸­ï¼Œ<code>SUPPORT_INDEXED_ISA</code> çš„å€¼æœ€ç»ˆä¸º <code>0</code>ã€‚</p>

<h4 id="å°¾é€’å½’è°ƒç”¨">å°¾é€’å½’è°ƒç”¨</h4>

<p>ğŸš§</p>

<h3 id="åŠ¨æ€æ–¹æ³•è§£æ">åŠ¨æ€æ–¹æ³•è§£æ</h3>

<h4 id="what">What</h4>

<p>å½“ä¸€ä¸ªç±»æˆ–å…ƒç±»è‡ªèº«åŠå…¶æ‰€æœ‰çˆ¶ç±»ä¸­éƒ½æ²¡æœ‰ç›¸åº”çš„æ–¹æ³•å®ç°æ—¶ï¼Œå°†å°è¯•åŠ¨æ€æ–¹æ³•è§£æã€‚å³è°ƒç”¨ <code>resolveInstanceMethod:</code> æˆ– <code>resolveClassMethod</code> ç±»æ–¹æ³•ï¼ˆä¸¤è€…ä¾æ¬¡å¯¹åº”è§£æå®ä¾‹æ–¹æ³•ã€ç±»æ–¹æ³•ï¼‰ï¼Œå¦‚æœæˆ‘ä»¬åœ¨å…¶ä¸­åŠ¨æ€å°†æ–¹æ³•æ·»åŠ ï¼Œé‚£ä¹ˆå°†å¯ä»¥æ‰§è¡Œåˆ°ç›¸åº”çš„æ–¹æ³•ä¸­ï¼š</p>

<pre><code class="language-objectivec">@interface Foo : NSObject
- (void)foo;
+ (void)classFoo;
- (void)tryC;
@end

@implementation Foo

- (void)bar {
    NSLog(@&quot;%s&quot;, __func__);
}

+ (void)classBar {
    NSLog(@&quot;%s&quot;, __func__);
}

void c_func(id self, SEL _cmd) {
    NSLog(@&quot;%p - %@&quot;, self, NSStringFromSelector(_cmd));
}

+ (BOOL)resolveInstanceMethod:(SEL)sel {
    if (sel == @selector(foo)) {
        // é€šè¿‡ Runtime API è·å¾—ç±»å¯¹è±¡ä¸­çš„å®ä¾‹æ–¹æ³•
        Method method = class_getInstanceMethod(self, @selector(bar));
        // åŠ¨æ€æ·»åŠ æ–¹æ³•
        class_addMethod(self, sel, method_getImplementation(method), method_getTypeEncoding(method));

        return YES;
    }

    if (sel == @selector(tryC)) {
        // ä¹Ÿå¯ä»¥å°† C å‡½æ•°è½¬æ¢ä¸º Method æ ¼å¼ä½œä¸ºåŠ¨æ€æ–¹æ³•ï¼›
        class_addMethod(self, sel, (IMP)c_func, &quot;v16@0:8&quot;);
    }

    // å½“å®ç°äº†åŠ¨æ€æ–¹æ³•è§£ææ—¶ï¼Œæœ€å¥½æŒ‰è¦æ±‚è¿”å› YESï¼Œä½†ç›®å‰çœ‹è¿”å›å€¼å¹¶ä¸å½±å“ç»“æœï¼ˆè¯¦è§ä¸‹æºç ï¼‰
    return [super resolveInstanceMethod:sel];
}

+ (BOOL)resolveClassMethod:(SEL)sel {
    if (sel == @selector(classFoo)) {
        // é€šè¿‡ Runtime API è·å¾—å…ƒç±»å¯¹è±¡ä¸­çš„ç±»æ–¹æ³•
        Method method = class_getClassMethod(object_getClass(self), @selector(classBar));
        // åŠ¨æ€æ·»åŠ æ–¹æ³•ï¼ˆæ³¨æ„å°†kç±»æ–¹æ³•æ·»åŠ åˆ°å…ƒç±»å¯¹è±¡ä¸­ï¼‰
        class_addMethod(object_getClass(self), sel, method_getImplementation(method), method_getTypeEncoding(method));

        return YES;
    }

    return [super resolveClassMethod:sel];
}
@end

Foo *foo = [[Foo alloc] init];
[foo foo];

[Foo classFoo];

// OUTPUT:
// -[Foo bar]
// +[Foo classBar]
// 0x2802d0a50 - tryC
</code></pre>

<p>è¿™é‡Œçš„ <code>Method</code> æ˜¯ä¸€ä¸ªç±»ä¼¼ <code>Class</code> çš„ä¸é€æ˜ç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ objc4 æºç ä¸­çœ‹åˆ°å®ƒçš„ç»“æ„ï¼Œæœ¬è´¨å³ <code>method_t</code>ï¼š</p>

<pre><code class="language-objectivec">// runtime.h

/// An opaque type that represents a method in a class definition.
typedef struct objc_method *Method;

struct objc_method {
    SEL _Nonnull method_name                                 OBJC2_UNAVAILABLE;
    char * _Nullable method_types                            OBJC2_UNAVAILABLE;
    IMP _Nonnull method_imp                                  OBJC2_UNAVAILABLE;
}

// objc-private.h

#if __OBJC2__
typedef struct method_t *Method;
// ...
</code></pre>

<p>è€Œ <code>class_addMethod</code> å°†æŠŠæ–°æ–¹æ³•æ”¾ç½®åœ¨ä¸€ä¸ªä¸€ç»´æ–¹æ³•åˆ—è¡¨ä¸­ï¼Œå¹¶æœ€ç»ˆé™„åŠ åœ¨ Obj-C ç±»ä¸­ <code>class_rw_t</code> çš„äºŒç»´ <code>method_array_t methods;</code> ä¸­ï¼ˆå› æ­¤ <code>class_addMethod</code> å¯¹äºæ¯ä¸ªæ–¹æ³•åªä¼šè°ƒç”¨ä¸€æ¬¡ï¼‰ï¼š</p>

<pre><code class="language-cpp">// objc-runtime-new.mm

BOOL
class_addMethod(Class cls, SEL name, IMP imp, const char *types)
{
    if (!cls) return NO;

    mutex_locker_t lock(runtimeLock);
    // â¬‡ï¸
    return ! addMethod(cls, name, imp, types ?: &quot;&quot;, NO);
}

/**********************************************************************
* addMethod
* fixme
* Locking: runtimeLock must be held by the caller
**********************************************************************/
static IMP
addMethod(Class cls, SEL name, IMP imp, const char *types, bool replace)
{
    IMP result = nil;

    runtimeLock.assertLocked();

    checkIsKnownClass(cls);

    assert(types);
    assert(cls-&gt;isRealized());

    method_t *m;
    if ((m = getMethodNoSuper_nolock(cls, name))) {
        // already exists
        if (!replace) {
            result = m-&gt;imp;
        } else {
            result = _method_setImplementation(cls, m, imp);
        }
    } else {
        // fixme optimize
        // åˆå§‹åŒ–æ–°çš„ method_list_t
        method_list_t *newlist;
        newlist = (method_list_t *)calloc(sizeof(*newlist), 1);
        newlist-&gt;entsizeAndFlags =
            (uint32_t)sizeof(method_t) | fixed_up_method_list;
        newlist-&gt;count = 1;
        // å°†æ–¹æ³•æ”¾ç½®åœ¨æ–°çš„æ–¹æ³•åˆ—è¡¨ä¸­
        newlist-&gt;first.name = name;
        newlist-&gt;first.types = strdupIfMutable(types);
        newlist-&gt;first.imp = imp;

        // æ–¹æ³•åˆ—è¡¨çš„å‡†å¤‡å·¥ä½œ
        prepareMethodLists(cls, &amp;newlist, 1, NO, NO);
        // â¬‡ï¸ é™„åŠ æ–¹æ³•åˆ—è¡¨
        cls-&gt;data()-&gt;methods.attachLists(&amp;newlist, 1);
        flushCaches(cls);

        result = nil;
    }

    return result;
}

static void
prepareMethodLists(Class cls, method_list_t **addedLists, int addedCount,
                   bool baseMethods, bool methodsFromBundle)
{
    runtimeLock.assertLocked();

    if (addedCount == 0) return;

    // Don't scan redundantly
    bool scanForCustomRR = !cls-&gt;hasCustomRR();
    bool scanForCustomAWZ = !cls-&gt;hasCustomAWZ();

    // There exist RR/AWZ special cases for some class's base methods.
    // But this code should never need to scan base methods for RR/AWZ:
    // default RR/AWZ cannot be set before setInitialized().
    // Therefore we need not handle any special cases here.
    if (baseMethods) {
        assert(!scanForCustomRR  &amp;&amp;  !scanForCustomAWZ);
    }

    // Add method lists to array.
    // Reallocate un-fixed method lists.
    // The new methods are PREPENDED to the method list array.

    for (int i = 0; i &lt; addedCount; i++) {
        method_list_t *mlist = addedLists[i];
        assert(mlist);

        // Fixup selectors if necessary
        if (!mlist-&gt;isFixedUp()) {
            fixupMethodList(mlist, methodsFromBundle, true/*sort*/);
        }

        // Scan for method implementations tracked by the class's flags
        if (scanForCustomRR  &amp;&amp;  methodListImplementsRR(mlist)) {
            cls-&gt;setHasCustomRR();
            scanForCustomRR = false;
        }
        if (scanForCustomAWZ  &amp;&amp;  methodListImplementsAWZ(mlist)) {
            cls-&gt;setHasCustomAWZ();
            scanForCustomAWZ = false;
        }
    }
}

// objc-runtime-new.h

template &lt;typename Element, typename List&gt;
class list_array_tt {
    // ...

    void attachLists(List* const * addedLists, uint32_t addedCount) {
        if (addedCount == 0) return;

        if (hasArray()) {
            // many lists -&gt; many lists
            // å·²æˆäºŒç»´ï¼Œåˆ™å…ˆåˆ†é…ç©ºé—´ï¼ŒæŒªåŠ¨åŸè¡¨ï¼Œæ”¾ç½®æ–°è¡¨
            //ï¼ˆå…³äº memmove &amp; momcpy å¯å‚è€ƒæ–‡æœ« Reference ä¸­ã€ŒiOS ä¸­çš„ Categoryã€ä¸€æ–‡ï¼‰
            uint32_t oldCount = array()-&gt;count;
            uint32_t newCount = oldCount + addedCount;
            setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));
            array()-&gt;count = newCount;
            memmove(array()-&gt;lists + addedCount, array()-&gt;lists,
                    oldCount * sizeof(array()-&gt;lists[0]));
            memcpy(array()-&gt;lists, addedLists,
                   addedCount * sizeof(array()-&gt;lists[0]));
        }
        else if (!list  &amp;&amp;  addedCount == 1) {
            // 0 lists -&gt; 1 list
            // ç©ºè¡¨åˆ™ç›´æ¥é™„åŠ 
            list = addedLists[0];
        }
        else {
            // 1 list -&gt; many lists
            // ä¸€ç»´å•è¡¨é™„åŠ è‡³äºŒç»´
            List* oldList = list;
            uint32_t oldCount = oldList ? 1 : 0;
            uint32_t newCount = oldCount + addedCount;
            setArray((array_t *)malloc(array_t::byteSize(newCount)));
            array()-&gt;count = newCount;
            if (oldList) array()-&gt;lists[addedCount] = oldList;
            memcpy(array()-&gt;lists, addedLists,
                   addedCount * sizeof(array()-&gt;lists[0]));
        }
    }

    // ...
};
</code></pre>

<h4 id="how">How</h4>

<p>æ­£å¦‚ä¸Šæ‰€è¿°ï¼Œåœ¨ä¸Šé¢æœªå‘½ä¸­ç¼“å­˜ä¸”æœ¬ç±»åŠæ‰€æœ‰çˆ¶ç±»ä¸­éƒ½æ— æ³•æ‰¾åˆ°è¦è°ƒç”¨çš„æ–¹æ³•æ—¶ï¼Œå°†è¿›å…¥ <code>lookUpImpOrForward</code> ä¸­çš„ Method Resovle å³ã€ŒåŠ¨æ€æ–¹æ³•è§£æã€ï¼š</p>

<pre><code class="language-cpp">// objc-runtime-new.mm

IMP lookUpImpOrForward(Class cls, SEL sel, id inst,
                       bool initialize, bool cache, bool resolver)
    // ...

    // No implementation found. Try method resolver once.
    // IMP æ‰¾ä¸åˆ°ï¼Œåˆ™è¿›å…¥æ–¹æ³•åŠ¨æ€è§£æä¸€æ¬¡ã€‚
    if (resolver  &amp;&amp;  !triedResolver) {
        runtimeLock.unlock();
        // â¬‡ï¸ å°è¯•æ–¹æ³•è§£æ
        _class_resolveMethod(cls, sel, inst);
        runtimeLock.lock();
        // Don't cache the result; we don't hold the lock so it may have
        // changed already. Re-do the search from scratch instead.
        // æ ‡è®°ä¸º YES
        triedResolver = YES;
        // æ·»åŠ åˆ°æ–¹æ³•åˆ—è¡¨åï¼Œè¿›è€Œè¿›å…¥å†æ¬¡å°è¯•ä»æ–¹æ³•åˆ—è¡¨ä¸­è·å–å¹¶å­˜å…¥ç¼“å­˜
        goto retry;
    }

    // ...
}

/***********************************************************************
* _class_resolveMethod
* Call +resolveClassMethod or +resolveInstanceMethod.
* Returns nothing; any result would be potentially out-of-date already.
* Does not check if the method already exists.
**********************************************************************/
void _class_resolveMethod(Class cls, SEL sel, id inst)
{
    if (! cls-&gt;isMetaClass()) {
        // éå…ƒç±»å¯¹è±¡ï¼Œåˆ™è§£æç±»å¯¹è±¡
        // try [cls resolveInstanceMethod:sel]
        _class_resolveInstanceMethod(cls, sel, inst);
    }
    else {
        // è§£æå…ƒç±»å¯¹è±¡
        // try [nonMetaClass resolveClassMethod:sel]
        // and [cls resolveInstanceMethod:sel]
        _class_resolveClassMethod(cls, sel, inst);
        if (!lookUpImpOrNil(cls, sel, inst,
                            NO/*initialize*/, YES/*cache*/, NO/*resolver*/))
        {
            _class_resolveInstanceMethod(cls, sel, inst);
        }
    }
}

/***********************************************************************
* _class_resolveInstanceMethod
* Call +resolveInstanceMethod, looking for a method to be added to class cls.
* è°ƒç”¨ +resolveInstanceMethodï¼Œå¹¶æŸ¥æ‰¾è¦æ·»åŠ åˆ° cls ç±»çš„æ–¹æ³•ã€‚
* cls may be a metaclass or a non-meta class.
* cls å¯èƒ½æ˜¯å…ƒç±»æˆ–éå…ƒç±»ã€‚
* Does not check if the method already exists.
* å¦‚æœæ–¹æ³•å·²ç»å­˜åœ¨åˆ™ä¸æ£€æŸ¥ã€‚
**********************************************************************/
static void _class_resolveInstanceMethod(Class cls, SEL sel, id inst)
{
    // å¦‚æœæœªå®ç° resolveInstanceMethod åˆ™è¿”å›
    if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls,
                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/))
    {
        // Resolver not implemented.
        return;
    }

    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;
    // ä½¿ç”¨ objc_msgSend æ‰§è¡Œ resolveInstanceMethodï¼Œå°†è¿”å›å€¼ä¿å­˜ä¸º resolved
    bool resolved = msg(cls, SEL_resolveInstanceMethod, sel);

    // æ ¹æ® resolved åšä¸€äº›æ—¥å¿—ç­‰å¤„ç†
    // Cache the result (good or bad) so the resolver doesn't fire next time.
    // +resolveInstanceMethod adds to self a.k.a. cls
    IMP imp = lookUpImpOrNil(cls, sel, inst,
                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);

    if (resolved  &amp;&amp;  PrintResolving) {
        if (imp) {
            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;
                         &quot;dynamically resolved to %p&quot;,
                         cls-&gt;isMetaClass() ? '+' : '-',
                         cls-&gt;nameForLogging(), sel_getName(sel), imp);
        }
        else {
            // Method resolver didn't add anything?
            _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;
                         &quot;, but no new implementation of %c[%s %s] was found&quot;,
                         cls-&gt;nameForLogging(), sel_getName(sel),
                         cls-&gt;isMetaClass() ? '+' : '-',
                         cls-&gt;nameForLogging(), sel_getName(sel));
        }
    }
}

/***********************************************************************
* _class_resolveClassMethod
* Call +resolveClassMethod, looking for a method to be added to class cls.
* è°ƒç”¨ +resolveClassMethodï¼Œå¹¶æŸ¥æ‰¾è¦æ·»åŠ åˆ° cls ç±»çš„æ–¹æ³•ã€‚
* cls should be a metaclass.
* cls åº”å½“æ˜¯å…ƒç±»ã€‚
* Does not check if the method already exists.
* å¦‚æœæ–¹æ³•å·²ç»å­˜åœ¨åˆ™ä¸æ£€æŸ¥ã€‚
**********************************************************************/
static void _class_resolveClassMethod(Class cls, SEL sel, id inst)
{
    assert(cls-&gt;isMetaClass());

    if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst,
                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/))
    {
        // Resolver not implemented.
        return;
    }

    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;
    bool resolved = msg(_class_getNonMetaClass(cls, inst),
                        SEL_resolveClassMethod, sel);

    // Cache the result (good or bad) so the resolver doesn't fire next time.
    // +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls
    IMP imp = lookUpImpOrNil(cls, sel, inst,
                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);

    if (resolved  &amp;&amp;  PrintResolving) {
        if (imp) {
            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;
                         &quot;dynamically resolved to %p&quot;,
                         cls-&gt;isMetaClass() ? '+' : '-',
                         cls-&gt;nameForLogging(), sel_getName(sel), imp);
        }
        else {
            // Method resolver didn't add anything?
            _objc_inform(&quot;RESOLVE: +[%s resolveClassMethod:%s] returned YES&quot;
                         &quot;, but no new implementation of %c[%s %s] was found&quot;,
                         cls-&gt;nameForLogging(), sel_getName(sel),
                         cls-&gt;isMetaClass() ? '+' : '-',
                         cls-&gt;nameForLogging(), sel_getName(sel));
        }
    }
}

/***********************************************************************
* lookUpImpOrNil.
* Like lookUpImpOrForward, but returns nil instead of _objc_msgForward_impcache
* ç±»ä¼¼ lookUpImpOrForwardï¼Œä½†è¿”å› nil è€Œé _objc_msgForward_impcache
**********************************************************************/
IMP lookUpImpOrNil(Class cls, SEL sel, id inst,
                   bool initialize, bool cache, bool resolver)
{
    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);
    // è‹¥æ‰¾ä¸åˆ°è¯¥æ–¹æ³•ï¼ˆè¿”å›äº†æ¶ˆæ¯è½¬å‘ï¼‰ï¼Œåˆ™è¿”å› nil
    if (imp == _objc_msgForward_impcache) return nil;
    else return imp;
}
</code></pre>

<h3 id="æ¶ˆæ¯è½¬å‘">æ¶ˆæ¯è½¬å‘</h3>

<h4 id="what-1">What</h4>

<p>å½“åŠ¨æ€æ–¹æ³•è§£æä¹Ÿæ— èƒ½ä¸ºåŠ›æ—¶ï¼Œå°†æœ€ç»ˆå°è¯•æ¶ˆæ¯è½¬å‘ã€‚å³ <code>- (id)forwardingTargetForSelector:(SEL)aSelector</code> å®ä¾‹æ–¹æ³•æˆ– <code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code> ç±»æ–¹æ³•ï¼Œå¦‚æœæˆ‘ä»¬å°†éœ€è¦è½¬å‘åˆ°çš„ç›®æ ‡è¿”å›ï¼Œé‚£ä¹ˆç›®æ ‡å°±å¯ä»¥æ‰§è¡Œåˆ°è½¬å‘çš„ç›¸åŒæ–¹æ³•ï¼š</p>

<pre><code class="language-objectivec">@interface FooBackup : NSObject
@end

@implementation FooBackup
- (void)foo {
    NSLog(@&quot;%s&quot;, __func__);
}

+ (void)foo {
    NSLog(@&quot;%s&quot;, __func__);
}

+ (void)classFoo {
    NSLog(@&quot;%s&quot;, __func__);
}

- (void)classFoo {
    NSLog(@&quot;%s&quot;, __func__);
}
@end

@interface Foo : NSObject
- (void)foo;
+ (void)classFoo;
@end

@implementation Foo
- (id)forwardingTargetForSelector:(SEL)aSelector {
    if (aSelector == @selector(foo)) {
        // å®ä¾‹æ–¹æ³•ä¹Ÿå¯ä»¥è½¬å‘ç»™ç±»å¯¹è±¡
        // return [FooBackup class];
        return [[FooBackup alloc] init];
    }

    return [super forwardingTargetForSelector:aSelector];
}

+ (id)forwardingTargetForSelector:(SEL)aSelector {
    if (aSelector == @selector(classFoo)) {
        // return [[FooBackup alloc] init];
        return [FooBackup class];
    }

    return [super forwardingTargetForSelector:aSelector];
}
@end

Foo *foo = [[Foo alloc] init];
[foo foo];

[Foo classFoo];

// OUTPUT:
// -[FooBackup foo]
// +[FooBackup classFoo]
</code></pre>

<p>æ­£å¦‚ã€ŠEffective Objective-C 2.0ã€‹ä¸€ä¹¦ä¸­æ‰€æåˆ°çš„ï¼Œé€šè¿‡è¿™ç§æ–¹å¼æˆ‘ä»¬å¯ä»¥æ¨¡æ‹Ÿå‡ºå¤šé‡ç»§æ‰¿ï¼ˆMultiple Inheritanceï¼‰ï¼Œå³åœ¨ä¸€ä¸ªå¯¹è±¡å†…éƒ¨ä½¿ç”¨ä¸€ç³»åˆ—å…¶å®ƒå¯¹è±¡æ¥å¤„ç†ç›¸åº”çš„æ¶ˆæ¯ã€‚å¦å¤–éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨è¿™ä¸€æ­¥éª¤æˆ‘ä»¬æ— æ³•å¯¹æ¶ˆæ¯æœ¬èº«è¿›è¡Œæ›´æ”¹ï¼Œæˆ‘ä»¬åªèƒ½è¿”å›å¤„ç†æ¶ˆæ¯çš„å¯¹è±¡ã€‚</p>

<p>å¦‚æœ <code>forwardingTargetForSelector:</code> ä¹Ÿæ²¡æœ‰è½¬å‘åˆ°ç›®æ ‡ï¼Œæ¶ˆæ¯å°†å°è¯•ä» <code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>/<code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code> è·å–æ–¹æ³•ç­¾åï¼Œæ–¹æ³•ç­¾åå¯ä»¥æ ¹æ®æ–¹æ³•çš„ç±»å‹ç¼–ç è·å¾—ï¼›æ¥ä¸‹æ¥å°†å¯ä»¥é€šè¿‡ <code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>/<code>+ (void)forwardInvocation:(NSInvocation *)anInvocation</code> æ‰§è¡Œï¼ŒåŸæ¥çš„æ¶ˆæ¯å°†è¢«å°è£…åœ¨ <code>NSInvocation</code> ä¸­ï¼š</p>

<pre><code class="language-objectivec">@interface FooBackup : NSObject
@end

@implementation FooBackup
- (void)foo {
    NSLog(@&quot;%s&quot;, __func__);
}

+ (void)classFoo {
    NSLog(@&quot;%s&quot;, __func__);
}
@end

@interface Foo : NSObject
- (void)foo;
+ (void)classFoo;
@end

@implementation Foo
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
    if (aSelector == @selector(foo)) {
        // return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];
        return [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];
    }

    return [super methodSignatureForSelector:aSelector];
}

- (void)forwardInvocation:(NSInvocation *)anInvocation {
    if (anInvocation.selector == @selector(foo)) {
        [anInvocation invokeWithTarget:[[FooBackup alloc] init]];
    }
}

+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
    if (aSelector == @selector(classFoo)) {
        // return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];
        return [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];
    }

    return [super methodSignatureForSelector:aSelector];
}

+ (void)forwardInvocation:(NSInvocation *)anInvocation {
    if (anInvocation.selector == @selector(classFoo)) {
        [anInvocation invokeWithTarget:[FooBackup class]];
    }
}
@end
</code></pre>

<h4 id="how-1">How</h4>

<p>æ­£å¦‚ä¸Šæ‰€è¿°ï¼Œå½“åŠ¨æ€æ–¹æ³•è§£æä¹Ÿæ— æ³•å¥æ•ˆæˆ–è€…æˆ‘ä»¬åœ¨åŠ¨æ€æ–¹æ³•è§£æä¸­å¹¶æ²¡æœ‰æ·»åŠ äº†æ­£ç¡®çš„æ–¹æ³•æ—¶ï¼Œå°†è¿›å…¥ <code>lookUpImpOrForward</code> ä¸­çš„ Method Forward å³ã€Œæ¶ˆæ¯è½¬å‘ã€ï¼š</p>

<pre><code class="language-cpp">IMP lookUpImpOrForward(Class cls, SEL sel, id inst,
                       bool initialize, bool cache, bool resolver)
    // ...

    // No implementation found, and method resolver didn't help.
    // Use forwarding.
    // å®ç°æ— æ³•æ‰¾åˆ°ï¼Œæ–¹æ³•è§£ææ— æ•ˆï¼Œå°è¯•æ–¹æ³•è½¬å‘ã€‚

    imp = (IMP)_objc_msgForward_impcache;
    cache_fill(cls, sel, imp, inst);

    // ...
}
</code></pre>

<p><code>_objc_msgForward_impcache</code> åˆ™åˆæ˜¯åœ¨æ±‡ç¼–ä¸­ï¼š</p>

<pre><code class="language-asm">// objc-msg-arm.s
/********************************************************************
*
* id _objc_msgForward(id self, SEL _cmd,...);
*
* _objc_msgForward is the externally-callable
*   function returned by things like method_getImplementation().
* _objc_msgForward_impcache is the function pointer actually stored in
*   method caches.
*
********************************************************************/

	STATIC_ENTRY __objc_msgForward_impcache

	// No stret specialization.
	b	__objc_msgForward

	END_ENTRY __objc_msgForward_impcache


	ENTRY __objc_msgForward

	adrp	x17, __objc_forward_handler@PAGE
	ldr	p17, [x17, __objc_forward_handler@PAGEOFF]
	TailCallFunctionPointer x17

	END_ENTRY __objc_msgForward
</code></pre>

<p>æœ€ç»ˆä¼šå‘ç° objc4 ä¸­å¹¶æ²¡æœ‰å¼€æºçš„ <code>objc_msgForward</code> å®ç°ï¼š</p>

<pre><code class="language-cpp">// objc-runtime.mm

// Default forward handler halts the process.
__attribute__((noreturn)) void
objc_defaultForwardHandler(id self, SEL sel)
{
    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;
                &quot;(no message forward handler is installed)&quot;,
                class_isMetaClass(object_getClass(self)) ? '+' : '-',
                object_getClassName(self), sel_getName(sel), self);
}
void *_objc_forward_handler = (void*)objc_defaultForwardHandler;
</code></pre>

<hr />

<p>ç»¼ä¸Šï¼Œä¸€ä¸ª Obj-C æ–¹æ³•è°ƒç”¨çš„è¿‡ç¨‹å¯ä»¥æè¿°ä¸ºï¼š</p>

<ol>
<li><code>objc_msgSend</code> åˆ¤æ–­æ¶ˆæ¯æ¥æ”¶è€…æ˜¯å¦ä¸º <code>nil</code></li>
<li>å½“é <code>nil</code> æ—¶ï¼Œå°†æ ¹æ® <code>isa</code> æŒ‡é’ˆæ‰¾åˆ°ç¼“å­˜æ‰€åœ¨çš„ç±»æˆ–å…ƒç±»å¯¹è±¡çš„ç¼“å­˜ä¸­å¯»æ‰¾ï¼›</li>
<li>å½“æ— æ³•åœ¨ç¼“å­˜ä¸­æ‰¾åˆ°æ—¶ï¼Œå°†ä»æœ¬ç±»å¼€å§‹åˆ°çˆ¶ç±»ï¼ˆåˆ°çˆ¶ç±»çš„çˆ¶ï¼‰åœ¨å…¶æ–¹æ³•åˆ—è¡¨ä¸­æŸ¥æ‰¾ï¼Œå¦‚æœæ‰¾åˆ°ä¼šåŒæ—¶ç¼“å­˜åˆ°åŸæœ‰ç±»ä¸­ä¸€ä»½ï¼›</li>
<li>å¦‚æœæ–¹æ³•åˆ—è¡¨ä¹Ÿæ— æ³•æ‰¾åˆ°å°†å°è¯•åŠ¨æ€æ–¹æ³•è§£æï¼Œå³è¿›å…¥ <code>resolveInstanceMethod</code>/<code>resolveClassMethod</code>ï¼Œå¦‚æœå…¶ä¸­å°†æ–¹æ³•æ­£ç¡®åœ°åŠ¨æ€æ·»åŠ äº†ï¼Œåˆ™ä»æ–¹æ³•åˆ—è¡¨ä¸­è°ƒç”¨å¹¶ç¼“å­˜ï¼›</li>
<li>å¦‚æœä»æ— ï¼Œå°†å°è¯• <code>forwardingTargetForSelector</code>ï¼Œå…¶è¿”å›å°†ä½œä¸ºè¢«è½¬å‘åˆ°çš„ç›®æ ‡å°è¯•æ‰§è¡Œç›¸åº”æ–¹æ³•ï¼›</li>
<li>å¦‚æœè½¬å‘ç›®æ ‡ä¸º <code>nil</code>ï¼Œå°†æœ€ç»ˆå°è¯• <code>methodSignatureForSelector:</code> è¿”å›æ–¹æ³•ç­¾åå¹¶åœ¨ <code>forwardInvocation:</code> å†³å®šæ ¹æ®æ¶ˆæ¯çš„ä¿¡æ¯é€‰æ‹©å¦‚ä½•æ‰§è¡Œï¼›</li>
<li>å¦‚æœåœ¨ <code>methodSignatureForSelector:</code> è¿”å›äº†ç©ºæ–¹æ³•ç­¾åï¼Œå°†æœ€ç»ˆå¯¼è‡´ã€Œunrecognized selector sent to instanceã€ã€‚</li>
</ol>

<p>æ­£å¦‚ã€ŠEffective Objective-C 2.0ã€‹ä¸€ä¹¦ä¸­æåˆ°çš„ <code>CALayer</code> ä½¿ç”¨äº†æ¶ˆæ¯è½¬å‘æ¥å®ç°å…¼å®¹ KVC çš„å®¹å™¨ç±»ï¼š</p>

<pre><code class="language-objectivec">@interface MyLayer : CALayer
@property (nonatomic, copy) NSString *foo;
@end

@implementation MyLayer
@dynamic foo; // ä¸è‡ªåŠ¨ç”Ÿæˆ getter &amp; setter
@end

MyLayer *layer = [[MyLayer alloc] init];
[layer setFoo:@&quot;kingcos.me&quot;];
NSLog(@&quot;%@&quot;, [layer foo]);
NSLog(@&quot;%@&quot;, [layer valueForKey:@&quot;foo&quot;]);

// OUTPUT:
// kingcos.me
// kingcos.me
</code></pre>

<!--

- Obj-C å¯¹è±¡æ–¹æ³•æŸ¥æ‰¾é¡ºåºï¼šæœ¬ç±»çš„ç±»å¯¹è±¡æ–¹æ³•åˆ—è¡¨ä¸­æŸ¥æ‰¾åŒåæ–¹æ³•ï¼ˆåˆ†ç±» Category ä¸­çš„æ–¹æ³•ä¼šåˆå¹¶åˆ°ç±»çš„æ–¹æ³•åˆ—è¡¨ä¸­ï¼Œæ ¹æ®åç¼–è¯‘æ›´é å‰ï¼Œä¼šè¢«å…ˆæ‰¾åˆ°ï¼‰ -> è‹¥æ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™æ ¹æ® `superclass` æŒ‡é’ˆå‘çˆ¶ç±»çš„ç±»å¯¹è±¡æ–¹æ³•åˆ—è¡¨ä¸­æŸ¥æ‰¾ï¼Œç›´åˆ°æŸ¥æ‰¾åŸºç±» `NSObject` çš„ç±»å¯¹è±¡ä¸­ä¹Ÿæ²¡æœ‰åˆ™è¿›è¡Œæ¶ˆæ¯è½¬å‘ï¼ˆMessage Forwardingï¼‰ã€‚
- `objc_msgSend` ä¼šå°†æ–¹æ³•çš„åŒ¹é…çš„ç»“æœç¼“å­˜åœ¨ç±»å¯¹è±¡çš„ `cache_t cache;` ä¸­ï¼Œä¼˜åŒ–ä¹‹åæŸ¥æ‰¾ç›¸åŒæ–¹æ³•çš„é€Ÿåº¦ï¼Œä½†ä»æ…¢äºé™æ€ç»‘å®šï¼Œä¸è¿‡ä¹Ÿä¸è‡³äºæ˜¯ç“¶é¢ˆï¼›å¦‚æœå¯¹æŸ¥æ‰¾é€Ÿåº¦æè‡´è¿½æ±‚åˆ™å¯ä½¿ç”¨çº¯ C å‡½æ•°ã€‚
- è¾¹ç•Œæƒ…å†µï¼š

  - `objc_msgSend_stret`ï¼šå¦‚æœå¾…å‘é€çš„æ¶ˆæ¯è¦è¿”å›ç»“æ„ä½“ï¼Œé‚£ä¹ˆå¯äº¤ç”±æ­¤å‡½æ•°å¤„ç†ã€‚åªæœ‰å½“ CPU çš„å¯„å­˜å™¨èƒ½å¤Ÿå®¹çº³å¾—ä¸‹æ¶ˆæ¯è¿”å›ç±»å‹æ—¶ï¼Œè¿™ä¸ªå‡½æ•°æ‰èƒ½å¤„ç†æ­¤æ¶ˆæ¯ã€‚è‹¥æ˜¯è¿”å›å€¼æ— æ³•å®¹çº³äº CPU å¯„å­˜å™¨ä¸­ï¼ˆæ¯”å¦‚è¿”å›çš„ç»“æ„ä½“å¤ªå¤§äº†ï¼‰ï¼Œé‚£ä¹ˆå°±äº¤ç”±å¦ä¸€ä¸ªå‡½æ•°æ‰§è¡Œæ´¾å‘ã€‚æ­¤æ—¶ï¼Œé‚£ä¸ªå‡½æ•°ä¼šé€šè¿‡åˆ†é…åœ¨æ ˆä¸Šçš„æŸä¸ªå˜é‡æ¥å¤„ç†æ¶ˆæ¯æ‰€è¿”å›çš„ç»“æ„ä½“ã€‚
  - `objc_msgSend_fpret`ï¼šå¦‚æœæ¶ˆæ¯è¿”å›çš„æ˜¯æµ®ç‚¹æ•°ï¼Œé‚£ä¹ˆå¯äº¤ç”±æ­¤å‡½æ•°å¤„ç†ã€‚åœ¨æŸäº›ç»“æ„çš„ CPU ä¸­è°ƒç”¨å‡½æ•°æ—¶ï¼Œéœ€è¦å¯¹ã€Œæµ®ç‚¹æ•°å¯„å­˜å™¨ï¼ˆFloating-Point Registerï¼‰ã€åšç‰¹æ®Šå¤„ç†ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œé€šå¸¸æ‰€ç”¨çš„ `objc_msgSend` åœ¨è¿™ç§æƒ…å†µä¸‹å¹¶ä¸åˆé€‚ã€‚è¿™ä¸ªå‡½æ•°æ˜¯ä¸ºäº†å¤„ç† x86 ç­‰æ¶æ„ CPU ä¸­æŸäº›ä»¤äººç¨è§‰æƒŠè®¶çš„å¥‡æ€ªçŠ¶å†µã€‚ï¼ˆä¸ä¼šä½¿ç”¨åœ¨ ARM 64 æ¶æ„ä¸­ï¼‰
  - `objc_msgSendSuper`ï¼šå¦‚æœè¦ç»™çˆ¶ç±»å‘é€æ¶ˆæ¯ï¼Œä¾‹å¦‚ `[super message:parameter]`ï¼Œé‚£ä¹ˆå°±äº¤ç”±æ­¤å‡½æ•°å¤„ç†ã€‚ä¹Ÿæœ‰å¦å¤–ä¸¤ä¸ªä¸ `objc_msgSend_stret` å’Œ `objc_msgSend_fpret` ç­‰æ•ˆçš„å‡½æ•°ï¼Œç”¨äºå¤„ç†å‘ç»™ `super` çš„ç›¸åº”çš„æ¶ˆæ¯ã€‚

- Obj-C æ¯ä¸ªç±»ä¸­éƒ½æœ‰ä»¥ä¸ŠåŸå‹å‡½æ•°è¡¨ï¼Œ`objc_msgSend` ç­‰å‡½æ•°é€šè¿‡è¯¥è¡¨å¯»æ‰¾åº”è¯¥æ‰§è¡Œçš„æ–¹æ³•å¹¶è·³è‡³å…¶å®ç°ï¼ˆåŸå‹ä¸ `objc_msgSend` å‡½æ•°ç±»ä¼¼æ˜¯ä¸ºäº†åˆ©ç”¨å°¾è°ƒç”¨ä¼˜åŒ– Tail-Call Optimization æŠ€æœ¯ï¼Œç®€åŒ–è·³è‡³å®ç°çš„æ“ä½œï¼‰ã€‚
- å¦‚æœæŸä¸ªå‡½æ•°çš„æœ€åä¸€é¡¹æ“ä½œæ˜¯è°ƒç”¨å¦å¤–ä¸€ä¸ªå‡½æ•°ï¼Œé‚£ä¹ˆå°±å¯ä»¥è¿ç”¨ã€Œå°¾è°ƒç”¨ä¼˜åŒ–ã€æŠ€æœ¯ã€‚ç¼–è¯‘å™¨ä¼šç”Ÿæˆè°ƒè½¬è‡³å¦ä¸€å‡½æ•°æ‰€éœ€çš„æŒ‡ä»¤ç ï¼Œè€Œä¸”ä¸ä¼šå‘è°ƒç”¨å †æ ˆä¸­æ¨å…¥æ–°çš„ã€Œæ ˆå¸§ Frame Stackã€ã€‚åªæœ‰å½“æŸå‡½æ•°çš„æœ€åä¸€ä¸ªæ“ä½œä»…ä»…æ˜¯è°ƒç”¨å…¶ä»–å‡½æ•°è€Œä¸ä¼šå°†å…¶è¿”å›å€¼å¦ä½œä»–ç”¨æ—¶ï¼Œæ‰èƒ½æ‰§è¡Œã€Œå°¾è°ƒç”¨ä¼˜åŒ–ã€ã€‚å¦‚æœä¸è¿™æ ·çš„è¯ï¼Œæ¯æ¬¡è°ƒç”¨ Obj-C æ–¹æ³•ä¹‹å‰éƒ½éœ€è¦éœ€è¦ä¸º `objc_msgSend` å‡†å¤‡æ ˆå¸§ï¼ˆå¯ä»¥åœ¨æ ˆè¿½è¸ª Stack Traceï¼‰ä¸­çœ‹åˆ°è¿™ç§æ ˆå¸§ï¼‰ã€‚æ­¤å¤–ï¼Œè‹¥æ˜¯ä¸ä¼˜åŒ–ï¼Œè¿˜ä¼šè¿‡æ—©åœ°å‘ç”Ÿã€Œæ ˆæº¢å‡ºï¼ˆStack Overflowï¼‰ã€ç°è±¡ã€‚ -->

<h2 id="reference">Reference</h2>

<ul>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html">Dissecting objc_msgSend on ARM64 - Mike Ash</a></li>
<li><a href="http://infocenter.arm.com/help/index.jsp">ARM Software development tools - arm.com</a></li>
<li><a href="https://stackoverflow.com/questions/27353096/1b-and-1f-in-gnu-assembly">1b and 1f in GNU assembly - StackOverflow</a></li>
<li><a href="https://clang.llvm.org/doxygen/Basic_2Targets_2ARM_8cpp_source.html">ARM.cpp - clang</a></li>
<li><a href="https://www.ibm.com/support/knowledgecenter/zh/SSXVZZ_13.1.0/com.ibm.xlcpp131.linux.doc/getstart/predef_macro_v10v12.html">é¢„å®šä¹‰å® - IBM</a></li>
<li><a href="../objects_in_obj-c/">Obj-C ä¸­çš„å¯¹è±¡ - kingcos</a></li>
<li><a href="../category_in_ios/">iOS ä¸­çš„ Category - kingcos</a></li>
<li><a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/">Objective-C æ¶ˆæ¯å‘é€ä¸è½¬å‘æœºåˆ¶åŸç† - æ¨è§ç‰</a></li>
</ul>

<h2 id="todo">TODO</h2>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> å°¾é€’å½’è°ƒç”¨</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> å°è¯•é€†å‘å¾—åˆ°æ¶ˆæ¯è½¬å‘éƒ¨åˆ†çš„æ­¥éª¤</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> æ¶ˆæ¯å‘é€æµç¨‹å›¾</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> å°è¯•ä½¿ç”¨ Swift å®ç°æ•´ä¸ªè¿‡ç¨‹</label></li>
</ul>

    </div>
    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>
        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="/posts/2019/effective_obj-c_2.0_notes/">
                <span class="button__icon">â†</span>
                <span class="button__text">ã€Šç¼–å†™é«˜è´¨é‡ iOS ä¸ OS X ä»£ç çš„ 52 ä¸ªæœ‰æ•ˆæ–¹æ³•ã€‹é˜…è¯»ç¬”è®°</span>
              </a>
            </span>
          
          
            <span class="button next">
              <a href="/posts/2019/coding_with_vs_code/">
                <span class="button__text">ä¸ Visual Studio Code å…±èˆ</span>
                <span class="button__icon">â†’</span>
              </a>
            </span>
          
        </div>
      </div>
    

    

    
    
    <div>
      <div id="github-comment">
      </div>

      <script type="text/javascript">
        function getUtterances(isDark) {
          var utterances = document.createElement('script');
          utterances.type = 'text/javascript';
          utterances.async = true;
          utterances.setAttribute('issue-term', "pathname")
          utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
          utterances.setAttribute('label', "comments")
          isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
          utterances.crossorigin = 'anonymous';
          utterances.src = 'https://utteranc.es/client.js';

          return utterances
        }

        var themeToggle = document.querySelector(".theme-toggle")
        themeToggle.addEventListener("click", function () {
          var getTheme = window.localStorage && window.localStorage.getItem("theme")
          var divNode = document.getElementById('github-comment')
          while(divNode.hasChildNodes()) {
            divNode.removeChild(divNode.firstChild);
          }
          
          
          

          
          
          
          
          
          
          document.getElementById('github-comment').appendChild(getUtterances(getTheme !== "dark"))
        })

        var getTheme = window.localStorage && window.localStorage.getItem("theme")
        document.getElementById('github-comment').appendChild(getUtterances(getTheme === "dark"))
      </script>
    </div>
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">All rights reserved by kingcos.me</div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </body>
</html>
