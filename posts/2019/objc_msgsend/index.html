<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>浅尝 objc_msgSend :: iBlog</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Refers.     2019-07-20 首次提交 objc4-750.1   2019-09-07 完成「缓存、动态方法解析」等部分 Obj-C 中的对象 - kingcos   2019-10-21 补充《Effective Objective-C 2.0》相关内容 《〈编写高质量 iOS 与 OS X 代码的 52 个有效方法〉阅读笔记 - kingcos》    Preface Obj-C 中方法调用的本质是消息发送机制，即 [foo bar] 是向 foo 对象发送一条 bar 的消息，而消息发送就是通过 objc_msgSend 所进行的。那么这次本文就简单窥探一下 objc_msgSend 吧。
Why 在开始之前，先思考以下为什么 Obj-C 中方法调用的本质是 objc_msgSend 呢？
我们创建一个使用 Obj-C 的 iOS 项目，如下在 ViewController 中添加一个按钮，并在按钮的点击事件中创建一个 Obj-C 对象，再调用其方法：
#import &amp;#34;ViewController."/>
<meta name="keywords" content="kingcos.me,maimieng.comios,swift,objective-c,obj-c,objc,oc,geek,python,ruby,golang,go,apple,mac"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/objc_msgsend/" />





<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="浅尝 objc_msgSend"/>
<meta name="twitter:description" content="Obj-C 中方法调用的本质是消息发送机制，即 `[foo bar]` 是向 `foo` 对象发送一条 `bar` 的消息，而消息发送就是通过 `objc_msgSend` 所进行的。那么这次本文就简单窥探一下 `objc_msgSend` 吧。"/>



<meta property="og:title" content="浅尝 objc_msgSend" />
<meta property="og:description" content="Obj-C 中方法调用的本质是消息发送机制，即 `[foo bar]` 是向 `foo` 对象发送一条 `bar` 的消息，而消息发送就是通过 `objc_msgSend` 所进行的。那么这次本文就简单窥探一下 `objc_msgSend` 吧。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2019/objc_msgsend/" />
<meta property="article:published_time" content="2019-10-21T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-10-21T00:00:00+00:00" /><meta property="og:site_name" content="iBlog" />




<script data-ad-client="ca-pub-9925978992661955" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  </head>
  <body class="">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">kingcos.me</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="post">
    <h2 class="post-title"><a href="/posts/2019/objc_msgsend/">浅尝 objc_msgSend</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            2019-10-21
        </span>
      
      
      
        <span class="post-read-time">— 20 min read</span>
      
    </div>

    
      <span class="post-tags">
        
          #<a href="/tags/focus/">Focus</a>&nbsp;
        
          #<a href="/tags/ios/">iOS</a>&nbsp;
        
          #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
        
          #<a href="/tags//">🚧</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      <table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Refers.</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">2019-07-20</td>
<td align="center">首次提交</td>
<td align="center"><a href="https://opensource.apple.com/tarballs/objc4/">objc4-750.1</a></td>
</tr>
<tr>
<td align="center">2019-09-07</td>
<td align="center">完成「缓存、动态方法解析」等部分</td>
<td align="center"><a href="../objects_in_obj-c/">Obj-C 中的对象 - kingcos</a></td>
</tr>
<tr>
<td align="center">2019-10-21</td>
<td align="center">补充《Effective Objective-C 2.0》相关内容</td>
<td align="center">《<a href="../effective_obj-c_2.0_notes/">〈编写高质量 iOS 与 OS X 代码的 52 个有效方法〉阅读笔记 - kingcos</a>》</td>
</tr>
</tbody>
</table>
<p><img src="/img/2019/objc_msgsend/0.png" alt="0"></p>
<h2 id="preface">Preface</h2>
<p>Obj-C 中方法调用的本质是消息发送机制，即 <code>[foo bar]</code> 是向 <code>foo</code> 对象发送一条 <code>bar</code> 的消息，而消息发送就是通过 <code>objc_msgSend</code> 所进行的。那么这次本文就简单窥探一下 <code>objc_msgSend</code> 吧。</p>
<h2 id="why">Why</h2>
<p>在开始之前，先思考以下为什么 Obj-C 中方法调用的本质是 <code>objc_msgSend</code> 呢？</p>
<p>我们创建一个使用 Obj-C 的 iOS 项目，如下在 <code>ViewController</code> 中添加一个按钮，并在按钮的点击事件中创建一个 Obj-C 对象，再调用其方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">#import &#34;ViewController.h&#34;
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo</span> : <span style="color:#a6e22e">NSObject</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">bar</span>;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">bar</span> {}
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">ViewController</span> ()
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">ViewController</span>

- (<span style="color:#66d9ef">IBAction</span>)<span style="color:#a6e22e">clickOnButton:</span>(UIButton <span style="color:#f92672">*</span>)sender {
    Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [[Foo alloc] init];

    [foo bar]; <span style="color:#75715e">// 🔴 Breakpoint
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">@end</span>
</code></pre></div><p>我们将断点打在 <code>[foo bar];</code> 一行，启动程序并点击按钮。在 Xcode 的控制台多次输入 <code>si</code>（Step Into）即可最终跳转到 <code>objc_msgSend</code>：</p>
<p><img src="/img/2019/objc_msgsend/3.png" alt="3"></p>
<p>或者我们也可以使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc ViewController.m -o foo.cpp</code> 将 Obj-C 代码翻译为 C/C++：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_I_ViewController_clickOnButton_</span>(ViewController <span style="color:#f92672">*</span> self, <span style="color:#66d9ef">SEL</span> _cmd, UIButton <span style="color:#f92672">*</span>sender) {
    Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> ((Foo <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>)(<span style="color:#66d9ef">id</span>, <span style="color:#66d9ef">SEL</span>))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((<span style="color:#66d9ef">id</span>)((Foo <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>)(<span style="color:#66d9ef">id</span>, <span style="color:#66d9ef">SEL</span>))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((<span style="color:#66d9ef">id</span>)objc_getClass(<span style="color:#e6db74">&#34;Foo&#34;</span>), sel_registerName(<span style="color:#e6db74">&#34;alloc&#34;</span>)), sel_registerName(<span style="color:#e6db74">&#34;init&#34;</span>));

    <span style="color:#75715e">// objc_msgSend(foo, sel_registerName(&#34;bar&#34;))
</span><span style="color:#75715e"></span>    ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(<span style="color:#66d9ef">id</span>, <span style="color:#66d9ef">SEL</span>))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((<span style="color:#66d9ef">id</span>)foo, sel_registerName(<span style="color:#e6db74">&#34;bar&#34;</span>));
}
</code></pre></div><p>综上，我们可以说 Obj-C 中方法调用的本质即是 <code>objc_msgSend</code>。</p>
<h2 id="steps">Steps</h2>
<p><code>objc_msgSend</code> 总共分为消息发送、动态方法解析、以及消息转发三大部分，下面我们就依次来研究一下。</p>
<h3 id="消息发送">消息发送</h3>
<p><code>objc_msgSend</code> 中的第一个部分是消息发送，即对消息接收者发送一条方法消息，当接收者可以处理消息时将执行相应的方法，无法处理时则进入下一步骤。</p>
<h4 id="where--why">Where &amp; Why</h4>
<p>在 Apple 开源的 objc4 源码中，我们似乎只能在「message.h」中找到 <code>objc_msgSend</code> 的声明，其将消息接收者（即对象）作为第一个参数，将消息（即方法选择器）作为第二个参数，并将方法的参数追加在参数列表的最后：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// message.h
</span><span style="color:#75715e"></span>
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Sends a message with a simple return value to an instance of a class.
</span><span style="color:#75715e"> * 发送一个带有简易返回值的消息到一个类的实例。
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param self A pointer to the instance of the class that is to receive the message.
</span><span style="color:#75715e"> *             指向接收消息者实例的指针。
</span><span style="color:#75715e"> * @param op The selector of the method that handles the message.
</span><span style="color:#75715e"> *           处理消息的选择器。
</span><span style="color:#75715e"> * @param ...
</span><span style="color:#75715e"> *   A variable argument list containing the arguments to the method.
</span><span style="color:#75715e"> *   包含方法参数的可变参数列表。
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @return The return value of the method.
</span><span style="color:#75715e"> *         方法的返回值。
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @note When it encounters a method call, the compiler generates a call to one of the
</span><span style="color:#75715e"> *  functions \c objc_msgSend, \c objc_msgSend_stret, \c objc_msgSendSuper, or \c objc_msgSendSuper_stret.
</span><span style="color:#75715e"> *  Messages sent to an object’s superclass (using the \c super keyword) are sent using \c objc_msgSendSuper;
</span><span style="color:#75715e"> *  other messages are sent using \c objc_msgSend. Methods that have data structures as return values
</span><span style="color:#75715e"> *  are sent using \c objc_msgSendSuper_stret and \c objc_msgSend_stret.
</span><span style="color:#75715e"> * 注意：当遇到方法调用时，编译器会生成对 objc_msgSend、objc_msgSend_stret、objc_msgSendSuper、objc_msgSendSuper_stret 四个函数之一的调用。
</span><span style="color:#75715e"> * 到达对象父类（使用 super 关键字）的消息通过 objc_msgSendSuper 发送；其它消息则通过 objc_msgSend 发送。
</span><span style="color:#75715e"> * 返回值为结构体的消息通过 objc_msgSendSuper_stret 或 objc_msgSend_stret 发送。
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> */</span>
OBJC_EXPORT id _Nullable
<span style="color:#a6e22e">objc_msgSend</span>(id _Nullable self, SEL _Nonnull op, ...)
    OBJC_AVAILABLE(<span style="color:#ae81ff">10.0</span>, <span style="color:#ae81ff">2.0</span>, <span style="color:#ae81ff">9.0</span>, <span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">2.0</span>);
</code></pre></div><p><img src="/img/2019/objc_msgsend/1.png" alt="1"></p>
<p>而 <code>objc_msgSend</code> 的具体实现是由汇编语言编写的，原因有两点：</p>
<ol>
<li>对性能的极致追求，因为每一条汇编指令都对应一条机器指令，使用汇编可便于针对不同架构的 CPU 优化每一条指令的速度；</li>
<li>C 语言无法实现一个保存未知参数且支持跳转到任一函数指针处的函数，对于 C 来说没有必要的特性来表示（引自 <a href="https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html">Dissecting objc_msgSend on ARM64 - Mike Ash</a>）。</li>
</ol>
<p>由于 <code>objc_msgSend</code> 整个流程比较复杂，下面我将尝试把流程分解为多个用例，逐个分析。</p>
<h4 id="当接收者为-nil-时">当接收者为 <code>nil</code> 时</h4>
<p>当接收者为 <code>nil</code> 时，即 <code>[foo bar]</code> 中的 <code>foo</code> 为 <code>nil</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">- (<span style="color:#66d9ef">IBAction</span>)<span style="color:#a6e22e">clickOnButton:</span>(UIButton <span style="color:#f92672">*</span>)sender {
    Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [[Foo alloc] init];

    <span style="color:#75715e">// 将接收者置为 nil
</span><span style="color:#75715e"></span>    foo <span style="color:#f92672">=</span> nil;
    [foo bar];
}

<span style="color:#75715e">// LLDB:
</span><span style="color:#75715e">// 进入 objc_msgSend 后可以尝试使用 LLDB 命令读取 x0 寄存器中存储的值
</span><span style="color:#75715e">// (lldb) register read x0
</span><span style="color:#75715e">//       x0 = 0x0000000000000000
</span></code></pre></div><p>我们从 <code>ENTRY _objc_msgSend</code> 的第一条语句 <code>cmp p0, #0</code> 开始：</p>
<p><img src="/img/2019/objc_msgsend/4.png" alt="4"></p>
<p>在 Xcode 中 <code>si</code> 执行即可看到具体的汇编代码跳转，也与上图的源码分析一致：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">libobjc.A.dylib</span><span style="color:#960050;background-color:#1e0010">`</span><span style="color:#66d9ef">objc_msgSend</span>:
    <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x192bd8180</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">0</span><span style="color:#960050;background-color:#1e0010">&gt;</span>:   <span style="color:#66d9ef">cmp</span>    <span style="color:#66d9ef">x0</span>, <span style="color:#75715e">#0x0                  ; =0x0
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x192bd8184</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">4</span><span style="color:#960050;background-color:#1e0010">&gt;</span>:   <span style="color:#66d9ef">b.le</span>   <span style="color:#ae81ff">0x192bd81f8</span>               <span style="color:#75715e">; &lt;+120&gt;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">; ...
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x192bd81f8</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">120</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">b.eq</span>   <span style="color:#ae81ff">0x192bd8230</span>               <span style="color:#75715e">; &lt;+176&gt;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">; ...
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x192bd8230</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">176</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">mov</span>    <span style="color:#66d9ef">x1</span>, <span style="color:#75715e">#0x0
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x192bd8234</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">180</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">movi</span>   <span style="color:#66d9ef">d0</span>, <span style="color:#75715e">#0000000000000000
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x192bd8238</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">184</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">movi</span>   <span style="color:#66d9ef">d1</span>, <span style="color:#75715e">#0000000000000000
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x192bd823c</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">188</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">movi</span>   <span style="color:#66d9ef">d2</span>, <span style="color:#75715e">#0000000000000000
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x192bd8240</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">192</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">movi</span>   <span style="color:#66d9ef">d3</span>, <span style="color:#75715e">#0000000000000000
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x192bd8244</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">196</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">ret</span>
</code></pre></div><h4 id="方法缓存">方法缓存</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">objc_class</span> <span style="color:#f92672">:</span> objc_object {
    <span style="color:#75715e">// Class ISA;
</span><span style="color:#75715e"></span>    Class superclass;
    <span style="color:#75715e">// ⬇️ 方法缓存
</span><span style="color:#75715e"></span>    cache_t cache;             <span style="color:#75715e">// formerly cache pointer and vtable
</span><span style="color:#75715e"></span>    class_data_bits_t bits;    <span style="color:#75715e">// class_rw_t * plus custom rr/alloc flags
</span><span style="color:#75715e"></span>};
</code></pre></div><p>在 <a href="../objects_in_obj-c/">Obj-C 中的对象</a>一文中，我们简单了解了 Obj-C 中类和元类对象的结构，其中的 <code>cache_t cache;</code> 是方法缓存。那么为什么需要缓存呢？</p>
<p>Obj-C 的消息发送本质属于<strong>动态绑定（Dynamic Binding）</strong>，而非 C 语言常用的静态绑定（Static Binding）。动态绑定意味着只有在运行时才能确定真正被调用的函数；而静态绑定在编译时即可确定（不考虑内联函数的前提下），编译器会直接生成调用函数的指令，函数地址就被硬编码在指令当中。</p>
<blockquote>
<p><strong>Tips - 内联（Inline）函数</strong></p>
<p>建议编译器对函数进行内联扩展，即建议编译器将指定的函数体直接插入到每一处调用该函数的地方（注：「建议」指具体是否进行内联需要看编译器本身）。</p>
</blockquote>
<p>因此对于动态绑定的语言来说，其方法查找的速度一定是慢于静态绑定的。为了提高效率，Obj-C 会将方法查找的结果缓存在 <code>cache_t cache;</code> 中，当后续发送同样的消息时即可得到更快得执行。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// _uint32_t.h
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">uint32_t</span>;

<span style="color:#75715e">// _uintptr_t.h
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>           uintptr_t;

<span style="color:#75715e">// objc-ptrauth.h
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> MethodCacheIMP <span style="color:#f92672">=</span> IMP;

<span style="color:#75715e">// objc-runtime-new.h
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#if __LP64__
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">uint32_t</span> mask_t;  <span style="color:#75715e">// x86_64 &amp; arm64 asm are less efficient with 16-bits
</span><span style="color:#75715e"></span><span style="color:#75715e">#else
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">uint16_t</span> mask_t;
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> uintptr_t cache_key_t;

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">bucket_t</span> {
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#75715e">// IMP-first is better for arm64e ptrauth and no worse for arm64.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// SEL-first is better for armv7* and i386 and x86_64.
</span><span style="color:#75715e"></span><span style="color:#75715e">#if __arm64__
</span><span style="color:#75715e"></span>    MethodCacheIMP _imp;
    cache_key_t _key;
<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>    cache_key_t _key;
    MethodCacheIMP _imp;
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">cache_t</span> {
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">bucket_t</span> <span style="color:#f92672">*</span>_buckets;
    mask_t _mask;
    mask_t _occupied;

    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>};
</code></pre></div><p><code>cache_t</code> 结构体中存储了指向 <code>bucket_t</code> 结构体（数组）的指针、<code>_mask</code>（表示散列表容量 - 1，详见下文源码）、以及 <code>_occupied</code>（表示已缓存方法的数量）。<code>bucket_t</code> 即缓存方法的散列表，方法名将作为键，<code>IMP</code> 即方法的内存地址将作为值。</p>
<h4 id="当未命中缓存时">当未命中缓存时</h4>
<p>方法的首次调用或遇到缓存扩容后无法命中缓存，将进入 C 函数中搜索，并在找到方法后缓存在调用者本身的缓存中。因此我们仍从 <code>cmp p0, #0</code> 开始，但这次接收者并非 <code>nil</code> 所以不会跳入判空分支：</p>
<p><img src="/img/2019/objc_msgsend/5.png" alt="5"></p>
<p>到达 <code>bl __class_lookupMethodAndLoadCache3</code> 后将跳入 C 函数 <code>_class_lookupMethodAndLoadCache3</code> 中：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// objc-runtime-new.mm
</span><span style="color:#75715e"></span>
<span style="color:#75715e">/***********************************************************************
</span><span style="color:#75715e">* _class_lookupMethodAndLoadCache.
</span><span style="color:#75715e">* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().
</span><span style="color:#75715e">* 仅供调度程序所使用的方法查找。其它代码应当使用 lookUpImp()。
</span><span style="color:#75715e">* This lookup avoids optimistic cache scan because the dispatcher
</span><span style="color:#75715e">* already tried that.
</span><span style="color:#75715e">* 此查找可避免乐观缓存扫描，因为调度程序已经尝试了此操作。
</span><span style="color:#75715e">**********************************************************************/</span>
IMP <span style="color:#a6e22e">_class_lookupMethodAndLoadCache3</span>(id obj, SEL sel, Class cls)
{
    <span style="color:#75715e">// ⬇️ 查找 IMP 或转发
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> lookUpImpOrForward(cls, sel, obj,
                              YES<span style="color:#75715e">/*initialize*/</span>, NO<span style="color:#75715e">/*cache*/</span>, YES<span style="color:#75715e">/*resolver*/</span>);
}

<span style="color:#75715e">/***********************************************************************
</span><span style="color:#75715e">* lookUpImpOrForward.
</span><span style="color:#75715e">* The standard IMP lookup.
</span><span style="color:#75715e">* 标准 IMP 查找。
</span><span style="color:#75715e">* initialize==NO tries to avoid +initialize (but sometimes fails)
</span><span style="color:#75715e">* initialize==NO 尝试避免调用 +initialize（但有时会失败）
</span><span style="color:#75715e">* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)
</span><span style="color:#75715e">* cache==NO 跳过乐观解锁查找（但在其它地方使用缓存）
</span><span style="color:#75715e">* Most callers should use initialize==YES and cache==YES.
</span><span style="color:#75715e">* 大多数调用者应当使用 initialize==YES 和 cache==YES。
</span><span style="color:#75715e">* inst is an instance of cls or a subclass thereof, or nil if none is known.
</span><span style="color:#75715e">* inst 是 cls 或其子类的实例，若未知则为 nil。
</span><span style="color:#75715e">*   If cls is an un-initialized metaclass then a non-nil inst is faster.
</span><span style="color:#75715e">*   如果 cls 是未初始化的元类，那么非空 inst 将更快。
</span><span style="color:#75715e">* May return _objc_msgForward_impcache. IMPs destined for external use
</span><span style="color:#75715e">*   must be converted to _objc_msgForward or _objc_msgForward_stret.
</span><span style="color:#75715e">* 可能会返回 _objc_msgForward_impcache。被指定外部使用的 IMP 必须转换为 _objc_msgForward 或 _objc_msgForward_stret。
</span><span style="color:#75715e">*   If you don&#39;t want forwarding at all, use lookUpImpOrNil() instead.
</span><span style="color:#75715e">*   如果不你需要任何转发，使用 lookUpImpOrNil() 代替。
</span><span style="color:#75715e">**********************************************************************/</span>
IMP <span style="color:#a6e22e">lookUpImpOrForward</span>(Class cls, SEL sel, id inst,
                       <span style="color:#66d9ef">bool</span> initialize, <span style="color:#66d9ef">bool</span> cache, <span style="color:#66d9ef">bool</span> resolver)
{
    IMP imp <span style="color:#f92672">=</span> nil;
    <span style="color:#66d9ef">bool</span> triedResolver <span style="color:#f92672">=</span> NO;

    runtimeLock.assertUnlocked();

    <span style="color:#75715e">// Optimistic cache lookup
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// cache 为 NO，跳过
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (cache) {
        imp <span style="color:#f92672">=</span> cache_getImp(cls, sel);
        <span style="color:#66d9ef">if</span> (imp) <span style="color:#66d9ef">return</span> imp;
    }

    <span style="color:#75715e">// runtimeLock is held during isRealized and isInitialized checking
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// to prevent races against concurrent realization.
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// runtimeLock is held during method search to make
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// method-lookup + cache-fill atomic with respect to method addition.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Otherwise, a category could be added but ignored indefinitely because
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// the cache was re-filled with the old value after the cache flush on
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// behalf of the category.
</span><span style="color:#75715e"></span>
    runtimeLock.lock();
    checkIsKnownClass(cls);

    <span style="color:#75715e">// 若类未实化，则进行实化
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>cls<span style="color:#f92672">-&gt;</span>isRealized()) {
        realizeClass(cls);
    }

    <span style="color:#66d9ef">if</span> (initialize  <span style="color:#f92672">&amp;&amp;</span>  <span style="color:#f92672">!</span>cls<span style="color:#f92672">-&gt;</span>isInitialized()) {
        runtimeLock.unlock();
        _class_initialize (_class_getNonMetaClass(cls, inst));
        runtimeLock.lock();
        <span style="color:#75715e">// If sel == initialize, _class_initialize will send +initialize and
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// then the messenger will send +initialize again after this
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// procedure finishes. Of course, if this is not being called
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// from the messenger then it won&#39;t happen. 2778172
</span><span style="color:#75715e"></span>    }


 retry:
    runtimeLock.assertLocked();

    <span style="color:#75715e">// Try this class&#39;s cache.
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// ⬇️ 再次尝试从缓存中取 IMP（汇编）
</span><span style="color:#75715e"></span>    imp <span style="color:#f92672">=</span> cache_getImp(cls, sel);
    <span style="color:#75715e">// 取到了则结束
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (imp) <span style="color:#66d9ef">goto</span> done;

    <span style="color:#75715e">// Try this class&#39;s method lists.
</span><span style="color:#75715e"></span>    {
        <span style="color:#75715e">// ⬇️ 根据 SEL 获取本类的方法
</span><span style="color:#75715e"></span>        Method meth <span style="color:#f92672">=</span> getMethodNoSuper_nolock(cls, sel);
        <span style="color:#66d9ef">if</span> (meth) {
            <span style="color:#75715e">// ⬇️ 如果获取到方法了，则填充缓存，并返回 IMP
</span><span style="color:#75715e"></span>            log_and_fill_cache(cls, meth<span style="color:#f92672">-&gt;</span>imp, sel, inst, cls);
            imp <span style="color:#f92672">=</span> meth<span style="color:#f92672">-&gt;</span>imp;
            <span style="color:#66d9ef">goto</span> done;
        }
    }

    <span style="color:#75715e">// Try superclass caches and method lists.
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">unsigned</span> attempts <span style="color:#f92672">=</span> unreasonableClassCount();
        <span style="color:#75715e">// 如果本类找不到，则去父类（父类的父类）中查找
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (Class curClass <span style="color:#f92672">=</span> cls<span style="color:#f92672">-&gt;</span>superclass;
             curClass <span style="color:#f92672">!=</span> nil;
             curClass <span style="color:#f92672">=</span> curClass<span style="color:#f92672">-&gt;</span>superclass)
        {
            <span style="color:#75715e">// Halt if there is a cycle in the superclass chain.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">--</span>attempts <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
                _objc_fatal(<span style="color:#e6db74">&#34;Memory corruption in class list.&#34;</span>);
            }

            <span style="color:#75715e">// Superclass cache.
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 在父类缓存中找
</span><span style="color:#75715e"></span>            imp <span style="color:#f92672">=</span> cache_getImp(curClass, sel);
            <span style="color:#66d9ef">if</span> (imp) {
                <span style="color:#66d9ef">if</span> (imp <span style="color:#f92672">!=</span> (IMP)_objc_msgForward_impcache) {
                    <span style="color:#75715e">// Found the method in a superclass. Cache it in this class.
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// 父类中找到了，则在本类缓存并返回 IMP
</span><span style="color:#75715e"></span>                    log_and_fill_cache(cls, imp, sel, inst, curClass);
                    <span style="color:#66d9ef">goto</span> done;
                }
                <span style="color:#66d9ef">else</span> {
                    <span style="color:#75715e">// ⚠️ 父类的方法转发入口，停止循环
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// Found a forward:: entry in a superclass.
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// Stop searching, but don&#39;t cache yet; call method
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// resolver for this class first.
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">break</span>;
                }
            }

            <span style="color:#75715e">// Superclass method list.
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 父类缓存未找到，则在父类的方法列表中查找
</span><span style="color:#75715e"></span>            Method meth <span style="color:#f92672">=</span> getMethodNoSuper_nolock(curClass, sel);
            <span style="color:#66d9ef">if</span> (meth) {
                <span style="color:#75715e">// 找到则在本类缓存
</span><span style="color:#75715e"></span>                log_and_fill_cache(cls, meth<span style="color:#f92672">-&gt;</span>imp, sel, inst, curClass);
                imp <span style="color:#f92672">=</span> meth<span style="color:#f92672">-&gt;</span>imp;
                <span style="color:#66d9ef">goto</span> done;
            }
        }
    }

    <span style="color:#75715e">// No implementation found. Try method resolver once.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// IMP 找不到，则进入方法动态解析一次。详见下文「动态方法解析」一节。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (resolver  <span style="color:#f92672">&amp;&amp;</span>  <span style="color:#f92672">!</span>triedResolver) {
        runtimeLock.unlock();
        _class_resolveMethod(cls, sel, inst);
        runtimeLock.lock();
        <span style="color:#75715e">// Don&#39;t cache the result; we don&#39;t hold the lock so it may have
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// changed already. Re-do the search from scratch instead.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 标记为 YES
</span><span style="color:#75715e"></span>        triedResolver <span style="color:#f92672">=</span> YES;
        <span style="color:#66d9ef">goto</span> retry;
    }

    <span style="color:#75715e">// No implementation found, and method resolver didn&#39;t help.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Use forwarding.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 实现无法找到，方法解析无效，尝试方法转发。
</span><span style="color:#75715e"></span>
    imp <span style="color:#f92672">=</span> (IMP)_objc_msgForward_impcache;
    cache_fill(cls, sel, imp, inst);

 done:
    runtimeLock.unlock();

    <span style="color:#66d9ef">return</span> imp;
}

<span style="color:#66d9ef">static</span> method_t <span style="color:#f92672">*</span>
<span style="color:#a6e22e">getMethodNoSuper_nolock</span>(Class cls, SEL sel)
{
    runtimeLock.assertLocked();

    assert(cls<span style="color:#f92672">-&gt;</span>isRealized());
    <span style="color:#75715e">// fixme nil cls?
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// fixme nil sel?
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> mlists <span style="color:#f92672">=</span> cls<span style="color:#f92672">-&gt;</span>data()<span style="color:#f92672">-&gt;</span>methods.beginLists(),
              end <span style="color:#f92672">=</span> cls<span style="color:#f92672">-&gt;</span>data()<span style="color:#f92672">-&gt;</span>methods.endLists();
         mlists <span style="color:#f92672">!=</span> end;
         <span style="color:#f92672">++</span>mlists)
    {
        <span style="color:#75715e">// ⬇️ 在方法列表中查找方法
</span><span style="color:#75715e"></span>        method_t <span style="color:#f92672">*</span>m <span style="color:#f92672">=</span> search_method_list(<span style="color:#f92672">*</span>mlists, sel);
        <span style="color:#66d9ef">if</span> (m) <span style="color:#66d9ef">return</span> m;
    }

    <span style="color:#66d9ef">return</span> nil;
}

<span style="color:#75715e">/***********************************************************************
</span><span style="color:#75715e">* getMethodNoSuper_nolock
</span><span style="color:#75715e">* fixme
</span><span style="color:#75715e">* Locking: runtimeLock must be read- or write-locked by the caller
</span><span style="color:#75715e">**********************************************************************/</span>
<span style="color:#66d9ef">static</span> method_t <span style="color:#f92672">*</span><span style="color:#a6e22e">search_method_list</span>(<span style="color:#66d9ef">const</span> method_list_t <span style="color:#f92672">*</span>mlist, SEL sel)
{
    <span style="color:#66d9ef">int</span> methodListIsFixedUp <span style="color:#f92672">=</span> mlist<span style="color:#f92672">-&gt;</span>isFixedUp();
    <span style="color:#66d9ef">int</span> methodListHasExpectedSize <span style="color:#f92672">=</span> mlist<span style="color:#f92672">-&gt;</span>entsize() <span style="color:#f92672">==</span> <span style="color:#66d9ef">sizeof</span>(method_t);

    <span style="color:#66d9ef">if</span> (__builtin_expect(methodListIsFixedUp <span style="color:#f92672">&amp;&amp;</span> methodListHasExpectedSize, <span style="color:#ae81ff">1</span>)) {
        <span style="color:#75715e">// 在已排序的方法列表中查找
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> findMethodInSortedMethodList(sel, mlist);
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// Linear search of unsorted method list
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 线性查找未排序方法列表
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> meth : <span style="color:#f92672">*</span>mlist) {
            <span style="color:#66d9ef">if</span> (meth.name <span style="color:#f92672">==</span> sel) <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>meth;
        }
    }

<span style="color:#75715e">#if DEBUG
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// sanity-check negative results
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (mlist<span style="color:#f92672">-&gt;</span>isFixedUp()) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> meth : <span style="color:#f92672">*</span>mlist) {
            <span style="color:#66d9ef">if</span> (meth.name <span style="color:#f92672">==</span> sel) {
                _objc_fatal(<span style="color:#e6db74">&#34;linear search worked when binary search did not&#34;</span>);
            }
        }
    }
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> nil;
}

<span style="color:#75715e">/***********************************************************************
</span><span style="color:#75715e">* log_and_fill_cache
</span><span style="color:#75715e">* Log this method call. If the logger permits it, fill the method cache.
</span><span style="color:#75715e">* 记录该方法调用。如果记录器允许，填充方法缓存。
</span><span style="color:#75715e">* cls is the method whose cache should be filled.
</span><span style="color:#75715e">* 方法应当填充在 cls 的缓存中。
</span><span style="color:#75715e">* implementer is the class that owns the implementation in question.
</span><span style="color:#75715e">* implementer 指拥有相关实现的类。
</span><span style="color:#75715e">**********************************************************************/</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
<span style="color:#a6e22e">log_and_fill_cache</span>(Class cls, IMP imp, SEL sel, id receiver, Class implementer)
{
<span style="color:#75715e">#if SUPPORT_MESSAGE_LOGGING
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (objcMsgLogEnabled) {
        <span style="color:#66d9ef">bool</span> cacheIt <span style="color:#f92672">=</span> logMessageSend(implementer<span style="color:#f92672">-&gt;</span>isMetaClass(),
                                      cls<span style="color:#f92672">-&gt;</span>nameForLogging(),
                                      implementer<span style="color:#f92672">-&gt;</span>nameForLogging(),
                                      sel);
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>cacheIt) <span style="color:#66d9ef">return</span>;
    }
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// ⬇️ 填充缓存
</span><span style="color:#75715e"></span>    cache_fill (cls, sel, imp, receiver);
}

<span style="color:#75715e">// objc-cache.mm
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cache_fill</span>(Class cls, SEL sel, IMP imp, id receiver)
{
<span style="color:#75715e">#if !DEBUG_TASK_THREADS
</span><span style="color:#75715e"></span>    mutex_locker_t lock(cacheUpdateLock);
    <span style="color:#75715e">// ⬇️ 填充缓存
</span><span style="color:#75715e"></span>    cache_fill_nolock(cls, sel, imp, receiver);
<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>    _collecting_in_critical();
    <span style="color:#66d9ef">return</span>;
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cache_fill_nolock</span>(Class cls, SEL sel, IMP imp, id receiver)
{
    cacheUpdateLock.assertLocked();

    <span style="color:#75715e">// Never cache before +initialize is done
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 若类未初始化，则返回
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>cls<span style="color:#f92672">-&gt;</span>isInitialized()) <span style="color:#66d9ef">return</span>;

    <span style="color:#75715e">// Make sure the entry wasn&#39;t added to the cache by some other thread
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// before we grabbed the cacheUpdateLock.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 若缓存中已存在，则返回
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (cache_getImp(cls, sel)) <span style="color:#66d9ef">return</span>;

    cache_t <span style="color:#f92672">*</span>cache <span style="color:#f92672">=</span> getCache(cls);
    <span style="color:#75715e">// ⬇️ 获取缓存 key，本质即 SEL
</span><span style="color:#75715e"></span>    cache_key_t key <span style="color:#f92672">=</span> getKey(sel);

    <span style="color:#75715e">// Use the cache as-is if it is less than 3/4 full
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果小于等于 3/4 满，则使用缓存
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// newOccupied 为当前占用数 + 1
</span><span style="color:#75715e"></span>    mask_t newOccupied <span style="color:#f92672">=</span> cache<span style="color:#f92672">-&gt;</span>occupied() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#75715e">// capacity 为容量（mask + 1 或 0）
</span><span style="color:#75715e"></span>    mask_t capacity <span style="color:#f92672">=</span> cache<span style="color:#f92672">-&gt;</span>capacity();
    <span style="color:#66d9ef">if</span> (cache<span style="color:#f92672">-&gt;</span>isConstantEmptyCache()) {
        <span style="color:#75715e">// 缓存为空
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Cache is read-only. Replace it.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 重新分配内存
</span><span style="color:#75715e"></span>        cache<span style="color:#f92672">-&gt;</span>reallocate(capacity, capacity <span style="color:#f92672">?:</span> INIT_CACHE_SIZE);
    }
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (newOccupied <span style="color:#f92672">&lt;=</span> capacity <span style="color:#f92672">/</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>) {
        <span style="color:#75715e">// Cache is less than 3/4 full. Use it as-is.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 缓存已占用比例小于等于 3/4，则使用
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// Cache is too full. Expand it.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// ⬇️ 大于 3/4 则先扩容。
</span><span style="color:#75715e"></span>        cache<span style="color:#f92672">-&gt;</span>expand();
    }

    <span style="color:#75715e">// Scan for the first unused slot and insert there.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 扫描首个未使用的间隙并插入。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// There is guaranteed to be an empty slot because the
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// minimum size is 4 and we resized at 3/4 full.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 能够被确保有空间隙是因为最小大小为 4，并重调为 3/4 满。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// ⬇️ 查找要存入的 bucket_t
</span><span style="color:#75715e"></span>    bucket_t <span style="color:#f92672">*</span>bucket <span style="color:#f92672">=</span> cache<span style="color:#f92672">-&gt;</span>find(key, receiver);
    <span style="color:#75715e">// key 为空，则为新占用缓存，占用数需自增
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (bucket<span style="color:#f92672">-&gt;</span>key() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) cache<span style="color:#f92672">-&gt;</span>incrementOccupied();
    <span style="color:#75715e">// 存入 bucket
</span><span style="color:#75715e"></span>    bucket<span style="color:#f92672">-&gt;</span>set(key, imp);
}

mask_t cache_t<span style="color:#f92672">::</span>capacity()
{
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">mask</span>() <span style="color:#f92672">?</span> mask()<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>;
}

cache_key_t <span style="color:#a6e22e">getKey</span>(SEL sel)
{
    assert(sel);
    <span style="color:#75715e">// 将 SEL 强转为 cache_key_t 类型
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> (cache_key_t)sel;
}

<span style="color:#75715e">// 🌟 根据 key 查找 bucket_t
</span><span style="color:#75715e"></span>bucket_t <span style="color:#f92672">*</span> cache_t<span style="color:#f92672">::</span>find(cache_key_t k, id receiver)
{
    assert(k <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>);

    <span style="color:#75715e">// b 为 buckets 数组首地址
</span><span style="color:#75715e"></span>    bucket_t <span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> buckets();
    mask_t m <span style="color:#f92672">=</span> mask();
    <span style="color:#75715e">// begin 为方法在散列表的索引
</span><span style="color:#75715e"></span>    mask_t begin <span style="color:#f92672">=</span> cache_hash(k, m);
    <span style="color:#75715e">// 从索引开始遍历
</span><span style="color:#75715e"></span>    mask_t i <span style="color:#f92672">=</span> begin;
    <span style="color:#66d9ef">do</span> {
        <span style="color:#75715e">// 如果该索引对应的 bucket_t 中的 key（SEL）对应了我们查找的 key（即已存在）或为空
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 则代表当前 bucket_t 可插入
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (b[i].key() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>  <span style="color:#f92672">||</span>  b[i].key() <span style="color:#f92672">==</span> k) {
            <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>b[i];
        }
        <span style="color:#75715e">// 索引冲突，则进入当前索引的下一格
</span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">while</span> ((i <span style="color:#f92672">=</span> cache_next(i, m)) <span style="color:#f92672">!=</span> begin);

    <span style="color:#75715e">// hack
</span><span style="color:#75715e"></span>    Class cls <span style="color:#f92672">=</span> (Class)((uintptr_t)<span style="color:#66d9ef">this</span> <span style="color:#f92672">-</span> offsetof(objc_class, cache));
    cache_t<span style="color:#f92672">::</span>bad_cache(receiver, (SEL)k, cls);
}

<span style="color:#75715e">// Class points to cache. SEL is key. Cache buckets store SEL+IMP.
</span><span style="color:#75715e">// Caches are never built in the dyld shared cache.
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> mask_t <span style="color:#a6e22e">cache_hash</span>(cache_key_t key, mask_t mask)
{
    <span style="color:#75715e">// key &amp; mask 获得索引
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> (mask_t)(key <span style="color:#f92672">&amp;</span> mask);
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> mask_t <span style="color:#a6e22e">cache_next</span>(mask_t i, mask_t mask) {
    <span style="color:#66d9ef">return</span> (i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">&amp;</span> mask;
}

<span style="color:#75715e">// 缓存扩容
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> cache_t<span style="color:#f92672">::</span>expand()
{
    cacheUpdateLock.assertLocked();

    <span style="color:#66d9ef">uint32_t</span> oldCapacity <span style="color:#f92672">=</span> capacity();
    <span style="color:#75715e">// 扩容大小为原空间 2 倍（若原为空，则扩容为初始大小）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint32_t</span> newCapacity <span style="color:#f92672">=</span> oldCapacity <span style="color:#f92672">?</span> oldCapacity<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">:</span> INIT_CACHE_SIZE;

    <span style="color:#66d9ef">if</span> ((<span style="color:#66d9ef">uint32_t</span>)(mask_t)newCapacity <span style="color:#f92672">!=</span> newCapacity) {
        <span style="color:#75715e">// mask overflow - can&#39;t grow further
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// fixme this wastes one bit of mask
</span><span style="color:#75715e"></span>        newCapacity <span style="color:#f92672">=</span> oldCapacity;
    }

    reallocate(oldCapacity, newCapacity);
}

<span style="color:#75715e">/* Initial cache bucket count. INIT_CACHE_SIZE must be a power of two. */</span>
<span style="color:#66d9ef">enum</span> {
    INIT_CACHE_SIZE_LOG2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>,
    <span style="color:#75715e">// 左移 2 位，为 4
</span><span style="color:#75715e"></span>    INIT_CACHE_SIZE      <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> INIT_CACHE_SIZE_LOG2)
};
</code></pre></div><p>如上，消息发送的代码被分为两个部分：其一是快速路径（Fast Path），这一部分由汇编语言实现；其二是慢速路径（Slow Path），由 C 语言实现。当未命中缓存时，将调用 C 语言代码来查找方法列表，并缓存方法。</p>
<h4 id="当命中缓存时">当命中缓存时</h4>
<p>当方法被再次调用时，将可以命中缓存得以快速执行：</p>
<p><img src="/img/2019/objc_msgsend/6.png" alt="6"></p>
<h4 id="support_indexed_isa">SUPPORT_INDEXED_ISA</h4>
<p><code>SUPPORT_INDEXED_ISA</code>，即是否支持索引化 isa 我们可以在源码中找到这段定义的宏：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// objc-config.h
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Define SUPPORT_INDEXED_ISA=1 on platforms that store the class in the isa
</span><span style="color:#75715e">// field as an index into a class table.
</span><span style="color:#75715e">// 在将类存储在 isa 域中并作为类表索引的平台上定义 SUPPORT_INDEXED_ISA=1。
</span><span style="color:#75715e">// Note, keep this in sync with any .s files which also define it.
</span><span style="color:#75715e">// Be sure to edit objc-abi.h as well.
</span><span style="color:#75715e"></span><span style="color:#75715e">#if __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)
</span><span style="color:#75715e">#   define SUPPORT_INDEXED_ISA 1
</span><span style="color:#75715e">#else
</span><span style="color:#75715e">#   define SUPPORT_INDEXED_ISA 0
</span><span style="color:#75715e">#endif
</span></code></pre></div><p>比较简单的验证方式是我们可以直接在指定真机运行的代码中尝试获取最终的值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">#if __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)
</span><span style="color:#75715e">#   define SUPPORT_INDEXED_ISA 1
</span><span style="color:#75715e">#else
</span><span style="color:#75715e">#   define SUPPORT_INDEXED_ISA 0
</span><span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Use of undeclared identifier &#39;__ARM_ARCH_7K__&#39;
</span><span style="color:#75715e">// NSLog(@&#34;%d&#34;, __ARM_ARCH_7K__);
</span><span style="color:#75715e"></span>NSLog(<span style="color:#e6db74">@&#34;%d&#34;</span>, __arm64__);           <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>NSLog(<span style="color:#e6db74">@&#34;%d&#34;</span>, __LP64__);            <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>NSLog(<span style="color:#e6db74">@&#34;%d&#34;</span>, SUPPORT_INDEXED_ISA); <span style="color:#75715e">// 0
</span></code></pre></div><p>当然，我还是要细究一下。</p>
<p><code>__ARM_ARCH_7K__</code> 根据名称可以得出是定义在目标为 ARM 7k 架构 CPU 的代码中的标志宏。我们可以在 LLVM 开源的「ARM.cpp」找到其定义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// ARM.cpp
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Unfortunately, __ARM_ARCH_7K__ is now more of an ABI descriptor. The CPU
</span><span style="color:#75715e">// happens to be Cortex-A7 though, so it should still get __ARM_ARCH_7A__.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (getTriple().isWatchABI())
  Builder.defineMacro(<span style="color:#e6db74">&#34;__ARM_ARCH_7K__&#34;</span>, <span style="color:#e6db74">&#34;2&#34;</span>);
</code></pre></div><p><code>__arm64__</code> 即当目标为 ARM 64 架构 CPU 时为 <code>1</code>；<code>__LP64__</code> 即 Long Pointer，该标志宏为 <code>1</code> 的代码中 <code>long int</code> 和指针类型（指针中存储的是内存地址，也即内存地址）的长度为 64 位（8 字节），<code>int</code> 为 32 位（4 字节）。</p>
<p>综上，在 iOS 的真机设备中，<code>SUPPORT_INDEXED_ISA</code> 的值最终为 <code>0</code>。</p>
<h4 id="尾递归调用">尾递归调用</h4>
<p>🚧</p>
<h3 id="动态方法解析">动态方法解析</h3>
<h4 id="what">What</h4>
<p>当一个类或元类自身及其所有父类中都没有相应的方法实现时，将尝试动态方法解析。即调用 <code>resolveInstanceMethod:</code> 或 <code>resolveClassMethod</code> 类方法（两者依次对应解析实例方法、类方法），如果我们在其中动态将方法添加，那么将可以执行到相应的方法中：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo</span> : <span style="color:#a6e22e">NSObject</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">foo</span>;
+ (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">classFoo</span>;
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">tryC</span>;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo</span>

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">bar</span> {
    NSLog(<span style="color:#e6db74">@&#34;%s&#34;</span>, __func__);
}

+ (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">classBar</span> {
    NSLog(<span style="color:#e6db74">@&#34;%s&#34;</span>, __func__);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">c_func</span>(<span style="color:#66d9ef">id</span> self, <span style="color:#66d9ef">SEL</span> _cmd) {
    NSLog(<span style="color:#e6db74">@&#34;%p - %@&#34;</span>, self, NSStringFromSelector(_cmd));
}

+ (<span style="color:#66d9ef">BOOL</span>)<span style="color:#a6e22e">resolveInstanceMethod:</span>(<span style="color:#66d9ef">SEL</span>)sel {
    <span style="color:#66d9ef">if</span> (sel <span style="color:#f92672">==</span> <span style="color:#66d9ef">@selector</span>(foo)) {
        <span style="color:#75715e">// 通过 Runtime API 获得类对象中的实例方法
</span><span style="color:#75715e"></span>        Method method <span style="color:#f92672">=</span> class_getInstanceMethod(self, <span style="color:#66d9ef">@selector</span>(bar));
        <span style="color:#75715e">// 动态添加方法
</span><span style="color:#75715e"></span>        class_addMethod(self, sel, method_getImplementation(method), method_getTypeEncoding(method));

        <span style="color:#66d9ef">return</span> YES;
    }

    <span style="color:#66d9ef">if</span> (sel <span style="color:#f92672">==</span> <span style="color:#66d9ef">@selector</span>(tryC)) {
        <span style="color:#75715e">// 也可以将 C 函数转换为 Method 格式作为动态方法；
</span><span style="color:#75715e"></span>        class_addMethod(self, sel, (<span style="color:#66d9ef">IMP</span>)c_func, <span style="color:#e6db74">&#34;v16@0:8&#34;</span>);
    }

    <span style="color:#75715e">// 当实现了动态方法解析时，最好按要求返回 YES，但目前看返回值并不影响结果（详见下源码）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> [super resolveInstanceMethod:sel];
}

+ (<span style="color:#66d9ef">BOOL</span>)<span style="color:#a6e22e">resolveClassMethod:</span>(<span style="color:#66d9ef">SEL</span>)sel {
    <span style="color:#66d9ef">if</span> (sel <span style="color:#f92672">==</span> <span style="color:#66d9ef">@selector</span>(classFoo)) {
        <span style="color:#75715e">// 通过 Runtime API 获得元类对象中的类方法
</span><span style="color:#75715e"></span>        Method method <span style="color:#f92672">=</span> class_getClassMethod(object_getClass(self), <span style="color:#66d9ef">@selector</span>(classBar));
        <span style="color:#75715e">// 动态添加方法（注意将k类方法添加到元类对象中）
</span><span style="color:#75715e"></span>        class_addMethod(object_getClass(self), sel, method_getImplementation(method), method_getTypeEncoding(method));

        <span style="color:#66d9ef">return</span> YES;
    }

    <span style="color:#66d9ef">return</span> [super resolveClassMethod:sel];
}
<span style="color:#66d9ef">@end</span>

Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [[Foo alloc] init];
[foo foo];

[Foo classFoo];

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e">// -[Foo bar]
</span><span style="color:#75715e">// +[Foo classBar]
</span><span style="color:#75715e">// 0x2802d0a50 - tryC
</span></code></pre></div><p>这里的 <code>Method</code> 是一个类似 <code>Class</code> 的不透明类型，我们可以在 objc4 源码中看到它的结构，本质即 <code>method_t</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// runtime.h
</span><span style="color:#75715e"></span>
<span style="color:#75715e">/// An opaque type that represents a method in a class definition.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> objc_method <span style="color:#f92672">*</span>Method;

<span style="color:#66d9ef">struct</span> objc_method {
    <span style="color:#66d9ef">SEL</span> _Nonnull method_name                                 OBJC2_UNAVAILABLE;
    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> _Nullable method_types                            OBJC2_UNAVAILABLE;
    <span style="color:#66d9ef">IMP</span> _Nonnull method_imp                                  OBJC2_UNAVAILABLE;
}

<span style="color:#75715e">// objc-private.h
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#if __OBJC2__
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> method_t <span style="color:#f92672">*</span>Method;
<span style="color:#75715e">// ...
</span></code></pre></div><p>而 <code>class_addMethod</code> 将把新方法放置在一个一维方法列表中，并最终附加在 Obj-C 类中 <code>class_rw_t</code> 的二维 <code>method_array_t methods;</code> 中（因此 <code>class_addMethod</code> 对于每个方法只会调用一次）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// objc-runtime-new.mm
</span><span style="color:#75715e"></span>
BOOL
<span style="color:#a6e22e">class_addMethod</span>(Class cls, SEL name, IMP imp, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>types)
{
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>cls) <span style="color:#66d9ef">return</span> NO;

    mutex_locker_t lock(runtimeLock);
    <span style="color:#75715e">// ⬇️
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">!</span> addMethod(cls, name, imp, types <span style="color:#f92672">?:</span> <span style="color:#e6db74">&#34;&#34;</span>, NO);
}

<span style="color:#75715e">/**********************************************************************
</span><span style="color:#75715e">* addMethod
</span><span style="color:#75715e">* fixme
</span><span style="color:#75715e">* Locking: runtimeLock must be held by the caller
</span><span style="color:#75715e">**********************************************************************/</span>
<span style="color:#66d9ef">static</span> IMP
<span style="color:#a6e22e">addMethod</span>(Class cls, SEL name, IMP imp, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>types, <span style="color:#66d9ef">bool</span> replace)
{
    IMP result <span style="color:#f92672">=</span> nil;

    runtimeLock.assertLocked();

    checkIsKnownClass(cls);

    assert(types);
    assert(cls<span style="color:#f92672">-&gt;</span>isRealized());

    method_t <span style="color:#f92672">*</span>m;
    <span style="color:#66d9ef">if</span> ((m <span style="color:#f92672">=</span> getMethodNoSuper_nolock(cls, name))) {
        <span style="color:#75715e">// already exists
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>replace) {
            result <span style="color:#f92672">=</span> m<span style="color:#f92672">-&gt;</span>imp;
        } <span style="color:#66d9ef">else</span> {
            result <span style="color:#f92672">=</span> _method_setImplementation(cls, m, imp);
        }
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// fixme optimize
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 初始化新的 method_list_t
</span><span style="color:#75715e"></span>        method_list_t <span style="color:#f92672">*</span>newlist;
        newlist <span style="color:#f92672">=</span> (method_list_t <span style="color:#f92672">*</span>)calloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>newlist), <span style="color:#ae81ff">1</span>);
        newlist<span style="color:#f92672">-&gt;</span>entsizeAndFlags <span style="color:#f92672">=</span>
            (<span style="color:#66d9ef">uint32_t</span>)<span style="color:#66d9ef">sizeof</span>(method_t) <span style="color:#f92672">|</span> fixed_up_method_list;
        newlist<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#75715e">// 将方法放置在新的方法列表中
</span><span style="color:#75715e"></span>        newlist<span style="color:#f92672">-&gt;</span>first.name <span style="color:#f92672">=</span> name;
        newlist<span style="color:#f92672">-&gt;</span>first.types <span style="color:#f92672">=</span> strdupIfMutable(types);
        newlist<span style="color:#f92672">-&gt;</span>first.imp <span style="color:#f92672">=</span> imp;

        <span style="color:#75715e">// 方法列表的准备工作
</span><span style="color:#75715e"></span>        prepareMethodLists(cls, <span style="color:#f92672">&amp;</span>newlist, <span style="color:#ae81ff">1</span>, NO, NO);
        <span style="color:#75715e">// ⬇️ 附加方法列表
</span><span style="color:#75715e"></span>        cls<span style="color:#f92672">-&gt;</span>data()<span style="color:#f92672">-&gt;</span>methods.attachLists(<span style="color:#f92672">&amp;</span>newlist, <span style="color:#ae81ff">1</span>);
        flushCaches(cls);

        result <span style="color:#f92672">=</span> nil;
    }

    <span style="color:#66d9ef">return</span> result;
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
<span style="color:#a6e22e">prepareMethodLists</span>(Class cls, method_list_t <span style="color:#f92672">**</span>addedLists, <span style="color:#66d9ef">int</span> addedCount,
                   <span style="color:#66d9ef">bool</span> baseMethods, <span style="color:#66d9ef">bool</span> methodsFromBundle)
{
    runtimeLock.assertLocked();

    <span style="color:#66d9ef">if</span> (addedCount <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span>;

    <span style="color:#75715e">// Don&#39;t scan redundantly
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> scanForCustomRR <span style="color:#f92672">=</span> <span style="color:#f92672">!</span>cls<span style="color:#f92672">-&gt;</span>hasCustomRR();
    <span style="color:#66d9ef">bool</span> scanForCustomAWZ <span style="color:#f92672">=</span> <span style="color:#f92672">!</span>cls<span style="color:#f92672">-&gt;</span>hasCustomAWZ();

    <span style="color:#75715e">// There exist RR/AWZ special cases for some class&#39;s base methods.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// But this code should never need to scan base methods for RR/AWZ:
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// default RR/AWZ cannot be set before setInitialized().
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Therefore we need not handle any special cases here.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (baseMethods) {
        assert(<span style="color:#f92672">!</span>scanForCustomRR  <span style="color:#f92672">&amp;&amp;</span>  <span style="color:#f92672">!</span>scanForCustomAWZ);
    }

    <span style="color:#75715e">// Add method lists to array.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Reallocate un-fixed method lists.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// The new methods are PREPENDED to the method list array.
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> addedCount; i<span style="color:#f92672">++</span>) {
        method_list_t <span style="color:#f92672">*</span>mlist <span style="color:#f92672">=</span> addedLists[i];
        assert(mlist);

        <span style="color:#75715e">// Fixup selectors if necessary
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>mlist<span style="color:#f92672">-&gt;</span>isFixedUp()) {
            fixupMethodList(mlist, methodsFromBundle, true<span style="color:#75715e">/*sort*/</span>);
        }

        <span style="color:#75715e">// Scan for method implementations tracked by the class&#39;s flags
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (scanForCustomRR  <span style="color:#f92672">&amp;&amp;</span>  methodListImplementsRR(mlist)) {
            cls<span style="color:#f92672">-&gt;</span>setHasCustomRR();
            scanForCustomRR <span style="color:#f92672">=</span> false;
        }
        <span style="color:#66d9ef">if</span> (scanForCustomAWZ  <span style="color:#f92672">&amp;&amp;</span>  methodListImplementsAWZ(mlist)) {
            cls<span style="color:#f92672">-&gt;</span>setHasCustomAWZ();
            scanForCustomAWZ <span style="color:#f92672">=</span> false;
        }
    }
}

<span style="color:#75715e">// objc-runtime-new.h
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Element, <span style="color:#66d9ef">typename</span> List<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">list_array_tt</span> {
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">attachLists</span>(List<span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span> addedLists, <span style="color:#66d9ef">uint32_t</span> addedCount) {
        <span style="color:#66d9ef">if</span> (addedCount <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span>;

        <span style="color:#66d9ef">if</span> (hasArray()) {
            <span style="color:#75715e">// many lists -&gt; many lists
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 已成二维，则先分配空间，挪动原表，放置新表
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//（关于 memmove &amp; momcpy 可参考文末 Reference 中「iOS 中的 Category」一文）
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">uint32_t</span> oldCount <span style="color:#f92672">=</span> array()<span style="color:#f92672">-&gt;</span>count;
            <span style="color:#66d9ef">uint32_t</span> newCount <span style="color:#f92672">=</span> oldCount <span style="color:#f92672">+</span> addedCount;
            setArray((array_t <span style="color:#f92672">*</span>)realloc(array(), array_t<span style="color:#f92672">::</span>byteSize(newCount)));
            array()<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">=</span> newCount;
            memmove(array()<span style="color:#f92672">-&gt;</span>lists <span style="color:#f92672">+</span> addedCount, array()<span style="color:#f92672">-&gt;</span>lists,
                    oldCount <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(array()<span style="color:#f92672">-&gt;</span>lists[<span style="color:#ae81ff">0</span>]));
            memcpy(array()<span style="color:#f92672">-&gt;</span>lists, addedLists,
                   addedCount <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(array()<span style="color:#f92672">-&gt;</span>lists[<span style="color:#ae81ff">0</span>]));
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>list  <span style="color:#f92672">&amp;&amp;</span>  addedCount <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
            <span style="color:#75715e">// 0 lists -&gt; 1 list
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 空表则直接附加
</span><span style="color:#75715e"></span>            list <span style="color:#f92672">=</span> addedLists[<span style="color:#ae81ff">0</span>];
        }
        <span style="color:#66d9ef">else</span> {
            <span style="color:#75715e">// 1 list -&gt; many lists
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 一维单表附加至二维
</span><span style="color:#75715e"></span>            List<span style="color:#f92672">*</span> oldList <span style="color:#f92672">=</span> list;
            <span style="color:#66d9ef">uint32_t</span> oldCount <span style="color:#f92672">=</span> oldList <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>;
            <span style="color:#66d9ef">uint32_t</span> newCount <span style="color:#f92672">=</span> oldCount <span style="color:#f92672">+</span> addedCount;
            setArray((array_t <span style="color:#f92672">*</span>)malloc(array_t<span style="color:#f92672">::</span>byteSize(newCount)));
            array()<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">=</span> newCount;
            <span style="color:#66d9ef">if</span> (oldList) array()<span style="color:#f92672">-&gt;</span>lists[addedCount] <span style="color:#f92672">=</span> oldList;
            memcpy(array()<span style="color:#f92672">-&gt;</span>lists, addedLists,
                   addedCount <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(array()<span style="color:#f92672">-&gt;</span>lists[<span style="color:#ae81ff">0</span>]));
        }
    }

    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>};
</code></pre></div><h4 id="how">How</h4>
<p>正如上所述，在上面未命中缓存且本类及所有父类中都无法找到要调用的方法时，将进入 <code>lookUpImpOrForward</code> 中的 Method Resovle 即「动态方法解析」：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// objc-runtime-new.mm
</span><span style="color:#75715e"></span>
IMP <span style="color:#a6e22e">lookUpImpOrForward</span>(Class cls, SEL sel, id inst,
                       <span style="color:#66d9ef">bool</span> initialize, <span style="color:#66d9ef">bool</span> cache, <span style="color:#66d9ef">bool</span> resolver)
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// No implementation found. Try method resolver once.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// IMP 找不到，则进入方法动态解析一次。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (resolver  <span style="color:#f92672">&amp;&amp;</span>  <span style="color:#f92672">!</span>triedResolver) {
        runtimeLock.unlock();
        <span style="color:#75715e">// ⬇️ 尝试方法解析
</span><span style="color:#75715e"></span>        _class_resolveMethod(cls, sel, inst);
        runtimeLock.lock();
        <span style="color:#75715e">// Don&#39;t cache the result; we don&#39;t hold the lock so it may have
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// changed already. Re-do the search from scratch instead.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 标记为 YES
</span><span style="color:#75715e"></span>        triedResolver <span style="color:#f92672">=</span> YES;
        <span style="color:#75715e">// 添加到方法列表后，进而进入再次尝试从方法列表中获取并存入缓存
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">goto</span> retry;
    }

    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">/***********************************************************************
</span><span style="color:#75715e">* _class_resolveMethod
</span><span style="color:#75715e">* Call +resolveClassMethod or +resolveInstanceMethod.
</span><span style="color:#75715e">* Returns nothing; any result would be potentially out-of-date already.
</span><span style="color:#75715e">* Does not check if the method already exists.
</span><span style="color:#75715e">**********************************************************************/</span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_class_resolveMethod</span>(Class cls, SEL sel, id inst)
{
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span> cls<span style="color:#f92672">-&gt;</span>isMetaClass()) {
        <span style="color:#75715e">// 非元类对象，则解析类对象
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// try [cls resolveInstanceMethod:sel]
</span><span style="color:#75715e"></span>        _class_resolveInstanceMethod(cls, sel, inst);
    }
    <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// 解析元类对象
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// try [nonMetaClass resolveClassMethod:sel]
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// and [cls resolveInstanceMethod:sel]
</span><span style="color:#75715e"></span>        _class_resolveClassMethod(cls, sel, inst);
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>lookUpImpOrNil(cls, sel, inst,
                            NO<span style="color:#75715e">/*initialize*/</span>, YES<span style="color:#75715e">/*cache*/</span>, NO<span style="color:#75715e">/*resolver*/</span>))
        {
            _class_resolveInstanceMethod(cls, sel, inst);
        }
    }
}

<span style="color:#75715e">/***********************************************************************
</span><span style="color:#75715e">* _class_resolveInstanceMethod
</span><span style="color:#75715e">* Call +resolveInstanceMethod, looking for a method to be added to class cls.
</span><span style="color:#75715e">* 调用 +resolveInstanceMethod，并查找要添加到 cls 类的方法。
</span><span style="color:#75715e">* cls may be a metaclass or a non-meta class.
</span><span style="color:#75715e">* cls 可能是元类或非元类。
</span><span style="color:#75715e">* Does not check if the method already exists.
</span><span style="color:#75715e">* 如果方法已经存在则不检查。
</span><span style="color:#75715e">**********************************************************************/</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_class_resolveInstanceMethod</span>(Class cls, SEL sel, id inst)
{
    <span style="color:#75715e">// 如果未实现 resolveInstanceMethod 则返回
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span> lookUpImpOrNil(cls<span style="color:#f92672">-&gt;</span>ISA(), SEL_resolveInstanceMethod, cls,
                         NO<span style="color:#75715e">/*initialize*/</span>, YES<span style="color:#75715e">/*cache*/</span>, NO<span style="color:#75715e">/*resolver*/</span>))
    {
        <span style="color:#75715e">// Resolver not implemented.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span>;
    }

    BOOL (<span style="color:#f92672">*</span>msg)(Class, SEL, SEL) <span style="color:#f92672">=</span> (typeof(msg))objc_msgSend;
    <span style="color:#75715e">// 使用 objc_msgSend 执行 resolveInstanceMethod，将返回值保存为 resolved
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> resolved <span style="color:#f92672">=</span> msg(cls, SEL_resolveInstanceMethod, sel);

    <span style="color:#75715e">// 根据 resolved 做一些日志等处理
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Cache the result (good or bad) so the resolver doesn&#39;t fire next time.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// +resolveInstanceMethod adds to self a.k.a. cls
</span><span style="color:#75715e"></span>    IMP imp <span style="color:#f92672">=</span> lookUpImpOrNil(cls, sel, inst,
                             NO<span style="color:#75715e">/*initialize*/</span>, YES<span style="color:#75715e">/*cache*/</span>, NO<span style="color:#75715e">/*resolver*/</span>);

    <span style="color:#66d9ef">if</span> (resolved  <span style="color:#f92672">&amp;&amp;</span>  PrintResolving) {
        <span style="color:#66d9ef">if</span> (imp) {
            _objc_inform(<span style="color:#e6db74">&#34;RESOLVE: method %c[%s %s] &#34;</span>
                         <span style="color:#e6db74">&#34;dynamically resolved to %p&#34;</span>,
                         cls<span style="color:#f92672">-&gt;</span>isMetaClass() <span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;-&#39;</span>,
                         cls<span style="color:#f92672">-&gt;</span>nameForLogging(), sel_getName(sel), imp);
        }
        <span style="color:#66d9ef">else</span> {
            <span style="color:#75715e">// Method resolver didn&#39;t add anything?
</span><span style="color:#75715e"></span>            _objc_inform(<span style="color:#e6db74">&#34;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&#34;</span>
                         <span style="color:#e6db74">&#34;, but no new implementation of %c[%s %s] was found&#34;</span>,
                         cls<span style="color:#f92672">-&gt;</span>nameForLogging(), sel_getName(sel),
                         cls<span style="color:#f92672">-&gt;</span>isMetaClass() <span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;-&#39;</span>,
                         cls<span style="color:#f92672">-&gt;</span>nameForLogging(), sel_getName(sel));
        }
    }
}

<span style="color:#75715e">/***********************************************************************
</span><span style="color:#75715e">* _class_resolveClassMethod
</span><span style="color:#75715e">* Call +resolveClassMethod, looking for a method to be added to class cls.
</span><span style="color:#75715e">* 调用 +resolveClassMethod，并查找要添加到 cls 类的方法。
</span><span style="color:#75715e">* cls should be a metaclass.
</span><span style="color:#75715e">* cls 应当是元类。
</span><span style="color:#75715e">* Does not check if the method already exists.
</span><span style="color:#75715e">* 如果方法已经存在则不检查。
</span><span style="color:#75715e">**********************************************************************/</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_class_resolveClassMethod</span>(Class cls, SEL sel, id inst)
{
    assert(cls<span style="color:#f92672">-&gt;</span>isMetaClass());

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span> lookUpImpOrNil(cls, SEL_resolveClassMethod, inst,
                         NO<span style="color:#75715e">/*initialize*/</span>, YES<span style="color:#75715e">/*cache*/</span>, NO<span style="color:#75715e">/*resolver*/</span>))
    {
        <span style="color:#75715e">// Resolver not implemented.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span>;
    }

    BOOL (<span style="color:#f92672">*</span>msg)(Class, SEL, SEL) <span style="color:#f92672">=</span> (typeof(msg))objc_msgSend;
    <span style="color:#66d9ef">bool</span> resolved <span style="color:#f92672">=</span> msg(_class_getNonMetaClass(cls, inst),
                        SEL_resolveClassMethod, sel);

    <span style="color:#75715e">// Cache the result (good or bad) so the resolver doesn&#39;t fire next time.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls
</span><span style="color:#75715e"></span>    IMP imp <span style="color:#f92672">=</span> lookUpImpOrNil(cls, sel, inst,
                             NO<span style="color:#75715e">/*initialize*/</span>, YES<span style="color:#75715e">/*cache*/</span>, NO<span style="color:#75715e">/*resolver*/</span>);

    <span style="color:#66d9ef">if</span> (resolved  <span style="color:#f92672">&amp;&amp;</span>  PrintResolving) {
        <span style="color:#66d9ef">if</span> (imp) {
            _objc_inform(<span style="color:#e6db74">&#34;RESOLVE: method %c[%s %s] &#34;</span>
                         <span style="color:#e6db74">&#34;dynamically resolved to %p&#34;</span>,
                         cls<span style="color:#f92672">-&gt;</span>isMetaClass() <span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;-&#39;</span>,
                         cls<span style="color:#f92672">-&gt;</span>nameForLogging(), sel_getName(sel), imp);
        }
        <span style="color:#66d9ef">else</span> {
            <span style="color:#75715e">// Method resolver didn&#39;t add anything?
</span><span style="color:#75715e"></span>            _objc_inform(<span style="color:#e6db74">&#34;RESOLVE: +[%s resolveClassMethod:%s] returned YES&#34;</span>
                         <span style="color:#e6db74">&#34;, but no new implementation of %c[%s %s] was found&#34;</span>,
                         cls<span style="color:#f92672">-&gt;</span>nameForLogging(), sel_getName(sel),
                         cls<span style="color:#f92672">-&gt;</span>isMetaClass() <span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;-&#39;</span>,
                         cls<span style="color:#f92672">-&gt;</span>nameForLogging(), sel_getName(sel));
        }
    }
}

<span style="color:#75715e">/***********************************************************************
</span><span style="color:#75715e">* lookUpImpOrNil.
</span><span style="color:#75715e">* Like lookUpImpOrForward, but returns nil instead of _objc_msgForward_impcache
</span><span style="color:#75715e">* 类似 lookUpImpOrForward，但返回 nil 而非 _objc_msgForward_impcache
</span><span style="color:#75715e">**********************************************************************/</span>
IMP <span style="color:#a6e22e">lookUpImpOrNil</span>(Class cls, SEL sel, id inst,
                   <span style="color:#66d9ef">bool</span> initialize, <span style="color:#66d9ef">bool</span> cache, <span style="color:#66d9ef">bool</span> resolver)
{
    IMP imp <span style="color:#f92672">=</span> lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);
    <span style="color:#75715e">// 若找不到该方法（返回了消息转发），则返回 nil
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (imp <span style="color:#f92672">==</span> _objc_msgForward_impcache) <span style="color:#66d9ef">return</span> nil;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> imp;
}
</code></pre></div><h3 id="消息转发">消息转发</h3>
<h4 id="what-1">What</h4>
<p>当动态方法解析也无能为力时，将最终尝试消息转发。即 <code>- (id)forwardingTargetForSelector:(SEL)aSelector</code> 实例方法或 <code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code> 类方法，如果我们将需要转发到的目标返回，那么目标就可以执行到转发的相同方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">FooBackup</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">FooBackup</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">foo</span> {
    NSLog(<span style="color:#e6db74">@&#34;%s&#34;</span>, __func__);
}

+ (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">foo</span> {
    NSLog(<span style="color:#e6db74">@&#34;%s&#34;</span>, __func__);
}

+ (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">classFoo</span> {
    NSLog(<span style="color:#e6db74">@&#34;%s&#34;</span>, __func__);
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">classFoo</span> {
    NSLog(<span style="color:#e6db74">@&#34;%s&#34;</span>, __func__);
}
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo</span> : <span style="color:#a6e22e">NSObject</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">foo</span>;
+ (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">classFoo</span>;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo</span>
- (<span style="color:#66d9ef">id</span>)<span style="color:#a6e22e">forwardingTargetForSelector:</span>(<span style="color:#66d9ef">SEL</span>)aSelector {
    <span style="color:#66d9ef">if</span> (aSelector <span style="color:#f92672">==</span> <span style="color:#66d9ef">@selector</span>(foo)) {
        <span style="color:#75715e">// 实例方法也可以转发给类对象
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// return [FooBackup class];
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> [[FooBackup alloc] init];
    }

    <span style="color:#66d9ef">return</span> [super forwardingTargetForSelector:aSelector];
}

+ (<span style="color:#66d9ef">id</span>)<span style="color:#a6e22e">forwardingTargetForSelector:</span>(<span style="color:#66d9ef">SEL</span>)aSelector {
    <span style="color:#66d9ef">if</span> (aSelector <span style="color:#f92672">==</span> <span style="color:#66d9ef">@selector</span>(classFoo)) {
        <span style="color:#75715e">// return [[FooBackup alloc] init];
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> [FooBackup <span style="color:#66d9ef">class</span>];
    }

    <span style="color:#66d9ef">return</span> [super forwardingTargetForSelector:aSelector];
}
<span style="color:#66d9ef">@end</span>

Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [[Foo alloc] init];
[foo foo];

[Foo classFoo];

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e">// -[FooBackup foo]
</span><span style="color:#75715e">// +[FooBackup classFoo]
</span></code></pre></div><p>正如《Effective Objective-C 2.0》一书中所提到的，通过这种方式我们可以模拟出多重继承（Multiple Inheritance），即在一个对象内部使用一系列其它对象来处理相应的消息。另外需要注意的是，在这一步骤我们无法对消息本身进行更改，我们只能返回处理消息的对象。</p>
<p>如果 <code>forwardingTargetForSelector:</code> 也没有转发到目标，消息将尝试从 <code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>/<code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code> 获取方法签名，方法签名可以根据方法的类型编码获得；接下来将可以通过 <code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>/<code>+ (void)forwardInvocation:(NSInvocation *)anInvocation</code> 执行，原来的消息将被封装在 <code>NSInvocation</code> 中：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">FooBackup</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">FooBackup</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">foo</span> {
    NSLog(<span style="color:#e6db74">@&#34;%s&#34;</span>, __func__);
}

+ (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">classFoo</span> {
    NSLog(<span style="color:#e6db74">@&#34;%s&#34;</span>, __func__);
}
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo</span> : <span style="color:#a6e22e">NSObject</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">foo</span>;
+ (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">classFoo</span>;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo</span>
- (NSMethodSignature <span style="color:#f92672">*</span>)<span style="color:#a6e22e">methodSignatureForSelector:</span>(<span style="color:#66d9ef">SEL</span>)aSelector {
    <span style="color:#66d9ef">if</span> (aSelector <span style="color:#f92672">==</span> <span style="color:#66d9ef">@selector</span>(foo)) {
        <span style="color:#75715e">// return [NSMethodSignature signatureWithObjCTypes:&#34;v@:&#34;];
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> [NSMethodSignature signatureWithObjCTypes:<span style="color:#e6db74">&#34;v16@0:8&#34;</span>];
    }

    <span style="color:#66d9ef">return</span> [super methodSignatureForSelector:aSelector];
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">forwardInvocation:</span>(NSInvocation <span style="color:#f92672">*</span>)anInvocation {
    <span style="color:#66d9ef">if</span> (anInvocation.selector <span style="color:#f92672">==</span> <span style="color:#66d9ef">@selector</span>(foo)) {
        [anInvocation invokeWithTarget:[[FooBackup alloc] init]];
    }
}

+ (NSMethodSignature <span style="color:#f92672">*</span>)<span style="color:#a6e22e">methodSignatureForSelector:</span>(<span style="color:#66d9ef">SEL</span>)aSelector {
    <span style="color:#66d9ef">if</span> (aSelector <span style="color:#f92672">==</span> <span style="color:#66d9ef">@selector</span>(classFoo)) {
        <span style="color:#75715e">// return [NSMethodSignature signatureWithObjCTypes:&#34;v@:&#34;];
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> [NSMethodSignature signatureWithObjCTypes:<span style="color:#e6db74">&#34;v16@0:8&#34;</span>];
    }

    <span style="color:#66d9ef">return</span> [super methodSignatureForSelector:aSelector];
}

+ (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">forwardInvocation:</span>(NSInvocation <span style="color:#f92672">*</span>)anInvocation {
    <span style="color:#66d9ef">if</span> (anInvocation.selector <span style="color:#f92672">==</span> <span style="color:#66d9ef">@selector</span>(classFoo)) {
        [anInvocation invokeWithTarget:[FooBackup <span style="color:#66d9ef">class</span>]];
    }
}
<span style="color:#66d9ef">@end</span>
</code></pre></div><h4 id="how-1">How</h4>
<p>正如上所述，当动态方法解析也无法奏效或者我们在动态方法解析中并没有添加了正确的方法时，将进入 <code>lookUpImpOrForward</code> 中的 Method Forward 即「消息转发」：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">IMP <span style="color:#a6e22e">lookUpImpOrForward</span>(Class cls, SEL sel, id inst,
                       <span style="color:#66d9ef">bool</span> initialize, <span style="color:#66d9ef">bool</span> cache, <span style="color:#66d9ef">bool</span> resolver)
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// No implementation found, and method resolver didn&#39;t help.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Use forwarding.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 实现无法找到，方法解析无效，尝试方法转发。
</span><span style="color:#75715e"></span>
    imp <span style="color:#f92672">=</span> (IMP)_objc_msgForward_impcache;
    cache_fill(cls, sel, imp, inst);

    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><p><code>_objc_msgForward_impcache</code> 则又是在汇编中：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#a6e22e">objc-msg-arm.s</span>
<span style="color:#960050;background-color:#1e0010">/********************************************************************</span>
<span style="color:#960050;background-color:#1e0010">*</span>
<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#a6e22e">id</span> <span style="color:#66d9ef">_objc_msgForward</span>(<span style="color:#66d9ef">id</span> <span style="color:#66d9ef">self</span>, <span style="color:#66d9ef">SEL</span> <span style="color:#66d9ef">_cmd</span>,...)<span style="color:#75715e">;
</span><span style="color:#75715e"></span>*
<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#a6e22e">_objc_msgForward</span> <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">the</span> <span style="color:#66d9ef">externally-callable</span>
<span style="color:#960050;background-color:#1e0010">*</span>   <span style="color:#a6e22e">function</span> <span style="color:#66d9ef">returned</span> <span style="color:#66d9ef">by</span> <span style="color:#66d9ef">things</span> <span style="color:#66d9ef">like</span> <span style="color:#66d9ef">method_getImplementation</span>().
<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#a6e22e">_objc_msgForward_impcache</span> <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">the</span> <span style="color:#66d9ef">function</span> <span style="color:#66d9ef">pointer</span> <span style="color:#66d9ef">actually</span> <span style="color:#66d9ef">stored</span> <span style="color:#66d9ef">in</span>
<span style="color:#960050;background-color:#1e0010">*</span>   <span style="color:#a6e22e">method</span> <span style="color:#66d9ef">caches.</span>
<span style="color:#960050;background-color:#1e0010">*</span>
<span style="color:#960050;background-color:#1e0010">********************************************************************/</span>

	<span style="color:#a6e22e">STATIC_ENTRY</span> <span style="color:#66d9ef">__objc_msgForward_impcache</span>

	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#a6e22e">No</span> <span style="color:#66d9ef">stret</span> <span style="color:#66d9ef">specialization.</span>
	<span style="color:#a6e22e">b</span>	<span style="color:#66d9ef">__objc_msgForward</span>

	<span style="color:#a6e22e">END_ENTRY</span> <span style="color:#66d9ef">__objc_msgForward_impcache</span>


	<span style="color:#a6e22e">ENTRY</span> <span style="color:#66d9ef">__objc_msgForward</span>

	<span style="color:#a6e22e">adrp</span>	<span style="color:#66d9ef">x17</span>, <span style="color:#66d9ef">__objc_forward_handler@PAGE</span>
	<span style="color:#a6e22e">ldr</span>	<span style="color:#66d9ef">p17</span>, [<span style="color:#66d9ef">x17</span>, <span style="color:#66d9ef">__objc_forward_handler@PAGEOFF</span>]
	<span style="color:#a6e22e">TailCallFunctionPointer</span> <span style="color:#66d9ef">x17</span>

	<span style="color:#a6e22e">END_ENTRY</span> <span style="color:#66d9ef">__objc_msgForward</span>
</code></pre></div><p>最终会发现 objc4 中并没有开源的 <code>objc_msgForward</code> 实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// objc-runtime.mm
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Default forward handler halts the process.
</span><span style="color:#75715e"></span>__attribute__((noreturn)) <span style="color:#66d9ef">void</span>
objc_defaultForwardHandler(id self, SEL sel)
{
    _objc_fatal(<span style="color:#e6db74">&#34;%c[%s %s]: unrecognized selector sent to instance %p &#34;</span>
                <span style="color:#e6db74">&#34;(no message forward handler is installed)&#34;</span>,
                class_isMetaClass(object_getClass(self)) <span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;-&#39;</span>,
                object_getClassName(self), sel_getName(sel), self);
}
<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>_objc_forward_handler <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)objc_defaultForwardHandler;
</code></pre></div><hr>
<p>综上，一个 Obj-C 方法调用的过程可以描述为：</p>
<ol>
<li><code>objc_msgSend</code> 判断消息接收者是否为 <code>nil</code></li>
<li>当非 <code>nil</code> 时，将根据 <code>isa</code> 指针找到缓存所在的类或元类对象的缓存中寻找；</li>
<li>当无法在缓存中找到时，将从本类开始到父类（到父类的父）在其方法列表中查找，如果找到会同时缓存到原有类中一份；</li>
<li>如果方法列表也无法找到将尝试动态方法解析，即进入 <code>resolveInstanceMethod</code>/<code>resolveClassMethod</code>，如果其中将方法正确地动态添加了，则从方法列表中调用并缓存；</li>
<li>如果仍无，将尝试 <code>forwardingTargetForSelector</code>，其返回将作为被转发到的目标尝试执行相应方法；</li>
<li>如果转发目标为 <code>nil</code>，将最终尝试 <code>methodSignatureForSelector:</code> 返回方法签名并在 <code>forwardInvocation:</code> 决定根据消息的信息选择如何执行；</li>
<li>如果在 <code>methodSignatureForSelector:</code> 返回了空方法签名，将最终导致「unrecognized selector sent to instance」。</li>
</ol>
<p>正如《Effective Objective-C 2.0》一书中提到的 <code>CALayer</code> 使用了消息转发来实现兼容 KVC 的容器类：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">MyLayer</span> : <span style="color:#a6e22e">CALayer</span>
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">copy</span>) NSString <span style="color:#f92672">*</span>foo;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">MyLayer</span>
<span style="color:#66d9ef">@dynamic</span> foo; <span style="color:#75715e">// 不自动生成 getter &amp; setter
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@end</span>

MyLayer <span style="color:#f92672">*</span>layer <span style="color:#f92672">=</span> [[MyLayer alloc] init];
[layer setFoo:<span style="color:#e6db74">@&#34;kingcos.me&#34;</span>];
NSLog(<span style="color:#e6db74">@&#34;%@&#34;</span>, [layer foo]);
NSLog(<span style="color:#e6db74">@&#34;%@&#34;</span>, [layer valueForKey:<span style="color:#e6db74">@&#34;foo&#34;</span>]);

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e">// kingcos.me
</span><span style="color:#75715e">// kingcos.me
</span></code></pre></div><!--

- Obj-C 对象方法查找顺序：本类的类对象方法列表中查找同名方法（分类 Category 中的方法会合并到类的方法列表中，根据后编译更靠前，会被先找到） -> 若没有找到，则根据 `superclass` 指针向父类的类对象方法列表中查找，直到查找基类 `NSObject` 的类对象中也没有则进行消息转发（Message Forwarding）。
- `objc_msgSend` 会将方法的匹配的结果缓存在类对象的 `cache_t cache;` 中，优化之后查找相同方法的速度，但仍慢于静态绑定，不过也不至于是瓶颈；如果对查找速度极致追求则可使用纯 C 函数。
- 边界情况：

  - `objc_msgSend_stret`：如果待发送的消息要返回结构体，那么可交由此函数处理。只有当 CPU 的寄存器能够容纳得下消息返回类型时，这个函数才能处理此消息。若是返回值无法容纳于 CPU 寄存器中（比如返回的结构体太大了），那么就交由另一个函数执行派发。此时，那个函数会通过分配在栈上的某个变量来处理消息所返回的结构体。
  - `objc_msgSend_fpret`：如果消息返回的是浮点数，那么可交由此函数处理。在某些结构的 CPU 中调用函数时，需要对「浮点数寄存器（Floating-Point Register）」做特殊处理，也就是说，通常所用的 `objc_msgSend` 在这种情况下并不合适。这个函数是为了处理 x86 等架构 CPU 中某些令人稍觉惊讶的奇怪状况。（不会使用在 ARM 64 架构中）
  - `objc_msgSendSuper`：如果要给父类发送消息，例如 `[super message:parameter]`，那么就交由此函数处理。也有另外两个与 `objc_msgSend_stret` 和 `objc_msgSend_fpret` 等效的函数，用于处理发给 `super` 的相应的消息。

- Obj-C 每个类中都有以上原型函数表，`objc_msgSend` 等函数通过该表寻找应该执行的方法并跳至其实现（原型与 `objc_msgSend` 函数类似是为了利用尾调用优化 Tail-Call Optimization 技术，简化跳至实现的操作）。
- 如果某个函数的最后一项操作是调用另外一个函数，那么就可以运用「尾调用优化」技术。编译器会生成调转至另一函数所需的指令码，而且不会向调用堆栈中推入新的「栈帧 Frame Stack」。只有当某函数的最后一个操作仅仅是调用其他函数而不会将其返回值另作他用时，才能执行「尾调用优化」。如果不这样的话，每次调用 Obj-C 方法之前都需要需要为 `objc_msgSend` 准备栈帧（可以在栈追踪 Stack Trace）中看到这种栈帧）。此外，若是不优化，还会过早地发生「栈溢出（Stack Overflow）」现象。 -->
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html">Dissecting objc_msgSend on ARM64 - Mike Ash</a></li>
<li><a href="http://infocenter.arm.com/help/index.jsp">ARM Software development tools - arm.com</a></li>
<li><a href="https://stackoverflow.com/questions/27353096/1b-and-1f-in-gnu-assembly">1b and 1f in GNU assembly - StackOverflow</a></li>
<li><a href="https://clang.llvm.org/doxygen/Basic_2Targets_2ARM_8cpp_source.html">ARM.cpp - clang</a></li>
<li><a href="https://www.ibm.com/support/knowledgecenter/zh/SSXVZZ_13.1.0/com.ibm.xlcpp131.linux.doc/getstart/predef_macro_v10v12.html">预定义宏 - IBM</a></li>
<li><a href="../objects_in_obj-c/">Obj-C 中的对象 - kingcos</a></li>
<li><a href="../category_in_ios/">iOS 中的 Category - kingcos</a></li>
<li><a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/">Objective-C 消息发送与转发机制原理 - 杨萧玉</a></li>
</ul>
<h2 id="todo">TODO</h2>
<ul>
<li><input disabled="" type="checkbox"> 尾递归调用</li>
<li><input disabled="" type="checkbox"> 尝试逆向得到消息转发部分的步骤</li>
<li><input disabled="" type="checkbox"> 消息发送流程图</li>
<li><input disabled="" type="checkbox"> 尝试使用 Swift 实现整个过程</li>
</ul>

    </div>
    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>
        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="/posts/2019/category_in_ios/">
                <span class="button__icon">←</span>
                <span class="button__text">iOS 中的 Category</span>
              </a>
            </span>
          
          
            <span class="button next">
              <a href="/posts/2019/coding_with_vs_code/">
                <span class="button__text">与 Visual Studio Code 共舞</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    

    

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<table style="border: 0;">
  <tr>
  <td style="border: 0; width: 30%;">
    <img src='/img/about/1.jpg'>
  </td>
  <td style="border: 0;">
    <ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-9925978992661955"
     data-ad-slot="3213735320"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
  </td>
  </tr>
</table>



<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>


    
    
    <div>
      <div id="github-comment">
      </div>

      <script type="text/javascript">
        function getUtterances(isDark) {
          var utterances = document.createElement('script');
          utterances.type = 'text/javascript';
          utterances.async = true;
          utterances.setAttribute('issue-term', "pathname")
          utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
          utterances.setAttribute('label', "comments")
          isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
          utterances.crossorigin = 'anonymous';
          utterances.src = 'https://utteranc.es/client.js';

          return utterances
        }

        var themeToggle = document.querySelector(".theme-toggle")
        themeToggle.addEventListener("click", function () {
          var getTheme = window.localStorage && window.localStorage.getItem("theme")
          var divNode = document.getElementById('github-comment')
          while(divNode.hasChildNodes()) {
            divNode.removeChild(divNode.firstChild);
          }
          
          
          

          
          
          
          
          
          
          document.getElementById('github-comment').appendChild(getUtterances(getTheme !== "dark"))
        })

        var getTheme = window.localStorage && window.localStorage.getItem("theme")
        document.getElementById('github-comment').appendChild(getUtterances(getTheme === "dark"))
      </script>
    </div>
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">All rights reserved by kingcos.me</div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>



      
    </div>

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </body>
</html>
