<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>C/C&#43;&#43; 中的位域与共用体 :: iBlog</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Env     2019-08-17 首次提交 clang&#43;&#43;、macOS 10.14.4    Preface C/C&#43;&#43; 中有许多「奇技淫巧」来让开发者能够以效率更高的方式使用内存，这也是一些高级语言着力去避讳的一点，但这种能够直面内存细节的「踏实感」让我个人觉得非常安心。本文将简单涉及 C/C&#43;&#43; 中的位域（Bit Field）与共用体（Union）的概念。
位域 布尔类型 对于布尔（Boolean）类型，我们都知道其只有两种值：逻辑真或逻辑假。在 C 语言中，其实并没有严格意义上的布尔类型；而在 C&#43;&#43; 中，则诞生了专用的 bool 类型：
#include &amp;lt;iostream&amp;gt; using namespace std; int main() { bool foo = true; bool bar = 0; cout &amp;lt;&amp;lt; foo &amp;lt;&amp;lt; endl; // 1  cout &amp;lt;&amp;lt; bar &amp;lt;&amp;lt; endl; // 0  cout &amp;lt;&amp;lt; sizeof(foo) &amp;lt;&amp;lt; endl; // 1  cout &amp;lt;&amp;lt; sizeof(bar) &amp;lt;&amp;lt; endl; // 1  return 0; } 如上，在 C&#43;&#43; 中，true 和非 0 代表布尔类型中的逻辑真，false 和 0 代表逻辑假。bool 类型的值通常在 C&#43;&#43; 中占用一个字节长度（「通常」代表对于不同的编译器结果可能并非完全一致）。"/>
<meta name="keywords" content="kingcos.me,maimieng.comios,swift,objective-c,obj-c,objc,oc,geek,python,ruby,golang,go,apple,mac"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/bit_field_union_in_cpp/" />





<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C/C&#43;&#43; 中的位域与共用体"/>
<meta name="twitter:description" content="C/C&#43;&#43; 中有许多「奇技淫巧」来让开发者能够以效率更高的方式使用内存，这也是一些高级语言着力去避讳的一点，但这种能够直面内存细节的「踏实感」让我个人觉得非常安心。本文将简单涉及 C/C&#43;&#43; 中的位域与共用体的概念。"/>



<meta property="og:title" content="C/C&#43;&#43; 中的位域与共用体" />
<meta property="og:description" content="C/C&#43;&#43; 中有许多「奇技淫巧」来让开发者能够以效率更高的方式使用内存，这也是一些高级语言着力去避讳的一点，但这种能够直面内存细节的「踏实感」让我个人觉得非常安心。本文将简单涉及 C/C&#43;&#43; 中的位域与共用体的概念。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2019/bit_field_union_in_cpp/" />
<meta property="article:published_time" content="2019-08-17T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-08-17T00:00:00+00:00" /><meta property="og:site_name" content="iBlog" />




<script data-ad-client="ca-pub-9925978992661955" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  </head>
  <body class="">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">kingcos.me</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="post">
    <h2 class="post-title"><a href="/posts/2019/bit_field_union_in_cpp/">C/C++ 中的位域与共用体</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            2019-08-17
        </span>
      
      
      
        <span class="post-read-time">— 4 min read</span>
      
    </div>

    
      <span class="post-tags">
        
          #<a href="/tags/focus/">Focus</a>&nbsp;
        
          #<a href="/tags/c/c&#43;&#43;/">C/C&#43;&#43;</a>&nbsp;
        
          #<a href="/tags//">★</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      <table>
<thead>
<tr>
<th style="text-align:center">Date</th>
<th style="text-align:center">Notes</th>
<th style="text-align:center">Env</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2019-08-17</td>
<td style="text-align:center">首次提交</td>
<td style="text-align:center"><code>clang++</code>、macOS 10.14.4</td>
</tr>
</tbody>
</table>
<p><img src="/img/2019/bit_field_union_in_cpp/0.png" alt="0"></p>
<h2 id="preface">Preface</h2>
<p>C/C++ 中有许多「奇技淫巧」来让开发者能够以效率更高的方式使用内存，这也是一些高级语言着力去避讳的一点，但这种能够直面内存细节的「踏实感」让我个人觉得非常安心。本文将简单涉及 C/C++ 中的位域（Bit Field）与共用体（Union）的概念。</p>
<h2 id="位域">位域</h2>
<h3 id="布尔类型">布尔类型</h3>
<p>对于布尔（Boolean）类型，我们都知道其只有两种值：逻辑真或逻辑假。在 C 语言中，其实并没有严格意义上的布尔类型；而在 C++ 中，则诞生了专用的 <code>bool</code> 类型：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">bool</span> foo <span style="color:#f92672">=</span> true;
    <span style="color:#66d9ef">bool</span> bar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    cout <span style="color:#f92672">&lt;&lt;</span> foo <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> bar <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 0
</span><span style="color:#75715e"></span>
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(foo) <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(bar) <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>如上，在 C++ 中，<code>true</code> 和非 <code>0</code> 代表布尔类型中的逻辑真，<code>false</code> 和 <code>0</code> 代表逻辑假。<code>bool</code> 类型的值通常在 C++ 中占用一个字节长度（「通常」代表对于不同的编译器结果可能并非完全一致）。</p>
<h3 id="why">Why</h3>
<p>熟悉计算机存储单位的同学都应该知道，<code>bit</code> 正是存储 <code>0</code> 或 <code>1</code> 的单位，那么为什么 <code>bool</code> 要占用一字节而不是一位的内存空间呢？</p>
<blockquote>
<p>Because the CPU can&rsquo;t address anything smaller than a byte.</p>
<p>&ndash; Paul Tomblin, StackOverflow</p>
</blockquote>
<p>原因是：<strong>字节是 CPU 可处理的最小单位</strong>。而一个字节为 8 位，当我们使用到多个相关的 <code>bool</code> 类型时，有没有方法可以优化内存的占用呢？</p>
<h3 id="what">What</h3>
<p>位域（也称位段），是一种数据结构，即可以将数据以位为单位存储，节省内存空间。</p>
<p>我们尝试定义一个 <code>FooBarBaz</code> 位域结构，其中 <code>foo</code> &amp; <code>bar</code> 各占用 1 位，<code>baz</code> 占用 2 位。由于位数之和并没有占满 8 位，整个结构的大小使用一个字节就足够了：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span>
{
    <span style="color:#66d9ef">char</span> foo : <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">char</span> bar : <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">char</span> baz : <span style="color:#ae81ff">2</span>;
} FooBarBaz;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(FooBarBaz) <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>需要注意的是，在上述的位域结构里，这里我们使用了 <code>char</code> 类型。在 C99 标准中，位域被解释为特定位数的有符号或无符号整型，或者一些其它由实现定义的类型。<strong>因此其实这里的类型多是用作描述整个位域结构的大小，而非定义位中存储的数据类型。</strong></p>
<p>所以在小端模式的机器上，<code>char</code> 类型的一个字节中，假设为 <code>0b 0000 0110</code>，<code>foo</code> 为 <code>0</code>，<code>bar</code> 为 <code>1</code>，<code>baz</code> 为 <code>01</code>（从右往左）。</p>
<h3 id="how">How</h3>
<p>那么到底如何使用位域来存储多个 <code>bool</code> 值呢？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Demo</span>
{
    <span style="color:#66d9ef">struct</span>
    {
        <span style="color:#66d9ef">char</span> foo : <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">char</span> bar : <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">char</span> baz : <span style="color:#ae81ff">1</span>;
    } fooBarBaz;

<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> setFoo(<span style="color:#66d9ef">bool</span> foo)
    {
        fooBarBaz.foo <span style="color:#f92672">=</span> foo;
    }

    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">getFoo</span>()
    {
        <span style="color:#66d9ef">return</span> fooBarBaz.foo;
    }

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setBar</span>(<span style="color:#66d9ef">bool</span> bar)
    {
        fooBarBaz.bar <span style="color:#f92672">=</span> bar;
    }

    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">getBar</span>()
    {
        <span style="color:#66d9ef">return</span> fooBarBaz.bar;
    }

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setBaz</span>(<span style="color:#66d9ef">bool</span> baz)
    {
        fooBarBaz.baz <span style="color:#f92672">=</span> baz;
    }

    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">getBaz</span>()
    {
        <span style="color:#66d9ef">return</span> fooBarBaz.baz;
    }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    Demo d <span style="color:#f92672">=</span> Demo();
    d.setFoo(true);
    d.setBar(false);
    d.setBaz(true);

    cout <span style="color:#f92672">&lt;&lt;</span> d.getFoo() <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> d.getBar() <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 0
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> d.getBaz() <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// LLDB:
</span><span style="color:#75715e">// (lldb) p/t true
</span><span style="color:#75715e">// (bool) $0 = 0b00000001
</span><span style="color:#75715e">// (lldb) p/t false
</span><span style="color:#75715e">// (bool) $1 = 0b00000000
</span><span style="color:#75715e">// (lldb) p/t d.fooBarBaz
</span><span style="color:#75715e">// (Demo::(anonymous struct)) $2 = (foo = 0b0, bar = 0b0, baz = 0b0)
</span><span style="color:#75715e">// (lldb) p/t d.fooBarBaz
</span><span style="color:#75715e">// (Demo::(anonymous struct)) $3 = (foo = 0b1, bar = 0b0, baz = 0b1)
</span><span style="color:#75715e">// (lldb) p 0b00000001 == 0b1
</span><span style="color:#75715e">// (bool) $4 = true
</span><span style="color:#75715e">// (lldb) p 0b00000000 == 0b0
</span><span style="color:#75715e">// (bool) $5 = true
</span></code></pre></div><p>在 C++ 中 <code>true</code> 和 <code>false</code> 是整型十进制中的 <code>1</code> 和 <code>0</code>，整型在内存中占用一个字节，即 8 位，换算为二进制为 <code>0b 0000 0001</code>（即 <code>0b1</code>）和 <code>0b 0000 0000</code>（即 <code>0b0</code>），而 <code>foo</code>、<code>bar</code>、<code>baz</code> 各占一位，因此当赋值 <code>true</code> 和 <code>false</code> 时，将其各自的位置为 <code>1</code> 或 <code>0</code>，也就达到了使用一位来存储布尔类型的目的。</p>
<h2 id="共用体">共用体</h2>
<p>在 C/C++ 等其它语言中都有结构体这种数据结构，我们经常会定义结构体类型来存储多个相关变量，在内存中变量依次占据连续的内存空间。而 C/C++ 中的共用体中也可以存储多个相关变量，不同的是<strong>变量在内存中占用同一起点的内存空间</strong>。</p>
<p>我们定义一个 <code>FooBar</code> 共同体，其中有两个类型不同的变量，<code>int</code> 类型的 <code>foo</code> 和 <code>char</code> 类型的 <code>bar</code>。整个共用体结构的大小为其中最大元素的大小，即 <code>int</code> 的 4 个字节。由于共用用一块内存空间，当我们为 <code>foo</code> 赋值 <code>65</code> 时，<code>bar</code> 所占用的一个字节也被赋值了，因此最终输出了 <code>A</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">union</span> <span style="color:#a6e22e">FooBar</span>
{
    <span style="color:#66d9ef">int</span> foo;
    <span style="color:#66d9ef">char</span> bar;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(FooBar) <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 4
</span><span style="color:#75715e"></span>
    FooBar fbb;
    fbb.foo <span style="color:#f92672">=</span> <span style="color:#ae81ff">65</span>;

    cout <span style="color:#f92672">&lt;&lt;</span> fbb.foo <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 65
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> fbb.bar <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// A
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="位域与共用体">位域与共用体</h2>
<p>上面我们简单认识了位域与共用体各自的作用，但位域只能按位赋值，共用体中各自变量内存重叠用处也似乎有局限。那为何不将多个位共用一个变量大小的内存空间呢？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">union</span> <span style="color:#a6e22e">FooBar</span>
{
    <span style="color:#66d9ef">char</span> bits;

    <span style="color:#66d9ef">struct</span>
    {
        <span style="color:#66d9ef">char</span> foo : <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">char</span> bar : <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">char</span> baz : <span style="color:#ae81ff">1</span>;
    } fooBarBaz;
};
</code></pre></div><p>这里我们定义了一个 <code>FooBar</code> 共用体，虽然其中有两个变量，但根据共用体的定义，<code>bits</code> 将和位域 <code>fooBarBaz</code> 共享同一个字节的内存空间；而根据位域的描述，这一个字节的 8 位中，<code>foo</code>、<code>bar</code>、<code>baz</code> 各自占用一位。这样的好处是，比单一使用共用体更加直观，外界操作时却只需要访问 <code>bits</code> 即可。</p>
<p>那么如何只访问 <code>bits</code> 就可以操作三个不同的变量呢？我们要首先了解一下 <code>&amp;</code> 和 <code>|</code> 即按位与、按位或运算符。<code>&amp;</code> 按位与，即按位计算，只有同时为 <code>1</code> 时该位结果才为 <code>1</code>；<code>|</code> 按位或，即按位计算，只有同时为 <code>0</code> 时该位结果才为 <code>0</code>；另外还要知道左移 <code>&lt;&lt;</code>、右移 <code>&gt;&gt;</code>、取反码 <code>~</code> 运算符，左移即将二进制位整体向左移动，右移反之，取反码则根据 <code>0</code> 和 <code>1</code> 对立互取即可。</p>
<p>通过位域与共用体，以及上述运算符我们就可以实现了：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#define FooMask (1 &lt;&lt; 0) </span><span style="color:#75715e">// 0b 0000 0001
</span><span style="color:#75715e"></span><span style="color:#75715e">#define BarMask (1 &lt;&lt; 1) </span><span style="color:#75715e">// 0b 0000 0010
</span><span style="color:#75715e"></span><span style="color:#75715e">#define BazMask (1 &lt;&lt; 2) </span><span style="color:#75715e">// 0b 0000 0100
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Demo</span>
{
    FooBar fooBar;

<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> setFoo(<span style="color:#66d9ef">bool</span> foo)
    {
        <span style="color:#66d9ef">if</span> (foo)
        {
            fooBar.bits <span style="color:#f92672">|=</span> FooMask;
        }
        <span style="color:#66d9ef">else</span>
        {
            fooBar.bits <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>FooMask;
        }
    }

    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">getFoo</span>()
    {
        <span style="color:#66d9ef">return</span> fooBar.bits <span style="color:#f92672">&amp;</span> FooMask;
    }

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setBar</span>(<span style="color:#66d9ef">bool</span> bar)
    {
        <span style="color:#66d9ef">if</span> (bar)
        {
            fooBar.bits <span style="color:#f92672">|=</span> BarMask;
        }
        <span style="color:#66d9ef">else</span>
        {
            fooBar.bits <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>BarMask;
        }
    }

    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">getBar</span>()
    {
        <span style="color:#66d9ef">return</span> fooBar.bits <span style="color:#f92672">&amp;</span> BarMask;
    }

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setBaz</span>(<span style="color:#66d9ef">bool</span> baz)
    {
        <span style="color:#66d9ef">if</span> (baz)
        {
            fooBar.bits <span style="color:#f92672">|=</span> BazMask;
        }
        <span style="color:#66d9ef">else</span>
        {
            fooBar.bits <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>BazMask;
        }
    }

    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">getBaz</span>()
    {
        <span style="color:#66d9ef">return</span> fooBar.bits <span style="color:#f92672">&amp;</span> BazMask;
    }
};


<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(FooBar) <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>
    Demo d <span style="color:#f92672">=</span> Demo();
    d.setFoo(true);
    d.setBar(false);
    d.setBaz(true);

    cout <span style="color:#f92672">&lt;&lt;</span> d.getFoo() <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> d.getBar() <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 0
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> d.getBaz() <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>当然，第一次使用可能比较抽象，我们以一对 getter &amp; setter 为例说明下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setFoo</span>(<span style="color:#66d9ef">bool</span> foo)
{
    <span style="color:#66d9ef">if</span> (foo) <span style="color:#75715e">// 当 foo 为真时，我们需要将 foo 的二进制位置为 1
</span><span style="color:#75715e"></span>    {
        <span style="color:#75715e">// FooMask 是 foo 的掩码，即 1 &lt;&lt; 0，0b 0000 0001
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">// 此时我们需要仅将 bits 的最后一位置为 1，而不能更改其它位
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 因此这里选择需要与掩码逻辑或，保证其它位和 0 运算都能得到其原先值并将 foo 置为 1
</span><span style="color:#75715e"></span>        fooBar.bits <span style="color:#f92672">|=</span> FooMask;
    }
    <span style="color:#66d9ef">else</span> <span style="color:#75715e">// 当 foo 为假时，我们需要将 foo 的二进制位置为 0
</span><span style="color:#75715e"></span>    {
        <span style="color:#75715e">// 此时我们需要仅将 bits 的最后一位置为 0，而不能更改其它位
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 因此首先需要取掩码的反码，并进行逻辑与，保证其它位不变并将 foo 置为 0
</span><span style="color:#75715e"></span>        fooBar.bits <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>FooMask;
    }
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">getFoo</span>()
{
    <span style="color:#75715e">// 获取值时，我们仅需要特定位即可，因此与掩码逻辑与可将其它位置为 0，并将需要的位取出
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> fooBar.bits <span style="color:#f92672">&amp;</span> FooMask;
}
</code></pre></div><h2 id="reference">Reference</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/4626815/why-is-a-boolean-1-byte-and-not-1-bit-of-size">Why is a boolean 1 byte and not 1 bit of size? - StackOverflow</a></li>
<li><a href="https://stackoverflow.com/questions/3971085/how-does-a-bit-field-work-with-character-types">How does a bit field work with character types? - StackOverflow</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5">位段 - WikiPedia</a></li>
</ul>

    </div>
    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>
        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="/posts/2019/isa_in_objc/">
                <span class="button__icon">←</span>
                <span class="button__text">Obj-C 中的 isa 指针</span>
              </a>
            </span>
          
          
            <span class="button next">
              <a href="/posts/2019/link_map_file_in_xcode/">
                <span class="button__text">Xcode 中的 Link Map 文件</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    

    

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<table style="border: 0;">
  <tr>
  <td style="border: 0; width: 30%;">
    <img src='/img/about/1.jpg'>
  </td>
  <td style="border: 0;">
    <ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-9925978992661955"
     data-ad-slot="3213735320"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
  </td>
  </tr>
</table>



<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>


    
    
    <div>
      <div id="github-comment">
      </div>

      <script type="text/javascript">
        function getUtterances(isDark) {
          var utterances = document.createElement('script');
          utterances.type = 'text/javascript';
          utterances.async = true;
          utterances.setAttribute('issue-term', "pathname")
          utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
          utterances.setAttribute('label', "comments")
          isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
          utterances.crossorigin = 'anonymous';
          utterances.src = 'https://utteranc.es/client.js';

          return utterances
        }

        var themeToggle = document.querySelector(".theme-toggle")
        themeToggle.addEventListener("click", function () {
          var getTheme = window.localStorage && window.localStorage.getItem("theme")
          var divNode = document.getElementById('github-comment')
          while(divNode.hasChildNodes()) {
            divNode.removeChild(divNode.firstChild);
          }
          
          
          

          
          
          
          
          
          
          document.getElementById('github-comment').appendChild(getUtterances(getTheme !== "dark"))
        })

        var getTheme = window.localStorage && window.localStorage.getItem("theme")
        document.getElementById('github-comment').appendChild(getUtterances(getTheme === "dark"))
      </script>
    </div>
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">All rights reserved by kingcos.me</div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>



      
    </div>

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </body>
</html>
