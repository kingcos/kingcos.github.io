<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>C/C&#43;&#43; 中的位域与共用体 :: iBlog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Notes     2019-08-17 首次提交     Preface C/C&#43;&#43; 中有许多「奇技淫巧」来让开发者能够以效率更高的方式使用内存，这也是一些高级语言着力去避讳的一点，但这种能够直面内存细节的「踏实感」让我个人觉得非常安心。本文将简单涉及 C/C&#43;&#43; 中的位域（Bit Field）与共用体（Union）的概念。
位域 布尔类型 对于布尔（Boolean）类型，我们都知道其只有两种值：逻辑真或假。在 C 语言中，其实并没有严格意义上的布尔类型；而在 C&#43;&#43; 中，则诞生了专用的 bool 类型：
#include &amp;lt;iostream&amp;gt; using namespace std; int main() { bool foo = true; bool bar = 0; cout &amp;lt;&amp;lt; foo &amp;lt;&amp;lt; endl; // 1 cout &amp;lt;&amp;lt; bar &amp;lt;&amp;lt; endl; // 0 cout &amp;lt;&amp;lt; sizeof(foo) &amp;lt;&amp;lt; endl; // 1 cout &amp;lt;&amp;lt; sizeof(bar) &amp;lt;&amp;lt; endl; // 1 return 0; }  如上，在 C&#43;&#43; 中，true 和非 0 代表布尔类型中的逻辑真，false 和 0 代表逻辑假。bool 类型的值通常在 C&#43;&#43; 中占用一个字节长度（「通常」代表对于不同的编译器结果可能并非完全一致）。"/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/bit_field_union_in_cpp/" />


<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/green.css">



<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="/img/favicon/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="C/C&#43;&#43; 中的位域与共用体 :: iBlog — " />
<meta name="twitter:description" content="Date Notes Notes     2019-08-17 首次提交     Preface C/C&#43;&#43; 中有许多「奇技淫巧」来让开发者能够以效率更高的方式使用内存，这也是一些高级语言着力去避讳的一点，但这种能够直面内存细节的「踏实感」让我个人觉得非常安心。本文将简单涉及 C/C&#43;&#43; 中的位域（Bit Field）与共用体（Union）的概念。
位域 布尔类型 对于布尔（Boolean）类型，我们都知道其只有两种值：逻辑真或假。在 C 语言中，其实并没有严格意义上的布尔类型；而在 C&#43;&#43; 中，则诞生了专用的 bool 类型：
#include &amp;lt;iostream&amp;gt; using namespace std; int main() { bool foo = true; bool bar = 0; cout &amp;lt;&amp;lt; foo &amp;lt;&amp;lt; endl; // 1 cout &amp;lt;&amp;lt; bar &amp;lt;&amp;lt; endl; // 0 cout &amp;lt;&amp;lt; sizeof(foo) &amp;lt;&amp;lt; endl; // 1 cout &amp;lt;&amp;lt; sizeof(bar) &amp;lt;&amp;lt; endl; // 1 return 0; }  如上，在 C&#43;&#43; 中，true 和非 0 代表布尔类型中的逻辑真，false 和 0 代表逻辑假。bool 类型的值通常在 C&#43;&#43; 中占用一个字节长度（「通常」代表对于不同的编译器结果可能并非完全一致）。" />
<meta name="twitter:site" content="/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="C/C&#43;&#43; 中的位域与共用体 :: iBlog — ">
<meta property="og:description" content="Date Notes Notes     2019-08-17 首次提交     Preface C/C&#43;&#43; 中有许多「奇技淫巧」来让开发者能够以效率更高的方式使用内存，这也是一些高级语言着力去避讳的一点，但这种能够直面内存细节的「踏实感」让我个人觉得非常安心。本文将简单涉及 C/C&#43;&#43; 中的位域（Bit Field）与共用体（Union）的概念。
位域 布尔类型 对于布尔（Boolean）类型，我们都知道其只有两种值：逻辑真或假。在 C 语言中，其实并没有严格意义上的布尔类型；而在 C&#43;&#43; 中，则诞生了专用的 bool 类型：
#include &amp;lt;iostream&amp;gt; using namespace std; int main() { bool foo = true; bool bar = 0; cout &amp;lt;&amp;lt; foo &amp;lt;&amp;lt; endl; // 1 cout &amp;lt;&amp;lt; bar &amp;lt;&amp;lt; endl; // 0 cout &amp;lt;&amp;lt; sizeof(foo) &amp;lt;&amp;lt; endl; // 1 cout &amp;lt;&amp;lt; sizeof(bar) &amp;lt;&amp;lt; endl; // 1 return 0; }  如上，在 C&#43;&#43; 中，true 和非 0 代表布尔类型中的逻辑真，false 和 0 代表逻辑假。bool 类型的值通常在 C&#43;&#43; 中占用一个字节长度（「通常」代表对于不同的编译器结果可能并非完全一致）。" />
<meta property="og:url" content="/posts/2019/bit_field_union_in_cpp/" />
<meta property="og:site_name" content="C/C&#43;&#43; 中的位域与共用体" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-08-17 00:00:00 &#43;0000 UTC" />











</head>
<body class="">


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    iBlog
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About &amp; AMA</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About &amp; AMA</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/2019/bit_field_union_in_cpp/">C/C++ 中的位域与共用体</a></h1>
  <div class="post-meta">
    <span class="post-date">
      2019-08-17
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/focus/">Focus</a>&nbsp;
    
    #<a href="/tags/c/c&#43;&#43;/">C/C&#43;&#43;</a>&nbsp;
    
    #<a href="/tags/">🚧</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Notes</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2019-08-17</td>
<td align="center">首次提交</td>
<td align="center"></td>
</tr>
</tbody>
</table>

<h2 id="preface">Preface</h2>

<p>C/C++ 中有许多「奇技淫巧」来让开发者能够以效率更高的方式使用内存，这也是一些高级语言着力去避讳的一点，但这种能够直面内存细节的「踏实感」让我个人觉得非常安心。本文将简单涉及 C/C++ 中的位域（Bit Field）与共用体（Union）的概念。</p>

<h2 id="位域">位域</h2>

<h3 id="布尔类型">布尔类型</h3>

<p>对于布尔（Boolean）类型，我们都知道其只有两种值：逻辑真或假。在 C 语言中，其实并没有严格意义上的布尔类型；而在 C++ 中，则诞生了专用的 <code>bool</code> 类型：</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main()
{
    bool foo = true;
    bool bar = 0;

    cout &lt;&lt; foo &lt;&lt; endl; // 1
    cout &lt;&lt; bar &lt;&lt; endl; // 0

    cout &lt;&lt; sizeof(foo) &lt;&lt; endl; // 1
    cout &lt;&lt; sizeof(bar) &lt;&lt; endl; // 1

    return 0;
}
</code></pre>

<p>如上，在 C++ 中，<code>true</code> 和非 <code>0</code> 代表布尔类型中的逻辑真，<code>false</code> 和 <code>0</code> 代表逻辑假。<code>bool</code> 类型的值通常在 C++ 中占用一个字节长度（「通常」代表对于不同的编译器结果可能并非完全一致）。</p>

<h3 id="why">Why</h3>

<p>熟悉计算机存储单位的同学都应该知道，<code>bit</code> 正是存储 <code>0</code> 或 <code>1</code> 的单位，那么为什么 <code>bool</code> 要占用一字节而不是一位的内存空间呢？</p>

<blockquote>
<p>Because the CPU can&rsquo;t address anything smaller than a byte.</p>

<p>&ndash; Paul Tomblin, StackOverflow</p>
</blockquote>

<p>原因是：字节是 CPU 可处理的最小单位。而一个字节为 8 位，当我们使用到多个相关的 <code>bool</code> 类型时，有没有方法可以优化内存的占用呢？</p>

<h3 id="what">What</h3>

<p>位域（也称位段），是一种数据结构，即可以将数据以位为单位存储，节省内存空间。</p>

<p>我们尝试定义一个 <code>FooBarBaz</code> 位域结构，其中 <code>foo</code> &amp; <code>bar</code> 各占用 1 位，<code>baz</code> 占用 2 位。由于位数之和并没有占满 8 位，整个结构的大小使用一个字节就足够了：</p>

<pre><code class="language-cpp">struct
{
    char foo : 1;
    char bar : 1;
    char baz : 2;
} FooBarBaz;

int main()
{
    cout &lt;&lt; sizeof(FooBarBaz) &lt;&lt; endl; // 1

    return 0;
}
</code></pre>

<p>需要注意的是，在上述的位域结构里，这里我们使用了 <code>char</code> 类型。在 C99 标准中，位域被解释为特定位数的有符号或无符号整型，或者一些其它由实现定义的类型。<strong>因此其实这里的类型多是用作描述整个位域结构的大小，而非定义位中存储的数据类型。</strong></p>

<p>所以在小端模式的机器上，<code>char</code> 类型的一个字节中，假设为 <code>0b 0000 0110</code>，<code>foo</code> 为 <code>0</code>，<code>bar</code> 为 <code>1</code>，<code>baz</code> 为 <code>01</code>（从右往左）。</p>

<h3 id="how">How</h3>

<p>那么到底如何使用位域来存储多个 <code>bool</code> 值呢？</p>

<pre><code class="language-cpp">class Demo
{
    struct
    {
        char foo : 1;
        char bar : 1;
        char baz : 1;
    } fooBarBaz;

public:
    void setFoo(bool foo)
    {
        fooBarBaz.foo = foo;
    }

    bool getFoo()
    {
        return fooBarBaz.foo;
    }

    void setBar(bool foo)
    {
        fooBarBaz.bar = foo;
    }

    bool getBar()
    {
        return fooBarBaz.bar;
    }

    void setBaz(bool foo)
    {
        fooBarBaz.baz = foo;
    }

    bool getBaz()
    {
        return fooBarBaz.baz;
    }
};

int main()
{
    Demo d = Demo();
    d.setFoo(true);
    d.setBar(false);
    d.setBaz(true);

    cout &lt;&lt; d.getFoo() &lt;&lt; endl; // 1
    cout &lt;&lt; d.getBar() &lt;&lt; endl; // 0
    cout &lt;&lt; d.getBaz() &lt;&lt; endl; // 1

    return 0;
}

// LLDB:
// (lldb) p/t true
// (bool) $0 = 0b00000001
// (lldb) p/t false
// (bool) $1 = 0b00000000
// (lldb) p/t d.fooBarBaz
// (Demo::(anonymous struct)) $0 = (foo = 0b0, bar = 0b0, baz = 0b0)
// (lldb) p/t d.fooBarBaz
// (Demo::(anonymous struct)) $3 = (foo = 0b1, bar = 0b0, baz = 0b1)
// (lldb) p 0b00000001 == 0b1
// (bool) $2 = true
// (lldb) p 0b00000000 == 0b0
// (bool) $3 = true
</code></pre>

<p>在 C++ 中 <code>true</code> 和 <code>false</code> 是整型十进制中的 <code>1</code> 和 <code>0</code>，整型在内存中占用一个字节，即 8 位，换算为二进制为 <code>0b 0000 0001</code>（即 <code>0b1</code>）和 <code>0b 0000 0000</code>（即 <code>0b0</code>），而 <code>foo</code>、<code>bar</code>、<code>baz</code> 各占一位，因此当赋值 <code>true</code> 和 <code>false</code> 时，将其各自的位置为 <code>1</code> 或 <code>0</code>，也就达到了使用一位来存储布尔类型的目的。</p>

<h2 id="共用体">共用体</h2>

<h2 id="位域与共用体">位域与共用体</h2>

<p>我们要首先了解一下 <code>&amp;</code> 和 <code>|</code> 即按位与、按位或运算。<code>&amp;</code> 按位与，即按位计算，只有同时为 <code>1</code> 时该位结果才为 <code>1</code>；<code>|</code> 按位或，即按位计算，只有同时为 <code>0</code> 时该位结果才为 <code>0</code>。</p>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="https://stackoverflow.com/questions/4626815/why-is-a-boolean-1-byte-and-not-1-bit-of-size">Why is a boolean 1 byte and not 1 bit of size? - StackOverflow</a></li>
<li><a href="https://stackoverflow.com/questions/3971085/how-does-a-bit-field-work-with-character-types">How does a bit field work with character types? - StackOverflow</a></li>
<li><a href="https://zh.wikipedia.org/wiki/位段">位段 - WikiPedia</a></li>
</ul>

  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span
        class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      
      <span class="button next">
        <a href="/posts/2019/block_in_obj-c/">
          <span class="button__text">Obj-C 中的 Block</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo="kingcos/kingcos.github.io"
            issue-term="pathname"
            label="comments"
            theme="github-dark"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2019 · <a href="http://github.com/kingcos">kingcos</a></span>
      </div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>





  
</div>

</body>
</html>
