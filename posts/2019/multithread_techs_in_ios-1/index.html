<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>iOS 多线程技术实践之 pthreads :: iBlog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Swift Xcode     2019-03-08 首次提交 4.2 10.1     在 iOS 中的多线程（Multithreading）技术通常有以下几种实现方式：pthreads、NSThread、GCD、NSOperation。首先，我们来一起看一看 pthreads。
 Preface  POSIX Threads, usually referred to as pthreads, is an execution model that exists independently from a language, as well as a parallel execution model. It allows a program to control multiple different flows of work that overlap in time. Each flow of work is referred to as a thread, and creation and control over these flows is achieved by making calls to the POSIX Threads API."/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/multithread_techs_in_ios-1/" />


<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/green.css">



<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="/img/favicon/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="iOS 多线程技术实践之 pthreads :: iBlog — " />
<meta name="twitter:description" content="Date Notes Swift Xcode     2019-03-08 首次提交 4.2 10.1     在 iOS 中的多线程（Multithreading）技术通常有以下几种实现方式：pthreads、NSThread、GCD、NSOperation。首先，我们来一起看一看 pthreads。
 Preface  POSIX Threads, usually referred to as pthreads, is an execution model that exists independently from a language, as well as a parallel execution model. It allows a program to control multiple different flows of work that overlap in time. Each flow of work is referred to as a thread, and creation and control over these flows is achieved by making calls to the POSIX Threads API." />
<meta name="twitter:site" content="/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="iOS 多线程技术实践之 pthreads :: iBlog — ">
<meta property="og:description" content="Date Notes Swift Xcode     2019-03-08 首次提交 4.2 10.1     在 iOS 中的多线程（Multithreading）技术通常有以下几种实现方式：pthreads、NSThread、GCD、NSOperation。首先，我们来一起看一看 pthreads。
 Preface  POSIX Threads, usually referred to as pthreads, is an execution model that exists independently from a language, as well as a parallel execution model. It allows a program to control multiple different flows of work that overlap in time. Each flow of work is referred to as a thread, and creation and control over these flows is achieved by making calls to the POSIX Threads API." />
<meta property="og:url" content="/posts/2019/multithread_techs_in_ios-1/" />
<meta property="og:site_name" content="iOS 多线程技术实践之 pthreads" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-03-08 00:00:00 &#43;0000 UTC" />











</head>
<body class="">


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    iBlog
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/2019/multithread_techs_in_ios-1/">iOS 多线程技术实践之 pthreads</a></h1>
  <div class="post-meta">
    <span class="post-date">
      2019-03-08
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/practice/">Practice</a>&nbsp;
    
    #<a href="/tags/ios/">iOS</a>&nbsp;
    
    #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
    
    #<a href="/tags/swift/">Swift</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Swift</th>
<th align="center">Xcode</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2019-03-08</td>
<td align="center">首次提交</td>
<td align="center">4.2</td>
<td align="center">10.1</td>
</tr>
</tbody>
</table>

<blockquote>
<p>在 iOS 中的多线程（Multithreading）技术通常有以下几种实现方式：pthreads、<code>NSThread</code>、GCD、<code>NSOperation</code>。首先，我们来一起看一看 pthreads。</p>
</blockquote>

<h2 id="preface">Preface</h2>

<blockquote>
<p>POSIX Threads, usually referred to as pthreads, is an execution model that exists independently from a language, as well as a parallel execution model. It allows a program to control multiple different flows of work that overlap in time. Each flow of work is referred to as a thread, and creation and control over these flows is achieved by making calls to the POSIX Threads API.</p>

<p>&ndash; POSIX Threads, Wikipedia</p>

<p>译：</p>

<p>POSIX（Portable Operating System Interface of UNIX，可移植操作系统接口）线程，即 pthreads，是一种不依赖于语言的执行模型，也称作并行（Parallel）执行模型。其允许一个程序控制多个时间重叠的不同工作流。每个工作流即为一个线程，通过调用 POSIX 线程 API 创建并控制这些流。</p>
</blockquote>

<p>如上所述，pthreads，即 POSIX Threads（后简称 pthreads）是一套跨平台的多线程 API。由 C 语言编写，在 Obj-C 中，<code>#import &lt;pthread.h&gt;</code> 即可引入 pthreads 相关的 API。但也由于是纯 C 的 API，使用起来不够友好，也需要手动管理线程的整个生命周期。</p>

<h2 id="pthread-create"><code>pthread_create</code></h2>

<p>pthreads 使用 <code>int pthread_create(pthread_t _Nullable * _Nonnull __restrict, const pthread_attr_t * _Nullable __restrict, void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable __restrict);</code> 来创建线程。<code>_Nullable</code> 和 <code>_Nonnull</code> 是 Obj-C 桥接 Swift 可选（Optional）类型的标志；<code>__restrict</code> 是 C99 标准引入的关键字，类似于 <code>restrict</code>，可以用在指针声明处，用于告诉编译器只有该指针本身才能修改指向的内容，便于编译器优化。去掉这些不影响函数本身的标志，补全参数名，即 <code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</code>。下面将简单分析下该函数的四个参数。</p>

<p>其中第一个参数是 <code>pthread_t *thread</code>。关于该参数实际意义，一种指整型（Integer）四字节的线程 ID，另一种指包含值和其他的抽象结构体，这种抽象有助于在一个进程（Process）中实现扩展到数千个线程，后者也可以称为 <code>pthread</code> 的句柄（Handle）。在 Obj-C 中，<code>pthread_t</code> 属于后者，其本质是 <code>_opaque_pthread_t</code>，一个不透明类型（Opaque Type）的结构体，即一种外界只需要知道其存在，而无需关心内部实现细节的数据类型。在函数中，该参数是作为指针传入的，总之我们可以简单将这个参数理解为线程的引用即可，通过它能找到线程的 ID 或者其他信息。</p>

<pre><code class="language-c">// sys/_pthread/_pthread_t.h
typedef __darwin_pthread_t pthread_t;

// sys/_pthread/_pthread_types.h
typedef struct _opaque_pthread_t *__darwin_pthread_t;

// sys/_pthread/_pthread_types.h
struct _opaque_pthread_t {
	long __sig;
	struct __darwin_pthread_handler_rec  *__cleanup_stack;
	char __opaque[__PTHREAD_SIZE__];
};
</code></pre>

<p>第二个参数是 <code>const pthread_attr_t *attr</code>。<code>pthread_attr_t</code> 本质也是一个不透明类型的结构体。可以使用 <code>int pthread_attr_init(pthread_attr_t *);</code> 初始化该结构体。该参数为 <code>NULL</code> 时将使用默认属性来创建线程。</p>

<pre><code class="language-c">// sys/_pthread/_pthread_attr_t.h
typedef __darwin_pthread_attr_t pthread_attr_t;

// sys/_pthread/_pthread_types.h
typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;

// sys/_pthread/_pthread_types.h
struct _opaque_pthread_attr_t {
	long __sig;
	char __opaque[__PTHREAD_ATTR_SIZE__];
};
</code></pre>

<p>最后两个参数是 <code>void *(*start_routine) (void *), void *arg</code>。<code>start_routine()</code> 是新线程运行时所执行的函数，<code>arg</code> 是传入 <code>start_routine()</code> 的参数。当 <code>start_routine()</code> 执行终止或者线程被明确杀死，线程也将会终止。</p>

<p>返回值是 <code>int</code> 类型，当返回 <code>0</code> 时，创建成功，否则将返回错误码。</p>

<pre><code class="language-objectivec">#import &quot;POSIXThreadManager.h&quot;

#import &lt;pthread.h&gt;

void * run_for_pthread_create_demo(void * arg) {
    // 打印参数 &amp; 当前线程 __opaque 属性的地址
    printf(&quot;%s (%p) is running.\n&quot;, arg, &amp;pthread_self()-&gt;__opaque);
    exit(2);
}

@implementation POSIXThreadManager

+ (void)pthread_create_demo {
    // 声明 thread_1 &amp; thread_2
    pthread_t thread_1, thread_2;
    
    // 创建 thread_1
    int result_1 = pthread_create(&amp;thread_1, NULL, run_for_pthread_create_demo, &quot;thread_1&quot;);
    
    // 打印 thread_1 创建函数返回值 &amp; __opaque 属性的地址
    printf(&quot;result_1 - %d - %p\n&quot;, result_1, &amp;thread_1-&gt;__opaque);
    
    // 检查线程是否创建成功
    if (result_1 != 0) {
        perror(&quot;pthread_create thread_1 error.&quot;);
        // 线程创建失败退出码为 1
        exit(1);
    }
    
    // 创建 thread_2
    int result_2 = pthread_create(&amp;thread_2, NULL, run_for_pthread_create_demo, &quot;thread_2&quot;);
    
    // 打印 thread_2 创建函数返回值 &amp; __opaque 属性的地址
    printf(&quot;result_2 - %d - %p\n&quot;, result_2, &amp;thread_2-&gt;__opaque);
    
    if (result_2 != 0) {
        perror(&quot;pthread_create thread_2 error.&quot;);
        // 线程创建失败退出码为 1
        exit(1);
    }
    
    // sleep(1);
    
    // 主线程退出码为 3
    exit(3);
}

@end
</code></pre>

<p>这段程序简单地创建了两个子线程，带上程序本身的主线程，其实一共有三个线程。当某个线程执行到 <code>exit()</code> 时，整个程序停止。尝试多运行几次就能发现，每次的输出结果都不太一样。<code>OUTPUT-1</code> 中，主线程先抢在了子线程之前输出，之后子线程输出，最后主线程结束了程序；<code>OUTPUT-2</code> 中，主线程和子线程轮流输出，最后被子线程结束了程序。<code>OUTPUT-3</code> 中，<code>thread_2</code> 还没执行完，就被主线程结束了程序，所以没有 <code>thread_2</code> 的输出。</p>

<pre><code>// OUTPUT-1:
result_1 - 0 - 0x700002479010 // 主线程输出
result_2 - 0 - 0x7000024fc010 // 主线程输出
thread_1 (0x700002479010) is running. // thread_1 输出
thread_2 (0x7000024fc010) is running. // thread_2 输出
Program ended with exit code: 3 // 主线程结束程序

// OUTPUT-2:
result_1 - 0 - 0x70000ff41010 // 主线程输出
thread_1 (0x70000ff41010) is running. // thread_1 输出
result_2 - 0 - 0x70000ffc4010 // 主线程输出
thread_2 (0x70000ffc4010) is running. // thread_2 输出
Program ended with exit code: 2 // 子线程结束程序

// OUTPUT-3:
result_1 - 0 - 0x700005914010 // 主线程输出
result_2 - 0 - 0x700005997010 // 主线程输出
thread_1 (0x700005914010) is running. // thread_1 输出
Program ended with exit code: 3 // 主线程结束程序
</code></pre>

<h2 id="pthread-join"><code>pthread_join</code></h2>

<p>那如何保证主线程在子线程还没有结束的时候，不执行完呢？首先可以想到的就是让主线程休息一会儿。在 <code>exit(3);</code> 之前加一句 <code>sleep(1);</code> 让主线程休眠一秒钟，这样子线程的程序就有足够的时间执行完。但这样真的好吗？如果子线程的执行时间小于一秒，那么我们的时间就浪费了；而当大于一秒时，这个方法就没用了。这时候就需要另外一个函数，<code>int pthread_join(pthread_t , void * _Nullable * _Nullable)</code>，即 <code>int pthread_join(pthread_t thread, void **retval);</code>，其作用是阻塞当前线程运行，直到参数线程 <code>thread</code> 终止，参数 <code>retval</code> 保存了线程函数的返回值。与 <code>pthread_create</code> 一样，当返回 <code>0</code> 时，参与成功，否则将返回错误码。</p>

<pre><code class="language-objectivec">#import &quot;POSIXThreadManager.h&quot;

#import &lt;pthread.h&gt;

void * run_for_pthread_join_demo(void * arg) {
    // 返回参数
    // return arg;
    pthread_exit(arg);
}

@implementation POSIXThreadManager

+ (void)pthread_join_demo {
    // 声明 thread_1 &amp; thread_2
    pthread_t thread_1, thread_2;
    
    // 创建 thread_1
    int result_1 = pthread_create(&amp;thread_1, NULL, run_for_pthread_join_demo, &quot;thread_1&quot;);
    
    // 打印 thread_1 创建函数返回值 &amp; __opaque 属性的地址
    printf(&quot;result_1 - %d - %p\n&quot;, result_1, &amp;thread_1-&gt;__opaque);
    
    // 检查线程是否创建成功
    if (result_1 != 0) {
        perror(&quot;pthread_create thread_1 error.&quot;);
        // 线程创建失败退出码为 1
        exit(1);
    }
    
    // 创建 thread_2
    int result_2 = pthread_create(&amp;thread_2, NULL, run_for_pthread_join_demo, &quot;thread_2&quot;);
    
    // 打印 thread_2 创建函数返回值 &amp; __opaque 属性的地址
    printf(&quot;result_2 - %d - %p\n&quot;, result_2, &amp;thread_2-&gt;__opaque);
    
    if (result_2 != 0) {
        perror(&quot;pthread_create thread_2 error.&quot;);
        // 线程创建失败退出码为 1
        exit(1);
    }
    
    void * result;
    if (pthread_join(thread_1, &amp;result) != 0) {
        perror(&quot;pthread_join thread_1 error.&quot;);
    }
    printf(&quot;%s\n&quot;, result);
    
    if (pthread_join(thread_2, &amp;result) != 0) {
        perror(&quot;pthread_join thread_2 error.&quot;);
    }
    printf(&quot;%s\n&quot;, result);
    
    // 主线程退出码为 3
    exit(3);
}

@end
</code></pre>

<p>这样主线程就能等待子线程全部执行完毕后再接着执行了，而且通过第二个参数也可以使我们在线程间进行数据传输。</p>

<pre><code>// OUTPUT:
result_1 - 0 - 0x70000c9e5010 // 主线程输出
result_2 - 0 - 0x70000ca68010 // 主线程输出
thread_1 // 主线程拿到了子线程调用函数的返回值并输出
thread_2 // 主线程拿到了子线程调用函数的返回值并输出
Program ended with exit code: 3 // 主线程结束程序
</code></pre>

<h2 id="互斥锁-mutex">互斥锁（Mutex）</h2>

<p>多线程的并行计算加快了速度，但这使得多个线程的管理变得复杂。其中一个问题便是，如果两个线程同时对同一个资源操作，情况将变得不可控。举个例子，从 0 开始数数，数到 10 为止，如果有 5 个线程，则平均每个线程只需要数 2 个即可完成。</p>

<pre><code class="language-objectivec">#import &quot;POSIXThreadManager.h&quot;

#import &lt;pthread.h&gt;

// 起始数
const int START_NUMBER = 0;
// 结束数
const int END_NUMBER = 10;
// 线程数
const int THREAD_NUMBER = 5;
// 平均每个线程的任务数
const int COUNT_PER_THREAD = (END_NUMBER - START_NUMBER) / THREAD_NUMBER;

// 当前数，初始为起始数
int current_count = START_NUMBER;

void * run_for_thread_conflict_demo(void * arg) {
    for (int i = 0; i &lt; COUNT_PER_THREAD; i++) {
        // 人为休息线程 1 秒
        sleep(1);
        current_count += 1;
        printf(&quot;Now - %d\n&quot;, current_count);
    }
    return NULL;
}

@implementation POSIXThreadManager

+ (void)thread_conflict_demo {
    // 线程数组
    pthread_t thread[THREAD_NUMBER];
    void * result;
    
    printf(&quot;Start number: %d\nEnd number: %d\nThread number: %d\n&quot;, START_NUMBER, END_NUMBER, THREAD_NUMBER);
    
    for (int i = 0; i &lt; THREAD_NUMBER; i++) {
        // 循环创建线程
        if (pthread_create(&amp;thread[i], NULL, run_for_thread_conflict_demo, NULL) != 0) {
            printf(&quot;pthread_create thread_%d error.&quot;, i);
            exit(1);
        }
    }
    
    for (int i = 0; i &lt; THREAD_NUMBER; i++) {
        // 循环 Join 线程，防止主线程提前结束
        pthread_join(thread[i], &amp;result);
    }
    
    // 打印最终的数
    printf(&quot;Result count - %d\n&quot;, current_count);
}

@end

// OUTPUT:
// Start number: 0
// End number: 10
// Thread number: 5
// Now - 1
// Now - 5
// Now - 4
// Now - 2
// Now - 3
// Now - 6
// Now - 6
// Now - 7
// Now - 8
// Now - 9
// Result count - 9
// Program ended with exit code: 0
</code></pre>

<p>结果怎么会是 9，是不是谁少数了 1 个呢？数一下输出语句可以发现并没有少数，而却有两个 <code>6</code>。其实问题就在于 <code>sleep(1);</code>，在一个线程休息的时候可能被另外一个线程抢先访问了同样的资源，而导致出错重复数数，虽然次数都是一定的，但最终的结果却少了。当然，因为这个示例程序是个很简单的 Demo，我们加入了人为的休息 <code>sleep()</code> 函数，然而其实每条程序语句的执行都是需要时间的，仍然有可能和其他线程同时访问一块资源。解决这一问题的方法就是加锁（Lock）。计算机科学中的锁不止互斥锁一种，限于主题，我将之后一篇文章中专门讲述锁相关的概念。最基本的锁就是互斥锁，即在不希望被同时多个线程访问的代码前加锁，执行完后再解锁，他们的执行是互斥的。</p>

<pre><code class="language-objectivec">// 创建互斥锁
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void * run_for_thread_conflict_demo(void * arg) {
    for (int i = 0; i &lt; COUNT_PER_THREAD; i++) {
        // 人为休息线程 1 秒
        sleep(1);
        
        // 加锁
        pthread_mutex_lock(&amp;mutex);
        
        current_count += 1;
        printf(&quot;Now - %d\n&quot;, current_count);
        
        // 解锁
        pthread_mutex_unlock(&amp;mutex);
    }
    return NULL;
}

// Start number: 0
// End number: 10
// Thread number: 5
// Now - 1
// Now - 2
// Now - 3
// Now - 4
// Now - 5
// Now - 6
// Now - 7
// Now - 8
// Now - 9
// Now - 10
// Result count - 10
// Program ended with exit code: 0
</code></pre>

<h2 id="信号量-semaphore">信号量（Semaphore）</h2>

<p>信号量的概念很难从字面直接理解，常用的比喻是信号灯：一段马路（即资源）对车辆（即线程）的承载量是有限的，当承载量达到限度时，红灯会亮起阻止进入；当承载量未达到时，绿灯会亮起允许进入。关于互斥锁和信号量的区别，简而言之，互斥锁通常处理多个线程对一个资源的争夺，意味着总是按顺序获取和释放。而信号量则应当用在一个任务到另一个任务的信号，其中的任务要么发送信号要么等待信号。我在 <a href="https://github.com/kingcos/WWDCHelper">WWDCHelper</a> 中也用到了信号量，函数返回的数据需要等待下载任务完成后才可以得到，所以当下载任务完成后发送信号，等待的信号收到后便继续前行。</p>

<p>我们创建两个线程，线程 2 中人为等待 1 秒代表处理任务，任务完成后发送信号，线程 1 中等待信号，等信号发出再执行自己的任务：</p>

<pre><code class="language-objectivec">#import &quot;POSIXThreadManager.h&quot;

#import &lt;pthread.h&gt;
#import &lt;sys/semaphore.h&gt;

// 声明信号量
sem_t * semaphore;

void * run_for_semaphore_demo_1(void * arg) {
    // 等待信号
    if (sem_wait(semaphore) != 0) {
        perror(&quot;sem_wait error.&quot;);
        exit(1);
    }
    
    printf(&quot;Running - %s.\n&quot;, arg);
    
    pthread_exit(NULL);
}

void * run_for_semaphore_demo_2(void * arg) {
    printf(&quot;Running - %s.\n&quot;, arg);
    
    sleep(1);
    // 发送信号
    if (sem_post(semaphore) != 0) {
        perror(&quot;sem_post error.&quot;);
        exit(1);
    }
    
    pthread_exit(NULL);
}

@implementation POSIXThreadManager

+ (void)semaphore_demo {
    // sem_init 初始化匿名信号量在 macOS 中已被废弃
    // semaphore = sem_init(&amp;semaphore, 0, 0);
    semaphore = sem_open(&quot;sem&quot;, 0, 0);
    
    pthread_t thread_1, thread_2;
    void * result;
    
    if (pthread_create(&amp;thread_1, NULL, run_for_semaphore_demo_1, &quot;Thread 1&quot;) != 0) {
        perror(&quot;pthread_create thread_1 error.&quot;);
        exit(1);
    }
    
    if (pthread_create(&amp;thread_2, NULL, run_for_semaphore_demo_2, &quot;Thread 2&quot;) != 0) {
        perror(&quot;pthread_create thread_2 error.&quot;);
        exit(1);
    }
    
    pthread_join(thread_1, &amp;result);
    pthread_join(thread_2, &amp;result);
}

@end
</code></pre>

<h2 id="one-more-thing">One more thing&hellip;</h2>

<p>上面我们在 Obj-C 中简单尝试了 pthreads 几个 API，那么它们能用 Swift 实现吗？答案是肯定的，但因为 Swift 没有指针的概念，存在了许多 <code>Unsafe</code> 开头的指针类型，告知我们其中可能存在隐患。</p>

<pre><code class="language-swift">import Foundation

class PThreadsManager {
    class func tryCreate() {
        var thread_1, thread_2: pthread_t?
        
        if pthread_create(&amp;thread_1, nil, runForCreate, encode(&quot;Thread 1&quot;)) != 0 {
            print(&quot;pthread_create thread_1 error.&quot;)
            exit(1)
        }
        
        if pthread_create(&amp;thread_2, nil, runForCreate, encode(&quot;Thread 2&quot;)) != 0 {
            print(&quot;pthread_create thread_2 error.&quot;)
            exit(1)
        }
        
        sleep(1)
        exit(3)
    }
    
    class func tryJoin() {
        var thread_1, thread_2: pthread_t?
        
        if pthread_create(&amp;thread_1, nil, runForJoin, encode(&quot;Thread 1&quot;)) != 0 {
            print(&quot;pthread_create thread_1 error.&quot;)
            exit(1)
        }
        
        if pthread_create(&amp;thread_2, nil, runForJoin, encode(&quot;Thread 2&quot;)) != 0 {
            print(&quot;pthread_create thread_2 error.&quot;)
            exit(1)
        }
        
        if pthread_join(thread_1!, nil) != 0 {
            print(&quot;pthread_join thread_1 error.&quot;)
            exit(1)
        }
        
        if pthread_join(thread_2!, nil) != 0 {
            print(&quot;pthread_join thread_2 error.&quot;)
            exit(1)
        }
    }
    
    class func tryMutex() {
        var thread_1, thread_2: pthread_t?
        
        if pthread_mutex_init(&amp;mutex, nil) != 0 {
            print(&quot;pthread_mutex_init error.&quot;)
        }
        
        if pthread_create(&amp;thread_1, nil, runForMutex, encode(&quot;Thread 1&quot;)) != 0 {
            print(&quot;pthread_create thread_1 error.&quot;)
            exit(1)
        }

        if pthread_create(&amp;thread_2, nil, runForMutex, encode(&quot;Thread 2&quot;)) != 0 {
            print(&quot;pthread_create thread_2 error.&quot;)
            exit(1)
        }

        if pthread_join(thread_1!, nil) != 0 {
            print(&quot;pthread_join thread_1 error.&quot;)
            exit(1)
        }

        if pthread_join(thread_2!, nil) != 0 {
            print(&quot;pthread_join thread_2 error.&quot;)
            exit(1)
        }

        print(&quot;Result count \(current_count)&quot;)
    }
    
    class func trySemaphore() {
        var thread_1, thread_2: pthread_t?
        
        if pthread_create(&amp;thread_1, nil, runForSemaphore1, encode(&quot;Thread 1&quot;)) != 0 {
            print(&quot;pthread_create thread_1 error.&quot;)
            exit(1)
        }
        
        if pthread_create(&amp;thread_2, nil, runForSemaphore2, encode(&quot;Thread 2&quot;)) != 0 {
            print(&quot;pthread_create thread_2 error.&quot;)
            exit(1)
        }
        
        if pthread_join(thread_1!, nil) != 0 {
            print(&quot;pthread_join thread_1 error.&quot;)
            exit(1)
        }
        
        if pthread_join(thread_2!, nil) != 0 {
            print(&quot;pthread_join thread_2 error.&quot;)
            exit(1)
        }
    }
}

let START_NUMBER = 0
let END_NUMBER = 10
let THREAD_NUMBER = 2
let COUNT_PER_THREAD = (END_NUMBER - START_NUMBER) / THREAD_NUMBER

var current_count = START_NUMBER
var mutex = pthread_mutex_t()

var sem: [CChar] = &quot;sem&quot;.cString(using: String.Encoding.utf8)!
var semaphore = sem_open(&amp;sem, 0, 0, 0)

func runForCreate(_ context: UnsafeMutableRawPointer) -&gt; UnsafeMutableRawPointer? {
    print(&quot;\(decode(context) as String) is running.&quot;)
    exit(2)
}

func runForJoin(_ context: UnsafeMutableRawPointer) -&gt; UnsafeMutableRawPointer? {
    print(&quot;\(decode(context) as String) is running.&quot;)
    exit(2)
}

func runForMutex(_ context: UnsafeMutableRawPointer) -&gt; UnsafeMutableRawPointer? {
    for _ in 0..&lt;COUNT_PER_THREAD {
        sleep(1)
        pthread_mutex_lock(&amp;mutex)

        current_count += 1
        print(&quot;Now - \(current_count)&quot;)
        
        pthread_mutex_unlock(&amp;mutex)
    }
    pthread_exit(nil)
}

func runForSemaphore1(_ context: UnsafeMutableRawPointer) -&gt; UnsafeMutableRawPointer? {
    if sem_wait(semaphore) != 0 {
        perror(&quot;sem_wait error.&quot;)
        exit(1)
    }
    print(&quot;runForSemaphore1&quot;)
    pthread_exit(nil)
}

func runForSemaphore2(_ context: UnsafeMutableRawPointer) -&gt; UnsafeMutableRawPointer? {
    sleep(1)
    
    if sem_post(semaphore) != 0 {
        print(&quot;sem_post error.&quot;)
        exit(1)
    }
    
    print(&quot;runForSemaphore2&quot;)
    pthread_exit(nil)
}

class Box&lt;T&gt; {
    let value: T
    
    init(_ value: T) {
        self.value = value
    }
}

private func decode&lt;T&gt;(_ memory: UnsafeMutableRawPointer) -&gt; T {
    let unmanaged = Unmanaged&lt;Box&lt;T&gt;&gt;.fromOpaque(memory)
    defer { unmanaged.release() }
    return unmanaged.takeUnretainedValue().value
}

private func encode&lt;T&gt;(_ t: T) -&gt; UnsafeMutableRawPointer {
    return Unmanaged.passRetained(Box(t)).toOpaque()
}
</code></pre>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="http://man7.org/linux/man-pages/man3/pthread_create.3.html">man - pthread_create</a></li>
<li><a href="https://www.ibm.com/support/knowledgecenter/en/ssw_ibm_i_71/apis/concep17.htm">IBM - Thread ID vs. Pthread Handle (pthread_t)</a></li>
<li><a href="https://www.cs.nmsu.edu/~jcook/Tools/pthreads/library.html">NMSU - The Pthreads Library</a></li>
<li><a href="https://github.com/kingcos/Perspective/issues/71">Translation - [译]在 Objective-C API 中指定可空性</a></li>
<li><a href="https://en.wikipedia.org/wiki/Restrict">Wikipedia - restrict</a></li>
<li><a href="https://stackoverflow.com/questions/34519/what-is-a-semaphore">StackOverflow - What is a semaphore?</a></li>
<li><a href="https://barrgroup.com/Embedded-Systems/How-To/RTOS-Mutex-Semaphore">Michael Barr - Mutexes and Semaphores Demystified</a></li>
<li><a href="https://see.stanford.edu/materials/icsppcs107/23-Concurrency-Examples.pdf">Stanford - Thread and Semaphore Examples</a></li>
<li><a href="https://github.com/kingcos/WWDCHelper">WWDCHelper</a></li>
<li><a href="https://stackoverflow.com/questions/1413785/sem-init-on-os-x">StackOverflow - sem_init on OS X</a></li>
<li><a href="https://github.com/ZewoGraveyard/POSIX">GitHub - ZewoGraveyard/POSIX</a></li>
</ul>

  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span
        class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      <span class="button previous">
        <a href="/posts/2019/nsobject_in_ios/">
          <span class="button__icon">←</span>
          <span class="button__text">iOS 中的 NSObject</span>
        </a>
      </span>
      
      
      <span class="button next">
        <a href="/posts/2019/obj-c_swift_bridge_tips/">
          <span class="button__text">Objective-C 与 Swift 桥接中的坑</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo="kingcos/kingcos.github.io"
            issue-term="pathname"
            label="comments"
            theme="github-dark"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2019 · <a href="http://github.com/kingcos">kingcos</a></span>
      </div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>





  
</div>

</body>
</html>
