<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>iOS 中的库与框架 :: iBlog — github.com/kingcos</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes     2019-09-14 首次提交    Preface 随着软件工程的发展，很多我们需要的功能前人都已经很好地实现了，为了提高效率避免重复建设，这些功能实现的代码被封装为代码库，有时也称框架。我们只需要在用到的时候通过依赖管理工具将它们以适当的方式引入即可。本文将简单聊聊 iOS 中的库与框架相关概念。
基本概念 在切入正题之前，我们先来达成一些共识。
不管是老派 Obj-C 还是新秀 Swift，它们的本质都是编译型语言。对于编译型语言，源代码会首先经由编译器编译为目标文件，链接器再将多个目标文件链接为可执行文件。针对链接阶段，主要分为静态链接与动态链接。
静态，即 Static。按照字面意思，静态即一旦确定，就不再容易改变。静态链接，即在链接阶段，直接将多个目标文件链接为一个文件。而静态库就可以理解为共同编译为一个目标文件的源代码集合。
动态，即 Dynamic。按照字面意思，动态即推迟到运行时动态地决议。动态链接，即在运行时才将各个部分组合形成完整的程序。而动态库就可以理解为支持动态链接方式的源代码集合。
静态链接的好处是，运行时不再额外需要时间动态链接；坏处则是由于链接的粒度是目标文件，那么可能会链接了没有使用到的函数，会造成可执行文件过大；而且当某一个目标文件的源代码改动时，那么所有依赖该目标文件的静态库都需要重新编译；动态链接则解决了静态链接的空间浪费与重复编译问题，比如在 iOS 中，系统库采用了 dyld_shared_cache 动态链接，这样其它程序就无需再将系统库重复链接，当 iOS 系统更新时也无需将所有 app 重新编译。而在移动端开发中，app 的启动时间与包体积大小将是一个权衡问题，值得我们侧重与考量。
另外，虽然广义上的库（Library）与框架（Framework）含义是类似的，但在 iOS 开发中，官方将这两个概念进行了区分，因此下文中我们会明确两个词的使用。
Cocoa Touch Static Library 我们先从 Xcode 中能够直接创建的 Cocoa Touch Static Library 说起：
Cocoa Touch Static Library 即静态库。iOS 上狭义的静态库，即只包含编译后代码的 .a 文件。我们创建一个 oc-static-lib 的静态库，为其默认提供的 oc_static_lib 类添加 foo 方法，并添加一个 NSObject 的分类，实现 &#43;load 和 foo 方法："/>
<meta name="keywords" content="ios,swift,objective-c,obj-c,objc,oc,geek,python,ruby,golang,go,apple,mac"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/libraries_in_ios/" />





<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="iOS 中的库与框架"/>
<meta name="twitter:description" content="随着软件工程的发展，很多我们需要的功能前人都已经很好地实现了，为了提高效率避免重复建设，这些功能实现的代码被封装为代码库，有时也称框架。我们只需要在用到的时候通过依赖管理工具将它们以适当的方式引入即可。本文将简单聊聊 iOS 中的库与框架相关概念。"/>



<meta property="og:title" content="iOS 中的库与框架" />
<meta property="og:description" content="随着软件工程的发展，很多我们需要的功能前人都已经很好地实现了，为了提高效率避免重复建设，这些功能实现的代码被封装为代码库，有时也称框架。我们只需要在用到的时候通过依赖管理工具将它们以适当的方式引入即可。本文将简单聊聊 iOS 中的库与框架相关概念。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2019/libraries_in_ios/" />
<meta property="article:published_time" content="2019-09-14T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-09-14T00:00:00+00:00" /><meta property="og:site_name" content="iBlog" />






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">iBlog</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="post">
    <h2 class="post-title"><a href="/posts/2019/libraries_in_ios/">iOS 中的库与框架</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            2019-09-14
        </span>
      
      
      
        <span class="post-read-time">— 4 min read</span>
      
    </div>

    
      <span class="post-tags">
        
          #<a href="/tags/focus/">Focus</a>&nbsp;
        
          #<a href="/tags/ios/">iOS</a>&nbsp;
        
          #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
        
          #<a href="/tags/swift/">Swift</a>&nbsp;
        
          #<a href="/tags//">🚧</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2019-09-14</td>
<td align="center">首次提交</td>
</tr>
</tbody>
</table>

<p><img src="/img/2019/libraries_in_ios/0.png" alt="0" /></p>

<h2 id="preface">Preface</h2>

<p>随着软件工程的发展，很多我们需要的功能前人都已经很好地实现了，为了提高效率避免重复建设，这些功能实现的代码被封装为代码库，有时也称框架。我们只需要在用到的时候通过依赖管理工具将它们以适当的方式引入即可。本文将简单聊聊 iOS 中的库与框架相关概念。</p>

<h2 id="基本概念">基本概念</h2>

<p>在切入正题之前，我们先来达成一些共识。</p>

<p>不管是老派 Obj-C 还是新秀 Swift，它们的本质都是编译型语言。对于编译型语言，源代码会首先经由编译器编译为目标文件，链接器再将多个目标文件链接为可执行文件。针对链接阶段，主要分为静态链接与动态链接。</p>

<p><strong>静态</strong>，即 Static。按照字面意思，静态即一旦确定，就不再容易改变。静态链接，即在链接阶段，直接将多个目标文件链接为一个文件。而静态库就可以理解为共同编译为一个目标文件的源代码集合。</p>

<p><strong>动态</strong>，即 Dynamic。按照字面意思，动态即推迟到运行时动态地决议。动态链接，即在运行时才将各个部分组合形成完整的程序。而动态库就可以理解为支持动态链接方式的源代码集合。</p>

<p>静态链接的好处是，运行时不再额外需要时间动态链接；坏处则是由于链接的粒度是目标文件，那么可能会链接了没有使用到的函数，会造成可执行文件过大；而且当某一个目标文件的源代码改动时，那么所有依赖该目标文件的静态库都需要重新编译；动态链接则解决了静态链接的空间浪费与重复编译问题，比如在 iOS 中，系统库采用了 dyld_shared_cache 动态链接，这样其它程序就无需再将系统库重复链接，当 iOS 系统更新时也无需将所有 app 重新编译。而在移动端开发中，app 的启动时间与包体积大小将是一个权衡问题，值得我们侧重与考量。</p>

<p>另外，虽然广义上的库（Library）与框架（Framework）含义是类似的，但在 iOS 开发中，官方将这两个概念进行了区分，因此下文中我们会明确两个词的使用。</p>

<h2 id="cocoa-touch-static-library">Cocoa Touch Static Library</h2>

<p>我们先从 Xcode 中能够直接创建的 Cocoa Touch Static Library 说起：</p>

<p><img src="/img/2019/libraries_in_ios/1.png" alt="1" /></p>

<p>Cocoa Touch Static Library 即静态库。iOS 上狭义的静态库，即只包含编译后代码的 <code>.a</code> 文件。我们创建一个 oc-static-lib 的静态库，为其默认提供的 <code>oc_static_lib</code> 类添加 <code>foo</code> 方法，并添加一个 <code>NSObject</code> 的分类，实现 +load 和 <code>foo</code> 方法：</p>

<pre><code class="language-objectivec">// oc_static_lib.h

#import &lt;Foundation/Foundation.h&gt;

@interface oc_static_lib : NSObject

- (void)foo;

@end

// oc_static_lib.m

#import &quot;oc_static_lib.h&quot;

@implementation oc_static_lib

- (void)foo {
    NSLog(@&quot;%@ - %@&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd));
}

@end

// NSObject+OC_Static_Lib.h

#import &lt;Foundation/Foundation.h&gt;

NS_ASSUME_NONNULL_BEGIN

@interface NSObject (OC_Static_Lib)

- (void)foo;

@end

NS_ASSUME_NONNULL_END

// NSObject+OC_Static_Lib.m

#import &quot;NSObject+OC_Static_Lib.h&quot;

@implementation NSObject (OC_Static_Lib)

+ (void)load {
    NSLog(@&quot;%@ - %@&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd));
}

- (void)foo {
    NSLog(@&quot;%@ - %@&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd));
}

@end
</code></pre>

<p>需要注意的是我们需要将新创建的 <code>.h</code> 加入到 Xcode - Targets - Build Phases - Copy Files 中，这样外界才能通过引入该头文件来访问其中的内容：</p>

<p><img src="/img/2019/libraries_in_ios/2.png" alt="2" /></p>

<blockquote>
<p>⚠️</p>

<p>这里我们的目标设备选择的是模拟器，所以默认编译后的 <code>.a</code> 文件也将只适用于模拟器架构（x86_64），为了同时能够真机运行和模拟器调试，通常会使用 <code>lipo</code> 命令将多种架构的 <code>.a</code> 文件进行合并为胖二进制（Fat-Binary）文件。</p>
</blockquote>

<h3 id="obj-c-工程引入-obj-c-静态库">Obj-C 工程引入 Obj-C 静态库</h3>

<p><img src="/img/2019/libraries_in_ios/3.png" alt="3" /></p>

<p>我们将 oc-static-lib 编译后的 <code>.a</code> 与 <code>.h</code> 一起拖入 Obj-C 工程，即可使用 <code>#import &quot;&quot;</code> 来引入并调用（需要注意的是：静态库中如果存在分类，需要添加 <code>-ObjC</code> 作为 Other Linker Flags，详见 <a href="/posts/2019/+load_in_ios/">iOS 中的 +load 方法</a>一文）：</p>

<blockquote>
<p><strong>Tips</strong></p>

<p>在 C/C++ 中，为了更加清晰化声明与实现，代码需要分别写在 <code>.h</code>（头文件）和 <code>.c</code> / <code>.cpp</code>（实现文件）中。这样的好处是，开发者可以无需额外的访问控制符即可将需要暴露在外界的声明放置在头文件中即可，外界使用时通过 <code>#include</code>。Obj-C/C++ 也延续了这一传统，不同的是实现文件的后缀分别为 <code>.m</code> 和 <code>.mm</code>，并为了避免重复引用推出了 <code>#import</code>。</p>

<p><code>#include</code> 和 <code>#import</code> 后面都可以加 <code>&lt;XXX.h&gt;</code> 或 <code>&quot;XXX.h&quot;</code>。通常来说加 <code>&quot;&quot;</code> 的头文件优先从本地当前文件目录查找，其中也可以包含相对路径，即 <code>#import &quot;oc-static-lib/oc_static_lib.h&quot;</code> / <code>#import &quot;NSObject+OC_Static_Lib.h&quot;</code> 都是支持的；而加 <code>&lt;&gt;</code> 的头文件则会使得编译器优先到系统目录下全局查找。</p>
</blockquote>

<h3 id="swift-工程引入-swift-静态库">Swift 工程引入 Swift 静态库</h3>

<p>在 Xcode 9 之后，Swift 也支持了静态库。与 Obj-C 不同，Swift 没有头文件的概念，因此我们需要将暴露给外界的类和函数等使用 <code>public</code> 修饰。编译后的 Swift 静态库也是 <code>.a</code> 文件，但不同的是多了 <code>.swiftmodule</code> 以及 <code>.swiftdoc</code>：</p>

<pre><code class="language-shell">➜  Debug-iphonesimulator tree
.
├── libswift-static-lib.a
└── swift_static_lib.swiftmodule
    ├── x86_64.swiftdoc
    └── x86_64.swiftmodule

1 directory, 3 files
</code></pre>

<p><code>.swiftmodule</code> 包含了序列化过的 AST（抽象语法树，Abstract Syntax Tree），可能也包含 SIL（Swift 中间语言，Swift Intermediate Language），我们可以将其理解为类似 C 语言库或框架中头文件的二进制格式文件；<code>.swiftdoc</code> 则是 Swift 文档注释生成的二进制文件，由 <code>Serialization::writeDocToStream()</code> 生成，因此并非是必要的。由于 Swift 的 Module 机制，我们需要将 Xcode - Targets - Build Settings - Swift Compiler - Search Paths - Import Paths 中引入：</p>

<p><img src="/img/2019/libraries_in_ios/4.png" alt="4" /></p>

<p>这样我们才能在 Swift 工程中正常使用：</p>

<pre><code class="language-swift">import UIKit
import swift_static_lib

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.

        swift_static_lib().foo()
    }
}
</code></pre>

<h3 id="obj-c-工程引入-swift-静态库">Obj-C 工程引入 Swift 静态库</h3>

<p>为了「提拔」新秀，Swift 支持与 Obj-C 混编，然而混编下的各种情况就会变得十分特殊。在同一个工程下 Swift 文件与 Obj-C 文件混编时，Xcode 会提示我们创建桥接头文件 <code>&lt;PROJECT_NAME&gt;-Bridging-Header.h</code>，我们可以将需要暴露给 Swift 的 Obj-C 代码在该桥接文件中引入；而 Obj-C 代码中希望使用 Swift 中的相关定义时，可以引入自动生成但不可见的 <code>&lt;PROJECT_NAME&gt;-Swift.h</code>，另外需要注意的是，暴露给 Obj-C 的类或函数等需要使用 <code>@objc</code> 或 <code>dynamic</code> 修饰，前者不能决定函数最终派发方式，而后者则为动态派发。</p>

<p>Swift 静态库也可以自动生成 <code>&lt;PROJECT_NAME&gt;-Swift.h</code>，但其并没有和最终产物 <code>.a</code> 放置在一起：</p>

<pre><code class="language-shell">➜  Build tree
.
├── Intermediates.noindex
│   ├── XCBuildData
│   │   ├── BuildDescriptionCacheIndex-039e2a7cd1451855448cd617c2c79f0d
│   │   ├── PIFCache
│   │   │   ├── project
│   │   │   │   ├── PROJECT@v8_mod=1568563268_hash=b6565d7e8bfe8171a813e95698ec414f-json
│   │   │   │   └── PROJECT@v8_mod=1568563366_hash=b6565d7e8bfe8171a813e95698ec414f-json
│   │   │   ├── target
│   │   │   │   ├── TARGET@v8_hash=9ED714DD9D72F2357197BC1BE00B9838-json
│   │   │   │   └── TARGET@v8_hash=B7634C70FA7FEB002C1D5B331F68AC57-json
│   │   │   └── workspace
│   │   │       ├── WORKSPACE@v8_mod=1568563268_hash=039e2a7cd1451855448cd617c2c79f0d_subobjects=359C431B6A9412A0DAB608A7B5E1B797-json
│   │   │       └── WORKSPACE@v8_mod=1568563268_hash=039e2a7cd1451855448cd617c2c79f0d_subobjects=FD7A1155808C379D6684AA719075DE4E-json
│   │   ├── a9f77306ac684b2857e1d38ab0444728-desc.xcbuild
│   │   ├── a9f77306ac684b2857e1d38ab0444728-manifest.xcbuild
│   │   ├── b87f53f8de8d4ad786bada5baea76917-desc.xcbuild
│   │   ├── b87f53f8de8d4ad786bada5baea76917-manifest.xcbuild
│   │   └── build.db
│   └── swift_static_lib.build
│       └── Debug-iphonesimulator
│           └── swift_static_lib.build
│               ├── DerivedSources
│               │   └── swift_static_lib-Swift.h ⬅️
│               ├── Objects-normal
│               │   └── x86_64
│               │       ├── swift_static_lib-OutputFileMap.json
│               │       ├── swift_static_lib-Swift.h
│               │       ├── swift_static_lib-master.swiftdeps
│               │       ├── swift_static_lib-master.swiftdeps~
│               │       ├── swift_static_lib-master.swiftdeps~moduleonly
│               │       ├── swift_static_lib.LinkFileList
│               │       ├── swift_static_lib.d
│               │       ├── swift_static_lib.dia
│               │       ├── swift_static_lib.o
│               │       ├── swift_static_lib.swiftdeps
│               │       ├── swift_static_lib.swiftdeps~
│               │       ├── swift_static_lib.swiftdoc
│               │       ├── swift_static_lib.swiftmodule
│               │       ├── swift_static_lib~partial.swiftdoc
│               │       └── swift_static_lib~partial.swiftmodule
│               ├── Script-841C800C232E981E007DF25D.sh
│               ├── all-product-headers.yaml
│               ├── swift_static_lib-all-non-framework-target-headers.hmap
│               ├── swift_static_lib-all-target-headers.hmap
│               ├── swift_static_lib-generated-files.hmap
│               ├── swift_static_lib-own-target-headers.hmap
│               ├── swift_static_lib-project-headers.hmap
│               └── swift_static_lib.hmap
└── Products
    └── Debug-iphonesimulator
        ├── include
        │   └── swift_static_lib
        │       ├── module.modulemap
        │       └── swift_static_lib-Swift.h
        ├── libswift_static_lib.a
        └── swift_static_lib.swiftmodule
            ├── x86_64.swiftdoc
            └── x86_64.swiftmodule

17 directories, 41 files
</code></pre>

<p>因此我们可以将以下脚本添加到 Xcode - Targets - Build Phases - New Run Script Phase 中，这样每次构建即可将 <code>&lt;PROJECT_NAME&gt;-Swift.h</code> 一并生成：</p>

<pre><code class="language-shell">// Powered by https://paul-samuels.com/blog/2018/01/14/swift-static-library-in-objective-c/

target_dir=${BUILT_PRODUCTS_DIR}/include/${PRODUCT_MODULE_NAME}/

# Ensure the target include path exists
mkdir -p ${target_dir}

# Copy any file that looks like a Swift generated header to the include path
cp ${DERIVED_SOURCES_DIR}/*-Swift.h ${target_dir}
</code></pre>

<p>之后我们需要将生成的产物放 swift_static_lib 文件中一起拖到 Obj-C 工程中（这里可以反选「Add to targets」选项）：</p>

<pre><code class="language-shell">➜  swift_static_lib tree
.
├── include
│   └── swift_static_lib
│       └── swift_static_lib-Swift.h
├── libswift_static_lib.a
└── swift_static_lib.swiftmodule
    ├── x86_64.swiftdoc
    └── x86_64.swiftmodule

3 directories, 4 files
</code></pre>

<p>之后我们将 <code>.a</code> 拖拽到 Xcode - General - Link Binary With Libraries（或 Xcode - Targets - Build Phases - Link Binary With Libraries）中：</p>

<p><img src="/img/2019/libraries_in_ios/5.png" alt="5" /></p>

<p>最后再将 Xcode - Targets - Build Settings - Header Search Paths &amp; Library Search Paths 添加上 <code>.a</code> 的父级路径 <code>$(PROJECT_DIR)/oc-demo-project/swift_static_lib</code> 即可：</p>

<p><img src="/img/2019/libraries_in_ios/6.png" alt="6" /></p>

<p>这样，在 Obj-C 工程中通过 <code>#import &quot;swift_static_lib-Swift.h&quot;</code> 即可使用到 swift_static_lib 中暴露给 Obj-C 的类或函数等了。</p>

<h3 id="swift-工程引入-obj-c-静态库">Swift 工程引入 Obj-C 静态库</h3>

<h2 id="cocoa-touch-framework">Cocoa Touch Framework</h2>

<ul class="task-list">
<li>TODO:</li>
<li><label><input type="checkbox" disabled class="task-list-item"> @import</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> use_framework</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> Module Map</label></li>
</ul>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="https://book.douban.com/subject/1436811/">Linkers and Loaders</a></li>
<li><a href="../../2018/dyld_shared_cache/">谈谈 iOS 中的 dyld_shared_cache - kingcos</a></li>
<li><a href="/posts/2019/+load_in_ios/">iOS 中的 +load 方法 - kingcos</a></li>
<li><a href="https://forums.swift.org/t/whats-in-the-file-of-swiftmodule-how-to-open-it/1032">what’s in the file of .swiftmodule?how to open it?</a></li>
<li><a href="https://forums.swift.org/t/looking-for-documentation-insight-on-swiftdoc/6869">Looking for documentation/insight on .swiftdoc</a></li>
<li><a href="https://forums.swift.org/t/swift-static-libraries-dont-copy-generated-objective-c-header/19816">Swift static libraries don’t copy generated Objective-C header</a></li>
<li><a href="https://stackoverflow.com/questions/29580438/use-swift-library-in-objc">Use Swift Library in ObjC - StackOverflow</a></li>
<li><a href="https://paul-samuels.com/blog/2018/01/14/swift-static-library-in-objective-c/">Swift static library in Objective-C - Paul Samuels</a></li>
</ul>

    </div>
    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>
        <div class="pagination__buttons">
          
          
            <span class="button next">
              <a href="/posts/2019/&#43;load_in_ios/">
                <span class="button__text">iOS 中的 &#43;load 方法</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    

    

    
    
    <div>
      <div id="github-comment">
      </div>

      <script type="text/javascript">
        function getUtterances(isDark) {
          var utterances = document.createElement('script');
          utterances.type = 'text/javascript';
          utterances.async = true;
          utterances.setAttribute('issue-term', "pathname")
          utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
          utterances.setAttribute('label', "comments")
          isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
          utterances.crossorigin = 'anonymous';
          utterances.src = 'https://utteranc.es/client.js';

          return utterances
        }

        var themeToggle = document.querySelector(".theme-toggle")
        themeToggle.addEventListener("click", function () {
          var getTheme = window.localStorage && window.localStorage.getItem("theme")
          var divNode = document.getElementById('github-comment')
          while(divNode.hasChildNodes()) {
            divNode.removeChild(divNode.firstChild);
          }
          
          
          

          
          
          
          
          
          
          document.getElementById('github-comment').appendChild(getUtterances(getTheme !== "dark"))
        })

        var getTheme = window.localStorage && window.localStorage.getItem("theme")
        document.getElementById('github-comment').appendChild(getUtterances(getTheme === "dark"))
      </script>
    </div>
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">Powered by github.com/kingcos</div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </body>
</html>
