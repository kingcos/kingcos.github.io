<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>iOS 中的库与框架 :: iBlog — github.com/kingcos</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes     2019-09-14 首次提交，持续更新完善   2019-09-22 持续更新完善，适配 Xcode 11    Preface 随着软件工程的发展，很多我们需要的功能前人都已经很好地实现了，为了提高效率避免重复建设，这些功能实现的代码被封装为代码库，有时也称框架。我们只需要在用到的时候通过依赖管理工具将它们以适当的方式引入即可。本文将简单聊聊 iOS 中的库与框架相关概念。
基本概念 在切入正题之前，我们先来达成一些共识。
不管是老派 Obj-C 还是新秀 Swift，它们的本质都是编译型语言。对于编译型语言，源代码会首先经由编译器编译为目标文件，链接器再将多个目标文件链接为可执行文件。针对链接阶段，主要分为静态链接与动态链接。
静态，即 Static。按照字面意思，静态即一旦确定，就不再容易改变。静态链接，即在链接阶段，直接将多个目标文件链接为一个文件。而静态库就可以理解为共同编译为一个目标文件的源代码集合。
动态，即 Dynamic。按照字面意思，动态即推迟到运行时动态地决议。动态链接，即在运行时才将各个部分组合形成完整的程序。而动态库就可以理解为支持动态链接方式的源代码集合。
静态链接的好处是，运行时不再额外需要时间动态链接；坏处则是由于链接的粒度是目标文件，那么可能会链接了没有使用到的函数，会造成可执行文件过大；而且当某一个目标文件的源代码改动时，那么所有依赖该目标文件的静态库都需要重新编译；动态链接则解决了静态链接的空间浪费与重复编译问题，比如在 iOS 中，系统库采用了 dyld_shared_cache 动态链接，这样其它程序就无需再将系统库重复链接，当 iOS 系统更新时也无需将所有 app 重新编译。而在移动端开发中，app 的启动时间与包体积大小将是一个权衡问题，值得我们侧重与考量。
另外，虽然广义上的库（Library）与框架（Framework）含义是类似的，但在 iOS 开发中，官方将这两个概念进行了区分，因此下文中我们会明确两个词的使用。
Cocoa Touch Static Library 我们先从 Xcode 中能够直接创建的 Cocoa Touch Static Library 说起（注意，在 Xcode 11 中，这里已经变成 Framework 与 Library，更加清晰）：
Cocoa Touch Static Library 即静态库。iOS 上狭义的静态库，即只包含编译后代码的 ."/>
<meta name="keywords" content="ios,swift,objective-c,obj-c,objc,oc,geek,python,ruby,golang,go,apple,mac"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/libraries_in_ios/" />





<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="iOS 中的库与框架"/>
<meta name="twitter:description" content="随着软件工程的发展，很多我们需要的功能前人都已经很好地实现了，为了提高效率避免重复建设，这些功能实现的代码被封装为代码库，有时也称框架。我们只需要在用到的时候通过依赖管理工具将它们以适当的方式引入即可。本文将简单聊聊 iOS 中的库与框架相关概念。"/>



<meta property="og:title" content="iOS 中的库与框架" />
<meta property="og:description" content="随着软件工程的发展，很多我们需要的功能前人都已经很好地实现了，为了提高效率避免重复建设，这些功能实现的代码被封装为代码库，有时也称框架。我们只需要在用到的时候通过依赖管理工具将它们以适当的方式引入即可。本文将简单聊聊 iOS 中的库与框架相关概念。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2019/libraries_in_ios/" />
<meta property="article:published_time" content="2019-09-14T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-09-14T00:00:00+00:00" /><meta property="og:site_name" content="iBlog" />






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">iBlog</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="post">
    <h2 class="post-title"><a href="/posts/2019/libraries_in_ios/">iOS 中的库与框架</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            2019-09-14
        </span>
      
      
      
        <span class="post-read-time">— 9 min read</span>
      
    </div>

    
      <span class="post-tags">
        
          #<a href="/tags/focus/">Focus</a>&nbsp;
        
          #<a href="/tags/ios/">iOS</a>&nbsp;
        
          #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
        
          #<a href="/tags/swift/">Swift</a>&nbsp;
        
          #<a href="/tags//">🚧</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2019-09-14</td>
<td align="center">首次提交，持续更新完善</td>
</tr>

<tr>
<td align="center">2019-09-22</td>
<td align="center">持续更新完善，适配 Xcode 11</td>
</tr>
</tbody>
</table>

<p><img src="/img/2019/libraries_in_ios/0.png" alt="0" /></p>

<h2 id="preface">Preface</h2>

<p>随着软件工程的发展，很多我们需要的功能前人都已经很好地实现了，为了提高效率避免重复建设，这些功能实现的代码被封装为代码库，有时也称框架。我们只需要在用到的时候通过依赖管理工具将它们以适当的方式引入即可。本文将简单聊聊 iOS 中的库与框架相关概念。</p>

<h2 id="基本概念">基本概念</h2>

<p>在切入正题之前，我们先来达成一些共识。</p>

<p>不管是老派 Obj-C 还是新秀 Swift，它们的本质都是编译型语言。对于编译型语言，源代码会首先经由编译器编译为目标文件，链接器再将多个目标文件链接为可执行文件。针对链接阶段，主要分为静态链接与动态链接。</p>

<p><strong>静态</strong>，即 Static。按照字面意思，静态即一旦确定，就不再容易改变。静态链接，即在链接阶段，直接将多个目标文件链接为一个文件。而静态库就可以理解为共同编译为一个目标文件的源代码集合。</p>

<p><strong>动态</strong>，即 Dynamic。按照字面意思，动态即推迟到运行时动态地决议。动态链接，即在运行时才将各个部分组合形成完整的程序。而动态库就可以理解为支持动态链接方式的源代码集合。</p>

<p>静态链接的好处是，运行时不再额外需要时间动态链接；坏处则是由于链接的粒度是目标文件，那么可能会链接了没有使用到的函数，会造成可执行文件过大；而且当某一个目标文件的源代码改动时，那么所有依赖该目标文件的静态库都需要重新编译；动态链接则解决了静态链接的空间浪费与重复编译问题，比如在 iOS 中，系统库采用了 dyld_shared_cache 动态链接，这样其它程序就无需再将系统库重复链接，当 iOS 系统更新时也无需将所有 app 重新编译。而在移动端开发中，app 的启动时间与包体积大小将是一个权衡问题，值得我们侧重与考量。</p>

<p>另外，虽然广义上的库（Library）与框架（Framework）含义是类似的，但在 iOS 开发中，官方将这两个概念进行了区分，因此下文中我们会明确两个词的使用。</p>

<h2 id="cocoa-touch-static-library">Cocoa Touch Static Library</h2>

<p>我们先从 Xcode 中能够直接创建的 Cocoa Touch Static Library 说起（注意，在 Xcode 11 中，这里已经变成 Framework 与 Library，更加清晰）：</p>

<p><img src="/img/2019/libraries_in_ios/1.png" alt="1" /></p>

<p>Cocoa Touch Static Library 即静态库。iOS 上狭义的静态库，即<strong>只包含编译后代码的 <code>.a</code> 文件</strong>。我们创建一个 oc-static-lib 的静态库，为其默认提供的 <code>oc_static_lib</code> 类添加 <code>foo</code> 方法，并添加一个 <code>NSObject</code> 的分类，实现 +load 和 <code>foo</code> 方法：</p>

<pre><code class="language-objectivec">// oc_static_lib.h

#import &lt;Foundation/Foundation.h&gt;

@interface oc_static_lib : NSObject
- (void)foo;
@end

// oc_static_lib.m

#import &quot;oc_static_lib.h&quot;

@implementation oc_static_lib
- (void)foo {
    NSLog(@&quot;%@ - %@&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd));
}
@end

// NSObject+OC_Static_Lib.h

#import &lt;Foundation/Foundation.h&gt;

NS_ASSUME_NONNULL_BEGIN
@interface NSObject (OC_Static_Lib)
- (void)foo;
@end
NS_ASSUME_NONNULL_END

// NSObject+OC_Static_Lib.m

#import &quot;NSObject+OC_Static_Lib.h&quot;

@implementation NSObject (OC_Static_Lib)
+ (void)load {
    NSLog(@&quot;%@ - %@&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd));
}
- (void)foo {
    NSLog(@&quot;%@ - %@&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd));
}
@end
</code></pre>

<p>需要注意的是我们需要将新创建的 <code>.h</code> 加入到 Xcode - Targets - Build Phases - Copy Files 中，这样外界才能通过引入该头文件来访问其中的内容：</p>

<p><img src="/img/2019/libraries_in_ios/2.png" alt="2" /></p>

<blockquote>
<p>⚠️</p>

<p>这里我们的目标设备选择的是模拟器，所以默认编译后的 <code>.a</code> 文件也将只适用于模拟器架构（x86_64），为了同时能够真机运行和模拟器调试，通常会使用 <code>lipo</code> 命令将多种架构的 <code>.a</code> 文件进行合并为胖二进制（Fat-Binary）文件。</p>
</blockquote>

<h3 id="obj-c-工程引入-obj-c-静态库">Obj-C 工程引入 Obj-C 静态库</h3>

<p><img src="/img/2019/libraries_in_ios/3.png" alt="3" /></p>

<p>我们将 oc-static-lib 编译后的 <code>.a</code> 与 <code>.h</code> 一起拖入 Obj-C 工程（记得勾选「Add to targets」，这样即可自动将 <code>.a</code> 加入到「Link Binary With Libraries」中），即可使用 <code>#import &quot;&quot;</code> 来引入并调用（需要注意的是：静态库中如果存在分类，需要添加 <code>-ObjC</code> 作为 Other Linker Flags，详见 <a href="/posts/2019/+load_in_ios/">iOS 中的 +load 方法</a>一文）：</p>

<blockquote>
<p><strong>Tips</strong></p>

<p>在 C/C++ 中，为了更加清晰化声明与实现，代码需要分别写在 <code>.h</code>（头文件）和 <code>.c</code> / <code>.cpp</code>（实现文件）中。这样的好处是，开发者可以无需额外的访问控制符即可将需要暴露在外界的声明放置在头文件中即可，外界使用时通过 <code>#include</code>。Obj-C/C++ 也延续了这一传统，不同的是实现文件的后缀分别为 <code>.m</code> 和 <code>.mm</code>，并为了避免重复引用推出了 <code>#import</code>。</p>

<p><code>#include</code> 和 <code>#import</code> 后面都可以加 <code>&lt;XXX.h&gt;</code> 或 <code>&quot;XXX.h&quot;</code>。通常来说加 <code>&quot;&quot;</code> 的头文件优先从本地当前文件目录查找，其中也可以包含相对路径，即 <code>#import &quot;oc-static-lib/oc_static_lib.h&quot;</code> / <code>#import &quot;NSObject+OC_Static_Lib.h&quot;</code> 都是支持的；而加 <code>&lt;&gt;</code> 的头文件则会使得编译器优先到系统目录下全局查找。</p>
</blockquote>

<h3 id="swift-工程引入-swift-静态库">Swift 工程引入 Swift 静态库</h3>

<p>在 Xcode 9 之后，Swift 也支持了静态库。与 Obj-C 不同，Swift 没有头文件的概念，因此我们需要将暴露给外界的类和函数等使用 <code>public</code> 修饰。编译后的 Swift 静态库也是 <code>.a</code> 文件，但不同的是多了 <code>.swiftmodule</code> 以及 <code>.swiftdoc</code>：</p>

<pre><code class="language-shell">➜  Debug-iphonesimulator tree
.
├── libswift-static-lib.a
└── swift_static_lib.swiftmodule
    ├── x86_64.swiftdoc
    └── x86_64.swiftmodule

1 directory, 3 files
</code></pre>

<p><code>.swiftmodule</code> 包含了序列化过的 AST（抽象语法树，Abstract Syntax Tree），可能也包含 SIL（Swift 中间语言，Swift Intermediate Language），我们可以将其理解为类似 C 语言库或框架中头文件的二进制格式文件；<code>.swiftdoc</code> 则是 Swift 文档注释生成的二进制文件，由 <code>Serialization::writeDocToStream()</code> 生成，因此并非是必要的。由于 Swift 的 Module 机制，我们需要将 Xcode - Targets - Build Settings - Swift Compiler - Search Paths - Import Paths 中引入：</p>

<p><img src="/img/2019/libraries_in_ios/4.png" alt="4" /></p>

<p>这样我们才能在 Swift 工程中正常使用：</p>

<pre><code class="language-swift">// swift_static_lib.swift
import Foundation

@objc public class swift_static_lib: NSObject {
    @objc public func foo() {
        print(&quot;swift_static_lib - \(#function)&quot;)
    }
}

// ViewController.swift
import UIKit
import swift_static_lib

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.

        swift_static_lib().foo()
    }
}
</code></pre>

<h3 id="obj-c-工程引入-swift-静态库">Obj-C 工程引入 Swift 静态库</h3>

<p>为了「提拔」新秀，Swift 支持与 Obj-C 混编，然而混编下的各种情况就会变得十分特殊。在同一个工程下 Swift 文件与 Obj-C 文件混编时，Xcode 会提示我们创建桥接头文件 <code>&lt;PROJECT_NAME&gt;-Bridging-Header.h</code>，我们可以将需要暴露给 Swift 的 Obj-C 代码在该桥接文件中引入；而 Obj-C 代码中希望使用 Swift 中的相关定义时，可以引入自动生成但不可见的 <code>&lt;PROJECT_NAME&gt;-Swift.h</code>，另外需要注意的是，暴露给 Obj-C 的类或函数等需要使用 <code>@objc</code> 或 <code>dynamic</code> 修饰，前者不能决定函数最终派发方式，而后者则为动态派发。</p>

<p>那么如果要在 Obj-C 工程引入 Swift 静态库，首先要在工程中引入一个占位 Swift 文件，并创建桥接文件，这样 Xcode 中 Swift 相关的依赖配置才能得以建立：</p>

<p><img src="/img/2019/libraries_in_ios/7.png" alt="7" /></p>

<p>Swift 静态库也可以自动生成 <code>&lt;PROJECT_NAME&gt;-Swift.h</code>，但其并没有和最终产物 <code>.a</code> 放置在一起：</p>

<pre><code class="language-shell">➜  Build tree
.
├── Intermediates.noindex
│   ├── XCBuildData
│   │   ├── BuildDescriptionCacheIndex-039e2a7cd1451855448cd617c2c79f0d
│   │   ├── PIFCache
│   │   │   ├── project
│   │   │   │   ├── PROJECT@v8_mod=1568563268_hash=b6565d7e8bfe8171a813e95698ec414f-json
│   │   │   │   └── PROJECT@v8_mod=1568563366_hash=b6565d7e8bfe8171a813e95698ec414f-json
│   │   │   ├── target
│   │   │   │   ├── TARGET@v8_hash=9ED714DD9D72F2357197BC1BE00B9838-json
│   │   │   │   └── TARGET@v8_hash=B7634C70FA7FEB002C1D5B331F68AC57-json
│   │   │   └── workspace
│   │   │       ├── WORKSPACE@v8_mod=1568563268_hash=039e2a7cd1451855448cd617c2c79f0d_subobjects=359C431B6A9412A0DAB608A7B5E1B797-json
│   │   │       └── WORKSPACE@v8_mod=1568563268_hash=039e2a7cd1451855448cd617c2c79f0d_subobjects=FD7A1155808C379D6684AA719075DE4E-json
│   │   ├── a9f77306ac684b2857e1d38ab0444728-desc.xcbuild
│   │   ├── a9f77306ac684b2857e1d38ab0444728-manifest.xcbuild
│   │   ├── b87f53f8de8d4ad786bada5baea76917-desc.xcbuild
│   │   ├── b87f53f8de8d4ad786bada5baea76917-manifest.xcbuild
│   │   └── build.db
│   └── swift_static_lib.build
│       └── Debug-iphonesimulator
│           └── swift_static_lib.build
│               ├── DerivedSources
│               │   └── swift_static_lib-Swift.h ⬅️
│               ├── Objects-normal
│               │   └── x86_64
│               │       ├── swift_static_lib-OutputFileMap.json
│               │       ├── swift_static_lib-Swift.h
│               │       ├── swift_static_lib-master.swiftdeps
│               │       ├── swift_static_lib-master.swiftdeps~
│               │       ├── swift_static_lib-master.swiftdeps~moduleonly
│               │       ├── swift_static_lib.LinkFileList
│               │       ├── swift_static_lib.d
│               │       ├── swift_static_lib.dia
│               │       ├── swift_static_lib.o
│               │       ├── swift_static_lib.swiftdeps
│               │       ├── swift_static_lib.swiftdeps~
│               │       ├── swift_static_lib.swiftdoc
│               │       ├── swift_static_lib.swiftmodule
│               │       ├── swift_static_lib~partial.swiftdoc
│               │       └── swift_static_lib~partial.swiftmodule
│               ├── Script-841C800C232E981E007DF25D.sh
│               ├── all-product-headers.yaml
│               ├── swift_static_lib-all-non-framework-target-headers.hmap
│               ├── swift_static_lib-all-target-headers.hmap
│               ├── swift_static_lib-generated-files.hmap
│               ├── swift_static_lib-own-target-headers.hmap
│               ├── swift_static_lib-project-headers.hmap
│               └── swift_static_lib.hmap
└── Products
    └── Debug-iphonesimulator
        ├── include
        │   └── swift_static_lib
        │       ├── module.modulemap
        │       └── swift_static_lib-Swift.h
        ├── libswift_static_lib.a
        └── swift_static_lib.swiftmodule
            ├── x86_64.swiftdoc
            └── x86_64.swiftmodule

17 directories, 41 files
</code></pre>

<p>因此我们可以将以下脚本添加到 Xcode - Targets - Build Phases - New Run Script Phase 中，这样每次构建即可将 <code>&lt;PROJECT_NAME&gt;-Swift.h</code> 一并生成：</p>

<pre><code class="language-shell">// Powered by https://paul-samuels.com/blog/2018/01/14/swift-static-library-in-objective-c/

target_dir=${BUILT_PRODUCTS_DIR}/include/${PRODUCT_MODULE_NAME}/

# Ensure the target include path exists
mkdir -p ${target_dir}

# Copy any file that looks like a Swift generated header to the include path
cp ${DERIVED_SOURCES_DIR}/*-Swift.h ${target_dir}
</code></pre>

<p>之后我们需要将生成的产物放 swift_static_lib 文件中一起拖到 Obj-C 工程中（这里可以反选「Add to targets」选项）：</p>

<pre><code class="language-shell">➜  swift_static_lib tree
.
├── include
│   └── swift_static_lib
│       └── swift_static_lib-Swift.h
├── libswift_static_lib.a
└── swift_static_lib.swiftmodule
    ├── x86_64.swiftdoc
    └── x86_64.swiftmodule

3 directories, 4 files
</code></pre>

<p>之后我们将 <code>.a</code> 拖拽到 Xcode - General - Link Binary With Libraries（或 Xcode - Targets - Build Phases - Link Binary With Libraries）中：</p>

<p><img src="/img/2019/libraries_in_ios/5.png" alt="5" /></p>

<p>最后再将 Xcode - Targets - Build Settings - Header Search Paths &amp; Library Search Paths 添加上 <code>.a</code> 的父级路径 <code>$(PROJECT_DIR)/oc-demo-project/swift_static_lib</code> 即可：</p>

<p><img src="/img/2019/libraries_in_ios/6.png" alt="6" /></p>

<p>这样，在 Obj-C 工程中通过 <code>#import &quot;swift_static_lib-Swift.h&quot;</code> 即可使用到 swift_static_lib 中暴露给 Obj-C 的类或函数等了。</p>

<h3 id="swift-工程引入-obj-c-静态库">Swift 工程引入 Obj-C 静态库</h3>

<p>如果想要在 Swift 工程中引入 Obj-C 静态库（注意如有分类仍需加 <code>-ObjC</code>），则也需要桥接头文件的中介。我们将 oc-static-lib 编译后的 <code>.a</code> 与 <code>.h</code> 一起拖入 Swift 工程，并在工程中建立 Obj-C 类，按 Xcode 提示创建桥接文件；在头文件中引入 Obj-C 静态库头文件即可在 Swift 中使用：</p>

<pre><code class="language-objectivec">// swift-demo-project-Bridging-Header.h

//
//  Use this file to import your target's public headers that you would like to expose to Swift.
//

#import &quot;liboc-static-lib/oc_static_lib.h&quot;
</code></pre>

<h2 id="cocoa-touch-framework">Cocoa Touch Framework</h2>

<p>Cocoa Touch Framework 是 Xcode 中能够创建的另外一种框架（Framework）类型（注意，在 Xcode 11 中，这里已经变成 Framework 与 Library，更加清晰），而非库（Library）。不同于库，iOS 中的框架指的是包含资源（比如图片、本地化文件、Storyboard 等）、头文件、以及编译后的二进制等的集合。框架的后缀名是 <code>.framework</code>，并可以通过 <code>NSBundle</code> API 访问，不同的是框架可以直接导航到其中的目录内容，便于开发者查看：</p>

<pre><code class="language-shell">➜  oc_framework.framework tree
.
├── Assets.car ➡️ 工程中的 xcassets 资源将被压缩为 car
├── Headers
│   ├── NSObject+OC_Framework.h
│   ├── OC_Foo.h
│   ├── PublicHeader.h
│   └── oc_framework.h
├── Info.plist
├── Modules
│   └── module.modulemap 🌟
├── _CodeSignature
│   └── CodeResources
└── oc_framework

3 directories, 9 files

➜  swift_framework.framework tree
.
├── Headers
│   ├── swift_framework-Swift.h ➡️ 自动生成的 *-Swift.h 便于 Obj-C 工程使用
│   └── swift_framework.h
├── Info.plist
├── Modules
│   ├── module.modulemap 🌟
│   └── swift_framework.swiftmodule ➡️ 类似 Swift 静态库
│       ├── x86_64.swiftdoc
│       └── x86_64.swiftmodule
├── _CodeSignature
│   └── CodeResources
├── eng.strings ➡️ 工程中的 strings 资源
└── swift_framework

4 directories, 9 files
</code></pre>

<p>Framework 中编译后的 Mach-O 可以根据需要作为动态库、静态库（注意如有分类仍需加 <code>-ObjC</code>）、或者可执行文件等：</p>

<p><img src="/img/2019/libraries_in_ios/8.png" alt="8" /></p>

<p>Framework 中需要暴露在外界的头文件，需要在 Xcode - Targets - Build Phases - Headers - Public 中公开（Swift Framework 中的 <code>*-Swift.h</code> 则不需要手动移动）；资源文件则需要加入 Copy Bundle Resources 中（使用时通过 <code>NSBunlde</code> API）：</p>

<p><img src="/img/2019/libraries_in_ios/10.png" alt="10" /></p>

<h3 id="obj-c-工程">Obj-C 工程</h3>

<p>在 Obj-C 工程中，只需要将 Framework 产物拖入并在 Xcode - Targets - General - Embedded Binaries &amp; Links Framework and Libraries 中添加即可：</p>

<p><img src="/img/2019/libraries_in_ios/9.png" alt="9" /></p>

<p>在工程中我们就可以将其引入并使用了：</p>

<ul>
<li>oc-framework:</li>
</ul>

<hr />

<pre><code class="language-objectivec">// OC_Foo.m

#import &quot;OC_Foo.h&quot;

@implementation OC_Foo

- (void)foo {
    NSLog(@&quot;%@ - %@&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd));
}

- (UIImage *)image {
    // 通过 NSBundle 获取资源
    NSBundle *bundle = [NSBundle bundleForClass:[self class]];
    return [UIImage imageNamed:@&quot;icon&quot; inBundle:bundle compatibleWithTraitCollection:nil];
}

@end
</code></pre>

<ul>
<li>swift-framework:</li>
</ul>

<hr />

<pre><code class="language-swift">// Swift_Foo.swift

import Foundation

@objc public class Swift_Foo : NSObject {
    @objc public func foo() {
        print(&quot;Swift_Foo - \(#function)&quot;)
    }

    @objc public func strings() -&gt; String {
        let bundle = Bundle(for: Swift_Foo.self)
        return NSLocalizedString(&quot;demo-string&quot;, bundle: bundle, comment: &quot;A demo string.&quot;)
    }
}
</code></pre>

<ul>
<li>Obj-C 工程：</li>
</ul>

<hr />

<pre><code class="language-objectivec">// ViewController.m

#import &quot;ViewController.h&quot;
@import oc_framework;
//#import &quot;oc_framework/oc_framework.h&quot;
//#import &lt;oc_framework/oc_framework.h&gt;
//#import &lt;oc_framework/PublicHeader.h&gt;
//#import &lt;oc_framework/OC_Foo.h&gt;

@import swift_framework;
//#import &quot;swift_framework/swift_framework.h&quot;
//#import &quot;swift_framework/swift_framework-Swift.h&quot;
//#import &lt;swift_framework/swift_framework.h&gt;
//#import &lt;swift_framework/swift_framework-Swift.h&gt;

@interface ViewController ()
@property (weak, nonatomic) IBOutlet UIImageView *imageView;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.

    OC_Foo *foo = [OC_Foo new];
    [foo foo];

    self.imageView.image = [foo image];

    Swift_Foo *sFoo = [[Swift_Foo alloc] init];
    [sFoo foo];

    NSLog(@&quot;%@&quot;, [sFoo strings]);
}

@end
</code></pre>

<h3 id="swift-工程">Swift 工程</h3>

<p>Framework 的引入要比静态库简单许多，我们只需要将其直接引入工程中（注意如有分类仍需加 <code>-ObjC</code>），并在 Swift 通过 <code>import &lt;FRAMEWORK_NAME&gt;</code> 导入即可：</p>

<pre><code class="language-swift">import UIKit
import oc_framework
import swift_framework

class ViewController: UIViewController {
    @IBOutlet weak var imageView: UIImageView!

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.

        let foo = OC_Foo()
        foo.foo()
        // ⚠️ 注意，比较奇怪的是：
        // 只有当 Obj-C Framework 的 Mach-O 类型为动态库时，以下的资源才有效
        imageView.image = foo.image()

        let sFoo = Swift_Foo()
        sFoo.foo()
        print(sFoo.strings())
    }
}
</code></pre>

<h3 id="aggregate-target">Aggregate Target</h3>

<p><img src="/img/2019/libraries_in_ios/11.png" alt="11" /></p>

<p>关于 Aggregate Target，官方提供的可参考资料很少。老版本的 Xcode 中描述为「This target is used to aggregate other targets together」，即 aggregate 本身具有聚合、总计之意，而 Aggregate Target 正是用于聚合其它 Target，使得可以在 Xcode 中达到一次性构建多个 Target 的目的。</p>

<h2 id="cocoapods">CocoaPods</h2>

<p>CocoaPods 是 iOS/macOS 开发的老牌搭档。</p>

<h3 id="非-use-framework">非 <code>use_framework</code></h3>

<p>CocoaPods 现在默认开启了 <code>use_framework</code> 选项，即使用 Framework 方式集成，我们将其注释，先来看下非 <code>use_framework</code> 的情况。此时我们定义在 Podfile 中的相关依赖将作为类似上文中 Cocoa Touch Static Library 一样的 Target 被 Pods 工程自身依赖：</p>

<p><img src="/img/2019/libraries_in_ios/13.png" alt="13" /></p>

<p>Pods 工程也将作为中介被打包为 <code>.a</code> 被主工程依赖：</p>

<p><img src="/img/2019/libraries_in_ios/12.png" alt="12" /></p>

<p>如前文所述，<code>.a</code> 仅仅包含了编译后的代码，那么它所以依赖的资源文件将如何处理呢？我们可以看到上图中的「[CP] Copy Pods Resoureces」，执行了如下的脚本：</p>

<pre><code class="language-shell">#!/bin/sh
set -e
set -u
set -o pipefail  # 设置

function on_error {
  echo &quot;$(realpath -mq &quot;${0}&quot;):$1: error: Unexpected failure&quot;
}
trap 'on_error $LINENO' ERR

# if [ -z #{STR} ]; 如果 STR 长度为 0 则真
# UNLOCALIZED_RESOURCES_FOLDER_PATH（app 名）：oc-demo-project.app
if [ -z ${UNLOCALIZED_RESOURCES_FOLDER_PATH+x} ]; then
  # If UNLOCALIZED_RESOURCES_FOLDER_PATH is not set, then there's nowhere for us to copy
  # resources to, so exit 0 (signalling the script phase was successful).
  exit 0
fi

# TARGET_BUILD_DIR（目标构建目录）：/Users/kingcos/Library/Developer/Xcode/DerivedData/oc-demo-project-fvrppqpxzudpvicewkjnbszgmrll/Build/Products/Debug-iphonesimulator
# 不管文件夹是否存在，尝试创建
mkdir -p &quot;${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&quot;

# RESOURCES_TO_COPY（欲拷贝资源记录，临时文件）：oc-demo-project/Pods/resources-to-copy-oc-demo-project.txt
RESOURCES_TO_COPY=${PODS_ROOT}/resources-to-copy-${TARGETNAME}.txt
# 创建该文件
&gt; &quot;$RESOURCES_TO_COPY&quot;

XCASSET_FILES=()

# 防止多个 target 同时拷贝相同的框架依赖
# This protects against multiple targets copying the same framework dependency at the same time. The solution
# was originally proposed here: https://lists.samba.org/archive/rsync/2008-February/020158.html
RSYNC_PROTECT_TMP_FILES=(--filter &quot;P .*.??????&quot;)

# TARGETED_DEVICE_FAMILY（目标设备家族）：1,2（iPhone &amp; iPad）
case &quot;${TARGETED_DEVICE_FAMILY:-}&quot; in
  1,2)
    TARGET_DEVICE_ARGS=&quot;--target-device ipad --target-device iphone&quot;
    ;;
  1)
    TARGET_DEVICE_ARGS=&quot;--target-device iphone&quot;
    ;;
  2)
    TARGET_DEVICE_ARGS=&quot;--target-device ipad&quot;
    ;;
  3)
    TARGET_DEVICE_ARGS=&quot;--target-device tv&quot;
    ;;
  4)
    TARGET_DEVICE_ARGS=&quot;--target-device watch&quot;
    ;;
  *)
    TARGET_DEVICE_ARGS=&quot;--target-device mac&quot;
    ;;
esac

# 安装资源函数
install_resource()
{
  if [[ &quot;$1&quot; = /* ]] ; then
    RESOURCE_PATH=&quot;$1&quot;
  else
    RESOURCE_PATH=&quot;${PODS_ROOT}/$1&quot;
  fi
  if [[ ! -e &quot;$RESOURCE_PATH&quot; ]] ; then
    cat &lt;&lt; EOM
error: Resource &quot;$RESOURCE_PATH&quot; not found. Run 'pod install' to update the copy resources script.
EOM
    exit 1
  fi
  case $RESOURCE_PATH in
    *.storyboard)
      echo &quot;ibtool --reference-external-strings-file --errors --warnings --notices --minimum-deployment-target ${!DEPLOYMENT_TARGET_SETTING_NAME} --output-format human-readable-text --compile ${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename \&quot;$RESOURCE_PATH\&quot; .storyboard`.storyboardc $RESOURCE_PATH --sdk ${SDKROOT} ${TARGET_DEVICE_ARGS}&quot; || true
      ibtool --reference-external-strings-file --errors --warnings --notices --minimum-deployment-target ${!DEPLOYMENT_TARGET_SETTING_NAME} --output-format human-readable-text --compile &quot;${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename \&quot;$RESOURCE_PATH\&quot; .storyboard`.storyboardc&quot; &quot;$RESOURCE_PATH&quot; --sdk &quot;${SDKROOT}&quot; ${TARGET_DEVICE_ARGS}
      ;;
    *.xib)
      echo &quot;ibtool --reference-external-strings-file --errors --warnings --notices --minimum-deployment-target ${!DEPLOYMENT_TARGET_SETTING_NAME} --output-format human-readable-text --compile ${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename \&quot;$RESOURCE_PATH\&quot; .xib`.nib $RESOURCE_PATH --sdk ${SDKROOT} ${TARGET_DEVICE_ARGS}&quot; || true
      ibtool --reference-external-strings-file --errors --warnings --notices --minimum-deployment-target ${!DEPLOYMENT_TARGET_SETTING_NAME} --output-format human-readable-text --compile &quot;${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename \&quot;$RESOURCE_PATH\&quot; .xib`.nib&quot; &quot;$RESOURCE_PATH&quot; --sdk &quot;${SDKROOT}&quot; ${TARGET_DEVICE_ARGS}
      ;;
    *.framework)
      echo &quot;mkdir -p ${TARGET_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}&quot; || true
      mkdir -p &quot;${TARGET_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}&quot;
      echo &quot;rsync --delete -av &quot;${RSYNC_PROTECT_TMP_FILES[@]}&quot; $RESOURCE_PATH ${TARGET_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}&quot; || true
      rsync --delete -av &quot;${RSYNC_PROTECT_TMP_FILES[@]}&quot; &quot;$RESOURCE_PATH&quot; &quot;${TARGET_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}&quot;
      ;;
    *.xcdatamodel)
      echo &quot;xcrun momc \&quot;$RESOURCE_PATH\&quot; \&quot;${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename &quot;$RESOURCE_PATH&quot;`.mom\&quot;&quot; || true
      xcrun momc &quot;$RESOURCE_PATH&quot; &quot;${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename &quot;$RESOURCE_PATH&quot; .xcdatamodel`.mom&quot;
      ;;
    *.xcdatamodeld)
      echo &quot;xcrun momc \&quot;$RESOURCE_PATH\&quot; \&quot;${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename &quot;$RESOURCE_PATH&quot; .xcdatamodeld`.momd\&quot;&quot; || true
      xcrun momc &quot;$RESOURCE_PATH&quot; &quot;${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename &quot;$RESOURCE_PATH&quot; .xcdatamodeld`.momd&quot;
      ;;
    *.xcmappingmodel)
      echo &quot;xcrun mapc \&quot;$RESOURCE_PATH\&quot; \&quot;${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename &quot;$RESOURCE_PATH&quot; .xcmappingmodel`.cdm\&quot;&quot; || true
      xcrun mapc &quot;$RESOURCE_PATH&quot; &quot;${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/`basename &quot;$RESOURCE_PATH&quot; .xcmappingmodel`.cdm&quot;
      ;;
    *.xcassets)
      ABSOLUTE_XCASSET_FILE=&quot;$RESOURCE_PATH&quot;
      XCASSET_FILES+=(&quot;$ABSOLUTE_XCASSET_FILE&quot;)
      ;;
    *)
      echo &quot;$RESOURCE_PATH&quot; || true
      echo &quot;$RESOURCE_PATH&quot; &gt;&gt; &quot;$RESOURCES_TO_COPY&quot;
      ;;
  esac
}

# CONFIGURATION：运行的 scheme 配置模式，Debug 或 Release
if [[ &quot;$CONFIGURATION&quot; == &quot;Debug&quot; ]]; then
  install_resource &quot;${PODS_ROOT}/MJRefresh/MJRefresh/MJRefresh.bundle&quot;
fi
if [[ &quot;$CONFIGURATION&quot; == &quot;Release&quot; ]]; then
  install_resource &quot;${PODS_ROOT}/MJRefresh/MJRefresh/MJRefresh.bundle&quot;
fi

mkdir -p &quot;${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&quot;
rsync -avr --copy-links --no-relative --exclude '*/.svn/*' --files-from=&quot;$RESOURCES_TO_COPY&quot; / &quot;${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&quot;
if [[ &quot;${ACTION}&quot; == &quot;install&quot; ]] &amp;&amp; [[ &quot;${SKIP_INSTALL}&quot; == &quot;NO&quot; ]]; then
  mkdir -p &quot;${INSTALL_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&quot;
  rsync -avr --copy-links --no-relative --exclude '*/.svn/*' --files-from=&quot;$RESOURCES_TO_COPY&quot; / &quot;${INSTALL_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&quot;
fi
rm -f &quot;$RESOURCES_TO_COPY&quot;

if [[ -n &quot;${WRAPPER_EXTENSION}&quot; ]] &amp;&amp; [ &quot;`xcrun --find actool`&quot; ] &amp;&amp; [ -n &quot;${XCASSET_FILES:-}&quot; ]
then
  # Find all other xcassets (this unfortunately includes those of path pods and other targets).
  OTHER_XCASSETS=$(find &quot;$PWD&quot; -iname &quot;*.xcassets&quot; -type d)
  while read line; do
    if [[ $line != &quot;${PODS_ROOT}*&quot; ]]; then
      XCASSET_FILES+=(&quot;$line&quot;)
    fi
  done &lt;&lt;&lt;&quot;$OTHER_XCASSETS&quot;

  if [ -z ${ASSETCATALOG_COMPILER_APPICON_NAME+x} ]; then
    printf &quot;%s\0&quot; &quot;${XCASSET_FILES[@]}&quot; | xargs -0 xcrun actool --output-format human-readable-text --notices --warnings --platform &quot;${PLATFORM_NAME}&quot; --minimum-deployment-target &quot;${!DEPLOYMENT_TARGET_SETTING_NAME}&quot; ${TARGET_DEVICE_ARGS} --compress-pngs --compile &quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&quot;
  else
    printf &quot;%s\0&quot; &quot;${XCASSET_FILES[@]}&quot; | xargs -0 xcrun actool --output-format human-readable-text --notices --warnings --platform &quot;${PLATFORM_NAME}&quot; --minimum-deployment-target &quot;${!DEPLOYMENT_TARGET_SETTING_NAME}&quot; ${TARGET_DEVICE_ARGS} --compress-pngs --compile &quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&quot; --app-icon &quot;${ASSETCATALOG_COMPILER_APPICON_NAME}&quot; --output-partial-info-plist &quot;${TARGET_TEMP_DIR}/assetcatalog_generated_info_cocoapods.plist&quot;
  fi
fi
</code></pre>

<h3 id="use-framework">use_framework</h3>

<ul class="task-list">
<li>TODO:</li>
<li><label><input type="checkbox" disabled class="task-list-item"> @import</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> Module Map</label></li>
</ul>

<h2 id="reference">Reference</h2>

<!-- - [Linkers and Loaders](https://book.douban.com/subject/1436811/) -->

<ul>
<li><a href="../../2018/dyld_shared_cache/">谈谈 iOS 中的 dyld_shared_cache - kingcos</a></li>
<li><a href="/posts/2019/+load_in_ios/">iOS 中的 +load 方法 - kingcos</a></li>
<li><a href="https://forums.swift.org/t/whats-in-the-file-of-swiftmodule-how-to-open-it/1032">what’s in the file of .swiftmodule?how to open it?</a></li>
<li><a href="https://forums.swift.org/t/looking-for-documentation-insight-on-swiftdoc/6869">Looking for documentation/insight on .swiftdoc</a></li>
<li><a href="https://forums.swift.org/t/swift-static-libraries-dont-copy-generated-objective-c-header/19816">Swift static libraries don’t copy generated Objective-C header</a></li>
<li><a href="https://stackoverflow.com/questions/29580438/use-swift-library-in-objc">Use Swift Library in ObjC - StackOverflow</a></li>
<li><a href="https://paul-samuels.com/blog/2018/01/14/swift-static-library-in-objective-c/">Swift static library in Objective-C - Paul Samuels</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html">Framework Programming Guide - Apple</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html">Bundle Programming Guide - Apple</a></li>
<li><a href="https://developer.apple.com/library/archive/technotes/tn2435/_index.html">Technical Note TN2435 - Embedding Frameworks In An App - Apple</a></li>
<li><a href="https://www.raywenderlich.com/2430-how-to-create-a-framework-for-ios">How to Create a Framework for iOS - Ray Wenderlich</a></li>
</ul>

    </div>
    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>
        <div class="pagination__buttons">
          
          
            <span class="button next">
              <a href="/posts/2019/&#43;load_in_ios/">
                <span class="button__text">iOS 中的 &#43;load 方法</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    

    

    
    
    <div>
      <div id="github-comment">
      </div>

      <script type="text/javascript">
        function getUtterances(isDark) {
          var utterances = document.createElement('script');
          utterances.type = 'text/javascript';
          utterances.async = true;
          utterances.setAttribute('issue-term', "pathname")
          utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
          utterances.setAttribute('label', "comments")
          isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
          utterances.crossorigin = 'anonymous';
          utterances.src = 'https://utteranc.es/client.js';

          return utterances
        }

        var themeToggle = document.querySelector(".theme-toggle")
        themeToggle.addEventListener("click", function () {
          var getTheme = window.localStorage && window.localStorage.getItem("theme")
          var divNode = document.getElementById('github-comment')
          while(divNode.hasChildNodes()) {
            divNode.removeChild(divNode.firstChild);
          }
          
          
          

          
          
          
          
          
          
          document.getElementById('github-comment').appendChild(getUtterances(getTheme !== "dark"))
        })

        var getTheme = window.localStorage && window.localStorage.getItem("theme")
        document.getElementById('github-comment').appendChild(getUtterances(getTheme === "dark"))
      </script>
    </div>
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">Powered by github.com/kingcos</div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </body>
</html>
