<!DOCTYPE html>
<html lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="kingcos" />
	
	
	
	<title>《Effective Objective-C 2.0》笔记 ｜ kingcos</title>
	
    
    
    <meta name="description" content="本文不仅是此书的阅读笔记，也有 Demo 代码等，较为独立的篇章内容则融入笔者的独立文章中" />
    

    
    
    <meta name="keywords" content="Hugo, theme, zozo" />
    

	
    
    <link rel="shortcut icon" href="https://kingcos.me/images/favicon.png" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/highlight.css" />

    
    
</head>

<script data-ad-client="ca-pub-9925978992661955" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<body>
    <div class="main animate__animated animate__fadeInDown">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/posts/">Archive</a>
            </li>
            
            <li>
                <a href="/tags/">Tags</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>


<link rel="stylesheet" href="https://kingcos.me/scss/main.min.75b49085bfb07b1bf150a1d59b4773d857e0452a747e37243805218b528a4045.css" integrity="sha256-dbSQhb&#43;wexvxUKHVm0dz2FfgRSp0fjckOAUhi1KKQEU=" media="screen">

<style>
.nav_container {
  height: 1rem;
}
 
table {
    width: 100%;
    table-layout: fixed;
}

 
.markdown code {
    white-space: normal;
    word-wrap: break-word;
    word-break: break-word;
    line-height: 1.5em;
    font-size: 0.85em;
    font-weight: bold;
    display: inline-block;
     
}

 
.menu_icon a {
    font-size: 16px;
}

 
body {
    font-family: 'Hiragino Sans GB', 'SFMono', 'Lato', '-apple-system';
    -webkit-font-smoothing: 'antialiased';
}

 
.markdown strong, .markdown b, .markdown em {
    font-weight: bold;
}

.post .post_content p {
     

    line-height: 1.75em;
}

 
.markdown img {
    max-width: 100%;
    margin: 0 auto;
    display: block;
    border-radius: 0.25rem;
}

 
.ri-stack-line {
    vertical-align: middle;
}

 
.ri-map-pin-time-line {
    vertical-align: middle;
}

 
.chroma .lntd:nth-child(2) {
    width: 100%;
}

 

 
.markdown .book-hint::before {
    content: none;
}

.markdown .book-hint {
    margin: 1rem 0;
    padding: 0.5rem 1rem 0.5rem 0.75rem;

    border-inline-start: 0.25rem solid #e9ecef;
    border-radius: 0.25rem;

    font-style: normal;
     
}

.book-hint strong {
    background-color: transparent;
}

.markdown .book-hint.info {
    border-left-color:#6bf;
    background-color:rgba(102,187,255,.1);
}

.markdown .book-hint.warning {
    border-left-color:#fd6;
    background-color:rgba(255,221,102,.1);
}

.markdown .book-hint.danger {
    border-left-color:#f66;
    background-color:rgba(255,102,102,.1);
}

</style>

        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            
                <a href="https://kingcos.me/">
                    
                    <img class="kingcos" style="margin-top: -20px; margin-left: -10px;" src="/title.svg" width="150px">
                </a>
            
        </div>
        <div class="description">
            <p class="sub_title">专注、坚持</p>
            <div class="my_socials">
                
                
                <a href="https://github.com/kingcos" title="github" target="_blank"><i class="ri-github-fill"></i></a>
                
                
                
                <a href="https://www.instagram.com/kingcos_v/" title="instagram" target="_blank"><i class="ri-instagram-fill"></i></a>
                
                
                
                <a href="https://twitter.com/kingcos_v" title="twitter" target="_blank"><i class="ri-twitter-fill"></i></a>
                
                
                
                <a href="https://weibo.com/u/1798410923" title="weibo" target="_blank"><i class="ri-weibo-fill"></i></a>
                
                
                
            </div>
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/posts/2019/effective_obj-c_2.0_notes/'>《Effective Objective-C 2.0》笔记</a></h2>
                        <span class="date">2021.05.24</span>
                        <span>by kingcos</span>
                        
                        
                        
                        
                    </div>
                    <div class="post_content markdown">
<div class="book-expand">
  <label>
    <div class="book-expand-head flex justify-between">
      <span>Release Notes</span>
      <span>↕</span>
    </div>
    <input type="checkbox" class="hidden" />
    <div class="book-expand-content markdown-inner">
      <table>
<thead>
<tr>
<th style="text-align:center">Book</th>
<th style="text-align:center">ISBN</th>
<th style="text-align:center">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Effective Objective-C 2.0</td>
<td style="text-align:center">9787111451297</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center"><strong>Date</strong></td>
<td style="text-align:center"><strong>Num.</strong></td>
<td style="text-align:center"><strong>Env</strong></td>
</tr>
<tr>
<td style="text-align:center">2019-05</td>
<td style="text-align:center">1-3</td>
<td style="text-align:center">Xcode 10.2.1</td>
</tr>
<tr>
<td style="text-align:center">2019-06</td>
<td style="text-align:center">4</td>
<td style="text-align:center">Xcode 10.2.1</td>
</tr>
<tr>
<td style="text-align:center">2019-07</td>
<td style="text-align:center">5-12</td>
<td style="text-align:center">Xcode 10.2.1</td>
</tr>
<tr>
<td style="text-align:center">2019-10</td>
<td style="text-align:center">13-20</td>
<td style="text-align:center">Xcode 11.1 &amp; 11.2</td>
</tr>
<tr>
<td style="text-align:center">2019-11</td>
<td style="text-align:center">20-52</td>
<td style="text-align:center">Xcode 11.1 &amp; 11.2</td>
</tr>
<tr>
<td style="text-align:center">2021-05-24</td>
<td style="text-align:center">-</td>
<td style="text-align:center">补充<a href="#%E7%90%86%E8%A7%A3%E5%B1%9E%E6%80%A7%E8%BF%99%E4%B8%80%E6%A6%82%E5%BF%B5">属性特性</a>中的可空性与 <code>direct</code></td>
</tr>
</tbody>
</table>

    </div>
  </label>
</div>

<h2 id="preface">Preface</h2>
<p>《Effective Objective-C 2.0》中文版书名为《编写高质量 iOS 与 OS X 代码的 52 个有效方法》，是类似笔者这样的 iOS 初级入门者必读书目之一。本文不仅是此书的阅读笔记，也有 Demo 代码等，较为独立的篇章内容则融入笔者以往的独立文章中。</p>
<h2 id="熟悉-objective-c">熟悉 Objective-C</h2>
<h3 id="了解-objective-c-语言的起源">了解 Objective-C 语言的起源</h3>
<p>消息结构（Message Structure）的语言，运行时执行的代码由运行环境决定；函数调用（Function Calling）的语言，运行时所执行的代码由编译器决定，对于多态，则按照虚函数表（Virtual Method Table）寻找。</p>
<p>运行时组件（Runtime Component） 本质上是一种与开发者所编写代码相链接的「动态库（Dynamic Library），这样的好处是只需要更新运行时组件（无需重新编译）即可提升程序性能。</p>
<p>Obj-C 是 C 的超集；Obj-C 中的对象所占内存总是分配在堆空间（Heap Space）；而指向对象的指针所占内存总是分配在栈帧（Stack Frame）中；堆中的内存需要开发者自己管理，栈中的内存会在其栈帧弹出（Pop）时自动清理；创建对象相比创建结构体（C 结构体）需要额外开销，例如分配和释放堆内存等。</p>
<p><img src="/img/2019/effective_obj-c_2.0_notes/1.png" alt="1"></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// ⚠️ 由于 Obj-C 中的字符串（NSString）略有特殊，此处并未使用书中的 NSString 作为范例
</span><span class="c1">// 对象本身被分配在堆上；obj1 &amp; obj2 被分配在栈上
</span><span class="c1"></span><span class="n">NSObject</span> <span class="o">*</span><span class="n">obj1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
<span class="n">NSObject</span> <span class="o">*</span><span class="n">obj2</span> <span class="o">=</span> <span class="n">obj1</span><span class="p">;</span>

<span class="c1">// (lldb) p obj1
</span><span class="c1">// (NSObject *) $0 = 0x00000001005092b0
</span><span class="c1">// (lldb) p obj2
</span><span class="c1">// (NSObject *) $1 = 0x00000001005092b0
</span><span class="c1">// (lldb) p &amp;obj1
</span><span class="c1">// (NSObject **) $2 = 0x00007ffeefbff508
</span><span class="c1">// (lldb) p &amp;obj2
</span><span class="c1">// (NSObject **) $3 = 0x00007ffeefbff500
</span></code></pre></div><h3 id="在类的头文件中尽量少引入其他头文件">在类的头文件中尽量少引入其他头文件</h3>
<p>当需要知道有一个类的存在时，而不关心其内部细节时，可以使用向前声明（Forward Declaring）告知编译器，即可以在 .h（头文件）中 <code>@class SomeClass</code>；而在 .m（实现文件）中引入实际的 .h；当在两个头文件中互相引入对方，则会导致「循环 引用（Chicken-Egg Situation，又称交叉引用）」，无法通过编译：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// A.h
</span><span class="c1"></span>
<span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="cp">#import &#34;B.h&#34; </span><span class="c1">// -&gt; @class B;
</span><span class="c1"></span>
<span class="n">NS_ASSUME_NONNULL_BEGIN</span>

<span class="k">@interface</span> <span class="nc">A</span> : <span class="nc">NSObject</span>

<span class="k">@end</span>

<span class="n">NS_ASSUME_NONNULL_END</span>

<span class="c1">// B.h
</span><span class="c1"></span>
<span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="cp">#import &#34;A.h&#34;
</span><span class="cp"></span>
<span class="n">NS_ASSUME_NONNULL_BEGIN</span>

<span class="c1">// ERORR: Cannot find interface declaration for &#39;A&#39;, superclass of &#39;B&#39;
</span><span class="c1"></span><span class="k">@interface</span> <span class="nc">B</span> : <span class="nc">A</span>

<span class="k">@end</span>

<span class="n">NS_ASSUME_NONNULL_END</span>
</code></pre></div><p>将引入头文件的时机尽量延后，只有在确定有需要时才引入，否则会增加耦合度、拉长编译时间、产生相互依赖等问题。</p>
<p>继承父类和遵循协议则不能使用向前声明，必须引入相应的头文件，因此协议最好声明在单独的头文件中；由于代理协议（Delegate Protocol）和遵守协议代理的类声明在一起时才有意义，最好在实现文件中声明类遵守了该代理协议，并将实现代码放在类扩展中；因此只需要在实现文件中引入包含代理协议的头文件即可，而不需要将其放在公共头文件（Public Header File）中。</p>
<h3 id="多用字面量语法少用与之等价的方法">多用字面量语法，少用与之等价的方法</h3>
<p>字面量（Literal）语法简化了 Obj-C 的部分 API：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="n">NSString</span> <span class="o">*</span><span class="n">strValue</span> <span class="o">=</span> <span class="s">@&#34;str&#34;</span><span class="p">;</span>
<span class="n">NSNumber</span> <span class="o">*</span><span class="n">intValue</span> <span class="o">=</span> <span class="mi">@1</span><span class="p">;</span>
<span class="n">NSNumber</span> <span class="o">*</span><span class="n">doubleValue</span> <span class="o">=</span> <span class="mf">@3.14</span><span class="p">;</span>
<span class="n">NSArray</span> <span class="o">*</span><span class="n">arrValue</span> <span class="o">=</span> <span class="l">@[</span><span class="s">@&#34;a&#34;</span><span class="p">,</span> <span class="s">@&#34;b&#34;</span><span class="p">,</span> <span class="s">@&#34;c&#34;</span><span class="l">]</span><span class="p">;</span>
<span class="n">NSString</span> <span class="o">*</span><span class="n">firstValueForArr</span> <span class="o">=</span> <span class="n">arrValue</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="c1">// ⚠️ 字面量创建的数组、字典都是不可变的
</span><span class="c1"></span><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mutableArrValue</span> <span class="o">=</span> <span class="p">[</span><span class="l">@[</span><span class="s">@&#34;a&#34;</span><span class="p">,</span> <span class="s">@&#34;b&#34;</span><span class="p">,</span> <span class="s">@&#34;c&#34;</span><span class="l">]</span> <span class="n">mutableCopy</span><span class="p">];</span>
<span class="n">mutableArrValue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">@&#34;kingcos.me&#34;</span><span class="p">;</span>
<span class="n">NSDictionary</span> <span class="o">*</span><span class="n">dictValue</span> <span class="o">=</span> <span class="l">@{</span><span class="s">@&#34;key&#34;</span> <span class="o">:</span> <span class="mi">@100</span><span class="l">}</span><span class="p">;</span>
<span class="n">NSNumber</span> <span class="o">*</span><span class="n">valueForDictByKey</span>  <span class="o">=</span> <span class="n">dictValue</span><span class="p">[</span><span class="s">@&#34;key&#34;</span><span class="p">];</span>
<span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">mutableDictValue</span> <span class="o">=</span> <span class="p">[</span><span class="l">@{</span><span class="s">@&#34;key&#34;</span> <span class="o">:</span> <span class="mi">@100</span><span class="l">}</span> <span class="n">mutableCopy</span><span class="p">];</span>
<span class="n">mutableDictValue</span><span class="p">[</span><span class="s">@&#34;key&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">@200</span><span class="p">;</span>
</code></pre></div><p>字面量语法在 <code>NSArray</code>、<code>NSDictionary</code> 等类中插入 <code>nil</code> 对象时会直接崩溃，而直接使用 API 则会发生「截断」，对于这两个用法差异务必要注意：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">id</span> <span class="n">nilObj</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
<span class="c1">// *** -[__NSPlaceholderArray initWithObjects:count:]: attempt to insert nil object from objects[3]
</span><span class="c1"></span><span class="n">NSArray</span> <span class="o">*</span><span class="n">arrWithNilObject1</span> <span class="o">=</span> <span class="l">@[</span><span class="mi">@0</span><span class="p">,</span> <span class="n">nilObj</span><span class="p">,</span> <span class="mi">@2</span><span class="l">]</span><span class="p">;</span>
<span class="c1">// (0)
</span><span class="c1"></span><span class="n">NSArray</span> <span class="o">*</span><span class="n">arrWithNilObject2</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSArray</span> <span class="nl">arrayWithObjects</span><span class="p">:</span><span class="mi">@0</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span> <span class="mi">@2</span><span class="p">,</span> <span class="nb">nil</span><span class="p">];</span>
<span class="c1">// *** -[__NSPlaceholderDictionary initWithObjects:forKeys:count:]: attempt to insert nil object from objects[0]
</span><span class="c1"></span><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">dictWithNilObject1</span> <span class="o">=</span> <span class="l">@{</span><span class="s">@&#34;a&#34;</span> <span class="o">:</span> <span class="s">@&#34;A&#34;</span><span class="p">,</span> <span class="s">@&#34;b&#34;</span> <span class="o">:</span> <span class="n">nilObj</span><span class="p">,</span> <span class="s">@&#34;c&#34;</span> <span class="o">:</span> <span class="s">@&#34;C&#34;</span><span class="l">}</span><span class="p">;</span>
<span class="c1">// { a = A; }
</span><span class="c1"></span><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">dictWithNilObject2</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSDictionary</span> <span class="nl">dictionaryWithObjectsAndKeys</span><span class="p">:</span><span class="s">@&#34;A&#34;</span><span class="p">,</span> <span class="s">@&#34;a&#34;</span><span class="p">,</span> <span class="n">nilObj</span><span class="p">,</span> <span class="s">@&#34;b&#34;</span><span class="p">,</span> <span class="s">@&#34;C&#34;</span><span class="p">,</span> <span class="s">@&#34;c&#34;</span><span class="p">,</span> <span class="nb">nil</span><span class="p">];</span>
</code></pre></div><p>除了字符串，字面量语法仅适用于 Foundation 框架中，即我们自定义继承自上述支持字面量的类时，将不再支持使用字面量。</p>
<h3 id="多用类型常量少用-define-预处理指令">多用类型常量，少用 #define 预处理指令</h3>
<p><code>#define</code> 预处理指令没有类型信息，且会在引用到包含该指令的所有文件中进行替换，因此更加推荐使用类型常量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// 预处理指令（编译前进行直接替换）
</span><span class="c1"></span><span class="cp">#define ANIMATION_DURATION 0.3
</span><span class="cp"></span>
<span class="c1">// Some.m
</span><span class="c1"></span>
<span class="c1">// 类型常量
</span><span class="c1">// const 决定了其为常量，不可被再次改变
</span><span class="c1">// static 决定了其作用域，即当前文件（因此如果将其定义在 *.h 中，其它引入该头文件的文件也可以访问到）
</span><span class="c1"></span><span class="k">static</span> <span class="k">const</span> <span class="n">NSTimeInterval</span> <span class="n">kAnimationDuration</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>

<span class="c1">// 如果不使用 static 修饰，编译器会创建一个外部符号（External Symbols）
</span><span class="c1"></span><span class="k">const</span> <span class="n">NSTimeInterval</span> <span class="n">SomeAnimationDuration</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>
<span class="c1">// 此时如果在其它文件内声明同名常量，则会报错「duplicate symbol」
</span><span class="c1">// Another.m
</span><span class="c1"></span><span class="k">const</span> <span class="n">NSTimeInterval</span> <span class="n">SomeAnimationDuration</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>

<span class="c1">// ---
</span><span class="c1"></span>
<span class="c1">// main.m
</span><span class="c1">// 声明为 `static` 和 `const` 的变量，编译器不会为其再创建符号
</span><span class="c1"></span><span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// static const + int
</span><span class="c1"></span><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// static const + int *
</span><span class="c1">// 对于指针，既要使其本身的内容不能改变，也不能改变其指向的内存地址，否则这个指针还是有可能改变的
</span><span class="c1"></span><span class="k">static</span> <span class="kt">int</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="n">k2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">;</span>
<span class="c1">// static const + NSString *
</span><span class="c1"></span><span class="k">static</span> <span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">k3</span> <span class="o">=</span> <span class="s">@&#34;&#34;</span><span class="p">;</span>
<span class="k">static</span> <span class="n">NSString</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="n">k4</span> <span class="o">=</span> <span class="s">@&#34;&#34;</span><span class="p">;</span>

<span class="c1">// const
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">k5</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="c1">// static
</span><span class="c1"></span><span class="k">static</span> <span class="kt">int</span> <span class="n">k6</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="c1">// 为了防止编译器优化未用到的符号，我们这里简单输出以上定义的变量
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%d&#34;</span><span class="p">,</span> <span class="n">k1</span><span class="p">);</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%d&#34;</span><span class="p">,</span> <span class="o">*</span><span class="n">k2</span><span class="p">);</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">k3</span><span class="p">);</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">k4</span><span class="p">);</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%d&#34;</span><span class="p">,</span> <span class="n">k5</span><span class="p">);</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%d&#34;</span><span class="p">,</span> <span class="n">k6</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 输出所有符号
</span><span class="c1">// ➜  Debug nm -C Demo
</span><span class="c1">// 通过以下输出可以得出由 static 和 const 修饰的 k1，k2 编译器都没有为其产生符号
</span><span class="c1">// 但 NSString * 是个例外（Why? 猜测是编译器认为该常量后续还要被修改的可能，因此需要保留其符号）
</span><span class="c1">//                  U _NSLog
</span><span class="c1">//                  U ___CFConstantStringClassReference
</span><span class="c1">// 0000000100000000 T __mh_execute_header
</span><span class="c1">// 00000001000010a0 D _foo
</span><span class="c1">// 0000000100001028 s _k3
</span><span class="c1">// 0000000100001030 s _k4
</span><span class="c1">// 0000000100000fb4 S _k5
</span><span class="c1">// 00000001000010a4 d _k6
</span><span class="c1">// 0000000100000eb0 T _main
</span><span class="c1">//                  U _objc_autoreleasePoolPop
</span><span class="c1">//                  U _objc_autoreleasePoolPush
</span><span class="c1">//                  U dyld_stub_binder
</span><span class="c1"></span>
<span class="c1">// 仅输出外部符号
</span><span class="c1">// ➜  Debug nm -gC Demo
</span><span class="c1">// 所有使用 static 修饰的变量均不在外部符号中，说明 static 将这些符号的作用域限制在当前文件中
</span><span class="c1">//                  U _NSLog
</span><span class="c1">//                  U ___CFConstantStringClassReference
</span><span class="c1">// 0000000100000000 T __mh_execute_header
</span><span class="c1">// 00000001000010a0 D _foo
</span><span class="c1">// 0000000100000fb4 S _k5
</span><span class="c1">// 0000000100000eb0 T _main
</span><span class="c1">//                  U _objc_autoreleasePoolPop
</span><span class="c1">//                  U _objc_autoreleasePoolPush
</span><span class="c1">//                  U dyld_stub_binder
</span></code></pre></div><p>类型常量的命名规则：</p>
<ul>
<li>若常量局限于某个编译单元（Translation Unit，即实现文件 <code>*.m</code>），则需要以小写字母 <code>k</code> 开头；</li>
<li>若常量在类之外也可见，则通常需要以类名开头。</li>
</ul>
<p>关于 <code>nm</code> 命令的基本使用，可以参考 <a href="../ivar_access_control_in_obj-c/">Obj-C 中实例变量和类的访问控制</a>一文。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// Some.h
</span><span class="c1">// extern 告知编译器全局符号表中存在该符号，允许外界使用
</span><span class="c1"></span><span class="k">extern</span> <span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">SomeConstant</span><span class="p">;</span>

<span class="c1">// Some.m
</span><span class="c1">// 外界需要访问则不能声明为 static；外界不可变更，因此声明为 const
</span><span class="c1">// 这里的 const 修饰的是 NSString *（即 const 从右向左原则），SomeConstant 保存的内存地址不能再改变（即不能指向另外一个 NSString 对象）
</span><span class="c1">// 编译器会在数据段（Data Section）为字符串分配存储空间，链接器会将目标文件相互链接，生成最终的可执行文件
</span><span class="c1">// 全局符号命名规则：范围（通常使用类名）+ 名称
</span><span class="c1"></span><span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">SomeConstant</span> <span class="o">=</span> <span class="s">@&#34;SomeConstant&#34;</span><span class="p">;</span>

<span class="c1">// 在 Obj-C 中，除了 C 中原有的 extern 还存在以下相关的宏定义
</span><span class="c1">// FOUNDATION_EXTERN、FOUNDATION_EXPORT、FOUNDATION_IMPORT、UIKIT_EXTERN
</span><span class="c1"></span>
<span class="c1">// NSObjCRuntime.h
</span><span class="c1"></span><span class="cp">#if defined(__cplusplus)
</span><span class="cp"></span><span class="c1">// C++ 下兼容 C++ 的 extern
</span><span class="c1"></span><span class="cp">#define FOUNDATION_EXTERN extern &#34;C&#34;
</span><span class="cp">#else
</span><span class="cp">#define FOUNDATION_EXTERN extern
</span><span class="cp">#endif
</span><span class="cp"></span>

    <span class="cp">#define FOUNDATION_EXPORT  FOUNDATION_EXTERN
</span><span class="cp"></span>    <span class="cp">#define FOUNDATION_IMPORT FOUNDATION_EXTERN
</span><span class="cp"></span>
<span class="c1">// UIKitDefines.h
</span><span class="c1">// UIKIT_EXTERN 还声明了符号的可见范围
</span><span class="c1"></span><span class="cp">#ifdef __cplusplus
</span><span class="cp">#define UIKIT_EXTERN		extern &#34;C&#34; __attribute__((visibility (&#34;default&#34;)))
</span><span class="cp">#else
</span><span class="cp">#define UIKIT_EXTERN	        extern __attribute__((visibility (&#34;default&#34;)))
</span><span class="cp">#endif
</span></code></pre></div><p>对于选择 <code>extern</code> 还是以上 <code>SOME_EXTERN</code>，得出以下的结论：</p>
<ul>
<li>对于这些固定前缀的 <code>extern</code> 应当在其范围下使用，即 <code>FOUNDATION_*</code> 在 Foundation 框架内部使用，<code>UIKIT_*</code> 在 <code>UIKit</code> 内部使用，在我们自己的库内应当推荐自定义 <code>SOME_*</code> 来使用，而不是直接套用其它库内的宏定义；</li>
<li>默认的 <code>extern</code> 由于可能不兼容 C++，那么在库中需要兼容 C++ 时应当使用 <code>extern &quot;C&quot;</code>。</li>
</ul>
<h3 id="用枚举表示状态选项状态码">用枚举表示状态、选项、状态码</h3>
<p>Obj-C 中的枚举（<code>enum</code>）来自 C 语言，而 C++11 标准使得枚举可以定义其底层数据类型（Underlying Type）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// 实现枚举所用的数据类型取决于编译器
</span><span class="c1">// 枚举的底层数据类型不是固定的，其二进制位（bit）的个数必须能完全表示下枚举编号
</span><span class="c1">// 比如 ImageSourceType 可以使用 char 类型（但在 Xcode 里其底层数据类型是第一项默认为 0 的 int 类型）
</span><span class="c1"></span><span class="k">enum</span> <span class="n">ImageSourceType</span> <span class="p">{</span>
    <span class="n">ImageSourceTypeCamera</span><span class="p">,</span>
    <span class="n">ImageSourceTypeGallery</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ImageSourceType</span> <span class="n">type1</span> <span class="o">=</span> <span class="n">ImageSourceTypeCamera</span><span class="p">;</span>

<span class="c1">// typedef 可以简化枚举类型声明
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">enum</span> <span class="n">ImageSourceType</span> <span class="n">ImageSourceType</span><span class="p">;</span>
<span class="n">ImageSourceType</span> <span class="n">type2</span> <span class="o">=</span> <span class="n">ImageSourceTypeGallery</span><span class="p">;</span>

<span class="c1">// C++ 11 标准，显式声明枚举底层数据类型
</span><span class="c1"></span><span class="k">enum</span> <span class="nl">NetworkType</span><span class="p">:</span> <span class="n">NSInteger</span> <span class="p">{</span>
    <span class="n">NetworkTypeUnknown</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="c1">// 显式为从 -1 开始
</span><span class="c1"></span>    <span class="n">NetworkTypeWiFi</span>   <span class="c1">// 0 递增
</span><span class="c1"></span>    <span class="n">NetworkCellular</span>   <span class="c1">// 1
</span><span class="c1"></span><span class="p">};</span>

<span class="c1">// 枚举的向前声明（在 .m 中引入或实现即可）
</span><span class="c1">// Some.h
</span><span class="c1"></span><span class="k">enum</span> <span class="nl">NetworkType</span><span class="p">:</span> <span class="n">NSInteger</span><span class="p">;</span>
</code></pre></div><p>枚举中使用按位或操作符（Bitwise OR Operator）可以使得枚举的每个选项均可启用或禁用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// UIViewAutoresizingNone 是无法与其它项目同时存在，因此为 0
</span><span class="c1"></span>
<span class="c1">// UIView.h
</span><span class="c1"></span><span class="k">typedef</span> <span class="nf">NS_OPTIONS</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">,</span> <span class="n">UIViewAutoresizing</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UIViewAutoresizingNone</span>                 <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">UIViewAutoresizingFlexibleLeftMargin</span>   <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">UIViewAutoresizingFlexibleWidth</span>        <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">UIViewAutoresizingFlexibleRightMargin</span>  <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">UIViewAutoresizingFlexibleTopMargin</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">UIViewAutoresizingFlexibleHeight</span>       <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">UIViewAutoresizingFlexibleBottomMargin</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span>
<span class="p">};</span>

<span class="c1">// 使用时可以使用按位或来组合多个选项：
</span><span class="c1"></span><span class="n">UIViewAutoresizing</span> <span class="n">resize</span> <span class="o">=</span> <span class="n">UIViewAutoresizingFlexibleWidth</span> <span class="o">|</span> <span class="n">UIViewAutoresizingFlexibleHeight</span><span class="p">;</span>

<span class="c1">// 判断时使用按位与（Bitwise AND Operator）即可
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">resize</span> <span class="o">&amp;</span> <span class="n">UIViewAutoresizingFlexibleWidth</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;UIViewAutoresizingFlexibleWidth&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">resize</span> <span class="o">&amp;</span> <span class="n">UIViewAutoresizingFlexibleHeight</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;UIViewAutoresizingFlexibleHeight&#34;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// UIViewAutoresizingFlexibleWidth
</span><span class="c1">// UIViewAutoresizingFlexibleHeight
</span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="cm">/* NS_ENUM supports the use of one or two arguments. The first argument is always the integer type used for the values of the enum. The second argument is an optional type name for the macro. When specifying a type name, you must precede the macro with &#39;typedef&#39; like so:
</span><span class="cm">
</span><span class="cm">typedef NS_ENUM(NSInteger, NSComparisonResult) {
</span><span class="cm">    ...
</span><span class="cm">};
</span><span class="cm">
</span><span class="cm">If you do not specify a type name, do not use &#39;typedef&#39;. For example:
</span><span class="cm">
</span><span class="cm">NS_ENUM(NSInteger) {
</span><span class="cm">    ...
</span><span class="cm">};
</span><span class="cm">*/</span>
<span class="cp">#define NS_ENUM(...) CF_ENUM(__VA_ARGS__)
</span><span class="cp">#define NS_OPTIONS(_type, _name) CF_OPTIONS(_type, _name)
</span><span class="cp"></span>
<span class="c1">// CFAvailability.h
</span><span class="c1"></span><span class="cp">#define CF_ENUM(...) __CF_ENUM_GET_MACRO(__VA_ARGS__, __CF_NAMED_ENUM, __CF_ANON_ENUM, )(__VA_ARGS__)
</span><span class="cp"></span><span class="c1">// 根据是否按照 C++ 模式编译而不同
</span><span class="c1"></span><span class="cp">#define __CF_ENUM_GET_MACRO(_1, _2, NAME, ...) NAME
</span><span class="cp">#if (__cplusplus &amp;&amp; __cplusplus &gt;= 201103L &amp;&amp; (__has_extension(cxx_strong_enums) || __has_feature(objc_fixed_enum))) || (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum))
</span><span class="cp"></span>    <span class="cp">#define __CF_NAMED_ENUM(_type, _name)     enum __CF_ENUM_ATTRIBUTES _name : _type _name; enum _name : _type
</span><span class="cp"></span>    <span class="cp">#define __CF_ANON_ENUM(_type)             enum __CF_ENUM_ATTRIBUTES : _type
</span><span class="cp"></span>    <span class="cp">#define CF_CLOSED_ENUM(_type, _name)      enum __CF_CLOSED_ENUM_ATTRIBUTES _name : _type _name; enum _name : _type
</span><span class="cp"></span>    <span class="cp">#if (__cplusplus)
</span><span class="cp"></span>        <span class="cp">#define CF_OPTIONS(_type, _name) _type _name; enum __CF_OPTIONS_ATTRIBUTES : _type
</span><span class="cp"></span>    <span class="cp">#else
</span><span class="cp"></span>        <span class="cp">#define CF_OPTIONS(_type, _name) enum __CF_OPTIONS_ATTRIBUTES _name : _type _name; enum _name : _type
</span><span class="cp"></span>    <span class="cp">#endif
</span><span class="cp">#else
</span><span class="cp"></span>    <span class="cp">#define __CF_NAMED_ENUM(_type, _name) _type _name; enum
</span><span class="cp"></span>    <span class="cp">#define __CF_ANON_ENUM(_type) enum
</span><span class="cp"></span>    <span class="cp">#define CF_CLOSED_ENUM(_type, _name) _type _name; enum
</span><span class="cp"></span>    <span class="cp">#define CF_OPTIONS(_type, _name) _type _name; enum
</span><span class="cp">#endif
</span><span class="cp"></span>
<span class="c1">// Some.mm
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">enum</span> <span class="nl">Direction</span><span class="p">:</span> <span class="kt">int</span> <span class="n">FooDirection</span><span class="p">;</span>
<span class="k">enum</span> <span class="nl">Direction</span><span class="p">:</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">Up</span>      <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">Down</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">Left</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">Right</span>   <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span>
<span class="p">};</span>

<span class="c1">// 在使用或运算操作两个枚举值时，C++ 认为运算结果的数据类型应当是枚举的底层数据类型，即 `NSUInteger`，且 C++ 不支持将底层数据类型隐式转换为枚举类型本身
</span><span class="c1">// ERROR: Cannot initialize a variable of type &#39;FooDirection&#39; (aka &#39;Direction&#39;) with an rvalue of type &#39;int&#39;
</span><span class="c1">// FooDirection direct = Up | Left;
</span></code></pre></div><p>Foundation 框架中枚举的辅助宏具备向后兼容（Backward Compatibility）能力，即根据目标平台决定相应的语法；凡是需要按位或操作来组合的枚举都应当使用 <code>NS_OPTIONS</code> 来定义；否则使用 <code>NS_ENUM</code>。</p>
<h2 id="对象消息运行期">对象、消息、运行期</h2>
<h3 id="理解属性这一概念">理解「属性」这一概念</h3>
<p>应用程序二进制接口（Application Binary Interface，即 ABI）定义了很多内容，其中有生成代码时所应遵循的规范。Obj-C 中实例变量（ivar）的内存布局在编译时刻固定，因此访问实例变量时，编译器会将其替换为偏移量（Offset），而偏移量是硬编码，表示其距离内存起始地址的长度；如果代码使用了编译时刻计算的偏移量，那么在修改类定义之后必须重新编译，即重新计算偏移量；</p>
<p>对于旧的类定义链接了新的类定义会出现不兼容情况，Obj-C 的做法如下：</p>
<ul>
<li>将实例变量当作一种存储偏移量所用的特殊变量，交由类对象保管，偏移量将在运行时查找，这样即使类定义变化了，也能找到正确的偏移量，甚至可以在运行时新增实例变量；</li>
<li>尽量不要直接访问实例变量，而是通过 getter &amp; setter，Obj-C 中可以使用 <code>@property</code> 语法。</li>
</ul>
<p>在 Xcode 4.4 之后，Obj-C 编译器 Clang 新增了自动合成（Autosynthesis）的特性。编译器默认会自动为 Obj-C 中的属性 <code>@property</code> 编写其所需的 getter &amp; setter 方法，另外还会添加适当类型的成员变量，并在属性名前加 <code>_</code> 前缀作为成员变量名，整个过程在编译时刻执行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// main.m
</span><span class="c1"></span>
<span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="cp"></span>
<span class="k">@protocol</span> <span class="nc">SomeProtocol</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>

<span class="c1">// 注意：实现协议中的属性将不会自动合成
</span><span class="c1">// WARNING: Auto property synthesis will not synthesize property &#39;propInProtocol1&#39; declared in protocol &#39;SomeProtocol&#39;
</span><span class="c1"></span><span class="k">@property</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">propInProtocol1</span><span class="p">;</span>
<span class="k">@property</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">propInProtocol2</span><span class="p">;</span>

<span class="k">@end</span>

<span class="k">@interface</span> <span class="nc">Foo</span> : <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">SomeProtocol</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="c1">// 手动合成后，重新声明为 public
</span><span class="c1"></span><span class="k">@public</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">propInProtocol2</span><span class="p">;</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">ivarForPropInClass3</span><span class="p">;</span> <span class="c1">// 也可使用 @synthesize 手动合成
</span><span class="c1"></span><span class="p">}</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">propInClass1</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">propInClass2</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">propInClass3</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">propInClass4</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">propInClass5</span><span class="p">;</span>

<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo</span>
<span class="c1">// @dynamic 标注后将不会自动合成，即不会实现 getter &amp; setter，也不会创建实例变量
</span><span class="c1">// 但使用 getter &amp; setter 可以编译，因为其声明仍存在，且相信会在运行时动态找到这些方法
</span><span class="c1"></span><span class="k">@dynamic</span> <span class="n">propInClass2</span><span class="p">;</span>

<span class="c1">// 手动合成 getter &amp; setter，以及成员变量 bar
</span><span class="c1"></span><span class="k">@synthesize</span> <span class="n">propInProtocol2</span><span class="p">;</span> <span class="c1">// 也等同于显式指定属性的成员变量名为 bar：@synthesize bar = bar;
</span><span class="c1"></span>
<span class="p">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">propInClass3</span> <span class="p">{</span>
    <span class="c1">// 当同时实现属性 getter &amp; setter 时，将不会自动合成成员变量
</span><span class="c1"></span>    <span class="c1">// ERROR: Use of undeclared identifier &#39;_propInClass3&#39;; did you mean &#39;_propInClass1&#39;?
</span><span class="c1"></span>    <span class="c1">// return _propInClass3;
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">ivarForPropInClass3</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setPropInClass3:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">propInClass3</span> <span class="p">{</span>
    <span class="c1">// _propInClass3 = propInClass3;
</span><span class="c1"></span>    <span class="n">ivarForPropInClass3</span> <span class="o">=</span> <span class="n">propInClass3</span><span class="p">;</span>

    <span class="c1">// readonly 属性重写 getter 时，将不会自动合成成员变量
</span><span class="c1"></span>    <span class="n">_propInClass4</span> <span class="o">=</span> <span class="s">@&#34;kingcos.me&#34;</span><span class="p">;</span>
    <span class="c1">// ERROR: Use of undeclared identifier &#39;_propInClass5&#39;
</span><span class="c1"></span>    <span class="c1">// _propInClass5 = @&#34;kingcos.me&#34;;
</span><span class="c1"></span><span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">propInClass5</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">@&#34;kingcos.me&#34;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@end</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

    <span class="c1">// CRASH: &#39;-[Foo setPropInProtocol1:]: unrecognized selector sent to instance 0x1005355f0&#39;
</span><span class="c1"></span>    <span class="c1">// foo.propInProtocol1 = @&#34;kingcos.me&#34;;
</span><span class="c1"></span>
    <span class="n">foo</span><span class="p">.</span><span class="n">propInProtocol2</span> <span class="o">=</span> <span class="s">@&#34;kingcos.me&#34;</span><span class="p">;</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">propInProtocol2</span><span class="p">);</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">foo</span><span class="o">-&gt;</span><span class="n">propInProtocol2</span><span class="p">);</span>

    <span class="n">foo</span><span class="p">.</span><span class="n">propInClass1</span> <span class="o">=</span> <span class="s">@&#34;kingcos.me&#34;</span><span class="p">;</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">propInClass1</span><span class="p">);</span>
    <span class="c1">// ERROR: Instance variable &#39;_propInClass1&#39; is private
</span><span class="c1"></span>    <span class="c1">// NSLog(@&#34;%@&#34;, foo-&gt;_propInClass1);
</span><span class="c1"></span>
    <span class="c1">// CRASH: &#39;-[Foo setpropInClass2:]: unrecognized selector sent to instance 0x101b00710&#39;
</span><span class="c1"></span>    <span class="c1">// foo.propInClass2 = @&#34;kingcos.me&#34;;
</span><span class="c1"></span>    <span class="c1">// CRASH: &#39;-[Foo propInClass2]: unrecognized selector sent to instance 0x1009481e0&#39;
</span><span class="c1"></span>    <span class="c1">// NSLog(@&#34;%@&#34;, foo.propInClass2);
</span><span class="c1"></span>
    <span class="n">foo</span><span class="p">.</span><span class="n">propInClass3</span> <span class="o">=</span> <span class="s">@&#34;kingcos.me&#34;</span><span class="p">;</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">propInClass3</span><span class="p">);</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">foo</span><span class="o">-&gt;</span><span class="n">ivarForPropInClass3</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ol>
<li>原子性</li>
</ol>
<p>原子（Atom）是参与化学反应中最小的粒子，因此可以理解为一个原子性（Atomicity）的操作是不会被中断的，即保证线程安全。声明属性时，如果不明确指定原子性则为 <code>atomic</code>。开发者自己实现的 getter &amp; setter 需要自己来保证相应的原子性。</p>
<p>那我们应当使用哪个修饰符呢？从源码来看，使用 <code>atomic</code> 或 <code>nonatomic</code> 修饰的属性会影响生成的 getter &amp; setter：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// objc4 - objc-accessors.mm
</span><span class="c1"></span>
<span class="c1">// 属性锁 Map（专用于 atomic &amp; nonatomic）
</span><span class="c1"></span><span class="n">StripedMap</span><span class="o">&lt;</span><span class="n">spinlock_t</span><span class="o">&gt;</span> <span class="n">PropertyLocks</span><span class="p">;</span>

<span class="c1">// getter
</span><span class="c1"></span><span class="kt">id</span> <span class="nf">objc_getProperty</span><span class="p">(</span><span class="kt">id</span> <span class="nb">self</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">_cmd</span><span class="p">,</span> <span class="n">ptrdiff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="k">atomic</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 偏移量为 0，即 isa
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 直接返回类
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">object_getClass</span><span class="p">(</span><span class="nb">self</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 根据 self 偏移，slot 指向成员变量的值
</span><span class="c1"></span>    <span class="c1">// Retain release world
</span><span class="c1"></span>    <span class="kt">id</span> <span class="o">*</span><span class="n">slot</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="nb">self</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
    <span class="c1">// nonatomic 下，直接返回
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">atomic</span><span class="p">)</span> <span class="k">return</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>

    <span class="c1">// atomic 下，则先加自旋锁，持有值，最后解锁（锁与 setter 是同一个）
</span><span class="c1"></span>    <span class="c1">// Atomic retain release world
</span><span class="c1"></span>    <span class="n">spinlock_t</span><span class="o">&amp;</span> <span class="n">slotlock</span> <span class="o">=</span> <span class="n">PropertyLocks</span><span class="p">[</span><span class="n">slot</span><span class="p">];</span>
    <span class="n">slotlock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="kt">id</span> <span class="n">value</span> <span class="o">=</span> <span class="n">objc_retain</span><span class="p">(</span><span class="o">*</span><span class="n">slot</span><span class="p">);</span>
    <span class="n">slotlock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>

    <span class="c1">// for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">objc_autoreleaseReturnValue</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reallySetProperty</span><span class="p">(</span><span class="kt">id</span> <span class="nb">self</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">_cmd</span><span class="p">,</span> <span class="kt">id</span> <span class="n">newValue</span><span class="p">,</span> <span class="n">ptrdiff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">bool</span> <span class="k">atomic</span><span class="p">,</span> <span class="kt">bool</span> <span class="k">copy</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">mutableCopy</span><span class="p">)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">));</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reallySetProperty</span><span class="p">(</span><span class="kt">id</span> <span class="nb">self</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">_cmd</span><span class="p">,</span> <span class="kt">id</span> <span class="n">newValue</span><span class="p">,</span> <span class="n">ptrdiff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">bool</span> <span class="k">atomic</span><span class="p">,</span> <span class="kt">bool</span> <span class="k">copy</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">mutableCopy</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 偏移量为 0，即 isa
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 设置对象的类，即 isa
</span><span class="c1"></span>        <span class="n">object_setClass</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">newValue</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 旧值
</span><span class="c1"></span>    <span class="kt">id</span> <span class="n">oldValue</span><span class="p">;</span>
    <span class="c1">// 根据 self 偏移，slot 指向成员变量的旧值
</span><span class="c1"></span>    <span class="kt">id</span> <span class="o">*</span><span class="n">slot</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="nb">self</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="k">copy</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// copy 属性
</span><span class="c1"></span>        <span class="n">newValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">newValue</span> <span class="nl">copyWithZone</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mutableCopy</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 可变 copy
</span><span class="c1"></span>        <span class="n">newValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">newValue</span> <span class="nl">mutableCopyWithZone</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 旧值等于新值，不执行操作
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">slot</span> <span class="o">==</span> <span class="n">newValue</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">newValue</span> <span class="o">=</span> <span class="n">objc_retain</span><span class="p">(</span><span class="n">newValue</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">atomic</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// nonatomic 下，仅做简单赋值操作
</span><span class="c1"></span>        <span class="n">oldValue</span> <span class="o">=</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
        <span class="o">*</span><span class="n">slot</span> <span class="o">=</span> <span class="n">newValue</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// atomic 下，则先加自旋锁（内部使用 os_unfair_lock 实现），再赋值，最后解锁（锁与 getter 是同一个）
</span><span class="c1"></span>        <span class="o">&amp;</span> <span class="n">slotlock</span> <span class="o">=</span> <span class="n">PropertyLocks</span><span class="p">[</span><span class="n">slot</span><span class="p">];</span>
        <span class="n">slotlock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span><span class="n">spinlock_t</span>
        <span class="n">oldValue</span> <span class="o">=</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
        <span class="o">*</span><span class="n">slot</span> <span class="o">=</span> <span class="n">newValue</span><span class="p">;</span>
        <span class="n">slotlock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">objc_release</span><span class="p">(</span><span class="n">oldValue</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// setter
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">objc_setProperty</span><span class="p">(</span><span class="kt">id</span> <span class="nb">self</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">_cmd</span><span class="p">,</span> <span class="n">ptrdiff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">id</span> <span class="n">newValue</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="k">atomic</span><span class="p">,</span> <span class="kt">signed</span> <span class="kt">char</span> <span class="n">shouldCopy</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="k">copy</span> <span class="o">=</span> <span class="p">(</span><span class="n">shouldCopy</span> <span class="o">&amp;&amp;</span> <span class="n">shouldCopy</span> <span class="o">!=</span> <span class="n">MUTABLE_COPY</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">mutableCopy</span> <span class="o">=</span> <span class="p">(</span><span class="n">shouldCopy</span> <span class="o">==</span> <span class="n">MUTABLE_COPY</span><span class="p">);</span>
    <span class="c1">// 实际调用 reallySetProperty ⬆️
</span><span class="c1"></span>    <span class="n">reallySetProperty</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">_cmd</span><span class="p">,</span> <span class="n">newValue</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">atomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">,</span> <span class="n">mutableCopy</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>由上我们可以得出，<code>atomic</code> 在 getter 和 setter 内部是通过自旋锁来避免资源竞争而导致的线程不安全。但在实际使用中，我们可能并非都是通过 setter 来改变属性的值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@interface</span> <span class="nc">Foo</span> : <span class="nc">NSObject</span>
<span class="c1">// 声明为 atomic
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">atomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">arr</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo</span>
<span class="k">@end</span>

<span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

<span class="c1">// 1. 通过 setter 设置，满足线程安全
</span><span class="c1"></span><span class="n">foo</span><span class="p">.</span><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="l">@[</span><span class="s">@&#34;kingcos.me&#34;</span><span class="p">,</span> <span class="s">@&#34;github.com/kingcos&#34;</span><span class="l">]</span> <span class="n">mutableCopy</span><span class="p">];</span>

<span class="c1">// 2. 通过 setter 设置，满足线程安全
</span><span class="c1"></span><span class="p">[</span><span class="n">foo</span> <span class="nl">setArr</span><span class="p">:[</span><span class="l">@[</span><span class="s">@&#34;kingcos.me&#34;</span><span class="p">,</span> <span class="s">@&#34;github.com/kingcos&#34;</span><span class="l">]</span> <span class="n">mutableCopy</span><span class="p">]];</span>

<span class="c1">// 3. 虽然是通过 getter 访问的 arr，但设置并未通过其 setter，线程不安全
</span><span class="c1"></span><span class="p">[</span><span class="n">foo</span><span class="p">.</span><span class="n">arr</span> <span class="nl">addObject</span><span class="p">:</span><span class="s">@&#34;instagram.com/kingcos_v&#34;</span><span class="p">];</span>
<span class="p">[</span><span class="n">foo</span><span class="p">.</span><span class="n">arr</span> <span class="nl">addObject</span><span class="p">:</span><span class="s">@&#34;twitter.com/kingcos_v&#34;</span><span class="p">];</span>
</code></pre></div><p>如 3 中的设置并未通过其 setter，因此 <code>atomic</code> 并不能使得属性完全满足线程安全，而 getter &amp; setter 又十分常用，加锁解锁的开销较大，所以我们通常都声明为 <code>nonatomic</code>，并在必要时在外界对属性的访问或设置加锁。</p>
<ol start="2">
<li>读写权限</li>
</ol>
<p>声明属性时，<code>readwrite</code> 为同时生成 getter &amp; setter，<code>readonly</code> 为仅生成 <code>getter</code>；外部 <code>.h</code> 中声明为 <code>readonly</code>，但内部类扩展中再次声明为 <code>readwrite</code> 时，<code>setter</code> 可以自动生成但不会暴露给外界。</p>
<ol start="3">
<li>内存管理语义</li>
</ol>
<p><code>assign</code>：setter 只会针对纯量类型（Scalar Type）例如 <code>CGFloat</code>、<code>NSInteger</code> 等执行简单地赋值操作。</p>
<p><code>strong</code>：定义一种拥有关系，为这种属性设置新值时，setter 会先保留新值，并释放旧值，然后再将新值设置上去。</p>
<p><code>weak</code>：定义一种<strong>非</strong>拥有关系，为这种属性设置新值时，setter 既不保留新值，也不释放旧值，类似 <code>assign</code>，但当属性所指向的对象销毁时，属性值会置为 <code>nil</code>。</p>
<p><code>unsafe_unretained</code>：内存语义与 <code>assign</code> 相同，但适用于对象类型，定义一种非拥有（不保留）关系，但当属性所指向的对象销毁时，属性值<strong>不会</strong>自动置为 <code>nil</code>（Autoniling），这也是与 <code>weak</code> 的差异。</p>
<p><code>copy</code>：类似 <code>strong</code>，但 setter 不保留新值，而是将其拷贝；当属性类型为 <code>NSString *</code> 时，可以使用 <code>copy</code> 保护其封装性，因为 setter 接收的新值有可能是指向 <code>NSMutableString</code> 的实例，若不拷贝则可能会被外界随时更改，因此需要拷贝为不可变的类型。</p>
<ol start="4">
<li>方法名</li>
</ol>
<p><code>getter=&lt;name&gt;</code> 可以指定 getter 方法名；<code>setter=&lt;name&gt;</code> 可以指定 setter 方法名。</p>
<ol start="5">
<li>类属性</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kd">class</span> <span class="nc">var</span> <span class="n">bar</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">baz</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div><p>在 Swift 中的 <code>class</code> 里，我们可以自由定义归属于类的属性，即这些属性只在该类中存储一份。Apple 为了使得 Obj-C 与 Swift 兼容，在 2016 年 Swift 3.0 诞生时，Obj-C 属性增加了 <code>class</code> 修饰符。但需要注意的是，<code>class</code> 修饰后，该属性将不会自动合成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@interface</span> <span class="nc">Foo</span> : <span class="nc">NSObject</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">class</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">bar</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo</span>
<span class="c1">// 静态变量存储
</span><span class="c1"></span><span class="k">static</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">_bar</span> <span class="o">=</span> <span class="s">@&#34;&#34;</span><span class="p">;</span>

<span class="c1">// 类方法 getter
</span><span class="c1"></span><span class="p">+</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">bar</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_bar</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 类方法 setter
</span><span class="c1"></span><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setBar:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span> <span class="p">{</span>
    <span class="n">_bar</span> <span class="o">=</span> <span class="n">bar</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">Foo</span><span class="p">.</span><span class="n">bar</span> <span class="o">=</span> <span class="s">@&#34;kingcos.me&#34;</span><span class="p">;</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="p">[</span><span class="n">Foo</span> <span class="n">bar</span><span class="p">]);</span>

    <span class="p">[</span><span class="n">Foo</span> <span class="nl">setBar</span><span class="p">:</span><span class="s">@&#34;github.com/kingcos&#34;</span><span class="p">];</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">Foo</span><span class="p">.</span><span class="n">bar</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// kingcos.me
</span><span class="c1">// github.com/kingcos
</span></code></pre></div><p>属性特性（Attribute）只在自动生成时有效，开发者自己实现的 getter &amp; setter 要保证其具备相应的属性特性。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@interface</span> <span class="nc">Foo</span> : <span class="nc">NSObject</span>
<span class="c1">// 即使 readonly 也要注明 copy，因为在 init 中进行了 copy
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">copy</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">bar</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithBar:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span>
<span class="p">{</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 要保证属性的内存语义
</span><span class="c1"></span>        <span class="n">_bar</span> <span class="o">=</span> <span class="p">[</span><span class="n">bar</span> <span class="k">copy</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></div><ol start="6">
<li>可空性</li>
</ol>
<p>可详见《<a href="https://kingcos.me/posts/2019/nullability_in_obj-c/">[译] 在 Objective-C API 中指定可空性</a>》一文。</p>
<ol start="7">
<li><code>direct</code></li>
</ol>
<p><code>direct</code> 是 2019 年底 LLVM 为 Obj-C 新增的一项特性，其使得开发者可以明确将消息传递的 Obj-C 方法改为直接派发（Direct Dispatch），这使得方法调用效率得以提升，但相反也损失了运行时。当我们在 Obj-C 属性特性中声明 <code>direct</code> 时，其 getter &amp; setter 方法将得到编译器的这种优化：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="cp"></span>
<span class="k">@interface</span> <span class="nc">Foo</span> : <span class="nc">NSObject</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">copy</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="n">direct</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">directProp</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">copy</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">normalProp</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo</span>
<span class="k">@end</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[</span><span class="n">Foo</span> <span class="n">new</span><span class="p">];</span>
        <span class="n">foo</span><span class="p">.</span><span class="n">directProp</span> <span class="o">=</span> <span class="s">@&#34;kingcos.me&#34;</span><span class="p">;</span>
        
        <span class="n">foo</span><span class="p">.</span><span class="n">normalProp</span> <span class="o">=</span> <span class="s">@&#34;maimieng.com&#34;</span><span class="p">;</span> <span class="c1">// BREAKPOINT 🔴
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>节选一部分汇编也能看到，此时 <code>directProp</code> 的 setter 不再需要借助 <code>objc_msgSend</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm">    <span class="c">; ...
</span><span class="c"></span>    <span class="err">0</span><span class="nf">x100003c73</span> <span class="err">&lt;+</span><span class="mi">67</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">callq</span>  <span class="mi">0x100003af0</span>               <span class="c">; -[Foo setDirectProp:] at main.m:15
</span><span class="c"></span>    <span class="mi">0x100003c78</span> <span class="err">&lt;+</span><span class="mi">72</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">leaq</span>   <span class="mi">0x3b9</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rax</span>         <span class="c">; @&#34;maimieng.com&#34;
</span><span class="c"></span><span class="p">-</span><span class="err">&gt;</span>  <span class="mi">0x100003c7f</span> <span class="err">&lt;+</span><span class="mi">79</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="p">-</span><span class="mi">0x18</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rcx</span>
    <span class="err">0</span><span class="nf">x100003c83</span> <span class="err">&lt;+</span><span class="mi">83</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="mi">0x4636</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rsi</span>        <span class="c">; &#34;setNormalProp:&#34;
</span><span class="c"></span>    <span class="mi">0x100003c8a</span> <span class="err">&lt;+</span><span class="mi">90</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rcx</span><span class="p">,</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x100003c8d</span> <span class="err">&lt;+</span><span class="mi">93</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rdx</span>
    <span class="err">0</span><span class="nf">x100003c90</span> <span class="err">&lt;+</span><span class="mi">96</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">callq</span>  <span class="p">*</span><span class="mi">0x36a</span><span class="p">(</span><span class="nv">%rip</span><span class="p">)</span>              <span class="c">; (void *)0x00007fff203ffd00: objc_msgSend
</span><span class="c"></span>    <span class="c">; ...
</span></code></pre></div><p>需要注意的是，当声明 <code>direct</code> 时，即使自定义 getter &amp; setter 也仍将获得该编译器优化。</p>
<ul>
<li><a href="https://github.com/llvm/llvm-project/commit/d4e1ba3fa9dfec2613bdcc7db0b58dea490c56b1">Implement <code>__attribute__((objc_direct))</code>, <code>__attribute__((objc_direct_members))</code> - llvm/llvm-project</a></li>
<li><a href="https://nshipster.com/direct/">Objective-C Direct Methods - Mattt, NSHipster</a></li>
<li><a href="https://lrdcq.com/me/read.php/99.htm">小议：oc 新增的 direct 方法与程序员的美学 - LRD</a></li>
</ul>
<h3 id="在对象内部尽量直接访问实例变量">在对象内部尽量直接访问实例变量</h3>
<p>直接访问实例变量（ivar）与通过属性（getter &amp; setter）访问的区别：</p>
<ul>
<li>直接访问不经过方法派发，速度更快；</li>
<li>直接访问不经过所定义的内存管理语义（例如 <code>copy</code>）；</li>
<li>直接访问不经过 KVO；</li>
<li>通过属性访问便于 Debug（可以打断点）。</li>
</ul>
<p>因此建议读取时直接访问，写入时通过属性，当然具体问题见仁见智。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// 懒加载的属性必须要通过 getter 访问
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="n">NSObject</span> <span class="o">*</span><span class="p">)</span><span class="nf">foo</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_foo</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_foo</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSObject</span> <span class="n">new</span><span class="p">];</span>
        <span class="k">return</span> <span class="n">_foo</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="理解对象等同性这一概念">理解「对象等同性」这一概念</h3>
<p>对于 Obj-C 中的对象类型，<code>==</code> 比较的是两个指针本身的值（即存储的地址）是否一致。NSString 类中的 <code>isEqualToString:</code> 比 <code>isEqual:</code> 方法速度更快（但其实差别不大）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEqual:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span> <span class="p">{</span>
    <span class="c1">// 地址一致，则必然一样
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span> <span class="o">==</span> <span class="n">object</span><span class="p">)</span> <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
    <span class="c1">// 如果非同类，则不相等（子父类之间比较视情况而定）
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[</span><span class="n">object</span> <span class="k">class</span><span class="p">])</span> <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>

    <span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="n">Foo</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">_bar</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="n">foo</span><span class="p">.</span><span class="n">bar</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_baz</span> <span class="o">!=</span> <span class="n">foo</span><span class="p">.</span><span class="n">baz</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>若两个对象相等，<code>hash</code> 也相等；<code>hash</code> 相等，但两个对象并不一定相等。实现 <code>hash</code> 方法要在减少碰撞与降低运算复杂程度（性能影响）之间权衡：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// 返回固定值
</span><span class="c1">// 可行，但在 collection 中使用该类型对象将产生性能问题，因为 collection 检索哈希表（Hash Table）时，会用对象的哈希码（Hash Code）做索引。
</span><span class="c1">// 假如某个 collection 是用 set 实现的，其可能会根据哈希码把对象分装到不同的数组中。
</span><span class="c1">// 若每个对象都返回相同的哈希码，则需要将所有对象全部扫描。
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">hash</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1024</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 属性拼接字符串并 hash
</span><span class="c1">// 但需承担创建字符串的开销；添加到 collection 中由于必须计算哈希码也会产生性能问题
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">hash</span> <span class="p">{</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&#34;%@:%i&#34;</span><span class="p">,</span> <span class="n">_bar</span><span class="p">,</span> <span class="n">_baz</span><span class="p">];</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">str</span> <span class="n">hash</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// 效率高，范围确定
</span><span class="c1">// 虽然会碰撞，但允许
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">hash</span> <span class="p">{</span>
    <span class="n">NSUInteger</span> <span class="n">bar</span> <span class="o">=</span> <span class="p">[</span><span class="n">_bar</span> <span class="n">hash</span><span class="p">];</span>
    <span class="n">NSUInteger</span> <span class="n">baz</span> <span class="o">=</span> <span class="n">_baz</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">bar</span> <span class="o">^</span> <span class="n">baz</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>编写特定类的等同性判定方法（比如 <code>isEqualToString:</code>）时，应一并重写 <code>isEqual:</code> 方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEqualToFoo:</span><span class="p">(</span><span class="n">Foo</span> <span class="o">*</span><span class="p">)</span><span class="nv">foo</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span> <span class="o">==</span> <span class="n">object</span><span class="p">)</span> <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">_bar</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="n">foo</span><span class="p">.</span><span class="n">bar</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_baz</span> <span class="o">!=</span> <span class="n">foo</span><span class="p">.</span><span class="n">baz</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEqual:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span> <span class="p">{</span>
    <span class="c1">// 相同类则自己判断
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="n">object</span> <span class="k">class</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">isEqualToFoo</span><span class="p">:(</span><span class="n">Foo</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// 不同类则交给父类
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">isEqual</span><span class="p">:</span><span class="n">object</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div><p>等同性判定的执行深度取决于受测对象，即若有某个 ID 字段则可以直接根据该 ID 来判定。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// 将对象放入 collection 中，不应再改变其哈希码，即需要确保哈希码并非根据对象的可变部分计算得出
</span><span class="c1"></span><span class="n">NSMutableSet</span> <span class="o">*</span><span class="n">set</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableSet</span> <span class="n">new</span><span class="p">];</span>
<span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="l">@[</span><span class="mi">@1</span><span class="l">]</span> <span class="n">mutableCopy</span><span class="p">];</span>
<span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">arr2</span> <span class="o">=</span> <span class="p">[</span><span class="l">@[</span><span class="mi">@1</span><span class="p">,</span> <span class="mi">@2</span><span class="l">]</span> <span class="n">mutableCopy</span><span class="p">];</span>

<span class="p">[</span><span class="n">set</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">arr1</span><span class="p">];</span>
<span class="p">[</span><span class="n">set</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">arr2</span><span class="p">];</span>

<span class="c1">// {((1), (1,2))}
</span><span class="c1"></span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>

<span class="c1">// Set 中存在了两个完全相同的结构
</span><span class="c1">// {((1,2), (1,2))}
</span><span class="c1"></span><span class="p">[</span><span class="n">arr1</span> <span class="nl">addObject</span><span class="p">:</span><span class="mi">@2</span><span class="p">];</span>
<span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
</code></pre></div><h3 id="以类族模式隐藏实现细节">以「类族模式」隐藏实现细节</h3>
<p>类族（Class Cluster，又称类簇）是一种隐藏抽象基类背后的实现细节的模式（例如 <code>UIButton</code> 的 <code>buttonWithType:</code> 类方法）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// 模式是不限定于语言的，因此这里使用了 Swift 来简单实现</span>

<span class="kd">enum</span> <span class="nc">FooType</span> <span class="p">{</span>
    <span class="k">case</span> <span class="bp">first</span>
    <span class="k">case</span> <span class="n">second</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">build</span><span class="p">(</span><span class="kc">_</span> <span class="n">type</span><span class="p">:</span> <span class="n">FooType</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Foo</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">type</span> <span class="p">{</span>
        <span class="k">case</span> <span class="p">.</span><span class="bp">first</span><span class="p">:</span> <span class="k">return</span> <span class="n">FooFirst</span><span class="p">()</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">second</span><span class="p">:</span> <span class="k">return</span> <span class="n">FooSecond</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
        <span class="bp">fatalError</span><span class="p">(</span><span class="s">&#34;bar should be implemented in subclasses.&#34;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">FooFirst</span><span class="p">:</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="kc">#function</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">FooSecond</span><span class="p">:</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="kc">#function</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 类族模式目的是隐藏内部实现的细节，因此外界创建的变量虽然是工厂类的类型，但实际上其实是内部子类的类型。</span>
<span class="c1">// 因此在 Obj-C 中使用 isMemberOfClass 判断类是否为工厂类本身，则会返回 NO。</span>
<span class="c1">// foo 在 Swift 中被推断为 Foo</span>
<span class="kd">let</span> <span class="nv">foo</span> <span class="p">=</span> <span class="n">Foo</span><span class="p">.</span><span class="n">build</span><span class="p">(.</span><span class="bp">first</span><span class="p">)</span>

<span class="bp">print</span><span class="p">(</span><span class="n">foo</span> <span class="k">is</span> <span class="n">Foo</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">foo</span> <span class="k">is</span> <span class="n">FooFirst</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">foo</span> <span class="k">is</span> <span class="n">FooSecond</span><span class="p">)</span>

<span class="c1">// OUTPUT:</span>
<span class="c1">// true</span>
<span class="c1">// true</span>
<span class="c1">// false</span>
</code></pre></div><p>系统框架中有许多类族，比如大部分的 collection 类（比如 <code>NSArray</code>）；由于 <code>NSArray</code> 是类族，因此 <code>[fooArr class] == [NSArray class]</code> 将一直返回 <code>false</code>，但可使用 <code>[fooArr isKindOfClass:[NSArray class]]</code>。</p>
<p>向类族中新增实体子类需要遵守以下规则：</p>
<ul>
<li>子类应该继承自类族中的抽象基类；</li>
<li>子类应该定义自己的数据存储方式：类族只是定义了通用的接口，实际存储的方式则由背后具体的实体子类承担；</li>
<li>子类应当覆写超类文档中指明需要覆写的方法：类族中的通用接口需要子类实现。</li>
</ul>
<h3 id="在既有类中使用关联对象存放自定义数据">在既有类中使用关联对象存放自定义数据</h3>
<p>略；关于关联对象，可详见《<a href="../associated_objects_in_ios">iOS 中的关联对象</a>》一文。</p>
<h3 id="理解-objc_msgsend-的作用">理解 objc_msgSend 的作用</h3>
<p>略；关于 objc_msgSend，可详见《<a href="../objc_msgsend">浅尝 objc_msgSend</a>》一文。</p>
<h3 id="理解消息转发机制">理解消息转发机制</h3>
<p>略；关于消息转发机制，可详见《<a href="../objc_msgsend">浅尝 objc_msgSend</a>》一文。</p>
<h3 id="用方法调配技术调试黑盒方法">用「方法调配技术」调试「黑盒方法」</h3>
<p>「方法调配技术」即 Method Swizzling，现在普遍称之为方法交换：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="cp">#import &lt;objc/runtime.h&gt;
</span><span class="cp"></span>
<span class="c1">// Foo_BASE 基类
</span><span class="c1"></span><span class="k">@interface</span> <span class="nc">Foo_BASE</span> : <span class="nc">NSObject</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">a</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo_BASE</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">a</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;a - Foo_BASE - %@&#34;</span><span class="p">,</span> <span class="nb">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="c1">// Foo_SUB 子类
</span><span class="c1"></span><span class="k">@interface</span> <span class="nc">Foo_SUB</span> : <span class="nc">Foo_BASE</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">b</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo_SUB</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">b</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;b - Foo_SUB - %@&#34;</span><span class="p">,</span> <span class="nb">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="k">@interface</span> <span class="nc">Bar</span> : <span class="nc">NSObject</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">e</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Bar</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">e</span> <span class="p">{</span>
    <span class="c1">// self 为 Foo_SUB
</span><span class="c1"></span>    <span class="c1">// [self e];  -[Foo_SUB e]: unrecognized selector sent to instance 0x1007031e0
</span><span class="c1"></span>
    <span class="c1">// [self performSelector:NSSelectorFromString(@&#34;f&#34;)]; // EXC_BAD_ACCESS
</span><span class="c1"></span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;e - Bar - %@&#34;</span><span class="p">,</span> <span class="nb">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="c1">// Foo_SUB (Extension) 分类
</span><span class="c1"></span><span class="k">@interface</span> <span class="nc">Foo_SUB</span> <span class="nl">(Extension)</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo_SUB</span> <span class="nl">(Extension)</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">c</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;c - Foo_SUB - %@&#34;</span><span class="p">,</span> <span class="nb">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">d</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;d - Foo_SUB - %@&#34;</span><span class="p">,</span> <span class="nb">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">f</span> <span class="p">{</span>
    <span class="c1">// self 为 Bar
</span><span class="c1"></span>    <span class="c1">// [self f]; // -[Bar f]: unrecognized selector sent to instance 0x102300290
</span><span class="c1"></span>
    <span class="c1">// [self performSelector:NSSelectorFromString(@&#34;e&#34;)]; // EXC_BAD_ACCESS
</span><span class="c1"></span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;f - Foo_SUB - %@&#34;</span><span class="p">,</span> <span class="nb">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">load</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="c1">// 1. 交换 b &amp; c（b 来自本类，c 来自本类的分类）
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="n">Method</span> <span class="n">m_b</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
            <span class="n">Method</span> <span class="n">m_c</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>

            <span class="c1">// 直接交换
</span><span class="c1"></span>            <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">m_b</span><span class="p">,</span> <span class="n">m_c</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// 2. 交换 a &amp; d（a 来自基类，本类未实现，d 来自本类的分类）
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="n">Method</span> <span class="n">m_a</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
            <span class="n">Method</span> <span class="n">m_d</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">d</span><span class="p">));</span>

            <span class="c1">// 2-1. 交换 IMP
</span><span class="c1"></span>            <span class="p">{</span>
                <span class="c1">// 为了防止基类的方法被改变，那么需要先为本类添加 m_a 方法（override）
</span><span class="c1"></span>                <span class="n">class_addMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">m_a</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">m_a</span><span class="p">));</span>
                <span class="c1">// 再获取本类中添加的方法
</span><span class="c1"></span>                <span class="n">Method</span> <span class="n">m_a_sub</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
                <span class="c1">// 交换
</span><span class="c1"></span>                <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">m_a_sub</span><span class="p">,</span> <span class="n">m_d</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// 2-2. 替换方法
</span><span class="c1"></span>            <span class="p">{</span>
                <span class="c1">// 为了防止基类的方法被改变，那么需要先为本类添加 m_a 方法（override），但 IMP 和 TypeEncoding 可直接使用 m_d 的信息
</span><span class="c1"></span>                <span class="n">class_addMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">m_d</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">m_d</span><span class="p">));</span>
                <span class="c1">// 再替代方法 d 方法的 IMP 和 TypeEncoding 为 m_a 的信息
</span><span class="c1"></span>                <span class="n">class_replaceMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">m_a</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">m_a</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 3. 交换 e &amp; f（e 来自 Bar 类，f 来自 Foo_SUB 类）
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="n">Method</span> <span class="n">m_e</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">([</span><span class="n">Bar</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
            <span class="n">Method</span> <span class="n">m_f</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">([</span><span class="n">Foo_SUB</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>

            <span class="c1">// 直接交换
</span><span class="c1"></span>            <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">m_e</span><span class="p">,</span> <span class="n">m_f</span><span class="p">);</span>

            <span class="c1">// ⚠️ 需要注意的是：
</span><span class="c1"></span>            <span class="c1">// 1. 此时不能在相应的方法中再调用自身的方法，这与交换本类的两个方法不同。
</span><span class="c1"></span>            <span class="c1">// 比如此时的 `f` 方法，交换后是通过 `Bar` 实例对象调用（发送）的，隐式参数 `self` 为 `Bar` 类型，而该类的方法列表中根本不包含 `f` 方法，因此调用时即发生 Crash，反之 `e` 方法同理；
</span><span class="c1"></span>            <span class="c1">// 2. 此时也不能在相应的方法中再调用当前方法。
</span><span class="c1"></span>            <span class="c1">// 比如此时的 `e` 方法，交换后是通过 `Foo_SUB` 实例对象调用（发送）的，隐式参数 `self` 为 `Foo_SUB` 类型，该类中确实包含 `f` 方法，但由于其 IMP 已经被交换，调用后会再次进入当前 `e` 方法，从而造成死循环，反之 `f` 方法同理。
</span><span class="c1"></span>        <span class="p">}</span>

        <span class="c1">// 4. 通用处理
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Method</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
            <span class="n">Method</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">class_addMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">m2</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">m2</span><span class="p">)))</span> <span class="p">{</span>
                <span class="n">class_replaceMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="k">@selector</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">m1</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">m1</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="k">@end</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="n">Foo_SUB</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo_SUB</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
            <span class="p">[</span><span class="n">f</span> <span class="n">b</span><span class="p">];</span>
            <span class="p">[</span><span class="n">f</span> <span class="n">c</span><span class="p">];</span>

            <span class="c1">// c - Foo_SUB - &lt;Foo_SUB: 0x10051b090&gt;
</span><span class="c1"></span>            <span class="c1">// b - Foo_SUB - &lt;Foo_SUB: 0x10051b090&gt;
</span><span class="c1"></span>        <span class="p">}</span>

        <span class="p">{</span>
            <span class="n">Foo_SUB</span> <span class="o">*</span><span class="n">f1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo_SUB</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
            <span class="p">[</span><span class="n">f1</span> <span class="n">a</span><span class="p">];</span>
            <span class="p">[</span><span class="n">f1</span> <span class="n">d</span><span class="p">];</span>
            <span class="c1">// d - Foo_SUB - &lt;Foo_SUB: 0x100505fd0&gt;
</span><span class="c1"></span>            <span class="c1">// a - Foo_BASE - &lt;Foo_SUB: 0x100505fd0&gt;
</span><span class="c1"></span>
            <span class="n">Foo_BASE</span> <span class="o">*</span><span class="n">f2</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo_BASE</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
            <span class="p">[</span><span class="n">f2</span> <span class="n">a</span><span class="p">];</span>
            <span class="c1">// a - Foo_BASE - &lt;Foo_BASE: 0x1021008a0&gt;
</span><span class="c1"></span>        <span class="p">}</span>

        <span class="p">{</span>
            <span class="n">Bar</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Bar</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
            <span class="n">Foo_SUB</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo_SUB</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

            <span class="p">[</span><span class="n">b</span> <span class="n">e</span><span class="p">];</span> <span class="c1">// f - Foo_SUB - &lt;Bar: 0x103001f10&gt;
</span><span class="c1"></span>            <span class="p">[</span><span class="n">f</span> <span class="n">f</span><span class="p">];</span> <span class="c1">// e - Bar - &lt;Foo_SUB: 0x103000cc0&gt;
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="理解类对象的用意">理解「类对象」的用意</h3>
<p>略；关于类对象，可详见《<a href="../objects_in_obj-c/">Obj-C 中的对象</a>》一文；关于内省，可详见《<a href="../type_introspection_and_reflection/">Obj-C &amp; Swift 的类型内省与反射</a>》一文；</p>
<h2 id="接口与-api-设计">接口与 API 设计</h2>
<h3 id="用前缀避免命名空间冲突">用前缀避免命名空间冲突</h3>
<p>Obj-C 没有命名空间（Namespace）机制；因此为了避免重复符号（Duplicate Symbol）错误，需在类名前加入前缀以区分。</p>
<h3 id="提供全能初始化方法">提供「全能初始化方法」</h3>
<p>全能初始化方法（Designated Initializer，又称指定初始化方法）指的是为对象提供必要信息以便其能完成工作的初始化方法。一个类可能不止有一个初始化方法，但通常将选择其中之一作为全能初始化方法，而其它初始化方法间接依赖它，这样可以保证初始化逻辑的统一。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@interface</span> <span class="nc">Rectangle</span> : <span class="nc">NSObject</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="kt">double</span> <span class="n">width</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="kt">double</span> <span class="n">height</span><span class="p">;</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithWidth:</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="nv">width</span> <span class="nf">height:</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="nv">height</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Rectangle</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithWidth:</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="nv">width</span> <span class="nf">height:</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="nv">height</span> <span class="p">{</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
        <span class="n">_height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
    <span class="c1">// 调用全能初始化方法以构造
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">initWithWidth</span><span class="p">:</span><span class="mf">0.0</span> <span class="nl">height</span><span class="p">:</span><span class="mf">0.0</span><span class="p">];</span>
    <span class="c1">// 也可抛出异常，避免外界通过 init 构造
</span><span class="c1">//    @throw [NSException exceptionWithName:NSInternalInconsistencyException
</span><span class="c1">//                                   reason:@&#34;Must use initWithWidth:height: instead.&#34;
</span><span class="c1">//                                 userInfo:nil];
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 另一个全能构造方法
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithCoder:</span><span class="p">(</span><span class="n">NSCoder</span> <span class="o">*</span><span class="p">)</span><span class="nv">coder</span> <span class="p">{</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_width</span> <span class="o">=</span> <span class="p">[</span><span class="n">coder</span> <span class="nl">decodeDoubleForKey</span><span class="p">:</span><span class="s">@&#34;width&#34;</span><span class="p">];</span>
        <span class="n">_height</span> <span class="o">=</span> <span class="p">[</span><span class="n">coder</span> <span class="nl">decodeDoubleForKey</span><span class="p">:</span><span class="s">@&#34;height&#34;</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="k">@interface</span> <span class="nc">Square</span> : <span class="nc">Rectangle</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithDimension:</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="nv">dimension</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Square</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithDimension:</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="nv">dimension</span> <span class="p">{</span>
    <span class="c1">// 调用父类全能初始化方法以构造
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">initWithWidth</span><span class="p">:</span><span class="n">dimension</span> <span class="nl">height</span><span class="p">:</span><span class="n">dimension</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithWidth:</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="nv">width</span> <span class="nf">height:</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="nv">height</span> <span class="p">{</span>
    <span class="c1">// 子类全能初始化方法不同，需重写父类全能初始化方法
</span><span class="c1">//    return [self initWithDimension:MAX(width, height)];
</span><span class="c1"></span>    <span class="c1">// 或可抛出异常，避免外界通过父类全能初始化方法构造
</span><span class="c1"></span>    <span class="k">@throw</span> <span class="p">[</span><span class="n">NSException</span> <span class="nl">exceptionWithName</span><span class="p">:</span><span class="n">NSInternalInconsistencyException</span>
                                   <span class="nl">reason</span><span class="p">:</span><span class="s">@&#34;Must use initWithDimension: instead.&#34;</span>
                                 <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
    <span class="c1">// 也需重写父类 init 方法，使用子类全能构造方法
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">initWithDimension</span><span class="p">:</span><span class="mf">0.0</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithCoder:</span><span class="p">(</span><span class="n">NSCoder</span> <span class="o">*</span><span class="p">)</span><span class="nv">coder</span> <span class="p">{</span>
    <span class="c1">// 先调用父类 initWithCoder: 全能构造方法
</span><span class="c1"></span>    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">initWithCoder</span><span class="p">:</span><span class="n">coder</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span>
</code></pre></div><h3 id="实现-description-方法">实现 description 方法</h3>
<p>NSObject 子类可以重写 <code>description</code> 方法来描述实例，在打印（<code>NSLog</code>）实例信息时即可输出；也可重写 <code>debugDescription</code> 用来在控制台使用 LLDB <code>po</code> 命令输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// ...
</span><span class="c1"></span><span class="k">@implementation</span> <span class="nc">Rectangle</span>
<span class="c1">// ...
</span><span class="c1"></span>
<span class="p">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&#34;&lt;%lf, %lf&gt;&#34;</span><span class="p">,</span> <span class="n">_width</span><span class="p">,</span> <span class="n">_height</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">debugDescription</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&#34;&lt;%@: %p&gt; &lt;%lf, %lf&gt;&#34;</span><span class="p">,</span> <span class="p">[</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="nb">self</span><span class="p">,</span> <span class="n">_width</span><span class="p">,</span> <span class="n">_height</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="n">Rectangle</span> <span class="o">*</span><span class="n">rect</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Rectangle</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithWidth</span><span class="p">:</span><span class="mi">30</span> <span class="nl">height</span><span class="p">:</span><span class="mi">50</span><span class="p">];</span>
<span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">rect</span><span class="p">);</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// &lt;30.000000, 50.000000&gt;
</span><span class="c1">// (lldb) po rect
</span><span class="c1">// &lt;Rectangle: 0x6000037887e0&gt; &lt;30.000000, 50.000000&gt;
</span></code></pre></div><h3 id="尽量使用不可变对象">尽量使用不可变对象</h3>
<p>尽量将外界不能改变的属性对外声明为 <code>readonly</code>，此时将只存在 getter 而不存在 setter。我们可以在实现文件中直接通过访问成员变量来更改，也可将属性再次声明在类扩展中以通过 setter 更改。</p>
<p>由于内存管理语义仅针对 setter，因此声明为 <code>readonly</code> 时也可使用默认的内存管理语义。<code>readonly</code> 并非是完全安全的，外部仍然可以通过 KVC、或者根据内存布局的偏移量直接访问修改。对于集合类型，我们可以将不可变属性本身作为 <code>readonly</code> 暴露在外，并通过额外方法使得外界可以添加或删除等操作集合；在内部则通过另外的可变类型属性作为具体实现，从而避免从底层直接修改对象中的数据：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@interface</span> <span class="nc">Rectangle</span> : <span class="nc">NSObject</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="kt">double</span> <span class="n">width</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="kt">double</span> <span class="n">height</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="n">NSArray</span><span class="o">&lt;</span><span class="n">Rectangle</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addElement:</span><span class="p">(</span><span class="n">Rectangle</span> <span class="o">*</span><span class="p">)</span><span class="nv">element</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeElement:</span><span class="p">(</span><span class="n">Rectangle</span> <span class="o">*</span><span class="p">)</span><span class="nv">element</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@interface</span> <span class="nc">Rectangle</span> <span class="p">()</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">,</span> <span class="k">readwrite</span><span class="p">)</span> <span class="kt">double</span> <span class="n">width</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="kt">double</span> <span class="n">height</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Rectangle</span> <span class="p">{</span>
    <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">_mutableArray</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">array</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_mutableArray</span> <span class="k">copy</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addElement:</span><span class="p">(</span><span class="n">Rectangle</span> <span class="o">*</span><span class="p">)</span><span class="nv">element</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">_mutableArray</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">element</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeElement:</span><span class="p">(</span><span class="n">Rectangle</span> <span class="o">*</span><span class="p">)</span><span class="nv">element</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">_mutableArray</span> <span class="nl">removeObject</span><span class="p">:</span><span class="n">element</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithWidth:</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="nv">width</span> <span class="nf">height:</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="nv">height</span> <span class="p">{</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
        <span class="n">_height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
        <span class="n">_mutableArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">new</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="n">Rectangle</span> <span class="o">*</span><span class="n">rect1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Rectangle</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithWidth</span><span class="p">:</span><span class="mi">10</span> <span class="nl">height</span><span class="p">:</span><span class="mi">20</span><span class="p">];</span>
<span class="n">Rectangle</span> <span class="o">*</span><span class="n">rect2</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Rectangle</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithWidth</span><span class="p">:</span><span class="mi">10</span> <span class="nl">height</span><span class="p">:</span><span class="mi">20</span><span class="p">];</span>
<span class="p">[</span><span class="n">rect1</span> <span class="nl">addElement</span><span class="p">:</span><span class="n">rect2</span><span class="p">];</span>
</code></pre></div><h3 id="使用清晰而协调的命名方式">使用清晰而协调的命名方式</h3>
<p>一些 Obj-C 的方法名十分冗长，但却语义化更加，这点 Swift 也继承了其优点，并适当精简方法名。方法的命名规则：</p>
<ul>
<li>若返回值是新创建的，那么方法名应当以返回值类型开始，也可加入对其修饰；</li>
<li>表示参数类型的名词应当置于参数之前；</li>
<li>方法内的行为要操作当前对象，那么应当包含动词；若执行时需要参数，则应当在动词之后加上一个或多个名词；</li>
<li>使用 <code>string</code> 全称而非 <code>str</code> 简称；</li>
<li><code>Boolean</code> 属性应当加 <code>is</code> 前缀；根据功能将返回 <code>Boolean</code> 类型的方法名选择 <code>has</code> 或 <code>is</code> 前缀；</li>
<li>使用输出参数（Out Parameter）保存返回值的方法可以使用 <code>get</code> 前缀。</li>
</ul>
<p>类与协议的名称尽量要加上前缀，以避免命名空间冲突。命名第一要务是确保其风格与代码框架相符合。</p>
<h3 id="为私有方法名加前缀">为私有方法名加前缀</h3>
<p>私有方法除了不应对外声明，也应加上前缀与以区分。但不推荐单用一个下划线 <code>_</code> 作为前缀，因为系统库中有很多私有方法即是以 <code>_</code> 为前缀的。</p>
<h3 id="理解-objective-c-错误模型">理解 Objective-C 错误模型</h3>
<p>异常（Exception）与错误（Error）在计算机中代表着完全不同的两种意义。</p>
<p>异常安全（Exception Safe）指的是当抛出异常时，需要释放的资源或对象也能得到安全地释放。自动引用计数默认是非异常安全的，但可以通过 <code>-fobjc-arc-exceptions</code> 设置编译器以达到异常安全（详见下文「编写「异常安全代码时」留意内存管理问题」一节）。由于异常安全很难得到保证，因此推荐只在必要时（如重大错误）抛出异常，并终止程序，而不再考虑异常安全。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@throw</span> <span class="p">[</span><span class="n">NSException</span> <span class="nl">exceptionWithName</span><span class="p">:</span><span class="n">NSInternalInconsistencyException</span> <span class="nl">reason</span><span class="p">:</span><span class="s">@&#34;Some reason.&#34;</span> <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</code></pre></div><p>非致命错误（Non-fatal Error）可以令方法返回 <code>nil</code> / <code>0</code> 或 <code>NSError</code>，以表明有错误发生。对于 NSError：</p>
<ul>
<li>Error Domain（<code>NSErrorDomain</code> 本质为 <code>NSString</code>）：错误范围表明了错误根源，eg. <code>NSURLErrorDomain</code>、<code>NSCocoaErrorDomain</code> 等；</li>
<li>Error Code（<code>NSInteger</code>）：错误代码表明了具体的独有错误，可使用枚举定义；</li>
<li>User Info（<code>NSDictionary&lt;NSErrorUserInfoKey,id&gt;</code>，<code>NSErrorUserInfoKey</code> 本质为 <code>NSString</code>）：用户信息表明了关于错误的额外信息，比如本地化的错误描述。</li>
</ul>
<p><code>NSError</code> 常见用法一是通过代理协议（Delegate Protocols）传递。当错误发生时，将通过调用代理对象的某个协议方法来告知代理本身；二是通过方法的输出参数返回给调用者。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// NSURLConnection.h
</span><span class="c1"></span><span class="k">@protocol</span> <span class="nc">NSURLConnectionDelegate</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>
<span class="k">@optional</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">connection</span><span class="p">:(</span><span class="n">NSURLConnection</span> <span class="o">*</span><span class="p">)</span><span class="n">connection</span> <span class="nl">didFailWithError</span><span class="p">:(</span><span class="n">NSError</span> <span class="o">*</span><span class="p">)</span><span class="n">error</span><span class="p">;</span>
<span class="k">@end</span>

<span class="c1">// ❌ 错误发生
</span><span class="c1"></span><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">delegate</span> <span class="nl">connection</span><span class="p">:</span><span class="n">someConnection</span> <span class="nl">didFailWithError</span><span class="p">:</span><span class="n">someError</span><span class="p">];</span>

<span class="c1">// ---
</span><span class="c1"></span>
<span class="k">extern</span> <span class="n">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">VErrorDomain</span><span class="p">;</span>

<span class="k">typedef</span> <span class="nf">NS_ENUM</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">,</span> <span class="n">VError</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">VErrorUnknown</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">VErrorFirst</span>   <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">VErrorSecond</span>  <span class="o">=</span> <span class="mi">200</span>
<span class="p">};</span>

<span class="n">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">VErrorDomain</span> <span class="o">=</span> <span class="s">@&#34;VErrorDomain&#34;</span><span class="p">;</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">doSomething:</span><span class="p">(</span><span class="n">NSError</span> <span class="o">**</span><span class="p">)</span><span class="nv">error</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>
    <span class="c1">// 如果错误发生
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">errorOccured</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果外界关心错误
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 解引用（Dereference）前要保证 error 不为 nil
</span><span class="c1"></span>            <span class="c1">// 否则对空指针解引用会导致段错误（Segmentation Fault）并崩溃（EXC_BAD_ACCESS）
</span><span class="c1"></span>            <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSError</span> <span class="nl">errorWithDomain</span><span class="p">:</span><span class="n">VErrorDomain</span> <span class="nl">code</span><span class="p">:</span><span class="n">VErrorFirst</span> <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// ❌ 错误发生
</span><span class="c1"></span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
<span class="kt">BOOL</span> <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span> <span class="nl">doSomething</span><span class="p">:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;Error occurred!&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>ARC 下，编译器将把第二种方法签名中的 <code>NSError **</code> 转换为 <code>NSError *__autoreleasing *</code>，即指针所指向的对象将在方法执行完毕后自动释放，因为该方法不能保证调用者将其中创建的 <code>NSError</code> 释放，由此保证与大部分方法（除 <code>new</code> / <code>alloc</code> / <code>copy</code> / <code>mutableCopy</code> 开头的方法）返回值所具备的语义相同。</p>
<!-- - [隐藏\_\_autoreleasing 属性变量(NSError \*\*)引起的 EXC_BAD_ACCESS 崩溃](https://www.jianshu.com/p/b16f36e98baf) -->
<h3 id="理解-nscopying-协议">理解 NSCopying 协议</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@protocol</span> <span class="nc">NSCopying</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">copyWithZone:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nv">zone</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@protocol</span> <span class="nc">NSMutableCopying</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">mutableCopyWithZone:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nv">zone</span><span class="p">;</span>
<span class="k">@end</span>
</code></pre></div><p>当我们调用一个对象的 <code>copy</code> / <code>mutableCopy</code> 方法时，该类必须实现 <code>NSCopying</code> / <code>NSMutableCopying</code> 协议中的唯一方法，指定该类实例对象的拷贝逻辑，而 <code>copy</code> / <code>mutableCopy</code> 本身由 <code>NSObject</code> 实现。这里的 <code>NSZone</code> 官方解释是「A type used to identify and manage memory zones」，即用来识别和管理内存区域的类型，但目前已经基本废弃，无需关心（Zones are ignored on iOS and 64-bit runtime in macOS. You should not use zones in current development. - Apple Developer）。为了保持和系统提供类行为一致，约定 <code>copy</code> 将总是返回不可变版本，而 <code>mutableCopy</code> 总是返回可变版本，与调用者的类型无关（或者可提供一个 <code>immutableCopy</code> 的方法区分）。</p>
<!-- http://cocoadev.com/wiki/NSZone -->
<p>无论是浅拷贝（Shallow Copy）还是深拷贝（Deep Copy），对象本身都会重新创建，其中的标量也会直接复制，而针对于使用对象中的指针或地址指向的类型，前者仅仅拷贝指向地址，而后者则是将指向的数据也拷贝一份至新的内存地址。<code>Foundation</code> 中的集合类型默认执行浅拷贝（因为集合类型内部的属性并不一定都能拷贝），因此自定义类中我们也默认是浅拷贝，必要时定义类似 <code>deepCoby</code> 方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@interface</span> <span class="nc">Rectangle</span> : <span class="nc">NSObject</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="kt">double</span> <span class="n">width</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="kt">double</span> <span class="n">height</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="n">NSArray</span><span class="o">&lt;</span><span class="n">Rectangle</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addElement:</span><span class="p">(</span><span class="n">Rectangle</span> <span class="o">*</span><span class="p">)</span><span class="nv">element</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeElement:</span><span class="p">(</span><span class="n">Rectangle</span> <span class="o">*</span><span class="p">)</span><span class="nv">element</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@interface</span> <span class="nc">Rectangle</span> <span class="p">()</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">,</span> <span class="k">readwrite</span><span class="p">)</span> <span class="kt">double</span> <span class="n">width</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="kt">double</span> <span class="n">height</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Rectangle</span> <span class="p">{</span>
    <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">_mutableArray</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">array</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_mutableArray</span> <span class="k">copy</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addElement:</span><span class="p">(</span><span class="n">Rectangle</span> <span class="o">*</span><span class="p">)</span><span class="nv">element</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">_mutableArray</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">element</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeElement:</span><span class="p">(</span><span class="n">Rectangle</span> <span class="o">*</span><span class="p">)</span><span class="nv">element</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">_mutableArray</span> <span class="nl">removeObject</span><span class="p">:</span><span class="n">element</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithWidth:</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="nv">width</span> <span class="nf">height:</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="nv">height</span> <span class="p">{</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
        <span class="n">_height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
        <span class="n">_mutableArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">new</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">copyWithZone:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nv">zone</span> <span class="p">{</span>
    <span class="n">Rectangle</span> <span class="o">*</span><span class="n">rect</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Rectangle</span> <span class="nl">allocWithZone</span><span class="p">:</span><span class="n">zone</span><span class="p">]</span> <span class="nl">initWithWidth</span><span class="p">:</span><span class="n">_width</span> <span class="nl">height</span><span class="p">:</span><span class="n">_height</span><span class="p">];</span>
    <span class="n">rect</span><span class="o">-&gt;</span><span class="n">_mutableArray</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithArray</span><span class="p">:</span><span class="n">_mutableArray</span> <span class="nl">copyItems</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span> <span class="c1">// 深拷贝
</span><span class="c1">//    rect-&gt;_mutableArray = [_mutableArray mutableCopy]; // 浅拷贝
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">rect</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="n">Rectangle</span> <span class="o">*</span><span class="n">rect</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Rectangle</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithWidth</span><span class="p">:</span><span class="mf">5.0</span> <span class="nl">height</span><span class="p">:</span><span class="mf">5.0</span><span class="p">];</span>
<span class="n">Rectangle</span> <span class="o">*</span><span class="n">rect1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Rectangle</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithWidth</span><span class="p">:</span><span class="mf">10.0</span> <span class="nl">height</span><span class="p">:</span><span class="mf">10.0</span><span class="p">];</span>

<span class="p">[</span><span class="n">rect1</span> <span class="nl">addElement</span><span class="p">:</span><span class="n">rect</span><span class="p">];</span>

<span class="n">rect1</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">Rectangle</span> <span class="o">*</span><span class="n">rect2</span> <span class="o">=</span> <span class="p">[</span><span class="n">rect1</span> <span class="k">copy</span><span class="p">];</span>
<span class="n">rect1</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>

<span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;rect1.array - %@, rect2.array - %@&#34;</span><span class="p">,</span> <span class="p">[</span><span class="n">rect1</span> <span class="n">array</span><span class="p">],</span> <span class="p">[</span><span class="n">rect2</span> <span class="n">array</span><span class="p">]);</span>
<span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;rect1.height - %f, rect2.height - %f&#34;</span><span class="p">,</span> <span class="n">rect1</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">rect2</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
<span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;rect1 - %@, rect2 - %@&#34;</span><span class="p">,</span> <span class="n">rect1</span><span class="p">,</span> <span class="n">rect2</span><span class="p">);</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// 深拷贝（集合是新的集合，且集合内部元素为新元素）
</span><span class="c1">// rect1.array - (
</span><span class="c1">//     &#34;&lt;Rectangle: 0x101125d40&gt;&#34;
</span><span class="c1">// ), rect2.array - (
</span><span class="c1">//     &#34;&lt;Rectangle: 0x101126250&gt;&#34;
</span><span class="c1">// )
</span><span class="c1">// rect1.height - 200.000000, rect2.height - 100.000000
</span><span class="c1">// rect1 - &lt;Rectangle: 0x101125e80&gt;, rect2 - &lt;Rectangle: 0x101125f70&gt;
</span><span class="c1">// 浅拷贝（集合是新的集合，但集合内部元素仍为原集合）
</span><span class="c1">// rect1.array - (
</span><span class="c1">//     &#34;&lt;Rectangle: 0x102a04010&gt;&#34;
</span><span class="c1">// ), rect2.array - (
</span><span class="c1">//     &#34;&lt;Rectangle: 0x102a04010&gt;&#34;
</span><span class="c1">// )
</span><span class="c1">// rect1.height - 200.000000, rect2.height - 100.000000
</span><span class="c1">// rect1 - &lt;Rectangle: 0x102a04150&gt;, rect2 - &lt;Rectangle: 0x102a04240&gt;
</span></code></pre></div><p><img src="/img/2019/effective_obj-c_2.0_notes/3.png" alt="3"></p>
<p>上图取自苹果官方文档中 <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectCopying.html">Object copying - Cocoa Core Competencies</a> 一节。</p>
<h2 id="协议与分类">协议与分类</h2>
<h3 id="通过委托与数据源协议进行对象间通信">通过委托与数据源协议进行对象间通信</h3>
<p>为了避免循环引用（Retain Cycle），遵守代理（Delegate）协议对象的内存管理语义需设置为 <code>weak</code> 或 <code>unsafe_unretained</code>（关于两者区别详见本文《理解「属性」这一概念》一节），而非 <code>strong</code>。代理协议中的方法通常只会在类内部使用，因此可以在类扩展（注：本文中称之为 Class-Continuation Category）中声明实现即可。代理协议中的方法通常使用 <code>@optional</code> 标记为可选，因为遵守代理协议的对象并非一定关心其中所有的方法，所以在调用回代理上的方法时一定要先使用类型信息查询方法进行确认，为了避免重复性调用查询方法，可使用位域来缓存结果，关于位域可详见《<a href="../bit_field_union_in_cpp/">C/C++ 中的位域与共用体</a>》一文。代理协议中的方法通常将调用者本身作为参数传回，以便根据不同的调用者执行不同的逻辑。数据源（DataSource）中，数据从代理对象中流向类；而调用者中，数据从调用者中流出至代理对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="cp">#import &#34;ViewController.h&#34;
</span><span class="cp"></span>
<span class="k">@class</span> <span class="nc">Foo</span>;
<span class="k">@protocol</span> <span class="nc">FooDelegate</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>

<span class="k">@optional</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">foo</span><span class="p">:(</span><span class="n">Foo</span> <span class="o">*</span><span class="p">)</span><span class="n">foo</span> <span class="nl">willLog</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">content</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">foo:</span><span class="p">(</span><span class="n">Foo</span> <span class="o">*</span><span class="p">)</span><span class="nv">foo</span> <span class="nf">didLog:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">content</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@protocol</span> <span class="nc">FooDataSource</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>
<span class="k">@required</span>
<span class="o">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">logContent</span><span class="p">;</span>
<span class="k">@end</span>


<span class="k">@interface</span> <span class="nc">Foo</span> : <span class="nc">NSObject</span> <span class="p">{</span>
    <span class="c1">// 位域
</span><span class="c1"></span>    <span class="k">struct</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">willLog</span> <span class="p">:</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">didLog</span>  <span class="p">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">_delegateFlags</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 声明为 weak
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">weak</span><span class="p">)</span> <span class="kt">id</span> <span class="o">&lt;</span><span class="n">FooDelegate</span><span class="o">&gt;</span> <span class="n">delegate</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">weak</span><span class="p">)</span> <span class="kt">id</span> <span class="o">&lt;</span><span class="n">FooDataSource</span><span class="o">&gt;</span> <span class="n">dataSource</span><span class="p">;</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">refresh</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setDelegate:</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">FooDelegate</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">delegate</span> <span class="p">{</span>
    <span class="n">_delegate</span> <span class="o">=</span> <span class="n">delegate</span><span class="p">;</span>

    <span class="c1">// 避免多次调用 respondsToSelector:
</span><span class="c1"></span>    <span class="n">_delegateFlags</span><span class="p">.</span><span class="n">willLog</span> <span class="o">=</span> <span class="p">[</span><span class="n">_delegate</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">foo</span><span class="p">:</span><span class="nl">willLog</span><span class="p">:)];</span>
    <span class="n">_delegateFlags</span><span class="p">.</span><span class="n">didLog</span> <span class="o">=</span> <span class="p">[</span><span class="n">_delegate</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">foo</span><span class="p">:</span><span class="nl">didLog</span><span class="p">:)];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">refresh</span> <span class="p">{</span>
    <span class="c1">// 数据源（DataSource）：数据 -&gt; 调用者
</span><span class="c1"></span>    <span class="n">NSString</span> <span class="o">*</span><span class="n">content</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">dataSource</span> <span class="n">logContent</span><span class="p">];</span>

    <span class="c1">// 检查代理是否实现可选协议
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">([</span><span class="n">_delegate</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">foo</span><span class="p">:</span><span class="nl">willLog</span><span class="p">:)])</span> <span class="p">{</span>
        <span class="c1">// 代理（Delegate）：数据 -&gt; 代理对象
</span><span class="c1"></span>        <span class="p">[</span><span class="n">_delegate</span> <span class="nl">foo</span><span class="p">:</span><span class="nb">self</span> <span class="nl">willLog</span><span class="p">:</span><span class="n">content</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;--------------------&#34;</span><span class="p">);</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">content</span><span class="p">);</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;--------------------&#34;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_delegateFlags</span><span class="p">.</span><span class="n">didLog</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">_delegate</span> <span class="nl">foo</span><span class="p">:</span><span class="nb">self</span> <span class="nl">didLog</span><span class="p">:</span><span class="n">content</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="k">@interface</span> <span class="nc">ViewController</span> <span class="p">()</span> <span class="o">&lt;</span><span class="n">FooDelegate</span><span class="p">,</span> <span class="n">FooDataSource</span><span class="o">&gt;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="n">Foo</span> <span class="o">*</span><span class="n">foo2</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">ViewController</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
    <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
    <span class="c1">// Do any additional setup after loading the view.
</span><span class="c1"></span>
    <span class="nb">self</span><span class="p">.</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
    <span class="nb">self</span><span class="p">.</span><span class="n">foo2</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

    <span class="nb">self</span><span class="p">.</span><span class="n">foo</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
    <span class="nb">self</span><span class="p">.</span><span class="n">foo</span><span class="p">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>

    <span class="nb">self</span><span class="p">.</span><span class="n">foo2</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
    <span class="nb">self</span><span class="p">.</span><span class="n">foo2</span><span class="p">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>

    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">foo</span> <span class="n">refresh</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">foo:</span><span class="p">(</span><span class="n">Foo</span> <span class="o">*</span><span class="p">)</span><span class="nv">foo</span> <span class="nf">willLog:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">content</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foo</span> <span class="o">==</span> <span class="n">_foo</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;foo - willLog - [%@]&#34;</span><span class="p">,</span> <span class="n">content</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">foo</span> <span class="o">==</span> <span class="n">_foo2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;foo2 - willLog - [%@]&#34;</span><span class="p">,</span> <span class="n">content</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">foo:</span><span class="p">(</span><span class="n">Foo</span> <span class="o">*</span><span class="p">)</span><span class="nv">foo</span> <span class="nf">didLog:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">content</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;willLog - [%@]&#34;</span><span class="p">,</span> <span class="n">content</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">logContent</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">@&#34;https://kingcos.me&#34;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@end</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// foo - willLog - [https://kingcos.me]
</span><span class="c1">// --------------------
</span><span class="c1">// https://kingcos.me
</span><span class="c1">// --------------------
</span><span class="c1">// willLog - [https://kingcos.me]
</span></code></pre></div><h3 id="将类的实现代码分散到便于管理的数个分类之中">将类的实现代码分散到便于管理的数个分类之中</h3>
<p>使用分类机制可以将类的实现代码分成不同的功能块。比如 <code>NSURLRequest</code> 类提供向 URL 请求的功能，但从其命名中并不得知其使用的具体协议，而 HTTP 相关的方法定义在 <code>NSURLRequest</code> 的 <code>NSHTTPURLRequest</code> 分类中。<code>NSURLRequest</code> 中封装了一套操作 <code>CFURLRequest</code> 数据结构所需的 C 函数，且 Obj-C 并不支持方法的访问控制修饰符，将 <code>NSHTTPURLRequest</code> 定义为子类也不甚方便。定义在分类中的方法符号会带有分类信息，便于 Debug。通常，我们将无需暴露在外界的方法定义在带有 <code>Private</code> 的分类中，这样即使出现问题也能输出 <code>Private</code> 相关的信息。</p>
<h3 id="总是为第三方的分类名称加前缀">总是为第三方的分类名称加前缀</h3>
<p>向第三方分类中添加分类时，应为分类名称加上特有前缀以区分；分类中的方法也要加上特有前缀以区分。关于分类（Category），可详见《<a href="../category_in_ios/">iOS 中的 Category</a>》一文。</p>
<h3 id="勿在分类中声明属性">勿在分类中声明属性</h3>
<p>分类中可以定义属性，但并不会生成成员变量以及 getter &amp; setter 的实现，因此建议在主接口或类扩展中封装所需的所有属性。</p>
<h3 id="使用class-continuation-分类隐藏实现细节">使用「class-continuation 分类」隐藏实现细节</h3>
<p>class-continuation 分类现在通常称之为类扩展。类扩展中之所以可以定义方法和实例变量，这是由于 ABI 稳固的机制。利用类扩展可以将一些接口声明在实现文件中，以对外隐藏。其中比较一个比较特别的用例是将所需的 C++ 类等使用声明在类扩展中，这样无需声明在头文件中，可以避免其它引入的类必须使用 Obj-C++ 语法（即 <code>.mm</code> 文件）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// CPPClass.hpp
</span><span class="c1"></span><span class="cp">#ifndef CPPClass_hpp
</span><span class="cp">#define CPPClass_hpp
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">class</span> <span class="nc">CPPClass</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">foo</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">CPPClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">foo</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* CPPClass_hpp */</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// CPPClass.cpp
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;CPPClass.hpp&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">CPPClass</span><span class="o">::</span><span class="n">CPPClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">foo</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// ObjCPPClass.h
</span><span class="c1"></span><span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="cp"></span>
<span class="c1">// 直接引入 CPPClass 的声明
</span><span class="c1">//#import &#34;CPPClass.h&#34;
</span><span class="c1"></span>
<span class="n">NS_ASSUME_NONNULL_BEGIN</span>

<span class="c1">// 向前声明，class 仍是 C++ 的关键字
</span><span class="c1">//class CPPClass;
</span><span class="c1"></span>
<span class="k">@interface</span> <span class="nc">ObjCPPClass</span> : <span class="nc">NSObject</span>
<span class="c1">//{
</span><span class="c1">//@private
</span><span class="c1">//    CPPClass *_obj;
</span><span class="c1">//}
</span><span class="c1"></span>
<span class="k">@end</span>

<span class="n">NS_ASSUME_NONNULL_END</span>

<span class="c1">// ObjCPPClass.mm
</span><span class="c1"></span><span class="cp">#import &#34;ObjCPPClass.h&#34;
</span><span class="cp">#import &#34;CPPClass.hpp&#34;
</span><span class="cp"></span>
<span class="c1">// 使用类扩展将 C++ 类引入并声明使用
</span><span class="c1"></span><span class="k">@interface</span> <span class="nc">ObjCPPClass</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">CPPClass</span> <span class="o">*</span><span class="n">_obj</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">ObjCPPClass</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">init</span>
<span class="p">{</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_obj</span> <span class="o">=</span> <span class="n">new</span> <span class="n">CPPClass</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_obj</span><span class="p">)</span> <span class="nb">self</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span>
<span class="p">{</span>
    <span class="c1">// 手动销毁 _obj
</span><span class="c1"></span>    <span class="n">delete</span> <span class="n">_obj</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></div><p>类扩展也可以将头文件中声明为 <code>readonly</code> 的属性重新使用 <code>readwrite</code> 声明，以在类内部使用；类扩展通常也用来声明遵循外界无需知晓的协议。</p>
<h3 id="通过协议提供匿名对象">通过协议提供匿名对象</h3>
<p>在「通过委托与数据源协议进行对象间通信」一节中，<code>Foo</code> 的 <code>delegate</code> 所声明的类型为 <code>id &lt;FooDelegate&gt;</code>，即任何遵循 <code>FooDeelgate</code> 协议的类型即可，而非必须为某一具体类型，这种只限定协议的类的对象就是 Obj-C 中的匿名对象（Anonymous Object）。<code>NSDictionary</code> 中的键是 <code>id &lt;NSCopying&gt;</code> 类型，同理只要是遵循 <code>NSCopying</code> 协议的类的对象即可。使用匿名对象也可对外隐藏类型名称。</p>
<p>有时对象类型并不重要，重要的是对象有没有实现某些方法，即可使用匿名类型（Anonymous Type）来表达这一概念。即便实现代码总是使用固定的类，但仍然写成遵循某种协议的匿名类型，以表明类型在此并不重要。</p>
<h2 id="内存管理">内存管理</h2>
<h3 id="理解引用计数">理解引用计数</h3>
<p>Mac OS X 10.8 开始，垃圾回收（Garbage Collector）已经正式废弃，而 iOS 从未支持垃圾回收，一直使用引用计数（Reference Count，又称 Retain Count，保留计数）管理内存。在 MRC 下，<code>NSObject</code> 协议中的 <code>retain</code>、<code>release</code> 以及 <code>autorelease</code> 方法用来操作计数。当引用计数归零，系统将把对象占用的内存标记为可重用的。需要注意的是，这并不代表对象所占用的内存地址一定会被覆写，因此在引用计数降为 0 再调用时只是「可能」而非「一定」会崩溃。因此通常在 <code>release</code> 后将对象置为 <code>nil</code> 而避免悬挂指针（Dangling Pointer）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
<span class="p">[</span><span class="n">foo</span> <span class="k">release</span><span class="p">];</span>
<span class="n">foo</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span> <span class="c1">// 将内存区域置为 nil，避免悬挂指针
</span></code></pre></div><p>属性存取方法中也需要注意引用计数相关：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// MRC
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setFoo:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">foo</span> <span class="p">{</span>
    <span class="c1">// 注意顺序：
</span><span class="c1"></span>    <span class="c1">// 当参数 foo 与成员变量 _foo 是同一对象时
</span><span class="c1"></span>    <span class="p">[</span><span class="n">foo</span> <span class="k">retain</span><span class="p">];</span>   <span class="c1">// 要先 retain 使得引用计数 +1
</span><span class="c1"></span>    <span class="p">[</span><span class="n">_foo</span> <span class="k">release</span><span class="p">];</span> <span class="c1">// 防止对象提前释放导致实例变量将成为悬挂指针
</span><span class="c1"></span>    <span class="n">_foo</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>为了防止系统回收对象，但又要能在合适的时机释放，那么可以使用自动释放池延长对象生命周期：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// MRC
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="n">Foo</span> <span class="o">*</span><span class="p">)</span><span class="nf">newFoo</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
    <span class="c1">// autorelease 使得超过方法边界依然可以存活一段时间
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">[</span><span class="n">foo</span> <span class="n">autorelease</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// foo 可以存活
</span><span class="c1"></span><span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">newFoo</span><span class="p">];</span>
<span class="c1">// 但若要持有此对象，仍需手动保留、释放
</span><span class="c1"></span><span class="n">_foo</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">self</span> <span class="n">newFoo</span><span class="p">]</span> <span class="k">retain</span><span class="p">];</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="p">[</span><span class="n">_foo</span> <span class="k">release</span><span class="p">];</span>
</code></pre></div><p>引用计数的概念应当理解为所执行的操作对于计数本身是增加了还是消减了，而非刻意追求为某个值。另外需要注意的是，查询引用计数的方法 <code>retainCount</code> 不推荐使用。</p>
<h2 id="以-arc-简化引用计数">以 ARC 简化引用计数</h2>
<p>ARC 下调用 <code>retain</code>、<code>release</code>、<code>autorelease</code>、<code>dealloc</code> 方法时并不通过 Obj-C 的消息发送机制，而是直接调用其底层的 C 语言版本，因而性能更好。在 Obj-C 中，以 <code>alloc</code>、<code>new</code>、<code>copy</code> 和 <code>mutableCopy</code> 开头的方法返回的对象归调用者所有，即调用这些方法的代码同样要负责释放；反之则不归调用者所有，需要在内部自己处理，因此返回的对象会自动释放，但外界希望保活则需要调用者再次保留：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// ARC
</span><span class="c1"></span><span class="p">+</span> <span class="p">(</span><span class="n">Foo</span> <span class="o">*</span><span class="p">)</span><span class="nf">newFoo</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">foo</span><span class="p">;</span> <span class="c1">// new 开头，本质即返回 foo
</span><span class="c1"></span><span class="p">}</span>

<span class="p">+</span> <span class="p">(</span><span class="n">Foo</span> <span class="o">*</span><span class="p">)</span><span class="nf">someFoo</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">foo</span><span class="p">;</span> <span class="c1">// 非特定开头，本质即返回 [foo autorelease]
</span><span class="c1"></span><span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">bar</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="o">*</span><span class="n">foo1</span> <span class="o">=</span> <span class="p">[</span><span class="n">Foo</span> <span class="n">newFoo</span><span class="p">];</span>
    <span class="n">Foo</span> <span class="o">*</span><span class="n">foo2</span> <span class="o">=</span> <span class="p">[</span><span class="n">Foo</span> <span class="n">someFoo</span><span class="p">];</span>

    <span class="c1">// 超过特定作用域下，变量将进行释放
</span><span class="c1"></span>    <span class="c1">// foo1 由 newFoo 创造，因此需要手动 [foo1 release];
</span><span class="c1"></span>    <span class="c1">// foo2 由 someFoo 创造，无需手动 release
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>ARC 有时会自动将同一个对象上的多次互相抵消的 <code>retain</code> 和 <code>release</code> 操作成对移除；ARC 也包括运行时组件来执行一些优化，以及需要考虑向后兼容性，以兼容使用 MRC 的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// ARC 下，_foo 是一个强引用的成员变量，编译器设置其值时会额外执行 [foo retain]；
</span><span class="c1"></span><span class="n">_foo</span> <span class="o">=</span> <span class="p">[</span><span class="n">Foo</span> <span class="n">someFoo</span><span class="p">];</span> <span class="c1">// someFoo 返回一个新的 Foo 对象，且由于非特定开头，本质即返回 [foo autorelease]
</span><span class="c1"></span>
<span class="c1">// 以上等同于在 MRC 下：
</span><span class="c1"></span><span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[</span><span class="n">Foo</span> <span class="n">someFoo</span><span class="p">];</span> <span class="c1">// return [foo autorelease];
</span><span class="c1"></span><span class="n">_foo</span> <span class="o">=</span> <span class="p">[</span><span class="n">foo</span> <span class="k">retain</span><span class="p">];</span>

<span class="c1">// ARC 可以在运行时检测到以上 autorelease 后紧跟 retain 的这种多余操作（因为后续既然 retain，这里就无需 autorelease），
</span><span class="c1">// 因此在方法中返回自动释放的对象时，改为执行 objc_autoreleaseReturnValue 函数：
</span><span class="c1">// MRC：
</span><span class="c1"></span><span class="p">+</span> <span class="p">(</span><span class="n">Foo</span> <span class="o">*</span><span class="p">)</span><span class="nf">someFoo</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">objc_autoreleaseReturnValue</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[</span><span class="n">Foo</span> <span class="n">someFoo</span><span class="p">];</span> <span class="c1">// return [foo autorelease];
</span><span class="c1">// 改为执行 objc_retainAutoreleasedReturnValue 函数：
</span><span class="c1"></span><span class="n">_foo</span> <span class="o">=</span> <span class="n">objc_retainAutoreleasedReturnValue</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>

<span class="c1">// 伪代码
</span><span class="c1"></span><span class="kt">id</span> <span class="nf">objc_autoreleaseReturnValue</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 具体如何判断需根据处理器的原始机器码指令来判断
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="cm">/* 若在调用后需在返回对象上执行 retain */</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">set_flag</span><span class="p">(</span><span class="n">object</span><span class="p">);</span> <span class="c1">// 设置全局数据结构符号位
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">object</span><span class="p">;</span> <span class="c1">// 返回对象本身
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">foo</span> <span class="n">autorelease</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">id</span> <span class="nf">objc_retainAutoreleasedReturnValue</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="cm">/* 设置过全局数据结构符号位 */</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clear_flag</span><span class="p">(</span><span class="n">object</span><span class="p">);</span> <span class="c1">// 清除符号位
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">object</span><span class="p">;</span> <span class="c1">// 返回对象本身
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">foo</span> <span class="k">retain</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 这样的好处是设置并检测标志位的速度要比调用 autorelease 和 retain 速度更快
</span></code></pre></div><p>ARC 会处理局部变量与实例变量的内存管理：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@interface</span> <span class="nc">Foo</span> : <span class="nc">NSObject</span> <span class="p">{</span>
    <span class="kt">id</span> <span class="k">__strong</span> <span class="n">_strongObj</span><span class="p">;</span> <span class="c1">// 默认，保留值
</span><span class="c1"></span>    <span class="kt">id</span> <span class="k">__weak</span> <span class="n">_weakObj</span><span class="p">;</span>     <span class="c1">// 不保留值，但系统回收对象时会自动置为 nil
</span><span class="c1"></span>    <span class="kt">id</span> <span class="n">__unsafe_unretained</span> <span class="n">_unsafeUnretainedObj</span><span class="p">;</span> <span class="c1">// 不保留值，但系统回收对象时不会自动置为 nil，不安全
</span><span class="c1">//    id __autoreleasing _autureleasingObj; // __autoreleasing 不能直接声明成员变量使用
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 使得值可以在方法返回后自动释放（无需在外界关心其是否释放）
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">fooWithParam:</span><span class="p">(</span><span class="kt">id</span> <span class="k">__autoreleasing</span> <span class="o">*</span><span class="p">)</span><span class="nv">_autureleasingObj</span><span class="p">;</span>
<span class="k">@end</span>
</code></pre></div><p>ARC 也负责对实例变量的内存管理：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// MRC 下需手动清理
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">_foo</span> <span class="k">release</span><span class="p">];</span>  <span class="c1">// 释放所有强引用变量
</span><span class="c1"></span>    <span class="p">[</span><span class="nb">super</span> <span class="n">dealloc</span><span class="p">];</span> <span class="c1">// 调用父类方法
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>ARC 下编译器若发现某个对象里含有 C++ 对象，就会生成名为 <code>.cxx_destruct</code> 方法来调用所有 C++ 对象的析构函数；非 Obj-C 对象则仍然需要清理，ARC 会自动在 <code>.cxx_destruct</code> 方法中生成代码并运行，其中会自动调用父类的 <code>dealloc</code> 方法，因此不能再直接调用父类的 <code>dealloc</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// ARC
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
    <span class="n">CFRelease</span><span class="p">(</span><span class="n">_coreFoundationObject</span><span class="p">);</span> <span class="c1">// 手动释放 CoreFoundation 中的对象
</span><span class="c1"></span>    <span class="n">free</span><span class="p">(</span><span class="n">_heapAllocatedMemoryBlob</span><span class="p">);</span>   <span class="c1">// 手动释放 malloc() 分配在堆中的内存
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>MRC 下为了实现单例可以将 <code>release</code> 方法替换为空操作即可；但在 ARC 不可这样操作，因为这将干扰 ARC 本身。</p>
<h3 id="在-dealloc-方法中只释放引用并解除监听">在 dealloc 方法中只释放引用并解除监听</h3>
<p>上一节中也提到了一些在 <code>dealloc</code> 方法中所应执行的操作，本节不再赘述。另外还要在其中将当前对象的 <code>NSNotificationCenter</code> 观察者移除，否则在其它地方发送通知时，接收者却已经销毁，将引发崩溃。</p>
<p>需要注意的是，<code>dealloc</code> 中并不建议释放开销较大的资源，因为其调用的具体时机我们无法把握，从而容易导致出现内存泄漏。而建议是将释放方法独立，并由开发者保证在不使用资源时释放资源。但为了防止开发者忘记释放资源，我们仍可以在 <code>dealloc</code> 中根据是否释放过而去兜底释放资源，也可抛出异常。另外系统也不能保证每个对象的 <code>dealloc</code> 方法最终都会被调用，即程序终止时某些对象的 <code>dealloc</code> 方法系统可能就不再去调用了，因此当需要在程序终止时清理某些对象时，可以在 <code>AppDelegate</code> 中的相关方法中操作。</p>
<p><code>dealloc</code> 方法调用时，对象的生命周期已经接近尾声，此时不应随便调用其它方法，尤其是异步方法、特定线程方法、属性 getter &amp; setter：</p>
<ol>
<li>异步方法：当异步方法执行完毕时，系统已经将待回收对象彻底销毁，这将可能导致很多问题；</li>
<li>特定线程方法：调用 <code>dealloc</code> 方法的所在线程将执行最终的释放操作，令对象的引用计数归零；而某些方法必须在特定的线程里（比如主线程里）调用，但此时已经无法保证其会在正确的线程上正确运行，因为对象已经处于正在回收的状态；为指明此状况，运行时系统已经改动了对象的内部数据结构；</li>
<li>属性 getter &amp; setter：getter &amp; setter 有可能会被重写，其中可能会做一些不受控制的操作；另外如果对象的属性处于 KVO 下，此时的改变将使用到即将回收的对象，这将可能导致很多问题。</li>
</ol>
<h3 id="编写异常安全代码时留意内存管理问题">编写「异常安全代码时」留意内存管理问题</h3>
<p>纯 C 中不支持异常（Exception），而 C++ 和 Obj-C 均支持异常，且在 Xcode 中两者的异常是互相兼容的（可以互相捕获）。异常安全的代码使得异常抛出但并不会影响程序的继续运行，但这里就会出现内存管理的问题：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@interface</span> <span class="nc">ExceptionMaker</span> : <span class="nc">NSObject</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">generate</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">ExceptionMaker</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">generate</span> <span class="p">{</span>
    <span class="k">@throw</span> <span class="p">[</span><span class="n">NSException</span> <span class="nl">exceptionWithName</span><span class="p">:</span><span class="n">NSInternalInconsistencyException</span>
                                   <span class="nl">reason</span><span class="p">:</span><span class="s">@&#34;Just generate one exception!&#34;</span>
                                 <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="c1">// MRC 下：
</span><span class="c1"></span><span class="k">@try</span> <span class="p">{</span>
    <span class="n">ExceptionMaker</span> <span class="o">*</span><span class="n">maker</span> <span class="o">=</span> <span class="p">[</span><span class="n">ExceptionMaker</span> <span class="n">new</span><span class="p">];</span>
    <span class="p">[</span><span class="n">maker</span> <span class="n">generate</span><span class="p">];</span>
    <span class="p">[</span><span class="n">maker</span> <span class="k">release</span><span class="p">];</span> <span class="c1">// 当异常发生，此行代码将直接跳过，将导致内存泄漏
</span><span class="c1"></span><span class="p">}</span> <span class="k">@catch</span> <span class="p">(</span><span class="n">NSException</span> <span class="o">*</span><span class="n">excpetion</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Do sth with exception
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// ⬇️
</span><span class="c1"></span>
<span class="n">ExceptionMaker</span> <span class="o">*</span><span class="n">maker</span><span class="p">;</span>
<span class="k">@try</span> <span class="p">{</span>
    <span class="n">maker</span> <span class="o">=</span> <span class="p">[</span><span class="n">ExceptionMaker</span> <span class="n">new</span><span class="p">];</span>
    <span class="p">[</span><span class="n">maker</span> <span class="n">generate</span><span class="p">];</span>
<span class="p">}</span> <span class="k">@catch</span> <span class="p">(</span><span class="n">NSException</span> <span class="o">*</span><span class="n">excpetion</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Do sth with exception
</span><span class="c1"></span><span class="p">}</span> <span class="k">@finally</span> <span class="p">{</span>
    <span class="c1">// 无论如何，最终均执行释放
</span><span class="c1"></span>    <span class="p">[</span><span class="n">maker</span> <span class="k">release</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div><p>ARC 下，内存问题则更加严重：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@try</span> <span class="p">{</span>
    <span class="c1">// ARC 下这样写很自然，但 maker 定义在当前块内，无法在 finally 中释放
</span><span class="c1"></span>    <span class="n">ExceptionMaker</span> <span class="o">*</span><span class="n">maker</span> <span class="o">=</span> <span class="p">[</span><span class="n">ExceptionMaker</span> <span class="n">new</span><span class="p">];</span>
    <span class="p">[</span><span class="n">maker</span> <span class="n">generate</span><span class="p">];</span>
<span class="p">}</span> <span class="k">@catch</span> <span class="p">(</span><span class="n">NSException</span> <span class="o">*</span><span class="n">excpetion</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Do sth with exception
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>ARC 下如果要自动处理则需要加入大量样板代码来跟踪待清理的对象，这样的弊端是会影响运行时性能，且会明显增大应用程序的大小，因此该自动处理默认是关闭的。但我们仍然可以通过 <code>-fobjc-arc-expection</code> 编译器标志来开启自动处理。如上文「理解 Objective-C 错误模型」一节中所述，默认不开启自动处理的原因是异常通常是发生严重错误终止程序才应抛出，自然也就无需再考虑内存泄漏问题。如果程序中有许多异常捕获操作时，应当考虑使用 <code>NSError</code> 来进行取代。</p>
<p>另外在 Obj-C++ 模式时，编译器将自动打开 <code>-fobjc-arc-expection</code> 标志。这是因为 C++ 处理异常所用的代码与 ARC 实现的附加代码类似，因此 ARC 加入样板代码来安全处理异常所造成的性能损失可以接受，且 C++/Obj-C++ 可能需要频繁使用异常。</p>
<h3 id="以弱引用避免保留环">以弱引用避免保留环</h3>
<p><code>weak</code> 弱引用可以自动清空，也可不自动清空。自动清空（Autonilling）是随着 ARC 引入的新特性，由运行时实现。</p>
<h3 id="以自动释放池块降低内存峰值">以「自动释放池块」降低内存峰值</h3>
<p>自动释放池（Autorelease Pool）用于存放那些需要在稍后某个时刻释放的对象，清空自动释放池时，系统会向其中的对象发送 <code>release</code> 消息。GCD 机制中的线程默认都有自动释放池，每次执行事件循环（Event Loop）时，就会将其清空，因此这里我们不需要自己创建；通常只有在程序的 <code>main</code> 函数入口创建：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// main.m
</span><span class="c1"></span>
<span class="c1">// Xcode 11 前
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">UIApplicationMain</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">AppDelegate</span> <span class="k">class</span><span class="p">]));</span>
    <span class="p">}</span>
    <span class="c1">// 自动释放池的末尾即程序的终止处，此时操作系统会把程序所占的所有内存释放；
</span><span class="c1"></span>    <span class="c1">// 若不写明则 UIApplicationMain 函数中所需自动释放的对象就没有自动释放池容纳了，系统将有警告来提示；
</span><span class="c1"></span>    <span class="c1">// 这个池可以理解成最外围全部自动释放对象所用的池。
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Xcode 11
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">NSString</span> <span class="o">*</span> <span class="n">appDelegateClassName</span><span class="p">;</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="c1">// Setup code that might create autoreleased objects goes here.
</span><span class="c1"></span>        <span class="n">appDelegateClassName</span> <span class="o">=</span> <span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">AppDelegate</span> <span class="k">class</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">UIApplicationMain</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span> <span class="n">appDelegateClassName</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>自动释放池可以嵌套：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@autoreleasepool</span> <span class="p">{</span> <span class="c1">// A
</span><span class="c1"></span>    <span class="n">NSString</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&#34;kingcos.me&#34;</span><span class="p">];</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span> <span class="c1">// B
</span><span class="c1"></span>        <span class="n">NSNumber</span> <span class="o">*</span><span class="n">number</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithInt</span><span class="p">:</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span> <span class="c1">// B Pool 自动清空，number 收到 release 消息
</span><span class="c1"></span><span class="p">}</span> <span class="c1">// A Pool 自动清空，string 收到 release 消息
</span></code></pre></div><p>自动释放池可以用来降低内存峰值（High-Memory Waterline）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">new</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000000</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span> <span class="c1">// 内部自动释放的对象将放在该池中，而非线程的主池中
</span><span class="c1"></span>        <span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">generate</span><span class="p">];</span> <span class="c1">// 若不加 @autoreleasepool 将在 for 循环结束后释放，内存占用将持续上涨
</span><span class="c1"></span>        <span class="p">[</span><span class="n">arr</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">foo</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MRC 下的 NSAutoreleasePool
</span><span class="c1"></span><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">new</span><span class="p">];</span>
<span class="n">NSAutoreleasePool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSAutoreleasePool</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000000</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="k">do</span><span class="p">];</span>
    <span class="p">[</span><span class="n">arr</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">foo</span><span class="p">];</span>

    <span class="c1">// 每隔 10 次释放一次
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">pool</span> <span class="n">drain</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 防止未释放，再手动释放一次
</span><span class="c1"></span><span class="p">[</span><span class="n">pool</span> <span class="n">drain</span><span class="p">];</span>

<span class="c1">// @autoreleasepool 语法较于 NSAutoreleasePool 更好的是范围的缺点，避免了在自动释放池清空后再次使用相关对象
</span><span class="c1"></span>
<span class="p">-</span> <span class="p">(</span><span class="n">Foo</span> <span class="o">*</span><span class="p">)</span><span class="nf">generate</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
    <span class="c1">// 放入自动释放池中
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">[</span><span class="n">foo</span> <span class="n">autorelease</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div><p>自动释放池机制类似栈，内部需要放入自动释放池的对象将入栈，而清空自动释放池则相当于将其出栈。自动释放池的建立会带来一定开销，具体是否用来优化效率，需取决于具体情况。</p>
<h3 id="用僵尸对象调试内存管理问题">用「僵尸对象」调试内存管理问题</h3>
<p>「僵尸对象」功能指的是在运行时系统会将所有已回收的对象转化为僵尸对象，当其再次收到消息时将抛出异常。我们可以在 Xcode - Edit Schemes - Memory Management - Zombie Objects 来开启该功能：</p>
<p><img src="/img/2019/effective_obj-c_2.0_notes/2.png" alt="2"></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="n">Bar</span> <span class="o">*</span><span class="n">bar</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Bar</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
<span class="c1">// 1: Bar *
</span><span class="c1"></span><span class="p">[</span><span class="n">bar</span> <span class="k">release</span><span class="p">];</span>
<span class="c1">// 2: _NSZombie_Bar *
</span><span class="c1"></span>
<span class="c1">// LLDB:
</span><span class="c1">// (lldb) p bar
</span><span class="c1">// (Bar *) $0 = 0x00006000009dc040
</span><span class="c1">// (lldb) p bar
</span><span class="c1">// (_NSZombie_Bar *) $1 = 0x00006000009dc040
</span><span class="c1">// (lldb)
</span></code></pre></div><p>僵尸类是从名为 <code>_NSZombie_</code> 的模版类里复制出来的，创建并复制新的僵尸类原因在于，僵尸对象发送消息时，可由此得知该对象原本所属的类型。创建继承自 <code>_NSZombie_</code> 的子类也可行，但效率低于拷贝。伪代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// 伪代码
</span><span class="c1"></span>
<span class="c1">// 运行时若发现 NSZombieEnabled 环境变量已经设置，将对对象的 dealloc 方法交换为以下方法：
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">zombieDealloc</span> <span class="p">{</span>
    <span class="c1">// 获取将要释放的对象的类对象
</span><span class="c1"></span>    <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">object_getClass</span><span class="p">(</span><span class="nb">self</span><span class="p">);</span>
    <span class="c1">// 获取类名
</span><span class="c1"></span>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">clsName</span> <span class="o">=</span> <span class="n">class_getName</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
    <span class="c1">// 生成新类名
</span><span class="c1"></span>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zombieClsName</span> <span class="o">=</span> <span class="s">&#34;_NSZombie_&#34;</span> <span class="o">+</span> <span class="n">clsName</span><span class="p">;</span>
    <span class="c1">// 查找是否存在该僵尸类
</span><span class="c1"></span>    <span class="kt">Class</span> <span class="n">zombieCls</span> <span class="o">=</span> <span class="n">objc_lookUpClass</span><span class="p">(</span><span class="n">zombieClsName</span><span class="p">);</span>
    <span class="c1">// 若不存在则需创建
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zombieCls</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 获取僵尸基类（使得后续可得知对象所属的类）
</span><span class="c1"></span>        <span class="kt">Class</span> <span class="n">baseZombieCls</span> <span class="o">=</span> <span class="n">objc_lookUpClass</span><span class="p">(</span><span class="s">&#34;_NSZombie_&#34;</span><span class="p">);</span>
        <span class="c1">// 复制僵尸基类为新类名即修改 isa 指针（拷贝而非创建子类的效率更高）
</span><span class="c1"></span>        <span class="n">zombieCls</span> <span class="o">=</span> <span class="n">objc_duplicateClass</span><span class="p">(</span><span class="n">baseZombieCls</span><span class="p">,</span> <span class="n">zombieClsName</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 执行正常的销毁操作
</span><span class="c1"></span>    <span class="n">objc_destructInstance</span><span class="p">(</span><span class="nb">self</span><span class="p">);</span>
    <span class="c1">// 将要销毁的对象的类型设置为僵尸类
</span><span class="c1"></span>    <span class="n">objc_setClass</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">zombieCls</span><span class="p">);</span>

    <span class="c1">// 关键之处在于对象本身并未通过 free() 被释放，虽然会内存泄漏，但该功能仅仅在调试阶段开启，可以忽略
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p><code>_NSZombie_</code> 模版类中并未实现任何方法，且没有超类（类似 <code>NSObject</code>），仅有一个 <code>isa</code> 成员变量，因此发送给该僵尸对象的消息需经由完整的消息转发机制。而完整的消息转发机制中，<code>___forwarding___</code> 是核心，其要检查接受消息的对象所属的类名，若前缀为 <code>_NSZombie_</code> 则消息接收者为僵尸对象，需特殊处理，即打印相关信息并终止程序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// 获取将要释放的对象的类对象
</span><span class="c1"></span><span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">object_getClass</span><span class="p">(</span><span class="nb">self</span><span class="p">);</span>
<span class="c1">// 获取类名
</span><span class="c1"></span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">clsName</span> <span class="o">=</span> <span class="n">class_getName</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
<span class="c1">// 确定是否为僵尸类型
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">string_has_prefix</span><span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="s">&#34;_NSZombie_&#34;</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// 截取原始类名
</span><span class="c1"></span>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">originalClsName</span> <span class="o">=</span> <span class="n">substring_from</span><span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">selectorName</span> <span class="o">=</span> <span class="n">sel_getName</span><span class="p">(</span><span class="n">_cmd</span><span class="p">);</span>

    <span class="c1">// 打印相关信息
</span><span class="c1"></span>    <span class="n">Log</span><span class="p">(</span><span class="s">&#34;*** -[%s %s]: message sent to deallocated instance %p&#34;</span><span class="p">,</span> <span class="n">originalClsName</span><span class="p">,</span> <span class="n">selectorName</span><span class="p">,</span> <span class="nb">self</span><span class="p">);</span>

    <span class="c1">// 终止程序
</span><span class="c1"></span>    <span class="n">abort</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><h3 id="不要使用-retaincount">不要使用 retainCount</h3>
<p><code>retainCount</code> 是 MRC 下的方法，用来获取对象的引用计数，但其实引用计数的具体值开发者不应特别关心。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// MRC
</span><span class="c1"></span><span class="k">while</span> <span class="p">([</span><span class="n">obj</span> <span class="n">retainCount</span><span class="p">])</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">obj</span> <span class="k">release</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div><p>以上的写法是错误的：</p>
<ol>
<li><code>retainCount</code> 方法并不会考虑到 <code>autorelease</code> 的情况，因此当跳出循环时引用计数确实归 0，但此时若自动释放池再次进行释放时将导致程序崩溃；</li>
<li><code>retainCount</code> 方法可能永远不返回 <code>0</code>，系统有时会优化对象的释放行为（即使引用计数为 1 时就可能被回收），如果对象已经被回收，但仍然进入循环进行释放，将同样导致程序崩溃。</li>
</ol>
<p>因此，释放对象不应当通过引用计数来判断，而是应该找清楚哪里仍对对象进行了持有，通过内存管理解决问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// 64 bit macOS
</span><span class="c1"></span>
<span class="c1">// 单例对象（编译期常量，编译器将该数据直接放在可执行文件中即可无需创建对象）引用计数不会变
</span><span class="c1"></span><span class="n">NSString</span> <span class="o">*</span><span class="n">str1</span> <span class="o">=</span> <span class="s">@&#34;kingcos.me&#34;</span><span class="p">;</span>
<span class="c1">// 18446744073709551615
</span><span class="c1"></span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%lu&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)[</span><span class="n">str1</span> <span class="n">retainCount</span><span class="p">]);</span>

<span class="c1">// 单例对象（标签指针，运行时在消息派发期间检测并执行相应操作）
</span><span class="c1"></span><span class="n">NSNumber</span> <span class="o">*</span><span class="n">num1</span> <span class="o">=</span> <span class="mi">@1</span><span class="p">;</span>
<span class="c1">// 9223372036854775807
</span><span class="c1"></span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%lu&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)[</span><span class="n">num1</span> <span class="n">retainCount</span><span class="p">]);</span>

<span class="c1">// NSNumber 浮点数没有此类优化
</span><span class="c1"></span><span class="n">NSNumber</span> <span class="o">*</span><span class="n">num2</span> <span class="o">=</span> <span class="mf">@3.14</span><span class="p">;</span>
<span class="c1">// 1
</span><span class="c1"></span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%lu&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)[</span><span class="n">num2</span> <span class="n">retainCount</span><span class="p">]);</span>
</code></pre></div><p>综上不建议使用 <code>retainCount</code> 方法。</p>
<h2 id="块与大中枢派发">块与大中枢派发</h2>
<h3 id="理解块这一概念">理解「块」这一概念</h3>
<p>略；关于 Block，可详见《<a href="../block_in_obj-c">Obj-C 中的 Block</a>》一文。</p>
<h3 id="为常用的块类型创建-typedef">为常用的块类型创建 <code>typedef</code></h3>
<p>略；关于 Block，可详见《<a href="../block_in_obj-c">Obj-C 中的 Block</a>》一文。</p>
<h3 id="用-handler-块降低代码分散程度">用 handler 块降低代码分散程度</h3>
<p>略；关于 Block，可详见《<a href="../block_in_obj-c">Obj-C 中的 Block</a>》一文。</p>
<h3 id="用块引用其所属对象时不要出现保留环">用块引用其所属对象时不要出现保留环</h3>
<p>略；关于 Block，可详见《<a href="../block_in_obj-c">Obj-C 中的 Block</a>》一文。</p>
<h3 id="多用派发队列少用同步锁">多用派发队列，少用同步锁</h3>
<h3 id="多用-gcd少用-performselector-系列方法">多用 GCD，少用 performSelector 系列方法</h3>
<h3 id="掌握-gcd-及操作队列的时机">掌握 GCD 及操作队列的时机</h3>
<h3 id="通过-dispatch-group-机制根据系统资源状况来执行任务">通过 Dispatch Group 机制，根据系统资源状况来执行任务</h3>
<h3 id="使用-dispatch_once-来执行只需运行一次的线程安全代码">使用 dispatch_once 来执行只需运行一次的线程安全代码</h3>
<h3 id="不要使用-dispatch_get_current_queue">不要使用 dispatch_get_current_queue</h3>
<h2 id="系统框架">系统框架</h2>
<h3 id="熟悉系统框架">熟悉系统框架</h3>
<p>略。</p>
<h3 id="多用块枚举少用-for-循环">多用块枚举，少用 for 循环</h3>
<p>遍历集合的方式有如下四种，之后可能会将此部分单独总结，此处不再赘述：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// 1⃣️ FOR-LOOP
</span><span class="c1"></span><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">dict</span> <span class="o">=</span> <span class="l">@{</span><span class="s">@&#34;A&#34;</span><span class="o">:</span><span class="s">@&#34;a&#34;</span><span class="p">,</span> <span class="s">@&#34;B&#34;</span><span class="o">:</span><span class="s">@&#34;b&#34;</span><span class="p">,</span> <span class="s">@&#34;C&#34;</span><span class="o">:</span><span class="s">@&#34;c&#34;</span><span class="p">,</span> <span class="s">@&#34;kingcos.me&#34;</span><span class="o">:</span><span class="s">@&#34;github.com/kingcos&#34;</span><span class="p">,</span><span class="l">}</span><span class="p">;</span>
<span class="n">NSArray</span> <span class="o">*</span><span class="n">allKeys</span> <span class="o">=</span> <span class="p">[</span><span class="n">dict</span> <span class="n">allKeys</span><span class="p">];</span> <span class="c1">// ⚠️：NSDictionary &amp; NSSet 的元素是无序的
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">allKeys</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;&lt;%@, %@&gt;&#34;</span><span class="p">,</span> <span class="n">allKeys</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dict</span><span class="p">[</span><span class="n">allKeys</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span>
<span class="p">}</span>

<span class="c1">// - 倒序
</span><span class="c1"></span><span class="n">NSArray</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="l">@[</span><span class="s">@&#34;A&#34;</span><span class="p">,</span> <span class="s">@&#34;kingcos.me&#34;</span><span class="p">,</span> <span class="s">@&#34;github.com/kingcos&#34;</span><span class="l">]</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">arr</span><span class="p">.</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;&lt;%@&gt;&#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="c1">// 2⃣️ ENUMERATOR
</span><span class="c1"></span><span class="n">NSEnumerator</span> <span class="o">*</span><span class="n">dictEnumerator</span> <span class="o">=</span> <span class="p">[</span><span class="n">dict</span> <span class="n">keyEnumerator</span><span class="p">];</span>
<span class="kt">id</span> <span class="n">dictNextObj</span><span class="p">;</span>
<span class="k">while</span> <span class="p">((</span><span class="n">dictNextObj</span> <span class="o">=</span> <span class="p">[</span><span class="n">dictEnumerator</span> <span class="n">nextObject</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;&lt;%@, %@&gt;&#34;</span><span class="p">,</span> <span class="n">dictNextObj</span><span class="p">,</span> <span class="n">dict</span><span class="p">[</span><span class="n">dictNextObj</span><span class="p">]);</span>
<span class="p">}</span>

<span class="c1">// - 倒序
</span><span class="c1"></span><span class="n">NSEnumerator</span> <span class="o">*</span><span class="n">arrReversedEnumerator</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span> <span class="n">reverseObjectEnumerator</span><span class="p">];</span>
<span class="kt">id</span> <span class="n">arrNextObj</span><span class="p">;</span>
<span class="k">while</span> <span class="p">((</span><span class="n">arrNextObj</span> <span class="o">=</span> <span class="p">[</span><span class="n">arrReversedEnumerator</span> <span class="n">nextObject</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;&lt;%@&gt;&#34;</span><span class="p">,</span> <span class="n">arrNextObj</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 3⃣️ FAST-ENUMERATION
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">id</span> <span class="n">obj</span> <span class="k">in</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;&lt;%@&gt;&#34;</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">id</span> <span class="n">obj</span> <span class="k">in</span> <span class="p">[</span><span class="n">arr</span> <span class="n">reverseObjectEnumerator</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;&lt;%@&gt;&#34;</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// - 自定义类型也可支持快速遍历：
</span><span class="c1">//   1. 继承 NSEnumerator 抽象基类，并实现 allObjects &amp; nextObject
</span><span class="c1">//   2. 遵守 NSFastEnumeration 协议，并实现 countByEnumeratingWithState:objects:count:
</span><span class="c1"></span>
<span class="c1">// 4⃣️ 基于 Block
</span><span class="c1">// 字典键值同时读取；id 类型使得可以修改方法签名，避免类型转换
</span><span class="c1"></span><span class="p">[</span><span class="n">dict</span> <span class="nl">enumerateKeysAndObjectsUsingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span>  <span class="n">_Nonnull</span> <span class="n">key</span><span class="p">,</span>
                                          <span class="n">NSString</span> <span class="o">*</span> <span class="n">_Nonnull</span> <span class="n">obj</span><span class="p">,</span>
                                          <span class="kt">BOOL</span> <span class="o">*</span> <span class="n">_Nonnull</span> <span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;&lt;%@, %@&gt;&#34;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">([</span><span class="n">obj</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="s">@&#34;github.com/kingcos&#34;</span><span class="p">])</span> <span class="p">{</span>
        <span class="c1">// 可在内部终止
</span><span class="c1"></span>        <span class="o">*</span><span class="n">stop</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}];</span>

<span class="c1">// NSEnumerationOptions 是枚举
</span><span class="c1">// typedef NS_OPTIONS(NSUInteger, NSEnumerationOptions) {
</span><span class="c1">//     NSEnumerationConcurrent = (1UL &lt;&lt; 0), // Block 可以并行执行
</span><span class="c1">//     NSEnumerationReverse = (1UL &lt;&lt; 1),    // 倒序（仅支持有序的集合结构）
</span><span class="c1">// };
</span><span class="c1"></span>
<span class="p">[</span><span class="n">arr</span> <span class="nl">enumerateObjectsWithOptions</span><span class="p">:</span><span class="n">NSEnumerationReverse</span>
                      <span class="nl">usingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span> <span class="n">_Nonnull</span> <span class="n">obj</span><span class="p">,</span>
                                   <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span>
                                   <span class="kt">BOOL</span> <span class="o">*</span> <span class="n">_Nonnull</span> <span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;&lt;%@&gt;&#34;</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
<span class="p">}];</span>
</code></pre></div><!-- https://www.cnblogs.com/zenny-chen/p/3593106.html

http://blog.leichunfeng.com/blog/2016/06/20/objective-c-fast-enumeration-implementation-principle/

https://zhuanlan.zhihu.com/p/25837870

https://www.jianshu.com/p/2ec49d525871 -->
<ul>
<li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Collections/Articles/Enumerators.html">Enumeration: Traversing a Collection’s Elements - Collections Programming Topics</a></li>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2010-04-09-comparison-of-objective-c-enumeration-techniques.html">Friday Q&amp;A 2010-04-09: Comparison of Objective-C Enumeration Techniques - Mike Ash</a></li>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2010-04-16-implementing-fast-enumeration.html">Friday Q&amp;A 2010-04-16: Implementing Fast Enumeration - Mike Ash</a></li>
</ul>
<h3 id="对自定义其内存管理语义的-collection-使用无缝桥接">对自定义其内存管理语义的 collection 使用无缝桥接</h3>
<p>无缝桥接（Toll-Free Bridging）使得 <code>Foundation</code> 框架中的 Obj-C 类型可以与 <code>CoreFoundation</code> 框架里的 C 语言数据结构之间可以平滑转换。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="n">NSArray</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="l">@[</span><span class="s">@&#34;A&#34;</span><span class="p">,</span> <span class="s">@&#34;kingcos.me&#34;</span><span class="p">,</span> <span class="s">@&#34;github.com/kingcos&#34;</span><span class="l">]</span><span class="p">;</span>

<span class="n">CFArrayRef</span> <span class="n">cfArray1</span> <span class="o">=</span> <span class="p">(</span><span class="k">__bridge</span> <span class="n">CFArrayRef</span><span class="p">)</span><span class="n">arr</span><span class="p">;</span>
<span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%li&#34;</span><span class="p">,</span> <span class="n">CFArrayGetCount</span><span class="p">(</span><span class="n">cfArray1</span><span class="p">));</span>

<span class="n">CFArrayRef</span> <span class="n">cfArray2</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge_retained</span> <span class="n">CFArrayRef</span><span class="p">)</span><span class="n">arr</span><span class="p">;</span>
<span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%li&#34;</span><span class="p">,</span> <span class="n">CFArrayGetCount</span><span class="p">(</span><span class="n">cfArray2</span><span class="p">));</span>
<span class="n">CFRelease</span><span class="p">(</span><span class="n">cfArray2</span><span class="p">);</span> <span class="c1">// 释放
</span><span class="c1"></span>
<span class="n">CFArrayRef</span> <span class="n">cfArray3</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge_retained</span> <span class="n">CFArrayRef</span><span class="p">)</span><span class="n">arr</span><span class="p">;</span>
<span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%li&#34;</span><span class="p">,</span> <span class="n">CFArrayGetCount</span><span class="p">(</span><span class="n">cfArray3</span><span class="p">));</span>
<span class="n">arr</span> <span class="o">=</span> <span class="p">(</span><span class="k">__bridge_transfer</span> <span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="n">cfArray3</span><span class="p">;</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// 3
</span><span class="c1">// 3
</span><span class="c1">// 3
</span></code></pre></div><ul>
<li>桥式转换（Bridged Cast）
<ul>
<li><code>__bridge</code>：仅桥接，ARC 仍拥有 Obj-C 对象所有权；</li>
<li><code>__bridge_retained</code>：桥接且持有，ARC 不再拥有对象所有权，交由 <code>CoreFoundation</code> 处理；</li>
<li><code>__bridge_transfer</code>：桥接且转换，ARC 再次拥有对象所有权。</li>
</ul>
</li>
</ul>
<p><code>Foundation</code> 框架与 <code>CoreFoundation</code> 框架的某些功能可以互相补足。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// CFDictionary.h
</span><span class="c1"></span><span class="n">CFMutableDictionaryRef</span> <span class="nf">CFDictionaryCreateMutable</span><span class="p">(</span><span class="n">CFAllocatorRef</span> <span class="n">allocator</span><span class="p">,</span> <span class="c1">// 内存分配器，传 NULL 为默认实现
</span><span class="c1"></span>                                                 <span class="n">CFIndex</span> <span class="n">capacity</span><span class="p">,</span>         <span class="c1">// 初始容量
</span><span class="c1"></span>                                                 <span class="k">const</span> <span class="n">CFDictionaryKeyCallBacks</span> <span class="o">*</span><span class="n">keyCallBacks</span><span class="p">,</span> <span class="c1">// 指向结构体的指针
</span><span class="c1"></span>                                                 <span class="k">const</span> <span class="n">CFDictionaryValueCallBacks</span> <span class="o">*</span><span class="n">valueCallBacks</span><span class="p">);</span> <span class="c1">// 同上
</span><span class="c1"></span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">CFIndex</span>                <span class="n">version</span><span class="p">;</span>           <span class="c1">// 版本号，通常设置为 0
</span><span class="c1"></span>    <span class="n">CFDictionaryRetainCallBack</span>        <span class="k">retain</span><span class="p">;</span> <span class="c1">// 当事件发送，通过函数指针调用，下同
</span><span class="c1"></span>    <span class="n">CFDictionaryReleaseCallBack</span>        <span class="k">release</span><span class="p">;</span>
    <span class="n">CFDictionaryCopyDescriptionCallBack</span>    <span class="n">copyDescription</span><span class="p">;</span>
    <span class="n">CFDictionaryEqualCallBack</span>        <span class="n">equal</span><span class="p">;</span>
    <span class="n">CFDictionaryHashCallBack</span>        <span class="n">hash</span><span class="p">;</span>
<span class="p">}</span> <span class="n">CFDictionaryKeyCallBacks</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">CFIndex</span>                <span class="n">version</span><span class="p">;</span>
    <span class="n">CFDictionaryRetainCallBack</span>        <span class="k">retain</span><span class="p">;</span>
    <span class="n">CFDictionaryReleaseCallBack</span>        <span class="k">release</span><span class="p">;</span>
    <span class="n">CFDictionaryCopyDescriptionCallBack</span>    <span class="n">copyDescription</span><span class="p">;</span>
    <span class="n">CFDictionaryEqualCallBack</span>        <span class="n">equal</span><span class="p">;</span>
<span class="p">}</span> <span class="n">CFDictionaryValueCallBacks</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span>    <span class="p">(</span><span class="o">*</span><span class="n">CFDictionaryRetainCallBack</span><span class="p">)(</span><span class="n">CFAllocatorRef</span> <span class="n">allocator</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
<span class="k">typedef</span> <span class="nf">void</span>        <span class="p">(</span><span class="o">*</span><span class="n">CFDictionaryReleaseCallBack</span><span class="p">)(</span><span class="n">CFAllocatorRef</span> <span class="n">allocator</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
<span class="k">typedef</span> <span class="nf">CFStringRef</span>    <span class="p">(</span><span class="o">*</span><span class="n">CFDictionaryCopyDescriptionCallBack</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
<span class="k">typedef</span> <span class="nf">Boolean</span>        <span class="p">(</span><span class="o">*</span><span class="n">CFDictionaryEqualCallBack</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value2</span><span class="p">);</span>
<span class="k">typedef</span> <span class="nf">CFHashCode</span>    <span class="p">(</span><span class="o">*</span><span class="n">CFDictionaryHashCallBack</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
</code></pre></div><p>比如 <code>Foundation</code> 中的字典对象的键内存管理语义为拷贝，值内存管理语义为保留，那么在键如果是自定义对象则需要遵守 <code>NSCopying</code> 协议。但我们可以在 <code>CoreFoundation</code> 层创建并修改内存管理语义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="nf">DictRetainCallBack</span><span class="p">(</span><span class="n">CFAllocatorRef</span> <span class="n">allocator</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">CFRetain</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">DictReleaseCallBack</span><span class="p">(</span><span class="n">CFAllocatorRef</span> <span class="n">allocator</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">CFRelease</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="n">CFDictionaryKeyCallBacks</span> <span class="n">keyCallbacks</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">0</span><span class="p">,</span>                   <span class="c1">// version
</span><span class="c1"></span>            <span class="n">DictRetainCallBack</span><span class="p">,</span>  <span class="c1">// retain
</span><span class="c1"></span>            <span class="n">DictReleaseCallBack</span><span class="p">,</span> <span class="c1">// release
</span><span class="c1"></span>            <span class="nb">NULL</span><span class="p">,</span>                <span class="c1">// copyDescription，传 NULL 为默认实现
</span><span class="c1"></span>            <span class="n">CFEqual</span><span class="p">,</span>             <span class="c1">// equal，CFEqual 与默认实现相同，最终调用 NSObject 的 isEqual:
</span><span class="c1"></span>            <span class="n">CFHash</span>               <span class="c1">// hash，CFHash 与默认实现相同，最终调用 NSObject 的 hash
</span><span class="c1"></span>        <span class="p">};</span>

        <span class="n">CFDictionaryValueCallBacks</span> <span class="n">valueCallbacks</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">0</span><span class="p">,</span>                   <span class="c1">// version
</span><span class="c1"></span>            <span class="n">DictRetainCallBack</span><span class="p">,</span>  <span class="c1">// retain
</span><span class="c1"></span>            <span class="n">DictReleaseCallBack</span><span class="p">,</span> <span class="c1">// release
</span><span class="c1"></span>            <span class="nb">NULL</span><span class="p">,</span>                <span class="c1">// copyDescription
</span><span class="c1"></span>            <span class="n">CFEqual</span><span class="p">,</span>             <span class="c1">// equal
</span><span class="c1"></span>        <span class="p">};</span>

        <span class="n">CFMutableDictionaryRef</span> <span class="n">cfDict</span> <span class="o">=</span> <span class="n">CFDictionaryCreateMutable</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">keyCallbacks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">valueCallbacks</span><span class="p">);</span>
        <span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">dict</span> <span class="o">=</span> <span class="p">(</span><span class="k">__bridge_transfer</span> <span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="p">)</span><span class="n">cfDict</span><span class="p">;</span>

        <span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
        <span class="c1">// dict[foo] = @&#34;foo&#34;; // CRASH: &#39;-[Foo copyWithZone:]: unrecognized selector sent to instance 0x100500670&#39;
</span><span class="c1"></span>        <span class="n">CFDictionaryAddValue</span><span class="p">(</span><span class="n">cfDict</span><span class="p">,</span> <span class="p">(</span><span class="k">__bridge</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">foo</span><span class="p">),</span> <span class="n">CFSTR</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">));</span>

        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">dict</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// {
</span><span class="c1">//    &#34;&lt;Foo: 0x10059b3c0&gt;&#34; = foo;
</span><span class="c1">// }
</span></code></pre></div><h3 id="构建缓存时选用-nscache-而非-nsdictionary">构建缓存时选用 NSCache 而非 NSDictionary</h3>
<p>当网络数据过大或者其它某些情况，我们可能需要使用到数据结构来做缓存以优化用户体验，此时 <code>NSCache</code> 要比 <code>NSDictionary</code> 好，首先当系统资源即将耗尽时，前者可以按最久未使用（Least Recently Used，LRU）算法自动删减缓存；其次 <code>NSCache</code> 对键不会做类似 <code>NSDictionary</code> 默认的拷贝操作，而是保留操作；而且 <code>NSCache</code> 是线程安全的，<code>NSDictionary</code> 则无此优势。</p>
<p>开发者可以控制缓存删减其内容的时机，其中有两个尺度可供调整，其一是缓存中的对象总数，其二是所有对象的总开销。缓存的使用目的即是为了更快地响应用户操作，而如果开销值计算是耗时操作就显得本末倒置了，除非是已知数据大小的 <code>NSData</code> 对象。另外控制尺度并非完全严格，其仅对 <code>NSCache</code> 起指导作用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">^</span><span class="n">HandlerBlock</span><span class="p">)(</span><span class="n">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="k">@interface</span> <span class="nc">Foo</span> : <span class="nc">NSObject</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithURL:</span><span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">url</span><span class="p">;</span>

<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="n">NSURL</span> <span class="o">*</span><span class="n">_url</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithURL:</span><span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">url</span> <span class="p">{</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_url</span> <span class="o">=</span> <span class="n">url</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">doWithHandler:</span><span class="p">(</span><span class="n">HandlerBlock</span><span class="p">)</span><span class="nv">handler</span> <span class="p">{</span>
    <span class="n">NSData</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">_url</span><span class="p">.</span><span class="n">absoluteString</span> <span class="nl">dataUsingEncoding</span><span class="p">:</span><span class="n">NSUTF8StringEncoding</span><span class="p">];</span>
    <span class="n">handler</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;dealloc&#34;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">@end</span>

<span class="k">@interface</span> <span class="nc">Bar</span> : <span class="nc">NSObject</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Bar</span> <span class="p">{</span>
    <span class="n">NSCache</span> <span class="o">*</span><span class="n">_cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_cache</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSCache</span> <span class="n">new</span><span class="p">];</span>

        <span class="c1">// 缓存对象总数上限
</span><span class="c1"></span>        <span class="n">_cache</span><span class="p">.</span><span class="n">countLimit</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="c1">// 缓存总开销上限（单位为字节 B）
</span><span class="c1"></span>        <span class="n">_cache</span><span class="p">.</span><span class="n">totalCostLimit</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">fetchFromURL:</span><span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">url</span> <span class="p">{</span>
    <span class="n">NSData</span> <span class="o">*</span><span class="n">cachedData</span> <span class="o">=</span> <span class="p">[</span><span class="n">_cache</span> <span class="nl">objectForKey</span><span class="p">:</span><span class="n">url</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cachedData</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;命中缓存&#34;</span><span class="p">);</span>

        <span class="p">[</span><span class="nb">self</span> <span class="nl">dealWithData</span><span class="p">:</span><span class="n">cachedData</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;未命中缓存&#34;</span><span class="p">);</span>

        <span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithURL</span><span class="p">:</span><span class="n">url</span><span class="p">];</span>

        <span class="k">__weak</span> <span class="k">typeof</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="n">weakSelf</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
        <span class="p">[</span><span class="n">foo</span> <span class="nl">doWithHandler</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 防止循环引用
</span><span class="c1"></span>            <span class="k">__strong</span> <span class="k">typeof</span><span class="p">(</span><span class="n">weakSelf</span><span class="p">)</span> <span class="n">strongSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>

            <span class="c1">// 缓存（NSData 长度读取不耗时）
</span><span class="c1"></span>            <span class="p">[</span><span class="n">strongSelf</span><span class="o">-&gt;</span><span class="n">_cache</span> <span class="nl">setObject</span><span class="p">:</span><span class="n">data</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">url</span> <span class="nl">cost</span><span class="p">:</span><span class="n">data</span><span class="p">.</span><span class="n">length</span><span class="p">];</span>

            <span class="p">[</span><span class="n">strongSelf</span> <span class="nl">dealWithData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
        <span class="p">}];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">fetchFromURL_2:</span><span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">url</span> <span class="p">{</span>
    <span class="c1">// NSPurgeableData 继承自 NSMutableData 且实现了 NSDiscardableContent 协议
</span><span class="c1"></span>    <span class="c1">// 当系统资源紧张时，可以把保存 NSPurgeableData 对象的那块内存释放
</span><span class="c1"></span>    <span class="c1">// NSDiscardableContent 协议：
</span><span class="c1"></span>    <span class="c1">// - isContentDiscarded：可用来查询相关内存是否已经释放
</span><span class="c1"></span>    <span class="c1">// - beginContentAccess：可用来告知此时不应丢弃占据的内存（类似某个计数 + 1）
</span><span class="c1"></span>    <span class="c1">// - endContentAccess：可用来告知必要时可以丢弃占据的内存（类似某个计数 - 1，只有为 0 时才可丢弃）
</span><span class="c1"></span>    <span class="c1">// NSPurgeableData 对象若加入了 NSCache，那么若其内存被系统丢弃，默认也会自动缓存中移除
</span><span class="c1"></span>    <span class="c1">// NSCache 中的 evictsObjectsWithDiscardedContent 用来控制此功能开关
</span><span class="c1"></span>    <span class="n">NSPurgeableData</span> <span class="o">*</span><span class="n">cachedData</span> <span class="o">=</span> <span class="p">[</span><span class="n">_cache</span> <span class="nl">objectForKey</span><span class="p">:</span><span class="n">url</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cachedData</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;命中缓存&#34;</span><span class="p">);</span>

        <span class="c1">// 后面要使用，此时 + 1
</span><span class="c1"></span>        <span class="p">[</span><span class="n">cachedData</span> <span class="n">beginContentAccess</span><span class="p">];</span>

        <span class="p">[</span><span class="nb">self</span> <span class="nl">dealWithData</span><span class="p">:</span><span class="n">cachedData</span><span class="p">];</span>

        <span class="c1">// 使用完毕，此时 - 1
</span><span class="c1"></span>        <span class="p">[</span><span class="n">cachedData</span> <span class="n">endContentAccess</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;未命中缓存&#34;</span><span class="p">);</span>

        <span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithURL</span><span class="p">:</span><span class="n">url</span><span class="p">];</span>

        <span class="k">__weak</span> <span class="k">typeof</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="n">weakSelf</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
        <span class="p">[</span><span class="n">foo</span> <span class="nl">doWithHandler</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 防止循环引用
</span><span class="c1"></span>            <span class="k">__strong</span> <span class="k">typeof</span><span class="p">(</span><span class="n">weakSelf</span><span class="p">)</span> <span class="n">strongSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>

            <span class="c1">// 根据 NSData 获取 NSPurgeableData 对象（创建时无需 beginContentAccess 计数会默认 + 1）
</span><span class="c1"></span>            <span class="n">NSPurgeableData</span> <span class="o">*</span><span class="n">purgeableData</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSPurgeableData</span> <span class="nl">dataWithData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>

            <span class="c1">// 缓存 NSPurgeableData 对象
</span><span class="c1"></span>            <span class="p">[</span><span class="n">strongSelf</span><span class="o">-&gt;</span><span class="n">_cache</span> <span class="nl">setObject</span><span class="p">:</span><span class="n">purgeableData</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">url</span> <span class="nl">cost</span><span class="p">:</span><span class="n">purgeableData</span><span class="p">.</span><span class="n">length</span><span class="p">];</span>

            <span class="p">[</span><span class="n">strongSelf</span> <span class="nl">dealWithData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>

            <span class="c1">// 标记 NSPurgeableData 对象可丢弃（计数 - 1）
</span><span class="c1"></span>            <span class="p">[</span><span class="n">purgeableData</span> <span class="n">endContentAccess</span><span class="p">];</span>
        <span class="p">}];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealWithData:</span><span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="nv">data</span> <span class="p">{</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="p">[[</span><span class="n">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithData</span><span class="p">:</span><span class="n">data</span> <span class="nl">encoding</span><span class="p">:</span><span class="n">NSUTF8StringEncoding</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">@end</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="n">Bar</span> <span class="o">*</span><span class="n">bar</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Bar</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

        <span class="p">[</span><span class="n">bar</span> <span class="nl">fetchFromURL</span><span class="p">:[</span><span class="n">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&#34;https://kingcos.me&#34;</span><span class="p">]];</span>
        <span class="p">[</span><span class="n">bar</span> <span class="nl">fetchFromURL</span><span class="p">:[</span><span class="n">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&#34;https://github.com/kingcos&#34;</span><span class="p">]];</span>
        <span class="p">[</span><span class="n">bar</span> <span class="nl">fetchFromURL</span><span class="p">:[</span><span class="n">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&#34;https://kingcos.me&#34;</span><span class="p">]];</span>

        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;---&#34;</span><span class="p">);</span>

        <span class="c1">// ⚠️ URL 不要和上面完全一致，否则缓存和实际类型有出入
</span><span class="c1"></span>        <span class="p">[</span><span class="n">bar</span> <span class="nl">fetchFromURL_2</span><span class="p">:[</span><span class="n">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&#34;https://kingcos.me/&#34;</span><span class="p">]];</span>
        <span class="p">[</span><span class="n">bar</span> <span class="nl">fetchFromURL_2</span><span class="p">:[</span><span class="n">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&#34;https://github.com/kingcos/&#34;</span><span class="p">]];</span>
        <span class="p">[</span><span class="n">bar</span> <span class="nl">fetchFromURL_2</span><span class="p">:[</span><span class="n">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&#34;https://kingcos.me/&#34;</span><span class="p">]];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 1024 B = 1 KB 缓存 &amp;&amp; countLimit 为 100 时：
</span><span class="c1">// 未命中缓存
</span><span class="c1">// https://kingcos.me
</span><span class="c1">// dealloc
</span><span class="c1">// 未命中缓存
</span><span class="c1">// https://github.com/kingcos
</span><span class="c1">// dealloc
</span><span class="c1">// 命中缓存
</span><span class="c1">// https://kingcos.me
</span><span class="c1"></span>
<span class="c1">// 1 B 缓存 || countLimit 为 1 时：
</span><span class="c1">// 未命中缓存
</span><span class="c1">// https://kingcos.me
</span><span class="c1">// dealloc
</span><span class="c1">// 未命中缓存
</span><span class="c1">// https://github.com/kingcos
</span><span class="c1">// dealloc
</span><span class="c1">// 未命中缓存
</span><span class="c1">// https://kingcos.me
</span><span class="c1">// dealloc
</span><span class="c1"></span>
<span class="c1">// NSPurgeableData（1024 B = 1 KB 缓存 &amp;&amp; countLimit 为 100 时）：
</span><span class="c1">// ---
</span><span class="c1">// 未命中缓存
</span><span class="c1">// https://kingcos.me/
</span><span class="c1">// dealloc
</span><span class="c1">// 未命中缓存
</span><span class="c1">// https://github.com/kingcos/
</span><span class="c1">// dealloc
</span><span class="c1">// 命中缓存
</span><span class="c1">// https://kingcos.me/
</span></code></pre></div><!-- https://github.com/AFNetworking/AFNetworking/issues/268 -->
<h3 id="精简-initialize-与-load-实现代码">精简 initialize 与 load 实现代码</h3>
<p>略；关于 +load，可详见《<a href="../block_in_obj-c">iOS 中的 +load 方法</a>》一文；关于 +initialize，可详见《<a href="../block_in_obj-c">iOS 中的 +initialize 方法</a>》一文。</p>
<h3 id="别忘了-nsimer-会保留其目标对象">别忘了 NSimer 会保留其目标对象</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@interface</span> <span class="nc">NSTimer</span> <span class="nl">(BlockCategory)</span>
<span class="p">+</span> <span class="p">(</span><span class="n">NSTimer</span> <span class="o">*</span><span class="p">)</span><span class="nf">bc_scheduledTimerWithTimeInterval:</span><span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nv">interval</span>
                                       <span class="nf">repeats:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">repeats</span>
                                         <span class="nf">block:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="nv">block</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">NSTimer</span> <span class="nl">(BlockCategory)</span>
<span class="p">+</span> <span class="p">(</span><span class="n">NSTimer</span> <span class="o">*</span><span class="p">)</span><span class="nf">bc_scheduledTimerWithTimeInterval:</span><span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nv">interval</span>
                                       <span class="nf">repeats:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">repeats</span>
                                         <span class="nf">block:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="nv">block</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">scheduledTimerWithTimeInterval</span><span class="p">:</span><span class="n">interval</span>
                                         <span class="nl">target</span><span class="p">:</span><span class="nb">self</span> <span class="c1">// target 为 self，而这里的 self 是类对象，但类对象本身即不需要释放
</span><span class="c1"></span>                                       <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">bc_timerBlockInvoked</span><span class="p">:)</span>
                                       <span class="nl">userInfo</span><span class="p">:[</span><span class="n">block</span> <span class="k">copy</span><span class="p">]</span> <span class="c1">// 将 Block 拷贝到堆，并保存在 userInfo 中
</span><span class="c1"></span>                                        <span class="nl">repeats</span><span class="p">:</span><span class="n">repeats</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">bc_timerBlockInvoked:</span><span class="p">(</span><span class="n">NSTimer</span> <span class="o">*</span><span class="p">)</span><span class="nv">timer</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="n">timer</span><span class="p">.</span><span class="n">userInfo</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">block</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">@end</span>

<span class="k">@interface</span> <span class="nc">Foo</span> : <span class="nc">NSObject</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">start:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">index</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">stop</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="c1">// 当前对象强引用 _timer
</span><span class="c1"></span>    <span class="n">NSTimer</span> <span class="o">*</span><span class="n">_timer0</span><span class="p">;</span>
    <span class="n">NSTimer</span> <span class="o">*</span><span class="n">_timer1</span><span class="p">;</span>
    <span class="n">NSTimer</span> <span class="o">*</span><span class="n">_timer2</span><span class="p">;</span>

    <span class="n">NSUInteger</span> <span class="n">_currentIndex</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">init</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">_timer0</span> <span class="n">invalidate</span><span class="p">];</span>
    <span class="p">[</span><span class="n">_timer1</span> <span class="n">invalidate</span><span class="p">];</span>
    <span class="p">[</span><span class="n">_timer2</span> <span class="n">invalidate</span><span class="p">];</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;Timer %lu dealloc&#34;</span><span class="p">,</span> <span class="n">_currentIndex</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">start:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">index</span> <span class="p">{</span>
    <span class="n">_currentIndex</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="p">{</span>
            <span class="c1">// _timer 的 target 为 self，因而强引用 self，产生了循环引用
</span><span class="c1"></span>            <span class="n">_timer0</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nl">scheduledTimerWithTimeInterval</span><span class="p">:</span><span class="mf">5.0</span>
                                                       <span class="nl">target</span><span class="p">:</span><span class="nb">self</span>
                                                     <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">timerInvoked</span><span class="p">)</span>
                                                     <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span>
                                                      <span class="nl">repeats</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
        <span class="p">}</span>

            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="p">{</span>
            <span class="k">__weak</span> <span class="k">typeof</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="n">weakSelf</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
            <span class="n">_timer1</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nl">bc_scheduledTimerWithTimeInterval</span><span class="p">:</span><span class="mf">5.0</span>
                                                         <span class="nl">repeats</span><span class="p">:</span><span class="nb">YES</span>
                                                           <span class="nl">block</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
                <span class="k">__strong</span> <span class="k">typeof</span><span class="p">(</span><span class="n">weakSelf</span><span class="p">)</span> <span class="n">strongSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>

                <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;--- kingcos.me ---&#34;</span><span class="p">);</span>
                <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">strongSelf</span><span class="p">);</span>
            <span class="p">}</span> <span class="p">];</span>
        <span class="p">}</span>

            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="p">{</span>
            <span class="k">__weak</span> <span class="k">typeof</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="n">weakSelf</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
            <span class="n">_timer2</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nl">scheduledTimerWithTimeInterval</span><span class="p">:</span><span class="mf">5.0</span>
                                                      <span class="nl">repeats</span><span class="p">:</span><span class="nb">YES</span>
                                                        <span class="nl">block</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSTimer</span> <span class="o">*</span> <span class="n">_Nonnull</span> <span class="n">timer</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">__strong</span> <span class="k">typeof</span><span class="p">(</span><span class="n">weakSelf</span><span class="p">)</span> <span class="n">strongSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>

                <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;--- kingcos.me ---&#34;</span><span class="p">);</span>
                <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">strongSelf</span><span class="p">);</span>
            <span class="p">}];</span>
        <span class="p">}</span>

            <span class="k">break</span><span class="p">;</span>

        <span class="k">default</span><span class="o">:</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">timerInvoked</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;--- kingcos.me ---&#34;</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">stop</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">_timer0</span> <span class="n">invalidate</span><span class="p">];</span> <span class="c1">// 此时 _timer1 才打破引用循环
</span><span class="c1"></span>    <span class="p">[</span><span class="n">_timer1</span> <span class="n">invalidate</span><span class="p">];</span>
    <span class="p">[</span><span class="n">_timer2</span> <span class="n">invalidate</span><span class="p">];</span>

    <span class="n">_timer0</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">_timer1</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">_timer2</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@end</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="p">[[[</span><span class="n">Foo</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">]</span> <span class="nl">start</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 若不调用 stop，_timer1 则发生循环引用
</span><span class="c1"></span>        <span class="p">[[[</span><span class="n">Foo</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">]</span> <span class="nl">start</span><span class="p">:</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// 通过自己加分类处理
</span><span class="c1"></span>        <span class="p">[[[</span><span class="n">Foo</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">]</span> <span class="nl">start</span><span class="p">:</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// iOS 10 之后可用
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// Timer 1 dealloc
</span><span class="c1">// Timer 2 dealloc
</span></code></pre></div><h2 id="reference">Reference</h2>
<ul>
<li><a href="../ivar_access_control_in_obj-c/">Obj-C 中实例变量和类的访问控制 - kingcos</a></li>
<li><a href="https://stackoverflow.com/questions/17668018/when-to-use-uikit-extern-vs-just-extern">When to use UIKIT_EXTERN vs just extern - StackOverflow</a></li>
<li><a href="../objc_msgsend">浅尝 objc_msgSend - kingcos</a></li>
<li><a href="../objects_in_obj-c/">Obj-C 中的对象 - kingcos</a></li>
<li><a href="../type_introspection_and_reflection/">Obj-C &amp; Swift 的类型内省与反射 - kingcos</a></li>
<li><a href="https://developer.apple.com/documentation/foundation/nszone?language=objc">NSZone - Apple Developer</a></li>
<li><a href="../bit_field_union_in_cpp/">C/C++ 中的位域与共用体 - kingcos</a></li>
<li><a href="../category_in_ios/">iOS 中的 Category - kingcos</a></li>
<li><a href="../block_in_obj-c/">Obj-C 中的 Block - kingcos</a></li>
<li><a href="https://opensource.apple.com/tarballs/objc4/">objc4-756.2.tar.gz - Apple</a></li>
<li><a href="https://useyourloaf.com/blog/objective-c-class-properties/">Objective-C Class Properties - K Harrison</a></li>
</ul>
</div>
                    <div class="post_footer">
                        
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    <a href="https://kingcos.me/tags/read/">Read</a>
                                    
                                    <a href="https://kingcos.me/tags/ios/">iOS</a>
                                    
                                    <a href="https://kingcos.me/tags/obj-c/">Obj-C</a>
                                    
                                </span>
                            </div>
                        </div>
                        
                    </div>
                </div>
                <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<table style="border: 0;">
  <tr>
  <td style="border: 0; width: 30%;">
    <img width='100%' src='/img/about/1.jpg'>
  </td>
  <td style="border: 0; width: 50%;">
    
    <ins class="adsbygoogle"
     style="display:block;width:100%;"
     data-ad-client="ca-pub-9925978992661955"
     data-ad-slot="3213735320"
     data-ad-format="rectangle"
     data-full-width-responsive="false"></ins>
  </td>
  </tr>
</table>

<hr>

<script>
    (adsbygoogle = window.adsbygoogle || []).push({});
</script>
                
                
                







    
    
    
    <div>
        <div id="github-comment">
        </div>

        <script type="text/javascript">
        function getUtterances(isDark) {
            var utterances = document.createElement('script');
            utterances.type = 'text/javascript';
            utterances.async = true;
            utterances.setAttribute('issue-term', "pathname")
            utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
            utterances.setAttribute('label', "comments")
            isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
            utterances.crossorigin = 'anonymous';
            utterances.src = 'https://utteranc.es/client.js';

            return utterances
        }
        document.getElementById('github-comment').appendChild(getUtterances(false))
        </script>
    </div>
    




                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://kingcos.me">Powered by kingcos with love.</a>
    </div>

    <div class="footer_slogan">
        <span>❤️</span>
    </div>
</footer>
    <script src="https://kingcos.me/js/jquery-3.5.1.min.js"></script>
<link href="https://kingcos.me/css/fancybox.min.css" rel="stylesheet">
<script src="https://kingcos.me/js/fancybox.min.js"></script>
<script src="https://kingcos.me/js/zozo.js"></script>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</body>

</html>