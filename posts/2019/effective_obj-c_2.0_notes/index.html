<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>《编写高质量 iOS 与 OS X 代码的 52 个有效方法》阅读笔记 :: iBlog</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Book ISBN Notes     《编写高质量 iOS 与 OS X 代码的 52 个有效方法》 9787111451297 《Effective Objective-C 2.0》   Date Num. Xcode   2019-05 1-3 10.2.1   2019-06 4 10.2.1   2019-07 5-12 10.2.1   2019-10 13-20 11.1 &amp;amp; 11.2   2019-11 20-52 11.1 &amp;amp; 11.2    Preface 《编写高质量 iOS 与 OS X 代码的 52 个有效方法》原著名为《Effective Objective-C 2.0》，是类似笔者这样的 iOS 初级入门者必读书目之一。本文不仅是此书的阅读笔记，也有 Demo 代码等，较为独立的篇章内容则融入笔者以往的独立文章中。"/>
<meta name="keywords" content="kingcos.me,maimieng.comios,swift,objective-c,obj-c,objc,oc,geek,python,ruby,golang,go,apple,mac"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/effective_obj-c_2.0_notes/" />





<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="《编写高质量 iOS 与 OS X 代码的 52 个有效方法》阅读笔记"/>
<meta name="twitter:description" content="《编写高质量 iOS 与 OS X 代码的 52 个有效方法》原著名为《Effective Objective-C 2.0》，是类似笔者这样的 iOS 初级入门者必读书目之一。本文不仅是此书的阅读笔记，也有 Demo 代码等，较为独立的篇章内容则融入笔者的独立文章中。"/>



<meta property="og:title" content="《编写高质量 iOS 与 OS X 代码的 52 个有效方法》阅读笔记" />
<meta property="og:description" content="《编写高质量 iOS 与 OS X 代码的 52 个有效方法》原著名为《Effective Objective-C 2.0》，是类似笔者这样的 iOS 初级入门者必读书目之一。本文不仅是此书的阅读笔记，也有 Demo 代码等，较为独立的篇章内容则融入笔者的独立文章中。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2019/effective_obj-c_2.0_notes/" />
<meta property="article:published_time" content="2019-11-24T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-11-24T00:00:00+00:00" /><meta property="og:site_name" content="iBlog" />




<script data-ad-client="ca-pub-9925978992661955" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">kingcos.me</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="post">
    <h2 class="post-title"><a href="/posts/2019/effective_obj-c_2.0_notes/">《编写高质量 iOS 与 OS X 代码的 52 个有效方法》阅读笔记</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            2019-11-24
        </span>
      
      
      
        <span class="post-read-time">— 30 min read</span>
      
    </div>

    
      <span class="post-tags">
        
          #<a href="/tags/read/">Read</a>&nbsp;
        
          #<a href="/tags/ios/">iOS</a>&nbsp;
        
          #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      <table>
<thead>
<tr>
<th align="center">Book</th>
<th align="center">ISBN</th>
<th align="center">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">《编写高质量 iOS 与 OS X 代码的 52 个有效方法》</td>
<td align="center">9787111451297</td>
<td align="center">《Effective Objective-C 2.0》</td>
</tr>
<tr>
<td align="center"><strong>Date</strong></td>
<td align="center"><strong>Num.</strong></td>
<td align="center"><strong>Xcode</strong></td>
</tr>
<tr>
<td align="center">2019-05</td>
<td align="center">1-3</td>
<td align="center">10.2.1</td>
</tr>
<tr>
<td align="center">2019-06</td>
<td align="center">4</td>
<td align="center">10.2.1</td>
</tr>
<tr>
<td align="center">2019-07</td>
<td align="center">5-12</td>
<td align="center">10.2.1</td>
</tr>
<tr>
<td align="center">2019-10</td>
<td align="center">13-20</td>
<td align="center">11.1 &amp; 11.2</td>
</tr>
<tr>
<td align="center">2019-11</td>
<td align="center">20-52</td>
<td align="center">11.1 &amp; 11.2</td>
</tr>
</tbody>
</table>
<h2 id="preface">Preface</h2>
<p>《编写高质量 iOS 与 OS X 代码的 52 个有效方法》原著名为《Effective Objective-C 2.0》，是类似笔者这样的 iOS 初级入门者必读书目之一。本文不仅是此书的阅读笔记，也有 Demo 代码等，较为独立的篇章内容则融入笔者以往的独立文章中。</p>
<h2 id="-objective-c">熟悉 Objective-C</h2>
<h3 id="-objective-c-">了解 Objective-C 语言的起源</h3>
<p>消息结构（Message Structure）的语言，运行时执行的代码由运行环境决定；函数调用（Function Calling）的语言，运行时所执行的代码由编译器决定，对于多态，则按照虚函数表（Virtual Method Table）寻找。</p>
<p>运行时组件（Runtime Component） 本质上是一种与开发者所编写代码相链接的「动态库（Dynamic Library），这样的好处是只需要更新运行时组件（无需重新编译）即可提升程序性能。</p>
<p>Obj-C 是 C 的超集；Obj-C 中的对象所占内存总是分配在堆空间（Heap Space）；而指向对象的指针所占内存总是分配在栈帧（Stack Frame）中；堆中的内存需要开发者自己管理，栈中的内存会在其栈帧弹出（Pop）时自动清理；创建对象相比创建结构体（C 结构体）需要额外开销，例如分配和释放堆内存等。</p>
<p><img src="/img/2019/effective_obj-c_2.0_notes/1.png" alt="1"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// ⚠️ 由于 Obj-C 中的字符串（NSString）略有特殊，此处并未使用书中的 NSString 作为范例
</span><span style="color:#75715e"></span><span style="color:#75715e">// 对象本身被分配在堆上；obj1 &amp; obj2 被分配在栈上
</span><span style="color:#75715e"></span>NSObject <span style="color:#f92672">*</span>obj1 <span style="color:#f92672">=</span> [[NSObject alloc] init];
NSObject <span style="color:#f92672">*</span>obj2 <span style="color:#f92672">=</span> obj1;

<span style="color:#75715e">// (lldb) p obj1
</span><span style="color:#75715e"></span><span style="color:#75715e">// (NSObject *) $0 = 0x00000001005092b0
</span><span style="color:#75715e"></span><span style="color:#75715e">// (lldb) p obj2
</span><span style="color:#75715e"></span><span style="color:#75715e">// (NSObject *) $1 = 0x00000001005092b0
</span><span style="color:#75715e"></span><span style="color:#75715e">// (lldb) p &amp;obj1
</span><span style="color:#75715e"></span><span style="color:#75715e">// (NSObject **) $2 = 0x00007ffeefbff508
</span><span style="color:#75715e"></span><span style="color:#75715e">// (lldb) p &amp;obj2
</span><span style="color:#75715e"></span><span style="color:#75715e">// (NSObject **) $3 = 0x00007ffeefbff500
</span></code></pre></div><h3 id="heading">在类的头文件中尽量少引入其他头文件</h3>
<p>当需要知道有一个类的存在时，而不关心其内部细节时，可以使用向前声明（Forward Declaring）告知编译器，即可以在 .h（头文件）中 <code>@class SomeClass</code>；而在 .m（实现文件）中引入实际的 .h；当在两个头文件中互相引入对方，则会导致「循环 引用（Chicken-Egg Situation，又称交叉引用）」，无法通过编译：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// A.h
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#</span><span style="color:#75715e">import &lt;Foundation</span><span style="color:#75715e">/</span><span style="color:#75715e">Foundation.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">import &#34;B.h&#34; </span><span style="color:#75715e">// -&gt; @class B;
</span><span style="color:#75715e"></span>
NS_ASSUME_NONNULL_BEGIN

<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">A</span> : <span style="color:#a6e22e">NSObject</span>

<span style="color:#66d9ef">@end</span>

NS_ASSUME_NONNULL_END

<span style="color:#75715e">// B.h
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#</span><span style="color:#75715e">import &lt;Foundation</span><span style="color:#75715e">/</span><span style="color:#75715e">Foundation.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">import &#34;A.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
NS_ASSUME_NONNULL_BEGIN

<span style="color:#75715e">// ERORR: Cannot find interface declaration for &#39;A&#39;, superclass of &#39;B&#39;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">B</span> : <span style="color:#a6e22e">A</span>

<span style="color:#66d9ef">@end</span>

NS_ASSUME_NONNULL_END
</code></pre></div><p>将引入头文件的时机尽量延后，只有在确定有需要时才引入，否则会增加耦合度、拉长编译时间、产生相互依赖等问题。</p>
<p>继承父类和遵循协议则不能使用向前声明，必须引入相应的头文件，因此协议最好声明在单独的头文件中；由于代理协议（Delegate Protocol）和遵守协议代理的类声明在一起时才有意义，最好在实现文件中声明类遵守了该代理协议，并将实现代码放在类扩展中；因此只需要在实现文件中引入包含代理协议的头文件即可，而不需要将其放在公共头文件（Public Header File）中。</p>
<h3 id="heading-1">多用字面量语法，少用与之等价的方法</h3>
<p>字面量（Literal）语法简化了 Obj-C 的部分 API：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">NSString <span style="color:#f92672">*</span>strValue <span style="color:#f92672">=</span> <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">str</span><span style="color:#e6db74">&#34;</span>;
NSNumber <span style="color:#f92672">*</span>intValue <span style="color:#f92672">=</span> <span style="color:#ae81ff">@1</span>;
NSNumber <span style="color:#f92672">*</span>doubleValue <span style="color:#f92672">=</span> <span style="color:#ae81ff">@3.14</span>;
NSArray <span style="color:#f92672">*</span>arrValue <span style="color:#f92672">=</span> <span style="color:#ae81ff">@[</span><span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">a</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">c</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">]</span>;
NSString <span style="color:#f92672">*</span>firstValueForArr <span style="color:#f92672">=</span> arrValue[<span style="color:#ae81ff">0</span>];
<span style="color:#75715e">// ⚠️ 字面量创建的数组、字典都是不可变的
</span><span style="color:#75715e"></span>NSMutableArray <span style="color:#f92672">*</span>mutableArrValue <span style="color:#f92672">=</span> [<span style="color:#ae81ff">@[</span><span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">a</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">c</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">]</span> mutableCopy];
mutableArrValue[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">kingcos.me</span><span style="color:#e6db74">&#34;</span>;
NSDictionary <span style="color:#f92672">*</span>dictValue <span style="color:#f92672">=</span> <span style="color:#ae81ff">@{</span><span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">key</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">@100</span><span style="color:#ae81ff">}</span>;
NSNumber <span style="color:#f92672">*</span>valueForDictByKey  <span style="color:#f92672">=</span> dictValue[<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">key</span><span style="color:#e6db74">&#34;</span>];
NSMutableDictionary <span style="color:#f92672">*</span>mutableDictValue <span style="color:#f92672">=</span> [<span style="color:#ae81ff">@{</span><span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">key</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">@100</span><span style="color:#ae81ff">}</span> mutableCopy];
mutableDictValue[<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">key</span><span style="color:#e6db74">&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">@200</span>;
</code></pre></div><p>字面量语法在 <code>NSArray</code>、<code>NSDictionary</code> 等类中插入 <code>nil</code> 对象时会直接崩溃，而直接使用 API 则会发生「截断」，对于这两个用法差异务必要注意：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">id</span> nilObj <span style="color:#f92672">=</span> nil;
<span style="color:#75715e">// *** -[__NSPlaceholderArray initWithObjects:count:]: attempt to insert nil object from objects[3]
</span><span style="color:#75715e"></span>NSArray <span style="color:#f92672">*</span>arrWithNilObject1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">@[</span><span style="color:#ae81ff">@0</span>, nilObj, <span style="color:#ae81ff">@2</span><span style="color:#ae81ff">]</span>;
<span style="color:#75715e">// (0)
</span><span style="color:#75715e"></span>NSArray <span style="color:#f92672">*</span>arrWithNilObject2 <span style="color:#f92672">=</span> [NSArray arrayWithObjects:<span style="color:#ae81ff">@0</span>, nil, <span style="color:#ae81ff">@2</span>, nil];
<span style="color:#75715e">// *** -[__NSPlaceholderDictionary initWithObjects:forKeys:count:]: attempt to insert nil object from objects[0]
</span><span style="color:#75715e"></span>NSDictionary <span style="color:#f92672">*</span>dictWithNilObject1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">@{</span><span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">a</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">A</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">:</span> nilObj, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">c</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">C</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">}</span>;
<span style="color:#75715e">// { a = A; }
</span><span style="color:#75715e"></span>NSDictionary <span style="color:#f92672">*</span>dictWithNilObject2 <span style="color:#f92672">=</span> [NSDictionary dictionaryWithObjectsAndKeys:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">A</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">a</span><span style="color:#e6db74">&#34;</span>, nilObj, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">C</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">c</span><span style="color:#e6db74">&#34;</span>, nil];
</code></pre></div><p>除了字符串，字面量语法仅适用于 Foundation 框架中，即我们自定义继承自上述支持字面量的类时，将不再支持使用字面量。</p>
<h3 id="-define-">多用类型常量，少用 #define 预处理指令</h3>
<p><code>#define</code> 预处理指令没有类型信息，且会在引用到包含该指令的所有文件中进行替换，因此更加推荐使用类型常量：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// 预处理指令（编译前进行直接替换）
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define ANIMATION_DURATION 0.3</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Some.m
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 类型常量
</span><span style="color:#75715e"></span><span style="color:#75715e">// const 决定了其为常量，不可被再次改变
</span><span style="color:#75715e"></span><span style="color:#75715e">// static 决定了其作用域，即当前文件（因此如果将其定义在 *.h 中，其它引入该头文件的文件也可以访问到）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> NSTimeInterval kAnimationDuration <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.3</span>;

<span style="color:#75715e">// 如果不使用 static 修饰，编译器会创建一个外部符号（External Symbols）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> NSTimeInterval SomeAnimationDuration <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.3</span>;
<span style="color:#75715e">// 此时如果在其它文件内声明同名常量，则会报错「duplicate symbol」
</span><span style="color:#75715e"></span><span style="color:#75715e">// Another.m
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> NSTimeInterval SomeAnimationDuration <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.5</span>;

<span style="color:#75715e">// ---
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// main.m
</span><span style="color:#75715e"></span><span style="color:#75715e">// 声明为 `static` 和 `const` 的变量，编译器不会为其再创建符号
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">import &lt;Foundation</span><span style="color:#75715e">/</span><span style="color:#75715e">Foundation.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> foo <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

<span style="color:#75715e">// static const + int
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> k1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#75715e">// static const + int *
</span><span style="color:#75715e"></span><span style="color:#75715e">// 对于指针，既要使其本身的内容不能改变，也不能改变其指向的内存地址，否则这个指针还是有可能改变的
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> k2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>foo;
<span style="color:#75715e">// static const + NSString *
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> NSString <span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> k3 <span style="color:#f92672">=</span> <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">&#34;</span>;
<span style="color:#66d9ef">static</span> NSString <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> k4 <span style="color:#f92672">=</span> <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">&#34;</span>;

<span style="color:#75715e">// const
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> k5 <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
<span style="color:#75715e">// static
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> k6 <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">@autoreleasepool</span> {
        <span style="color:#75715e">// 为了防止编译器优化未用到的符号，我们这里简单输出以上定义的变量
</span><span style="color:#75715e"></span>        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, k1);
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">*</span>k2);
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, k3);
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, k4);
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, k5);
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, k6);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// 输出所有符号
</span><span style="color:#75715e"></span><span style="color:#75715e">// ➜  Debug nm -C Demo
</span><span style="color:#75715e"></span><span style="color:#75715e">// 通过以下输出可以得出由 static 和 const 修饰的 k1，k2 编译器都没有为其产生符号
</span><span style="color:#75715e"></span><span style="color:#75715e">// 但 NSString * 是个例外（Why? 猜测是编译器认为该常量后续还要被修改的可能，因此需要保留其符号）
</span><span style="color:#75715e"></span><span style="color:#75715e">//                  U _NSLog
</span><span style="color:#75715e"></span><span style="color:#75715e">//                  U ___CFConstantStringClassReference
</span><span style="color:#75715e"></span><span style="color:#75715e">// 0000000100000000 T __mh_execute_header
</span><span style="color:#75715e"></span><span style="color:#75715e">// 00000001000010a0 D _foo
</span><span style="color:#75715e"></span><span style="color:#75715e">// 0000000100001028 s _k3
</span><span style="color:#75715e"></span><span style="color:#75715e">// 0000000100001030 s _k4
</span><span style="color:#75715e"></span><span style="color:#75715e">// 0000000100000fb4 S _k5
</span><span style="color:#75715e"></span><span style="color:#75715e">// 00000001000010a4 d _k6
</span><span style="color:#75715e"></span><span style="color:#75715e">// 0000000100000eb0 T _main
</span><span style="color:#75715e"></span><span style="color:#75715e">//                  U _objc_autoreleasePoolPop
</span><span style="color:#75715e"></span><span style="color:#75715e">//                  U _objc_autoreleasePoolPush
</span><span style="color:#75715e"></span><span style="color:#75715e">//                  U dyld_stub_binder
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 仅输出外部符号
</span><span style="color:#75715e"></span><span style="color:#75715e">// ➜  Debug nm -gC Demo
</span><span style="color:#75715e"></span><span style="color:#75715e">// 所有使用 static 修饰的变量均不在外部符号中，说明 static 将这些符号的作用域限制在当前文件中
</span><span style="color:#75715e"></span><span style="color:#75715e">//                  U _NSLog
</span><span style="color:#75715e"></span><span style="color:#75715e">//                  U ___CFConstantStringClassReference
</span><span style="color:#75715e"></span><span style="color:#75715e">// 0000000100000000 T __mh_execute_header
</span><span style="color:#75715e"></span><span style="color:#75715e">// 00000001000010a0 D _foo
</span><span style="color:#75715e"></span><span style="color:#75715e">// 0000000100000fb4 S _k5
</span><span style="color:#75715e"></span><span style="color:#75715e">// 0000000100000eb0 T _main
</span><span style="color:#75715e"></span><span style="color:#75715e">//                  U _objc_autoreleasePoolPop
</span><span style="color:#75715e"></span><span style="color:#75715e">//                  U _objc_autoreleasePoolPush
</span><span style="color:#75715e"></span><span style="color:#75715e">//                  U dyld_stub_binder
</span></code></pre></div><p>类型常量的命名规则：</p>
<ul>
<li>若常量局限于某个编译单元（Translation Unit，即实现文件 <code>*.m</code>），则需要以小写字母 <code>k</code> 开头；</li>
<li>若常量在类之外也可见，则通常需要以类名开头。</li>
</ul>
<p>关于 <code>nm</code> 命令的基本使用，可以参考 <a href="../ivar_access_control_in_obj-c/">Obj-C 中实例变量和类的访问控制</a>一文。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// Some.h
</span><span style="color:#75715e"></span><span style="color:#75715e">// extern 告知编译器全局符号表中存在该符号，允许外界使用
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> NSString <span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> SomeConstant;

<span style="color:#75715e">// Some.m
</span><span style="color:#75715e"></span><span style="color:#75715e">// 外界需要访问则不能声明为 static；外界不可变更，因此声明为 const
</span><span style="color:#75715e"></span><span style="color:#75715e">// 这里的 const 修饰的是 NSString *（即 const 从右向左原则），SomeConstant 保存的内存地址不能再改变（即不能指向另外一个 NSString 对象）
</span><span style="color:#75715e"></span><span style="color:#75715e">// 编译器会在数据段（Data Section）为字符串分配存储空间，链接器会将目标文件相互链接，生成最终的可执行文件
</span><span style="color:#75715e"></span><span style="color:#75715e">// 全局符号命名规则：范围（通常使用类名）+ 名称
</span><span style="color:#75715e"></span>NSString <span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> SomeConstant <span style="color:#f92672">=</span> <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">SomeConstant</span><span style="color:#e6db74">&#34;</span>;

<span style="color:#75715e">// 在 Obj-C 中，除了 C 中原有的 extern 还存在以下相关的宏定义
</span><span style="color:#75715e"></span><span style="color:#75715e">// FOUNDATION_EXTERN、FOUNDATION_EXPORT、FOUNDATION_IMPORT、UIKIT_EXTERN
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// NSObjCRuntime.h
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">if defined(__cplusplus)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">// C++ 下兼容 C++ 的 extern
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define FOUNDATION_EXTERN extern &#34;C&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">else</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define FOUNDATION_EXTERN extern</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>

    <span style="color:#75715e">#</span><span style="color:#75715e">define FOUNDATION_EXPORT  FOUNDATION_EXTERN</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#</span><span style="color:#75715e">define FOUNDATION_IMPORT FOUNDATION_EXTERN</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// UIKitDefines.h
</span><span style="color:#75715e"></span><span style="color:#75715e">// UIKIT_EXTERN 还声明了符号的可见范围
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">ifdef __cplusplus</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define UIKIT_EXTERN		extern &#34;C&#34; __attribute__((visibility (&#34;default&#34;)))</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">else</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define UIKIT_EXTERN	        extern __attribute__((visibility (&#34;default&#34;)))</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span></code></pre></div><p>对于选择 <code>extern</code> 还是以上 <code>SOME_EXTERN</code>，得出以下的结论：</p>
<ul>
<li>对于这些固定前缀的 <code>extern</code> 应当在其范围下使用，即 <code>FOUNDATION_*</code> 在 Foundation 框架内部使用，<code>UIKIT_*</code> 在 <code>UIKit</code> 内部使用，在我们自己的库内应当推荐自定义 <code>SOME_*</code> 来使用，而不是直接套用其它库内的宏定义；</li>
<li>默认的 <code>extern</code> 由于可能不兼容 C++，那么在库中需要兼容 C++ 时应当使用 <code>extern &quot;C&quot;</code>。</li>
</ul>
<h3 id="heading-2">用枚举表示状态、选项、状态码</h3>
<p>Obj-C 中的枚举（<code>enum</code>）来自 C 语言，而 C++11 标准使得枚举可以定义其底层数据类型（Underlying Type）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// 实现枚举所用的数据类型取决于编译器
</span><span style="color:#75715e"></span><span style="color:#75715e">// 枚举的底层数据类型不是固定的，其二进制位（bit）的个数必须能完全表示下枚举编号
</span><span style="color:#75715e"></span><span style="color:#75715e">// 比如 ImageSourceType 可以使用 char 类型（但在 Xcode 里其底层数据类型是第一项默认为 0 的 int 类型）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> ImageSourceType {
    ImageSourceTypeCamera,
    ImageSourceTypeGallery
};

<span style="color:#66d9ef">enum</span> ImageSourceType type1 <span style="color:#f92672">=</span> ImageSourceTypeCamera;

<span style="color:#75715e">// typedef 可以简化枚举类型声明
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">enum</span> ImageSourceType ImageSourceType;
ImageSourceType type2 <span style="color:#f92672">=</span> ImageSourceTypeGallery;

<span style="color:#75715e">// C++ 11 标准，显式声明枚举底层数据类型
</span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> NetworkType: NSInteger {
    NetworkTypeUnknown <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#75715e">// 显式为从 -1 开始
</span><span style="color:#75715e"></span>    NetworkTypeWiFi   <span style="color:#75715e">// 0 递增
</span><span style="color:#75715e"></span>    NetworkCellular   <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>};

<span style="color:#75715e">// 枚举的向前声明（在 .m 中引入或实现即可）
</span><span style="color:#75715e"></span><span style="color:#75715e">// Some.h
</span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> NetworkType: NSInteger;
</code></pre></div><p>枚举中使用按位或操作符（Bitwise OR Operator）可以使得枚举的每个选项均可启用或禁用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// UIViewAutoresizingNone 是无法与其它项目同时存在，因此为 0
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// UIView.h
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">NS_OPTIONS</span>(NSUInteger, UIViewAutoresizing) {
    UIViewAutoresizingNone                 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
    UIViewAutoresizingFlexibleLeftMargin   <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>,
    UIViewAutoresizingFlexibleWidth        <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>,
    UIViewAutoresizingFlexibleRightMargin  <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>,
    UIViewAutoresizingFlexibleTopMargin    <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>,
    UIViewAutoresizingFlexibleHeight       <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>,
    UIViewAutoresizingFlexibleBottomMargin <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>
};

<span style="color:#75715e">// 使用时可以使用按位或来组合多个选项：
</span><span style="color:#75715e"></span>UIViewAutoresizing resize <span style="color:#f92672">=</span> UIViewAutoresizingFlexibleWidth <span style="color:#f92672">|</span> UIViewAutoresizingFlexibleHeight;

<span style="color:#75715e">// 判断时使用按位与（Bitwise AND Operator）即可
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (resize <span style="color:#f92672">&amp;</span> UIViewAutoresizingFlexibleWidth) {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">UIViewAutoresizingFlexibleWidth</span><span style="color:#e6db74">&#34;</span>);
}
<span style="color:#66d9ef">if</span> (resize <span style="color:#f92672">&amp;</span> UIViewAutoresizingFlexibleHeight) {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">UIViewAutoresizingFlexibleHeight</span><span style="color:#e6db74">&#34;</span>);
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// UIViewAutoresizingFlexibleWidth
</span><span style="color:#75715e"></span><span style="color:#75715e">// UIViewAutoresizingFlexibleHeight
</span></code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">/* NS_ENUM supports the use of one or two arguments. The first argument is always the integer type used for the values of the enum. The second argument is an optional type name for the macro. When specifying a type name, you must precede the macro with &#39;typedef&#39; like so:
</span><span style="color:#75715e">
</span><span style="color:#75715e">typedef NS_ENUM(NSInteger, NSComparisonResult) {
</span><span style="color:#75715e">    ...
</span><span style="color:#75715e">};
</span><span style="color:#75715e">
</span><span style="color:#75715e">If you do not specify a type name, do not use &#39;typedef&#39;. For example:
</span><span style="color:#75715e">
</span><span style="color:#75715e">NS_ENUM(NSInteger) {
</span><span style="color:#75715e">    ...
</span><span style="color:#75715e">};
</span><span style="color:#75715e">*/</span>
<span style="color:#75715e">#</span><span style="color:#75715e">define NS_ENUM(...) CF_ENUM(__VA_ARGS__)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define NS_OPTIONS(_type, _name) CF_OPTIONS(_type, _name)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// CFAvailability.h
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define CF_ENUM(...) __CF_ENUM_GET_MACRO(__VA_ARGS__, __CF_NAMED_ENUM, __CF_ANON_ENUM, )(__VA_ARGS__)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">// 根据是否按照 C++ 模式编译而不同
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define __CF_ENUM_GET_MACRO(_1, _2, NAME, ...) NAME</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">if (__cplusplus &amp;&amp; __cplusplus &gt;= 201103L &amp;&amp; (__has_extension(cxx_strong_enums) || __has_feature(objc_fixed_enum))) || (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum))</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#</span><span style="color:#75715e">define __CF_NAMED_ENUM(_type, _name)     enum __CF_ENUM_ATTRIBUTES _name : _type _name; enum _name : _type</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#</span><span style="color:#75715e">define __CF_ANON_ENUM(_type)             enum __CF_ENUM_ATTRIBUTES : _type</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#</span><span style="color:#75715e">define CF_CLOSED_ENUM(_type, _name)      enum __CF_CLOSED_ENUM_ATTRIBUTES _name : _type _name; enum _name : _type</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#</span><span style="color:#75715e">if (__cplusplus)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>        <span style="color:#75715e">#</span><span style="color:#75715e">define CF_OPTIONS(_type, _name) _type _name; enum __CF_OPTIONS_ATTRIBUTES : _type</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#</span><span style="color:#75715e">else</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>        <span style="color:#75715e">#</span><span style="color:#75715e">define CF_OPTIONS(_type, _name) enum __CF_OPTIONS_ATTRIBUTES _name : _type _name; enum _name : _type</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">else</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#</span><span style="color:#75715e">define __CF_NAMED_ENUM(_type, _name) _type _name; enum</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#</span><span style="color:#75715e">define __CF_ANON_ENUM(_type) enum</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#</span><span style="color:#75715e">define CF_CLOSED_ENUM(_type, _name) _type _name; enum</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#</span><span style="color:#75715e">define CF_OPTIONS(_type, _name) _type _name; enum</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Some.mm
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">enum</span> Direction: <span style="color:#66d9ef">int</span> FooDirection;
<span style="color:#66d9ef">enum</span> Direction: <span style="color:#66d9ef">int</span> {
    Up      <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>,
    Down    <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>,
    Left    <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>,
    Right   <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>
};

<span style="color:#75715e">// 在使用或运算操作两个枚举值时，C++ 认为运算结果的数据类型应当是枚举的底层数据类型，即 `NSUInteger`，且 C++ 不支持将底层数据类型隐式转换为枚举类型本身
</span><span style="color:#75715e"></span><span style="color:#75715e">// ERROR: Cannot initialize a variable of type &#39;FooDirection&#39; (aka &#39;Direction&#39;) with an rvalue of type &#39;int&#39;
</span><span style="color:#75715e"></span><span style="color:#75715e">// FooDirection direct = Up | Left;
</span></code></pre></div><p>Foundation 框架中枚举的辅助宏具备向后兼容（Backward Compatibility）能力，即根据目标平台决定相应的语法；凡是需要按位或操作来组合的枚举都应当使用 <code>NS_OPTIONS</code> 来定义；否则使用 <code>NS_ENUM</code>。</p>
<h2 id="heading-3">对象、消息、运行期</h2>
<h3 id="heading-4">理解「属性」这一概念</h3>
<p>应用程序二进制接口（Application Binary Interface，即 ABI）定义了很多内容，其中有生成代码时所应遵循的规范。Obj-C 中实例变量（ivar）的内存布局在编译时刻固定，因此访问实例变量时，编译器会将其替换为偏移量（Offset），而偏移量是硬编码，表示其距离内存起始地址的长度；如果代码使用了编译时刻计算的偏移量，那么在修改类定义之后必须重新编译，即重新计算偏移量；</p>
<p>对于旧的类定义链接了新的类定义会出现不兼容情况，Obj-C 的做法如下：</p>
<ul>
<li>将实例变量当作一种存储偏移量所用的特殊变量，交由类对象保管，偏移量将在运行时查找，这样即使类定义变化了，也能找到正确的偏移量，甚至可以在运行时新增实例变量；</li>
<li>尽量不要直接访问实例变量，而是通过 getter &amp; setter，Obj-C 中可以使用 <code>@property</code> 语法；</li>
</ul>
<p>自动合成（Autosynthesis）：编译器会自动为 Obj-C 中的属性便携其所需的方法，该过程由编译器在编译时刻执行；编译器还会自动为 Obj-C 中的属性添加适当类型的实例变量，并在属性名前加 <code>_</code> 前缀作为实例变量名。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// Some.h
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@property</span> NSString <span style="color:#f92672">*</span>foo;
<span style="color:#66d9ef">@property</span> NSString <span style="color:#f92672">*</span>bar;

<span style="color:#75715e">// Some.m
</span><span style="color:#75715e"></span><span style="color:#75715e">// @dynamic 将不会自动合成，也不会创建实例变量
</span><span style="color:#75715e"></span><span style="color:#75715e">// 但使用 getter &amp; setter 可以编译，因为其相信会在运行时找到这些方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@dynamic</span> bar;

<span style="color:#75715e">// @synthesize 指定了属性的实例变量名
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@synthesize</span> foo <span style="color:#f92672">=</span> _foooo;

self<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>_foooo <span style="color:#f92672">=</span> <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">Foo</span><span style="color:#e6db74">&#34;</span>;
NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, [self foo]);
</code></pre></div><p>1⃣️ 原子性</p>
<ul>
<li>原子（Atom）是参与化学反应中最小的粒子，因此可以理解为一个原子性（Atomicity）的操作是不会被中断的，即保证线程安全；</li>
<li>声明属性时，如果不明确指定原子性则为 <code>atomic</code>；</li>
<li>开发者自己实现的 getter &amp; setter 需要自己来保证相应的原子性。</li>
</ul>
<p>那我们应当使用哪个修饰符呢？从源码来看，使用 <code>atomic</code> 或 <code>nonatomic</code> 修饰的属性会影响生成的 getter &amp; setter：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// objc4 - objc-accessors.mm
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 属性锁 Map（专用于 atomic &amp; nonatomic）
</span><span style="color:#75715e"></span>StripedMap<span style="color:#f92672">&lt;</span>spinlock_t<span style="color:#f92672">&gt;</span> PropertyLocks;

<span style="color:#75715e">// getter
</span><span style="color:#75715e"></span><span style="color:#66d9ef">id</span> <span style="color:#a6e22e">objc_getProperty</span>(<span style="color:#66d9ef">id</span> self, <span style="color:#66d9ef">SEL</span> _cmd, ptrdiff_t offset, <span style="color:#66d9ef">BOOL</span> <span style="color:#66d9ef">atomic</span>) {
    <span style="color:#75715e">// 偏移量为 0，即 isa
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (offset <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#75715e">// 直接返回类
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> object_getClass(self);
    }

    <span style="color:#75715e">// 根据 self 偏移，slot 指向成员变量的值
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Retain release world
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">id</span> <span style="color:#f92672">*</span>slot <span style="color:#f92672">=</span> (<span style="color:#66d9ef">id</span><span style="color:#f92672">*</span>) ((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)self <span style="color:#f92672">+</span> offset);
    <span style="color:#75715e">// nonatomic 下，直接返回
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#66d9ef">atomic</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>slot;

    <span style="color:#75715e">// atomic 下，则先加自旋锁，持有值，最后解锁（锁与 setter 是同一个）
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Atomic retain release world
</span><span style="color:#75715e"></span>    spinlock_t<span style="color:#f92672">&amp;</span> slotlock <span style="color:#f92672">=</span> PropertyLocks[slot];
    slotlock.lock();
    <span style="color:#66d9ef">id</span> value <span style="color:#f92672">=</span> objc_retain(<span style="color:#f92672">*</span>slot);
    slotlock.unlock();

    <span style="color:#75715e">// for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> objc_autoreleaseReturnValue(value);
}


<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reallySetProperty</span>(<span style="color:#66d9ef">id</span> self, <span style="color:#66d9ef">SEL</span> _cmd, <span style="color:#66d9ef">id</span> newValue, ptrdiff_t offset, <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">atomic</span>, <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">copy</span>, <span style="color:#66d9ef">bool</span> mutableCopy) __attribute__((always_inline));

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reallySetProperty</span>(<span style="color:#66d9ef">id</span> self, <span style="color:#66d9ef">SEL</span> _cmd, <span style="color:#66d9ef">id</span> newValue, ptrdiff_t offset, <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">atomic</span>, <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">copy</span>, <span style="color:#66d9ef">bool</span> mutableCopy)
{
    <span style="color:#75715e">// 偏移量为 0，即 isa
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (offset <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#75715e">// 设置对象的类，即 isa
</span><span style="color:#75715e"></span>        object_setClass(self, newValue);
        <span style="color:#66d9ef">return</span>;
    }

    <span style="color:#75715e">// 旧值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">id</span> oldValue;
    <span style="color:#75715e">// 根据 self 偏移，slot 指向成员变量的旧值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">id</span> <span style="color:#f92672">*</span>slot <span style="color:#f92672">=</span> (<span style="color:#66d9ef">id</span><span style="color:#f92672">*</span>) ((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)self <span style="color:#f92672">+</span> offset);

    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">copy</span>) {
        <span style="color:#75715e">// copy 属性
</span><span style="color:#75715e"></span>        newValue <span style="color:#f92672">=</span> [newValue copyWithZone:nil];
    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (mutableCopy) {
        <span style="color:#75715e">// 可变 copy
</span><span style="color:#75715e"></span>        newValue <span style="color:#f92672">=</span> [newValue mutableCopyWithZone:nil];
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// 旧值等于新值，不执行操作
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>slot <span style="color:#f92672">=</span><span style="color:#f92672">=</span> newValue) <span style="color:#66d9ef">return</span>;
        newValue <span style="color:#f92672">=</span> objc_retain(newValue);
    }

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#66d9ef">atomic</span>) {
        <span style="color:#75715e">// nonatomic 下，仅做简单赋值操作
</span><span style="color:#75715e"></span>        oldValue <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>slot;
        <span style="color:#f92672">*</span>slot <span style="color:#f92672">=</span> newValue;
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// atomic 下，则先加自旋锁（内部使用 os_unfair_lock 实现），再赋值，最后解锁（锁与 getter 是同一个）
</span><span style="color:#75715e"></span>        <span style="color:#f92672">&amp;</span> slotlock <span style="color:#f92672">=</span> PropertyLocks[slot];
        slotlock.lock();spinlock_t
        oldValue <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>slot;
        <span style="color:#f92672">*</span>slot <span style="color:#f92672">=</span> newValue;
        slotlock.unlock();
    }

    objc_release(oldValue);
}

<span style="color:#75715e">// setter
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">objc_setProperty</span>(<span style="color:#66d9ef">id</span> self, <span style="color:#66d9ef">SEL</span> _cmd, ptrdiff_t offset, <span style="color:#66d9ef">id</span> newValue, <span style="color:#66d9ef">BOOL</span> <span style="color:#66d9ef">atomic</span>, <span style="color:#66d9ef">signed</span> <span style="color:#66d9ef">char</span> shouldCopy)
{
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">copy</span> <span style="color:#f92672">=</span> (shouldCopy <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> shouldCopy <span style="color:#f92672">!</span><span style="color:#f92672">=</span> MUTABLE_COPY);
    <span style="color:#66d9ef">bool</span> mutableCopy <span style="color:#f92672">=</span> (shouldCopy <span style="color:#f92672">=</span><span style="color:#f92672">=</span> MUTABLE_COPY);
    <span style="color:#75715e">// 实际调用 reallySetProperty ⬆️
</span><span style="color:#75715e"></span>    reallySetProperty(self, _cmd, newValue, offset, <span style="color:#66d9ef">atomic</span>, <span style="color:#66d9ef">copy</span>, mutableCopy);
}
</code></pre></div><p>由上我们可以得出，<code>atomic</code> 在 getter 和 setter 内部是通过自旋锁来避免资源竞争而导致的线程不安全。但在实际使用中，我们可能并非都是通过 setter 来改变属性的值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#75715e">// 声明为 atomic
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">atomic</span>, <span style="color:#66d9ef">strong</span>) NSMutableArray <span style="color:#f92672">*</span>arr;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo</span>
<span style="color:#66d9ef">@end</span>

Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [[Foo alloc] init];

<span style="color:#75715e">// 1. 通过 setter 设置，满足线程安全
</span><span style="color:#75715e"></span>foo.arr <span style="color:#f92672">=</span> [<span style="color:#ae81ff">@[</span><span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">kingcos.me</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">github.com/kingcos</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">]</span> mutableCopy];

<span style="color:#75715e">// 2. 通过 setter 设置，满足线程安全
</span><span style="color:#75715e"></span>[foo setArr:[<span style="color:#ae81ff">@[</span><span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">kingcos.me</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">github.com/kingcos</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">]</span> mutableCopy]];

<span style="color:#75715e">// 3. 虽然是通过 getter 访问的 arr，但设置并未通过其 setter，线程不安全
</span><span style="color:#75715e"></span>[foo.arr addObject:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">instagram.com/kingcos_v</span><span style="color:#e6db74">&#34;</span>];
[foo.arr addObject:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">twitter.com/kingcos_v</span><span style="color:#e6db74">&#34;</span>];
</code></pre></div><p>如 3 中的设置并未通过其 setter，因此 <code>atomic</code> 并不能使得属性完全满足线程安全，而 getter &amp; setter 又十分常用，加锁解锁的开销较大，所以我们通常都声明为 <code>nonatomic</code>，并在必要时在外界对属性的访问或设置加锁。</p>
<p>2⃣️ 读写权限</p>
<ul>
<li>声明属性时，<code>readwrite</code> 为同时生成 getter &amp; setter，<code>readonly</code> 为仅生成 <code>getter</code>；</li>
<li>外部 <code>.h</code> 中声明为 <code>readonly</code>，但内部类扩展中再次声明为 <code>readwrite</code> 时，<code>setter</code> 可以自动生成但不会暴露给外界。</li>
</ul>
<p>3⃣️ 内存管理语义</p>
<ul>
<li><code>assign</code>：setter 只会针对纯量类型（Scalar Type）例如 <code>CGFloat</code>、<code>NSInteger</code> 等执行简单地赋值操作；</li>
<li><code>strong</code>：定义一种拥有关系，为这种属性设置新值时，setter 会先保留新值，并释放旧值，然后再将新值设置上去；</li>
<li><code>weak</code>：定义一种<strong>非</strong>拥有关系，为这种属性设置新值时，setter 既不保留新值，也不释放旧值，类似 <code>assign</code>，但当属性所指向的对象销毁时，属性值会置为 <code>nil</code>；</li>
<li><code>unsafe_unretained</code>：内存语义与 <code>assign</code> 相同，但适用于对象类型，定义一种非拥有（不保留）关系，但当属性所指向的对象销毁时，属性值<strong>不会</strong>自动置为 <code>nil</code>（Autoniling），这也是与 <code>weak</code> 的差异；</li>
<li><code>copy</code>：类似 <code>strong</code>，但 setter 不保留新值，而是将其拷贝；当属性类型为 <code>NSString *</code> 时，可以使用 <code>copy</code> 保护其封装性，因为 setter 接收的新值有可能是指向 <code>NSMutableString</code> 的实例，若不拷贝则可能会被外界随时更改，因此需要拷贝为不可变的类型；</li>
</ul>
<p>4⃣️ 方法名</p>
<ul>
<li><code>getter=&lt;name&gt;</code> 可以指定 getter 方法名；</li>
<li><code>setter=&lt;name&gt;</code> 可以指定 setter 方法名；</li>
</ul>
<p>属性特性（Attribute）只在自动生成时有效，开发者自己实现的 getter &amp; setter 要保证其具备相应的属性特性。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#75715e">// 即使 readonly 也要注明 copy，因为在 init 中进行了 copy
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">copy</span>, <span style="color:#66d9ef">readonly</span>) NSString <span style="color:#f92672">*</span>bar;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo</span>

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">initWithBar:</span>(NSString <span style="color:#f92672">*</span>)bar
{
    self <span style="color:#f92672">=</span> [super init];
    <span style="color:#66d9ef">if</span> (self) {
        <span style="color:#75715e">// 要保证属性的内存语义
</span><span style="color:#75715e"></span>        _bar <span style="color:#f92672">=</span> [bar <span style="color:#66d9ef">copy</span>];
    }
    <span style="color:#66d9ef">return</span> self;
}

<span style="color:#66d9ef">@end</span>
</code></pre></div><h3 id="heading-5">在对象内部尽量直接访问实例变量</h3>
<p>直接访问实例变量（ivar）与通过属性（getter &amp; setter）访问的区别：</p>
<ul>
<li>直接访问不经过方法派发，速度更快；</li>
<li>直接访问不经过所定义的内存管理语义（例如 <code>copy</code>）；</li>
<li>直接访问不经过 KVO；</li>
<li>通过属性访问便于 Debug（可以打断点）。</li>
</ul>
<p>因此建议读取时直接访问，写入时通过属性，当然具体问题见仁见智。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// 懒加载的属性必须要通过 getter 访问
</span><span style="color:#75715e"></span>- (NSObject <span style="color:#f92672">*</span>)<span style="color:#a6e22e">foo</span> {
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>_foo) {
        _foo <span style="color:#f92672">=</span> [NSObject new];
        <span style="color:#66d9ef">return</span> _foo;
    }
}
</code></pre></div><h3 id="heading-6">理解「对象等同性」这一概念</h3>
<p>对于 Obj-C 中的对象类型，<code>==</code> 比较的是两个指针本身的值（即存储的地址）是否一致。NSString 类中的 <code>isEqualToString:</code> 比 <code>isEqual:</code> 方法速度更快（但其实差别不大）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">- (<span style="color:#66d9ef">BOOL</span>)<span style="color:#a6e22e">isEqual:</span>(<span style="color:#66d9ef">id</span>)object {
    <span style="color:#75715e">// 地址一致，则必然一样
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (self <span style="color:#f92672">=</span><span style="color:#f92672">=</span> object) <span style="color:#66d9ef">return</span> YES;
    <span style="color:#75715e">// 如果非同类，则不相等（子父类之间比较视情况而定）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ([self <span style="color:#66d9ef">class</span>] <span style="color:#f92672">!</span><span style="color:#f92672">=</span> [object <span style="color:#66d9ef">class</span>]) <span style="color:#66d9ef">return</span> NO;

    Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> (Foo <span style="color:#f92672">*</span>)object;
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>[_bar isEqualToString:foo.bar])
        <span style="color:#66d9ef">return</span> NO;

    <span style="color:#66d9ef">if</span> (_baz <span style="color:#f92672">!</span><span style="color:#f92672">=</span> foo.baz)
        <span style="color:#66d9ef">return</span> NO;

    <span style="color:#66d9ef">return</span> YES;
}
</code></pre></div><p>若两个对象相等，<code>hash</code> 也相等；<code>hash</code> 相等，但两个对象并不一定相等。实现 <code>hash</code> 方法要在减少碰撞与降低运算复杂程度（性能影响）之间权衡：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// 返回固定值
</span><span style="color:#75715e"></span><span style="color:#75715e">// 可行，但在 collection 中使用该类型对象将产生性能问题，因为 collection 检索哈希表（Hash Table）时，会用对象的哈希码（Hash Code）做索引。
</span><span style="color:#75715e"></span><span style="color:#75715e">// 假如某个 collection 是用 set 实现的，其可能会根据哈希码把对象分装到不同的数组中。
</span><span style="color:#75715e"></span><span style="color:#75715e">// 若每个对象都返回相同的哈希码，则需要将所有对象全部扫描。
</span><span style="color:#75715e"></span>- (NSUInteger)<span style="color:#a6e22e">hash</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1024</span>;
}

<span style="color:#75715e">// 属性拼接字符串并 hash
</span><span style="color:#75715e"></span><span style="color:#75715e">// 但需承担创建字符串的开销；添加到 collection 中由于必须计算哈希码也会产生性能问题
</span><span style="color:#75715e"></span>- (NSUInteger)<span style="color:#a6e22e">hash</span> {
    NSString <span style="color:#f92672">*</span>str <span style="color:#f92672">=</span> [NSString stringWithFormat:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@:%i</span><span style="color:#e6db74">&#34;</span>, _bar, _baz];
    <span style="color:#66d9ef">return</span> [str hash];
}

<span style="color:#75715e">// 效率高，范围确定
</span><span style="color:#75715e"></span><span style="color:#75715e">// 虽然会碰撞，但允许
</span><span style="color:#75715e"></span>- (NSUInteger)<span style="color:#a6e22e">hash</span> {
    NSUInteger bar <span style="color:#f92672">=</span> [_bar hash];
    NSUInteger baz <span style="color:#f92672">=</span> _baz;
    <span style="color:#66d9ef">return</span> bar <span style="color:#f92672">^</span> baz;
}
</code></pre></div><p>编写特定类的等同性判定方法（比如 <code>isEqualToString:</code>）时，应一并重写 <code>isEqual:</code> 方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">- (<span style="color:#66d9ef">BOOL</span>)<span style="color:#a6e22e">isEqualToFoo:</span>(Foo <span style="color:#f92672">*</span>)foo {
    <span style="color:#66d9ef">if</span> (self <span style="color:#f92672">=</span><span style="color:#f92672">=</span> object) <span style="color:#66d9ef">return</span> YES;

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>[_bar isEqualToString:foo.bar])
        <span style="color:#66d9ef">return</span> NO;

    <span style="color:#66d9ef">if</span> (_baz <span style="color:#f92672">!</span><span style="color:#f92672">=</span> foo.baz)
        <span style="color:#66d9ef">return</span> NO;

    <span style="color:#66d9ef">return</span> YES;
}

- (<span style="color:#66d9ef">BOOL</span>)<span style="color:#a6e22e">isEqual:</span>(<span style="color:#66d9ef">id</span>)object {
    <span style="color:#75715e">// 相同类则自己判断
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ([self <span style="color:#66d9ef">class</span>] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> [object <span style="color:#66d9ef">class</span>]) {
        <span style="color:#66d9ef">return</span> [self isEqualToFoo:(Foo <span style="color:#f92672">*</span>)object];
    }

    <span style="color:#75715e">// 不同类则交给父类
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> [super isEqual:object];
}
</code></pre></div><p>等同性判定的执行深度取决于受测对象，即若有某个 ID 字段则可以直接根据该 ID 来判定。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// 将对象放入 collection 中，不应再改变其哈希码，即需要确保哈希码并非根据对象的可变部分计算得出
</span><span style="color:#75715e"></span>NSMutableSet <span style="color:#f92672">*</span>set <span style="color:#f92672">=</span> [NSMutableSet new];
NSMutableArray <span style="color:#f92672">*</span>arr1 <span style="color:#f92672">=</span> [<span style="color:#ae81ff">@[</span><span style="color:#ae81ff">@1</span><span style="color:#ae81ff">]</span> mutableCopy];
NSMutableArray <span style="color:#f92672">*</span>arr2 <span style="color:#f92672">=</span> [<span style="color:#ae81ff">@[</span><span style="color:#ae81ff">@1</span>, <span style="color:#ae81ff">@2</span><span style="color:#ae81ff">]</span> mutableCopy];

[set addObject:arr1];
[set addObject:arr2];

<span style="color:#75715e">// {((1), (1,2))}
</span><span style="color:#75715e"></span>NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, set);

<span style="color:#75715e">// Set 中存在了两个完全相同的结构
</span><span style="color:#75715e"></span><span style="color:#75715e">// {((1,2), (1,2))}
</span><span style="color:#75715e"></span>[arr1 addObject:<span style="color:#ae81ff">@2</span>];
NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, set);
</code></pre></div><h3 id="heading-7">以「类族模式」隐藏实现细节</h3>
<p>类族（Class Cluster，又称类簇）是一种隐藏抽象基类背后的实现细节的模式（例如 <code>UIButton</code> 的 <code>buttonWithType:</code> 类方法）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">模</span><span style="color:#75715e">式</span><span style="color:#75715e">是</span><span style="color:#75715e">不</span><span style="color:#75715e">限</span><span style="color:#75715e">定</span><span style="color:#75715e">于</span><span style="color:#75715e">语</span><span style="color:#75715e">言</span><span style="color:#75715e">的</span><span style="color:#75715e">，</span><span style="color:#75715e">因</span><span style="color:#75715e">此</span><span style="color:#75715e">这</span><span style="color:#75715e">里</span><span style="color:#75715e">使</span><span style="color:#75715e">用</span><span style="color:#75715e">了</span><span style="color:#75715e"> </span><span style="color:#75715e">S</span><span style="color:#75715e">w</span><span style="color:#75715e">i</span><span style="color:#75715e">f</span><span style="color:#75715e">t</span><span style="color:#75715e"> </span><span style="color:#75715e">来</span><span style="color:#75715e">简</span><span style="color:#75715e">单</span><span style="color:#75715e">实</span><span style="color:#75715e">现</span>

<span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">FooType</span> {
    <span style="color:#66d9ef">case</span> first
    <span style="color:#66d9ef">case</span> second
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Foo</span> {
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">build</span>(<span style="color:#66d9ef">_</span> type: FooType) -&gt; Foo {
        <span style="color:#66d9ef">switch</span> type {
        <span style="color:#66d9ef">case</span> .first: <span style="color:#66d9ef">return</span> FooFirst()
        <span style="color:#66d9ef">case</span> .second: <span style="color:#66d9ef">return</span> FooSecond()
        }
    }

    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bar</span>() {
        fatalError(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">bar should be implemented in subclasses.</span><span style="color:#e6db74">&#34;</span>)
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FooFirst</span>: Foo {
    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bar</span>() {
        print(<span style="color:#66d9ef">#function</span>)
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FooSecond</span>: Foo {
    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bar</span>() {
        print(<span style="color:#66d9ef">#function</span>)
    }
}

<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">类</span><span style="color:#75715e">族</span><span style="color:#75715e">模</span><span style="color:#75715e">式</span><span style="color:#75715e">目</span><span style="color:#75715e">的</span><span style="color:#75715e">是</span><span style="color:#75715e">隐</span><span style="color:#75715e">藏</span><span style="color:#75715e">内</span><span style="color:#75715e">部</span><span style="color:#75715e">实</span><span style="color:#75715e">现</span><span style="color:#75715e">的</span><span style="color:#75715e">细</span><span style="color:#75715e">节</span><span style="color:#75715e">，</span><span style="color:#75715e">因</span><span style="color:#75715e">此</span><span style="color:#75715e">外</span><span style="color:#75715e">界</span><span style="color:#75715e">创</span><span style="color:#75715e">建</span><span style="color:#75715e">的</span><span style="color:#75715e">变</span><span style="color:#75715e">量</span><span style="color:#75715e">虽</span><span style="color:#75715e">然</span><span style="color:#75715e">是</span><span style="color:#75715e">工</span><span style="color:#75715e">厂</span><span style="color:#75715e">类</span><span style="color:#75715e">的</span><span style="color:#75715e">类</span><span style="color:#75715e">型</span><span style="color:#75715e">，</span><span style="color:#75715e">但</span><span style="color:#75715e">实</span><span style="color:#75715e">际</span><span style="color:#75715e">上</span><span style="color:#75715e">其</span><span style="color:#75715e">实</span><span style="color:#75715e">是</span><span style="color:#75715e">内</span><span style="color:#75715e">部</span><span style="color:#75715e">子</span><span style="color:#75715e">类</span><span style="color:#75715e">的</span><span style="color:#75715e">类</span><span style="color:#75715e">型</span><span style="color:#75715e">。</span>
<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">因</span><span style="color:#75715e">此</span><span style="color:#75715e">在</span><span style="color:#75715e"> </span><span style="color:#75715e">O</span><span style="color:#75715e">b</span><span style="color:#75715e">j</span><span style="color:#75715e">-</span><span style="color:#75715e">C</span><span style="color:#75715e"> </span><span style="color:#75715e">中</span><span style="color:#75715e">使</span><span style="color:#75715e">用</span><span style="color:#75715e"> </span><span style="color:#75715e">i</span><span style="color:#75715e">s</span><span style="color:#75715e">M</span><span style="color:#75715e">e</span><span style="color:#75715e">m</span><span style="color:#75715e">b</span><span style="color:#75715e">e</span><span style="color:#75715e">r</span><span style="color:#75715e">O</span><span style="color:#75715e">f</span><span style="color:#75715e">C</span><span style="color:#75715e">l</span><span style="color:#75715e">a</span><span style="color:#75715e">s</span><span style="color:#75715e">s</span><span style="color:#75715e"> </span><span style="color:#75715e">判</span><span style="color:#75715e">断</span><span style="color:#75715e">类</span><span style="color:#75715e">是</span><span style="color:#75715e">否</span><span style="color:#75715e">为</span><span style="color:#75715e">工</span><span style="color:#75715e">厂</span><span style="color:#75715e">类</span><span style="color:#75715e">本</span><span style="color:#75715e">身</span><span style="color:#75715e">，</span><span style="color:#75715e">则</span><span style="color:#75715e">会</span><span style="color:#75715e">返</span><span style="color:#75715e">回</span><span style="color:#75715e"> </span><span style="color:#75715e">N</span><span style="color:#75715e">O</span><span style="color:#75715e">。</span>
<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">f</span><span style="color:#75715e">o</span><span style="color:#75715e">o</span><span style="color:#75715e"> </span><span style="color:#75715e">在</span><span style="color:#75715e"> </span><span style="color:#75715e">S</span><span style="color:#75715e">w</span><span style="color:#75715e">i</span><span style="color:#75715e">f</span><span style="color:#75715e">t</span><span style="color:#75715e"> </span><span style="color:#75715e">中</span><span style="color:#75715e">被</span><span style="color:#75715e">推</span><span style="color:#75715e">断</span><span style="color:#75715e">为</span><span style="color:#75715e"> </span><span style="color:#75715e">F</span><span style="color:#75715e">o</span><span style="color:#75715e">o</span>
<span style="color:#66d9ef">let</span> foo = Foo.build(.first)

print(foo <span style="color:#66d9ef">is</span> Foo)
print(foo <span style="color:#66d9ef">is</span> FooFirst)
print(foo <span style="color:#66d9ef">is</span> FooSecond)

<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">O</span><span style="color:#75715e">U</span><span style="color:#75715e">T</span><span style="color:#75715e">P</span><span style="color:#75715e">U</span><span style="color:#75715e">T</span><span style="color:#75715e">:</span>
<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">t</span><span style="color:#75715e">r</span><span style="color:#75715e">u</span><span style="color:#75715e">e</span>
<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">t</span><span style="color:#75715e">r</span><span style="color:#75715e">u</span><span style="color:#75715e">e</span>
<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">f</span><span style="color:#75715e">a</span><span style="color:#75715e">l</span><span style="color:#75715e">s</span><span style="color:#75715e">e</span>
</code></pre></div><p>系统框架中有许多类族，比如大部分的 collection 类（比如 <code>NSArray</code>）；由于 <code>NSArray</code> 是类族，因此 <code>[fooArr class] == [NSArray class]</code> 将一直返回 <code>false</code>，但可使用 <code>[fooArr isKindOfClass:[NSArray class]]</code>。</p>
<p>向类族中新增实体子类需要遵守以下规则：</p>
<ul>
<li>子类应该继承自类族中的抽象基类；</li>
<li>子类应该定义自己的数据存储方式：类族只是定义了通用的接口，实际存储的方式则由背后具体的实体子类承担；</li>
<li>子类应当覆写超类文档中指明需要覆写的方法：类族中的通用接口需要子类实现。</li>
</ul>
<h3 id="heading-8">在既有类中使用关联对象存放自定义数据</h3>
<p>略；关于关联对象，可详见《<a href="../associated_objects_in_ios">iOS 中的关联对象</a>》一文。</p>
<h3 id="-objc-msgsend-">理解 objc_msgSend 的作用</h3>
<p>略；关于 objc_msgSend，可详见《<a href="../objc_msgsend">浅尝 objc_msgSend</a>》一文。</p>
<h3 id="heading-9">理解消息转发机制</h3>
<p>略；关于消息转发机制，可详见《<a href="../objc_msgsend">浅尝 objc_msgSend</a>》一文。</p>
<h3 id="heading-10">用「方法调配技术」调试「黑盒方法」</h3>
<p>「方法调配技术」即 Method Swizzling，现在普遍称之为方法交换：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">#</span><span style="color:#75715e">import &lt;Foundation</span><span style="color:#75715e">/</span><span style="color:#75715e">Foundation.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">import &lt;objc</span><span style="color:#75715e">/</span><span style="color:#75715e">runtime.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Foo_BASE 基类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo_BASE</span> : <span style="color:#a6e22e">NSObject</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">a</span>;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo_BASE</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">a</span> {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">a - Foo_BASE - %@</span><span style="color:#e6db74">&#34;</span>, self);
}
<span style="color:#66d9ef">@end</span>

<span style="color:#75715e">// Foo_SUB 子类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo_SUB</span> : <span style="color:#a6e22e">Foo_BASE</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">b</span>;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo_SUB</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">b</span> {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">b - Foo_SUB - %@</span><span style="color:#e6db74">&#34;</span>, self);
}
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Bar</span> : <span style="color:#a6e22e">NSObject</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">e</span>;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Bar</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">e</span> {
    <span style="color:#75715e">// self 为 Foo_SUB
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// [self e];  -[Foo_SUB e]: unrecognized selector sent to instance 0x1007031e0
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// [self performSelector:NSSelectorFromString(@&#34;f&#34;)]; // EXC_BAD_ACCESS
</span><span style="color:#75715e"></span>
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">e - Bar - %@</span><span style="color:#e6db74">&#34;</span>, self);
}
<span style="color:#66d9ef">@end</span>

<span style="color:#75715e">// Foo_SUB (Extension) 分类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo_SUB</span> (Extension)
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo_SUB</span> (Extension)

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">c</span> {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">c - Foo_SUB - %@</span><span style="color:#e6db74">&#34;</span>, self);
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">d</span> {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">d - Foo_SUB - %@</span><span style="color:#e6db74">&#34;</span>, self);
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">f</span> {
    <span style="color:#75715e">// self 为 Bar
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// [self f]; // -[Bar f]: unrecognized selector sent to instance 0x102300290
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// [self performSelector:NSSelectorFromString(@&#34;e&#34;)]; // EXC_BAD_ACCESS
</span><span style="color:#75715e"></span>
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">f - Foo_SUB - %@</span><span style="color:#e6db74">&#34;</span>, self);
}

+ (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">load</span> {
    <span style="color:#66d9ef">static</span> dispatch_once_t onceToken;
    dispatch_once(<span style="color:#f92672">&amp;</span>onceToken, <span style="color:#f92672">^</span>{
        <span style="color:#75715e">// 1. 交换 b &amp; c（b 来自本类，c 来自本类的分类）
</span><span style="color:#75715e"></span>        {
            Method m_b <span style="color:#f92672">=</span> class_getInstanceMethod([self <span style="color:#66d9ef">class</span>], <span style="color:#66d9ef">@selector</span>(b));
            Method m_c <span style="color:#f92672">=</span> class_getInstanceMethod([self <span style="color:#66d9ef">class</span>], <span style="color:#66d9ef">@selector</span>(c));

            <span style="color:#75715e">// 直接交换
</span><span style="color:#75715e"></span>            method_exchangeImplementations(m_b, m_c);
        }

        <span style="color:#75715e">// 2. 交换 a &amp; d（a 来自基类，本类未实现，d 来自本类的分类）
</span><span style="color:#75715e"></span>        {
            Method m_a <span style="color:#f92672">=</span> class_getInstanceMethod([self <span style="color:#66d9ef">class</span>], <span style="color:#66d9ef">@selector</span>(a));
            Method m_d <span style="color:#f92672">=</span> class_getInstanceMethod([self <span style="color:#66d9ef">class</span>], <span style="color:#66d9ef">@selector</span>(d));

            <span style="color:#75715e">// 2-1. 交换 IMP
</span><span style="color:#75715e"></span>            {
                <span style="color:#75715e">// 为了防止基类的方法被改变，那么需要先为本类添加 m_a 方法（override）
</span><span style="color:#75715e"></span>                class_addMethod([self <span style="color:#66d9ef">class</span>], <span style="color:#66d9ef">@selector</span>(a), method_getImplementation(m_a), method_getTypeEncoding(m_a));
                <span style="color:#75715e">// 再获取本类中添加的方法
</span><span style="color:#75715e"></span>                Method m_a_sub <span style="color:#f92672">=</span> class_getInstanceMethod([self <span style="color:#66d9ef">class</span>], <span style="color:#66d9ef">@selector</span>(a));
                <span style="color:#75715e">// 交换
</span><span style="color:#75715e"></span>                method_exchangeImplementations(m_a_sub, m_d);
            }

            <span style="color:#75715e">// 2-2. 替换方法
</span><span style="color:#75715e"></span>            {
                <span style="color:#75715e">// 为了防止基类的方法被改变，那么需要先为本类添加 m_a 方法（override），但 IMP 和 TypeEncoding 可直接使用 m_d 的信息
</span><span style="color:#75715e"></span>                class_addMethod([self <span style="color:#66d9ef">class</span>], <span style="color:#66d9ef">@selector</span>(a), method_getImplementation(m_d), method_getTypeEncoding(m_d));
                <span style="color:#75715e">// 再替代方法 d 方法的 IMP 和 TypeEncoding 为 m_a 的信息
</span><span style="color:#75715e"></span>                class_replaceMethod([self <span style="color:#66d9ef">class</span>], <span style="color:#66d9ef">@selector</span>(d), method_getImplementation(m_a), method_getTypeEncoding(m_a));
            }
        }

        <span style="color:#75715e">// 3. 交换 e &amp; f（e 来自 Bar 类，f 来自 Foo_SUB 类）
</span><span style="color:#75715e"></span>        {
            Method m_e <span style="color:#f92672">=</span> class_getInstanceMethod([Bar <span style="color:#66d9ef">class</span>], <span style="color:#66d9ef">@selector</span>(e));
            Method m_f <span style="color:#f92672">=</span> class_getInstanceMethod([Foo_SUB <span style="color:#66d9ef">class</span>], <span style="color:#66d9ef">@selector</span>(f));

            <span style="color:#75715e">// 直接交换
</span><span style="color:#75715e"></span>            method_exchangeImplementations(m_e, m_f);

            <span style="color:#75715e">// ⚠️ 需要注意的是：
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 1. 此时不能在相应的方法中再调用自身的方法，这与交换本类的两个方法不同。
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 比如此时的 `f` 方法，交换后是通过 `Bar` 实例对象调用（发送）的，隐式参数 `self` 为 `Bar` 类型，而该类的方法列表中根本不包含 `f` 方法，因此调用时即发生 Crash，反之 `e` 方法同理；
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 2. 此时也不能在相应的方法中再调用当前方法。
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 比如此时的 `e` 方法，交换后是通过 `Foo_SUB` 实例对象调用（发送）的，隐式参数 `self` 为 `Foo_SUB` 类型，该类中确实包含 `f` 方法，但由于其 IMP 已经被交换，调用后会再次进入当前 `e` 方法，从而造成死循环，反之 `f` 方法同理。
</span><span style="color:#75715e"></span>        }

        <span style="color:#75715e">// 4. 通用处理
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (false) {
            Method m1 <span style="color:#f92672">=</span> class_getInstanceMethod([self <span style="color:#66d9ef">class</span>], <span style="color:#66d9ef">@selector</span>(b));
            Method m2 <span style="color:#f92672">=</span> class_getInstanceMethod([self <span style="color:#66d9ef">class</span>], <span style="color:#66d9ef">@selector</span>(c));

            <span style="color:#66d9ef">if</span> (class_addMethod([self <span style="color:#66d9ef">class</span>], <span style="color:#66d9ef">@selector</span>(b), method_getImplementation(m2), method_getTypeEncoding(m2))) {
                class_replaceMethod([self <span style="color:#66d9ef">class</span>], <span style="color:#66d9ef">@selector</span>(c), method_getImplementation(m1), method_getTypeEncoding(m1));
            } <span style="color:#66d9ef">else</span> {
                method_exchangeImplementations(m1, m2);
            }
        }
    });
}

<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">int</span> main(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">@autoreleasepool</span> {
        {
            Foo_SUB <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> [[Foo_SUB alloc] init];
            [f b];
            [f c];

            <span style="color:#75715e">// c - Foo_SUB - &lt;Foo_SUB: 0x10051b090&gt;
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// b - Foo_SUB - &lt;Foo_SUB: 0x10051b090&gt;
</span><span style="color:#75715e"></span>        }

        {
            Foo_SUB <span style="color:#f92672">*</span>f1 <span style="color:#f92672">=</span> [[Foo_SUB alloc] init];
            [f1 a];
            [f1 d];
            <span style="color:#75715e">// d - Foo_SUB - &lt;Foo_SUB: 0x100505fd0&gt;
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// a - Foo_BASE - &lt;Foo_SUB: 0x100505fd0&gt;
</span><span style="color:#75715e"></span>
            Foo_BASE <span style="color:#f92672">*</span>f2 <span style="color:#f92672">=</span> [[Foo_BASE alloc] init];
            [f2 a];
            <span style="color:#75715e">// a - Foo_BASE - &lt;Foo_BASE: 0x1021008a0&gt;
</span><span style="color:#75715e"></span>        }

        {
            Bar <span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> [[Bar alloc] init];
            Foo_SUB <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> [[Foo_SUB alloc] init];

            [b e]; <span style="color:#75715e">// f - Foo_SUB - &lt;Bar: 0x103001f10&gt;
</span><span style="color:#75715e"></span>            [f f]; <span style="color:#75715e">// e - Bar - &lt;Foo_SUB: 0x103000cc0&gt;
</span><span style="color:#75715e"></span>        }
    }
}
</code></pre></div><h3 id="heading-11">理解「类对象」的用意</h3>
<p>略；关于类对象，可详见《<a href="../objects_in_obj-c/">Obj-C 中的对象</a>》一文；关于内省，可详见《<a href="../type_introspection_and_reflection/">Obj-C &amp; Swift 的类型内省与反射</a>》一文；</p>
<h2 id="-api-">接口与 API 设计</h2>
<h3 id="heading-12">用前缀避免命名空间冲突</h3>
<p>Obj-C 没有命名空间（Namespace）机制；因此为了避免重复符号（Duplicate Symbol）错误，需在类名前加入前缀以区分。</p>
<h3 id="heading-13">提供「全能初始化方法」</h3>
<p>全能初始化方法（Designated Initializer，又称指定初始化方法）指的是为对象提供必要信息以便其能完成工作的初始化方法。一个类可能不止有一个初始化方法，但通常将选择其中之一作为全能初始化方法，而其它初始化方法间接依赖它，这样可以保证初始化逻辑的统一。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Rectangle</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">assign</span>, <span style="color:#66d9ef">readonly</span>) <span style="color:#66d9ef">double</span> width;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">assign</span>, <span style="color:#66d9ef">readonly</span>) <span style="color:#66d9ef">double</span> height;

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">initWithWidth:</span>(<span style="color:#66d9ef">double</span>)width <span style="color:#a6e22e">height:</span>(<span style="color:#66d9ef">double</span>)height;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Rectangle</span>
- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">initWithWidth:</span>(<span style="color:#66d9ef">double</span>)width <span style="color:#a6e22e">height:</span>(<span style="color:#66d9ef">double</span>)height {
    self <span style="color:#f92672">=</span> [super init];
    <span style="color:#66d9ef">if</span> (self) {
        _width <span style="color:#f92672">=</span> width;
        _height <span style="color:#f92672">=</span> height;
    }
    <span style="color:#66d9ef">return</span> self;
}

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">init</span> {
    <span style="color:#75715e">// 调用全能初始化方法以构造
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> [self initWithWidth:<span style="color:#ae81ff">0.0</span> height:<span style="color:#ae81ff">0.0</span>];
    <span style="color:#75715e">// 也可抛出异常，避免外界通过 init 构造
</span><span style="color:#75715e"></span><span style="color:#75715e">//    @throw [NSException exceptionWithName:NSInternalInconsistencyException
</span><span style="color:#75715e"></span><span style="color:#75715e">//                                   reason:@&#34;Must use initWithWidth:height: instead.&#34;
</span><span style="color:#75715e"></span><span style="color:#75715e">//                                 userInfo:nil];
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 另一个全能构造方法
</span><span style="color:#75715e"></span>- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">initWithCoder:</span>(NSCoder <span style="color:#f92672">*</span>)coder {
    self <span style="color:#f92672">=</span> [super init];
    <span style="color:#66d9ef">if</span> (self) {
        _width <span style="color:#f92672">=</span> [coder decodeDoubleForKey:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">width</span><span style="color:#e6db74">&#34;</span>];
        _height <span style="color:#f92672">=</span> [coder decodeDoubleForKey:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">height</span><span style="color:#e6db74">&#34;</span>];
    }
    <span style="color:#66d9ef">return</span> self;
}
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Square</span> : <span style="color:#a6e22e">Rectangle</span>
- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">initWithDimension:</span>(<span style="color:#66d9ef">double</span>)dimension;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Square</span>
- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">initWithDimension:</span>(<span style="color:#66d9ef">double</span>)dimension {
    <span style="color:#75715e">// 调用父类全能初始化方法以构造
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> [super initWithWidth:dimension height:dimension];
}

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">initWithWidth:</span>(<span style="color:#66d9ef">double</span>)width <span style="color:#a6e22e">height:</span>(<span style="color:#66d9ef">double</span>)height {
    <span style="color:#75715e">// 子类全能初始化方法不同，需重写父类全能初始化方法
</span><span style="color:#75715e"></span><span style="color:#75715e">//    return [self initWithDimension:MAX(width, height)];
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 或可抛出异常，避免外界通过父类全能初始化方法构造
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">@throw</span> [NSException exceptionWithName:NSInternalInconsistencyException
                                   reason:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">Must use initWithDimension: instead.</span><span style="color:#e6db74">&#34;</span>
                                 userInfo:nil];
}

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">init</span> {
    <span style="color:#75715e">// 也需重写父类 init 方法，使用子类全能构造方法
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> [self initWithDimension:<span style="color:#ae81ff">0.0</span>];
}

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">initWithCoder:</span>(NSCoder <span style="color:#f92672">*</span>)coder {
    <span style="color:#75715e">// 先调用父类 initWithCoder: 全能构造方法
</span><span style="color:#75715e"></span>    self <span style="color:#f92672">=</span> [super initWithCoder:coder];
    <span style="color:#66d9ef">if</span> (self) {
        <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">return</span> self;
}
<span style="color:#66d9ef">@end</span>
</code></pre></div><h3 id="-description-">实现 description 方法</h3>
<p>NSObject 子类可以重写 <code>description</code> 方法来描述实例，在打印（<code>NSLog</code>）实例信息时即可输出；也可重写 <code>debugDescription</code> 用来在控制台使用 LLDB <code>po</code> 命令输出：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// ...
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Rectangle</span>
<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>
- (NSString <span style="color:#f92672">*</span>)<span style="color:#a6e22e">description</span> {
    <span style="color:#66d9ef">return</span> [NSString stringWithFormat:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">&lt;%lf, %lf&gt;</span><span style="color:#e6db74">&#34;</span>, _width, _height];
}

- (NSString <span style="color:#f92672">*</span>)<span style="color:#a6e22e">debugDescription</span> {
    <span style="color:#66d9ef">return</span> [NSString stringWithFormat:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">&lt;%@: %p&gt; &lt;%lf, %lf&gt;</span><span style="color:#e6db74">&#34;</span>, [self <span style="color:#66d9ef">class</span>], self, _width, _height];
}
<span style="color:#66d9ef">@end</span>

Rectangle <span style="color:#f92672">*</span>rect <span style="color:#f92672">=</span> [[Rectangle alloc] initWithWidth:<span style="color:#ae81ff">30</span> height:<span style="color:#ae81ff">50</span>];
NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, rect);

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;30.000000, 50.000000&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// (lldb) po rect
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;Rectangle: 0x6000037887e0&gt; &lt;30.000000, 50.000000&gt;
</span></code></pre></div><h3 id="heading-14">尽量使用不可变对象</h3>
<p>尽量将外界不能改变的属性对外声明为 <code>readonly</code>，此时将只存在 getter 而不存在 setter。我们可以在实现文件中直接通过访问成员变量来更改，也可将属性再次声明在类扩展中以通过 setter 更改。</p>
<p>由于内存管理语义仅针对 setter，因此声明为 <code>readonly</code> 时也可使用默认的内存管理语义。<code>readonly</code> 并非是完全安全的，外部仍然可以通过 KVC、或者根据内存布局的偏移量直接访问修改。对于集合类型，我们可以将不可变属性本身作为 <code>readonly</code> 暴露在外，并通过额外方法使得外界可以添加或删除等操作集合；在内部则通过另外的可变类型属性作为具体实现，从而避免从底层直接修改对象中的数据：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Rectangle</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">assign</span>, <span style="color:#66d9ef">readonly</span>) <span style="color:#66d9ef">double</span> width;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">readonly</span>) <span style="color:#66d9ef">double</span> height;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>, <span style="color:#66d9ef">readonly</span>) NSArray<span style="color:#f92672">&lt;</span>Rectangle <span style="color:#f92672">*</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">*</span>array;

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">addElement:</span>(Rectangle <span style="color:#f92672">*</span>)element;
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">removeElement:</span>(Rectangle <span style="color:#f92672">*</span>)element;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Rectangle</span> ()
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">assign</span>, <span style="color:#66d9ef">readwrite</span>) <span style="color:#66d9ef">double</span> width;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">assign</span>) <span style="color:#66d9ef">double</span> height;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Rectangle</span> {
    NSMutableArray <span style="color:#f92672">*</span>_mutableArray;
}

- (NSArray <span style="color:#f92672">*</span>)<span style="color:#a6e22e">array</span> {
    <span style="color:#66d9ef">return</span> [_mutableArray <span style="color:#66d9ef">copy</span>];
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">addElement:</span>(Rectangle <span style="color:#f92672">*</span>)element {
    [_mutableArray addObject:element];
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">removeElement:</span>(Rectangle <span style="color:#f92672">*</span>)element {
    [_mutableArray removeObject:element];
}

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">initWithWidth:</span>(<span style="color:#66d9ef">double</span>)width <span style="color:#a6e22e">height:</span>(<span style="color:#66d9ef">double</span>)height {
    self <span style="color:#f92672">=</span> [super init];
    <span style="color:#66d9ef">if</span> (self) {
        _width <span style="color:#f92672">=</span> width;
        _height <span style="color:#f92672">=</span> height;
        _mutableArray <span style="color:#f92672">=</span> [NSMutableArray new];
    }
    <span style="color:#66d9ef">return</span> self;
}
<span style="color:#66d9ef">@end</span>

Rectangle <span style="color:#f92672">*</span>rect1 <span style="color:#f92672">=</span> [[Rectangle alloc] initWithWidth:<span style="color:#ae81ff">10</span> height:<span style="color:#ae81ff">20</span>];
Rectangle <span style="color:#f92672">*</span>rect2 <span style="color:#f92672">=</span> [[Rectangle alloc] initWithWidth:<span style="color:#ae81ff">10</span> height:<span style="color:#ae81ff">20</span>];
[rect1 addElement:rect2];
</code></pre></div><h3 id="heading-15">使用清晰而协调的命名方式</h3>
<p>一些 Obj-C 的方法名十分冗长，但却语义化更加，这点 Swift 也继承了其优点，并适当精简方法名。方法的命名规则：</p>
<ul>
<li>若返回值是新创建的，那么方法名应当以返回值类型开始，也可加入对其修饰；</li>
<li>表示参数类型的名词应当置于参数之前；</li>
<li>方法内的行为要操作当前对象，那么应当包含动词；若执行时需要参数，则应当在动词之后加上一个或多个名词；</li>
<li>使用 <code>string</code> 全称而非 <code>str</code> 简称；</li>
<li><code>Boolean</code> 属性应当加 <code>is</code> 前缀；根据功能将返回 <code>Boolean</code> 类型的方法名选择 <code>has</code> 或 <code>is</code> 前缀；</li>
<li>使用输出参数（Out Parameter）保存返回值的方法可以使用 <code>get</code> 前缀。</li>
</ul>
<p>类与协议的名称尽量要加上前缀，以避免命名空间冲突。命名第一要务是确保其风格与代码框架相符合。</p>
<h3 id="heading-16">为私有方法名加前缀</h3>
<p>私有方法除了不应对外声明，也应加上前缀与以区分。但不推荐单用一个下划线 <code>_</code> 作为前缀，因为系统库中有很多私有方法即是以 <code>_</code> 为前缀的。</p>
<h3 id="-objective-c--1">理解 Objective-C 错误模型</h3>
<p>异常（Exception）与错误（Error）在计算机中代表着完全不同的两种意义。</p>
<p>异常安全（Exception Safe）指的是当抛出异常时，需要释放的资源或对象也能得到安全地释放。自动引用计数默认是非异常安全的，但可以通过 <code>-fobjc-arc-exceptions</code> 设置编译器以达到异常安全（详见下文「编写「异常安全代码时」留意内存管理问题」一节）。由于异常安全很难得到保证，因此推荐只在必要时（如重大错误）抛出异常，并终止程序，而不再考虑异常安全。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@throw</span> [NSException exceptionWithName:NSInternalInconsistencyException reason:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">Some reason.</span><span style="color:#e6db74">&#34;</span> userInfo:nil];
</code></pre></div><p>非致命错误（Non-fatal Error）可以令方法返回 <code>nil</code> / <code>0</code> 或 <code>NSError</code>，以表明有错误发生。对于 NSError：</p>
<ul>
<li>Error Domain（<code>NSErrorDomain</code> 本质为 <code>NSString</code>）：错误范围表明了错误根源，eg. <code>NSURLErrorDomain</code>、<code>NSCocoaErrorDomain</code> 等；</li>
<li>Error Code（<code>NSInteger</code>）：错误代码表明了具体的独有错误，可使用枚举定义；</li>
<li>User Info（<code>NSDictionary&lt;NSErrorUserInfoKey,id&gt;</code>，<code>NSErrorUserInfoKey</code> 本质为 <code>NSString</code>）：用户信息表明了关于错误的额外信息，比如本地化的错误描述。</li>
</ul>
<p><code>NSError</code> 常见用法一是通过代理协议（Delegate Protocols）传递。当错误发生时，将通过调用代理对象的某个协议方法来告知代理本身；二是通过方法的输出参数返回给调用者。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// NSURLConnection.h
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@protocol</span> <span style="color:#a6e22e">NSURLConnectionDelegate</span> <span style="color:#f92672">&lt;</span>NSObject<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">@optional</span>
<span style="color:#f92672">-</span> (<span style="color:#66d9ef">void</span>)connection:(NSURLConnection <span style="color:#f92672">*</span>)connection didFailWithError:(NSError <span style="color:#f92672">*</span>)error;
<span style="color:#66d9ef">@end</span>

<span style="color:#75715e">// ❌ 错误发生
</span><span style="color:#75715e"></span>[self.delegate connection:someConnection didFailWithError:someError];

<span style="color:#75715e">// ---
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">extern</span> NSString <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> VErrorDomain;

<span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">NS_ENUM</span>(NSUInteger, VError) {
    VErrorUnknown <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,
    VErrorFirst   <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>,
    VErrorSecond  <span style="color:#f92672">=</span> <span style="color:#ae81ff">200</span>
};

NSString <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> VErrorDomain <span style="color:#f92672">=</span> <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">VErrorDomain</span><span style="color:#e6db74">&#34;</span>;

- (<span style="color:#66d9ef">BOOL</span>)<span style="color:#a6e22e">doSomething:</span>(NSError <span style="color:#f92672">*</span><span style="color:#f92672">*</span>)error {
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// 如果错误发生
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (errorOccured) {
        <span style="color:#75715e">// 如果外界关心错误
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (error) {
            <span style="color:#75715e">// 解引用（Dereference）前要保证 error 不为 nil
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 否则对空指针解引用会导致段错误（Segmentation Fault）并崩溃（EXC_BAD_ACCESS）
</span><span style="color:#75715e"></span>            <span style="color:#f92672">*</span>error <span style="color:#f92672">=</span> [NSError errorWithDomain:VErrorDomain code:VErrorFirst userInfo:nil];
        }

        <span style="color:#66d9ef">return</span> NO;
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span> YES;
    }
}
<span style="color:#75715e">// ❌ 错误发生
</span><span style="color:#75715e"></span>NSError <span style="color:#f92672">*</span>error <span style="color:#f92672">=</span> nil;
<span style="color:#66d9ef">BOOL</span> result <span style="color:#f92672">=</span> [obj doSomething:<span style="color:#f92672">&amp;</span>error];
<span style="color:#66d9ef">if</span> (error) {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">Error occurred!</span><span style="color:#e6db74">&#34;</span>);
}
</code></pre></div><p>ARC 下，编译器将把第二种方法签名中的 <code>NSError **</code> 转换为 <code>NSError *__autoreleasing *</code>，即指针所指向的对象将在方法执行完毕后自动释放，因为该方法不能保证调用者将其中创建的 <code>NSError</code> 释放，由此保证与大部分方法（除 <code>new</code> / <code>alloc</code> / <code>copy</code> / <code>mutableCopy</code> 开头的方法）返回值所具备的语义相同。</p>
<!-- - [隐藏\_\_autoreleasing 属性变量(NSError \*\*)引起的 EXC_BAD_ACCESS 崩溃](https://www.jianshu.com/p/b16f36e98baf) -->
<h3 id="-nscopying-">理解 NSCopying 协议</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@protocol</span> <span style="color:#a6e22e">NSCopying</span>
- (<span style="color:#66d9ef">id</span>)<span style="color:#a6e22e">copyWithZone:</span>(nullable NSZone <span style="color:#f92672">*</span>)zone;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@protocol</span> <span style="color:#a6e22e">NSMutableCopying</span>
- (<span style="color:#66d9ef">id</span>)<span style="color:#a6e22e">mutableCopyWithZone:</span>(nullable NSZone <span style="color:#f92672">*</span>)zone;
<span style="color:#66d9ef">@end</span>
</code></pre></div><p>当我们调用一个对象的 <code>copy</code> / <code>mutableCopy</code> 方法时，该类必须实现 <code>NSCopying</code> / <code>NSMutableCopying</code> 协议中的唯一方法，指定该类实例对象的拷贝逻辑，而 <code>copy</code> / <code>mutableCopy</code> 本身由 <code>NSObject</code> 实现。这里的 <code>NSZone</code> 官方解释是「A type used to identify and manage memory zones」，即用来识别和管理内存区域的类型，但目前已经基本废弃，无需关心（Zones are ignored on iOS and 64-bit runtime in macOS. You should not use zones in current development. - Apple Developer）。为了保持和系统提供类行为一致，约定 <code>copy</code> 将总是返回不可变版本，而 <code>mutableCopy</code> 总是返回可变版本，与调用者的类型无关（或者可提供一个 <code>immutableCopy</code> 的方法区分）。</p>
<!-- http://cocoadev.com/wiki/NSZone -->
<p>无论是浅拷贝（Shallow Copy）还是深拷贝（Deep Copy），对象本身都会重新创建，其中的标量也会直接复制，而针对于使用对象中的指针或地址指向的类型，前者仅仅拷贝指向地址，而后者则是将指向的数据也拷贝一份至新的内存地址。<code>Foundation</code> 中的集合类型默认执行浅拷贝（因为集合类型内部的属性并不一定都能拷贝），因此自定义类中我们也默认是浅拷贝，必要时定义类似 <code>deepCoby</code> 方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Rectangle</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">assign</span>, <span style="color:#66d9ef">readonly</span>) <span style="color:#66d9ef">double</span> width;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">readonly</span>) <span style="color:#66d9ef">double</span> height;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>, <span style="color:#66d9ef">readonly</span>) NSArray<span style="color:#f92672">&lt;</span>Rectangle <span style="color:#f92672">*</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">*</span>array;

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">addElement:</span>(Rectangle <span style="color:#f92672">*</span>)element;
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">removeElement:</span>(Rectangle <span style="color:#f92672">*</span>)element;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Rectangle</span> ()
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">assign</span>, <span style="color:#66d9ef">readwrite</span>) <span style="color:#66d9ef">double</span> width;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">assign</span>) <span style="color:#66d9ef">double</span> height;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Rectangle</span> {
    NSMutableArray <span style="color:#f92672">*</span>_mutableArray;
}

- (NSArray <span style="color:#f92672">*</span>)<span style="color:#a6e22e">array</span> {
    <span style="color:#66d9ef">return</span> [_mutableArray <span style="color:#66d9ef">copy</span>];
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">addElement:</span>(Rectangle <span style="color:#f92672">*</span>)element {
    [_mutableArray addObject:element];
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">removeElement:</span>(Rectangle <span style="color:#f92672">*</span>)element {
    [_mutableArray removeObject:element];
}

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">initWithWidth:</span>(<span style="color:#66d9ef">double</span>)width <span style="color:#a6e22e">height:</span>(<span style="color:#66d9ef">double</span>)height {
    self <span style="color:#f92672">=</span> [super init];
    <span style="color:#66d9ef">if</span> (self) {
        _width <span style="color:#f92672">=</span> width;
        _height <span style="color:#f92672">=</span> height;
        _mutableArray <span style="color:#f92672">=</span> [NSMutableArray new];
    }
    <span style="color:#66d9ef">return</span> self;
}

- (<span style="color:#66d9ef">id</span>)<span style="color:#a6e22e">copyWithZone:</span>(nullable NSZone <span style="color:#f92672">*</span>)zone {
    Rectangle <span style="color:#f92672">*</span>rect <span style="color:#f92672">=</span> [[Rectangle allocWithZone:zone] initWithWidth:_width height:_height];
    rect<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>_mutableArray <span style="color:#f92672">=</span> [[NSMutableArray alloc] initWithArray:_mutableArray copyItems:YES]; <span style="color:#75715e">// 深拷贝
</span><span style="color:#75715e"></span><span style="color:#75715e">//    rect-&gt;_mutableArray = [_mutableArray mutableCopy]; // 浅拷贝
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> rect;
}
<span style="color:#66d9ef">@end</span>

Rectangle <span style="color:#f92672">*</span>rect <span style="color:#f92672">=</span> [[Rectangle alloc] initWithWidth:<span style="color:#ae81ff">5.0</span> height:<span style="color:#ae81ff">5.0</span>];
Rectangle <span style="color:#f92672">*</span>rect1 <span style="color:#f92672">=</span> [[Rectangle alloc] initWithWidth:<span style="color:#ae81ff">10.0</span> height:<span style="color:#ae81ff">10.0</span>];

[rect1 addElement:rect];

rect1.height <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
Rectangle <span style="color:#f92672">*</span>rect2 <span style="color:#f92672">=</span> [rect1 <span style="color:#66d9ef">copy</span>];
rect1.height <span style="color:#f92672">=</span> <span style="color:#ae81ff">200</span>;

NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">rect1.array - %@, rect2.array - %@</span><span style="color:#e6db74">&#34;</span>, [rect1 array], [rect2 array]);
NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">rect1.height - %f, rect2.height - %f</span><span style="color:#e6db74">&#34;</span>, rect1.height, rect2.height);
NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">rect1 - %@, rect2 - %@</span><span style="color:#e6db74">&#34;</span>, rect1, rect2);

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// 深拷贝（集合是新的集合，且集合内部元素为新元素）
</span><span style="color:#75715e"></span><span style="color:#75715e">// rect1.array - (
</span><span style="color:#75715e"></span><span style="color:#75715e">//     &#34;&lt;Rectangle: 0x101125d40&gt;&#34;
</span><span style="color:#75715e"></span><span style="color:#75715e">// ), rect2.array - (
</span><span style="color:#75715e"></span><span style="color:#75715e">//     &#34;&lt;Rectangle: 0x101126250&gt;&#34;
</span><span style="color:#75715e"></span><span style="color:#75715e">// )
</span><span style="color:#75715e"></span><span style="color:#75715e">// rect1.height - 200.000000, rect2.height - 100.000000
</span><span style="color:#75715e"></span><span style="color:#75715e">// rect1 - &lt;Rectangle: 0x101125e80&gt;, rect2 - &lt;Rectangle: 0x101125f70&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// 浅拷贝（集合是新的集合，但集合内部元素仍为原集合）
</span><span style="color:#75715e"></span><span style="color:#75715e">// rect1.array - (
</span><span style="color:#75715e"></span><span style="color:#75715e">//     &#34;&lt;Rectangle: 0x102a04010&gt;&#34;
</span><span style="color:#75715e"></span><span style="color:#75715e">// ), rect2.array - (
</span><span style="color:#75715e"></span><span style="color:#75715e">//     &#34;&lt;Rectangle: 0x102a04010&gt;&#34;
</span><span style="color:#75715e"></span><span style="color:#75715e">// )
</span><span style="color:#75715e"></span><span style="color:#75715e">// rect1.height - 200.000000, rect2.height - 100.000000
</span><span style="color:#75715e"></span><span style="color:#75715e">// rect1 - &lt;Rectangle: 0x102a04150&gt;, rect2 - &lt;Rectangle: 0x102a04240&gt;
</span></code></pre></div><p><img src="/img/2019/effective_obj-c_2.0_notes/3.png" alt="3"></p>
<p>上图取自苹果官方文档中 <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectCopying.html">Object copying - Cocoa Core Competencies</a> 一节。</p>
<h2 id="heading-17">协议与分类</h2>
<h3 id="heading-18">通过委托与数据源协议进行对象间通信</h3>
<p>为了避免循环引用（Retain Cycle），遵守代理（Delegate）协议对象的内存管理语义需设置为 <code>weak</code> 或 <code>unsafe_unretained</code>（关于两者区别详见本文《理解「属性」这一概念》一节），而非 <code>strong</code>。代理协议中的方法通常只会在类内部使用，因此可以在类扩展（注：本文中称之为 Class-Continuation Category）中声明实现即可。代理协议中的方法通常使用 <code>@optional</code> 标记为可选，因为遵守代理协议的对象并非一定关心其中所有的方法，所以在调用回代理上的方法时一定要先使用类型信息查询方法进行确认，为了避免重复性调用查询方法，可使用位域来缓存结果，关于位域可详见《<a href="../bit_field_union_in_cpp/">C/C++ 中的位域与共用体</a>》一文。代理协议中的方法通常将调用者本身作为参数传回，以便根据不同的调用者执行不同的逻辑。数据源（DataSource）中，数据从代理对象中流向类；而调用者中，数据从调用者中流出至代理对象：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">#</span><span style="color:#75715e">import &#34;ViewController.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">@class</span> <span style="color:#a6e22e">Foo</span>;
<span style="color:#66d9ef">@protocol</span> <span style="color:#a6e22e">FooDelegate</span> <span style="color:#f92672">&lt;</span>NSObject<span style="color:#f92672">&gt;</span>

<span style="color:#66d9ef">@optional</span>
<span style="color:#f92672">-</span> (<span style="color:#66d9ef">void</span>)foo:(Foo <span style="color:#f92672">*</span>)foo willLog:(NSString <span style="color:#f92672">*</span>)content;
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">foo:</span>(Foo <span style="color:#f92672">*</span>)foo <span style="color:#a6e22e">didLog:</span>(NSString <span style="color:#f92672">*</span>)content;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@protocol</span> <span style="color:#a6e22e">FooDataSource</span> <span style="color:#f92672">&lt;</span>NSObject<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">@required</span>
<span style="color:#f92672">-</span> (NSString <span style="color:#f92672">*</span>)logContent;
<span style="color:#66d9ef">@end</span>


<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo</span> : <span style="color:#a6e22e">NSObject</span> {
    <span style="color:#75715e">// 位域
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> {
        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> willLog :<span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> didLog  :<span style="color:#ae81ff">1</span>;
    } _delegateFlags;
}
<span style="color:#75715e">// 声明为 weak
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">weak</span>) <span style="color:#66d9ef">id</span> <span style="color:#f92672">&lt;</span>FooDelegate<span style="color:#f92672">&gt;</span> delegate;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">weak</span>) <span style="color:#66d9ef">id</span> <span style="color:#f92672">&lt;</span>FooDataSource<span style="color:#f92672">&gt;</span> dataSource;

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">refresh</span>;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">setDelegate:</span>(<span style="color:#66d9ef">id</span><span style="color:#f92672">&lt;</span>FooDelegate<span style="color:#f92672">&gt;</span>)delegate {
    _delegate <span style="color:#f92672">=</span> delegate;

    <span style="color:#75715e">// 避免多次调用 respondsToSelector:
</span><span style="color:#75715e"></span>    _delegateFlags.willLog <span style="color:#f92672">=</span> [_delegate respondsToSelector:<span style="color:#66d9ef">@selector</span>(foo:willLog:)];
    _delegateFlags.didLog <span style="color:#f92672">=</span> [_delegate respondsToSelector:<span style="color:#66d9ef">@selector</span>(foo:didLog:)];
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">refresh</span> {
    <span style="color:#75715e">// 数据源（DataSource）：数据 -&gt; 调用者
</span><span style="color:#75715e"></span>    NSString <span style="color:#f92672">*</span>content <span style="color:#f92672">=</span> [self.dataSource logContent];

    <span style="color:#75715e">// 检查代理是否实现可选协议
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ([_delegate respondsToSelector:<span style="color:#66d9ef">@selector</span>(foo:willLog:)]) {
        <span style="color:#75715e">// 代理（Delegate）：数据 -&gt; 代理对象
</span><span style="color:#75715e"></span>        [_delegate foo:self willLog:content];
    }

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">--------------------</span><span style="color:#e6db74">&#34;</span>);
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, content);
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">--------------------</span><span style="color:#e6db74">&#34;</span>);

    <span style="color:#66d9ef">if</span> (_delegateFlags.didLog) {
        [_delegate foo:self didLog:content];
    }
}
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">ViewController</span> () <span style="color:#f92672">&lt;</span>FooDelegate, FooDataSource<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>) Foo <span style="color:#f92672">*</span>foo;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>) Foo <span style="color:#f92672">*</span>foo2;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">ViewController</span>

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">viewDidLoad</span> {
    [super viewDidLoad];
    <span style="color:#75715e">// Do any additional setup after loading the view.
</span><span style="color:#75715e"></span>
    self.foo <span style="color:#f92672">=</span> [[Foo alloc] init];
    self.foo2 <span style="color:#f92672">=</span> [[Foo alloc] init];

    self.foo.delegate <span style="color:#f92672">=</span> self;
    self.foo.dataSource <span style="color:#f92672">=</span> self;

    self.foo2.delegate <span style="color:#f92672">=</span> self;
    self.foo2.dataSource <span style="color:#f92672">=</span> self;

    [self.foo refresh];
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">foo:</span>(Foo <span style="color:#f92672">*</span>)foo <span style="color:#a6e22e">willLog:</span>(NSString <span style="color:#f92672">*</span>)content {
    <span style="color:#66d9ef">if</span> (foo <span style="color:#f92672">=</span><span style="color:#f92672">=</span> _foo) {
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">foo - willLog - [%@]</span><span style="color:#e6db74">&#34;</span>, content);
    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (foo <span style="color:#f92672">=</span><span style="color:#f92672">=</span> _foo2) {
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">foo2 - willLog - [%@]</span><span style="color:#e6db74">&#34;</span>, content);
    }
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">foo:</span>(Foo <span style="color:#f92672">*</span>)foo <span style="color:#a6e22e">didLog:</span>(NSString <span style="color:#f92672">*</span>)content {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">willLog - [%@]</span><span style="color:#e6db74">&#34;</span>, content);
}

- (NSString <span style="color:#f92672">*</span>)<span style="color:#a6e22e">logContent</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">https://kingcos.me</span><span style="color:#e6db74">&#34;</span>;
}

<span style="color:#66d9ef">@end</span>

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// foo - willLog - [https://kingcos.me]
</span><span style="color:#75715e"></span><span style="color:#75715e">// --------------------
</span><span style="color:#75715e"></span><span style="color:#75715e">// https://kingcos.me
</span><span style="color:#75715e"></span><span style="color:#75715e">// --------------------
</span><span style="color:#75715e"></span><span style="color:#75715e">// willLog - [https://kingcos.me]
</span></code></pre></div><h3 id="heading-19">将类的实现代码分散到便于管理的数个分类之中</h3>
<p>使用分类机制可以将类的实现代码分成不同的功能块。比如 <code>NSURLRequest</code> 类提供向 URL 请求的功能，但从其命名中并不得知其使用的具体协议，而 HTTP 相关的方法定义在 <code>NSURLRequest</code> 的 <code>NSHTTPURLRequest</code> 分类中。<code>NSURLRequest</code> 中封装了一套操作 <code>CFURLRequest</code> 数据结构所需的 C 函数，且 Obj-C 并不支持方法的访问控制修饰符，将 <code>NSHTTPURLRequest</code> 定义为子类也不甚方便。定义在分类中的方法符号会带有分类信息，便于 Debug。通常，我们将无需暴露在外界的方法定义在带有 <code>Private</code> 的分类中，这样即使出现问题也能输出 <code>Private</code> 相关的信息。</p>
<h3 id="heading-20">总是为第三方的分类名称加前缀</h3>
<p>向第三方分类中添加分类时，应为分类名称加上特有前缀以区分；分类中的方法也要加上特有前缀以区分。关于分类（Category），可详见《<a href="../category_in_ios/">iOS 中的 Category</a>》一文。</p>
<h3 id="heading-21">勿在分类中声明属性</h3>
<p>分类中可以定义属性，但并不会生成成员变量以及 getter &amp; setter 的实现，因此建议在主接口或类扩展中封装所需的所有属性。</p>
<h3 id="class-continuation-">使用「class-continuation 分类」隐藏实现细节</h3>
<p>class-continuation 分类现在通常称之为类扩展。类扩展中之所以可以定义方法和实例变量，这是由于 ABI 稳固的机制。利用类扩展可以将一些接口声明在实现文件中，以对外隐藏。其中比较一个比较特别的用例是将所需的 C++ 类等使用声明在类扩展中，这样无需声明在头文件中，可以避免其它引入的类必须使用 Obj-C++ 语法（即 <code>.mm</code> 文件）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// CPPClass.hpp
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">ifndef CPPClass_hpp</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">define CPPClass_hpp</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CPPClass</span> {
    <span style="color:#66d9ef">int</span> foo;

<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    CPPClass(<span style="color:#66d9ef">int</span> foo);
};

<span style="color:#75715e">#</span><span style="color:#75715e">endif </span><span style="color:#75715e">/* CPPClass_hpp */</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// CPPClass.cpp
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&#34;CPPClass.hpp&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
CPPClass<span style="color:#f92672">:</span><span style="color:#f92672">:</span>CPPClass(<span style="color:#66d9ef">int</span> foo) {
    <span style="color:#66d9ef">this</span><span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>foo <span style="color:#f92672">=</span> foo;
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// ObjCPPClass.h
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">import &lt;Foundation</span><span style="color:#75715e">/</span><span style="color:#75715e">Foundation.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 直接引入 CPPClass 的声明
</span><span style="color:#75715e"></span><span style="color:#75715e">//#import &#34;CPPClass.h&#34;
</span><span style="color:#75715e"></span>
NS_ASSUME_NONNULL_BEGIN

<span style="color:#75715e">// 向前声明，class 仍是 C++ 的关键字
</span><span style="color:#75715e"></span><span style="color:#75715e">//class CPPClass;
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">ObjCPPClass</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#75715e">//{
</span><span style="color:#75715e"></span><span style="color:#75715e">//@private
</span><span style="color:#75715e"></span><span style="color:#75715e">//    CPPClass *_obj;
</span><span style="color:#75715e"></span><span style="color:#75715e">//}
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">@end</span>

NS_ASSUME_NONNULL_END

<span style="color:#75715e">// ObjCPPClass.mm
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">import &#34;ObjCPPClass.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">import &#34;CPPClass.hpp&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 使用类扩展将 C++ 类引入并声明使用
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">ObjCPPClass</span> () {
    CPPClass <span style="color:#f92672">*</span>_obj;
}
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">ObjCPPClass</span>

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">init</span>
{
    self <span style="color:#f92672">=</span> [super init];
    <span style="color:#66d9ef">if</span> (self) {
        _obj <span style="color:#f92672">=</span> new CPPClass(<span style="color:#ae81ff">100</span>);
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>_obj) self <span style="color:#f92672">=</span> nil;
    }
    <span style="color:#66d9ef">return</span> self;
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">dealloc</span>
{
    <span style="color:#75715e">// 手动销毁 _obj
</span><span style="color:#75715e"></span>    delete _obj;
}

<span style="color:#66d9ef">@end</span>
</code></pre></div><p>类扩展也可以将头文件中声明为 <code>readonly</code> 的属性重新使用 <code>readwrite</code> 声明，以在类内部使用；类扩展通常也用来声明遵循外界无需知晓的协议。</p>
<h3 id="heading-22">通过协议提供匿名对象</h3>
<p>在「通过委托与数据源协议进行对象间通信」一节中，<code>Foo</code> 的 <code>delegate</code> 所声明的类型为 <code>id &lt;FooDelegate&gt;</code>，即任何遵循 <code>FooDeelgate</code> 协议的类型即可，而非必须为某一具体类型，这种只限定协议的类的对象就是 Obj-C 中的匿名对象（Anonymous Object）。<code>NSDictionary</code> 中的键是 <code>id &lt;NSCopying&gt;</code> 类型，同理只要是遵循 <code>NSCopying</code> 协议的类的对象即可。使用匿名对象也可对外隐藏类型名称。</p>
<p>有时对象类型并不重要，重要的是对象有没有实现某些方法，即可使用匿名类型（Anonymous Type）来表达这一概念。即便实现代码总是使用固定的类，但仍然写成遵循某种协议的匿名类型，以表明类型在此并不重要。</p>
<h2 id="heading-23">内存管理</h2>
<h3 id="heading-24">理解引用计数</h3>
<p>Mac OS X 10.8 开始，垃圾回收（Garbage Collector）已经正式废弃，而 iOS 从未支持垃圾回收，一直使用引用计数（Reference Count，又称 Retain Count，保留计数）管理内存。在 MRC 下，<code>NSObject</code> 协议中的 <code>retain</code>、<code>release</code> 以及 <code>autorelease</code> 方法用来操作计数。当引用计数归零，系统将把对象占用的内存标记为可重用的。需要注意的是，这并不代表对象所占用的内存地址一定会被覆写，因此在引用计数降为 0 再调用时只是「可能」而非「一定」会崩溃。因此通常在 <code>release</code> 后将对象置为 <code>nil</code> 而避免悬挂指针（Dangling Pointer）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [[Foo alloc] init];
[foo <span style="color:#66d9ef">release</span>];
foo <span style="color:#f92672">=</span> nil; <span style="color:#75715e">// 将内存区域置为 nil，避免悬挂指针
</span></code></pre></div><p>属性存取方法中也需要注意引用计数相关：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// MRC
</span><span style="color:#75715e"></span>- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">setFoo:</span>(<span style="color:#66d9ef">id</span>)foo {
    <span style="color:#75715e">// 注意顺序：
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 当参数 foo 与成员变量 _foo 是同一对象时
</span><span style="color:#75715e"></span>    [foo <span style="color:#66d9ef">retain</span>];   <span style="color:#75715e">// 要先 retain 使得引用计数 +1
</span><span style="color:#75715e"></span>    [_foo <span style="color:#66d9ef">release</span>]; <span style="color:#75715e">// 防止对象提前释放导致实例变量将成为悬挂指针
</span><span style="color:#75715e"></span>    _foo <span style="color:#f92672">=</span> foo;
}
</code></pre></div><p>为了防止系统回收对象，但又要能在合适的时机释放，那么可以使用自动释放池延长对象生命周期：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// MRC
</span><span style="color:#75715e"></span>- (Foo <span style="color:#f92672">*</span>)<span style="color:#a6e22e">newFoo</span> {
    Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [[Foo alloc] init];
    <span style="color:#75715e">// autorelease 使得超过方法边界依然可以存活一段时间
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> [foo autorelease];
}

<span style="color:#75715e">// foo 可以存活
</span><span style="color:#75715e"></span>Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [self newFoo];
<span style="color:#75715e">// 但若要持有此对象，仍需手动保留、释放
</span><span style="color:#75715e"></span>_foo <span style="color:#f92672">=</span> [[self newFoo] <span style="color:#66d9ef">retain</span>];
<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>[_foo <span style="color:#66d9ef">release</span>];
</code></pre></div><p>引用计数的概念应当理解为所执行的操作对于计数本身是增加了还是消减了，而非刻意追求为某个值。另外需要注意的是，查询引用计数的方法 <code>retainCount</code> 不推荐使用。</p>
<h2 id="-arc-">以 ARC 简化引用计数</h2>
<p>ARC 下调用 <code>retain</code>、<code>release</code>、<code>autorelease</code>、<code>dealloc</code> 方法时并不通过 Obj-C 的消息发送机制，而是直接调用其底层的 C 语言版本，因而性能更好。在 Obj-C 中，以 <code>alloc</code>、<code>new</code>、<code>copy</code> 和 <code>mutableCopy</code> 开头的方法返回的对象归调用者所有，即调用这些方法的代码同样要负责释放；反之则不归调用者所有，需要在内部自己处理，因此返回的对象会自动释放，但外界希望保活则需要调用者再次保留：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// ARC
</span><span style="color:#75715e"></span>+ (Foo <span style="color:#f92672">*</span>)<span style="color:#a6e22e">newFoo</span> {
    Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [[Foo alloc] init];
    <span style="color:#66d9ef">return</span> foo; <span style="color:#75715e">// new 开头，本质即返回 foo
</span><span style="color:#75715e"></span>}

+ (Foo <span style="color:#f92672">*</span>)<span style="color:#a6e22e">someFoo</span> {
    Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [[Foo alloc] init];
    <span style="color:#66d9ef">return</span> foo; <span style="color:#75715e">// 非特定开头，本质即返回 [foo autorelease]
</span><span style="color:#75715e"></span>}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">bar</span> {
    Foo <span style="color:#f92672">*</span>foo1 <span style="color:#f92672">=</span> [Foo newFoo];
    Foo <span style="color:#f92672">*</span>foo2 <span style="color:#f92672">=</span> [Foo someFoo];

    <span style="color:#75715e">// 超过特定作用域下，变量将进行释放
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// foo1 由 newFoo 创造，因此需要手动 [foo1 release];
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// foo2 由 someFoo 创造，无需手动 release
</span><span style="color:#75715e"></span>}
</code></pre></div><p>ARC 有时会自动将同一个对象上的多次互相抵消的 <code>retain</code> 和 <code>release</code> 操作成对移除；ARC 也包括运行时组件来执行一些优化，以及需要考虑向后兼容性，以兼容使用 MRC 的代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// ARC 下，_foo 是一个强引用的成员变量，编译器设置其值时会额外执行 [foo retain]；
</span><span style="color:#75715e"></span>_foo <span style="color:#f92672">=</span> [Foo someFoo]; <span style="color:#75715e">// someFoo 返回一个新的 Foo 对象，且由于非特定开头，本质即返回 [foo autorelease]
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 以上等同于在 MRC 下：
</span><span style="color:#75715e"></span>Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [Foo someFoo]; <span style="color:#75715e">// return [foo autorelease];
</span><span style="color:#75715e"></span>_foo <span style="color:#f92672">=</span> [foo <span style="color:#66d9ef">retain</span>];

<span style="color:#75715e">// ARC 可以在运行时检测到以上 autorelease 后紧跟 retain 的这种多余操作（因为后续既然 retain，这里就无需 autorelease），
</span><span style="color:#75715e"></span><span style="color:#75715e">// 因此在方法中返回自动释放的对象时，改为执行 objc_autoreleaseReturnValue 函数：
</span><span style="color:#75715e"></span><span style="color:#75715e">// MRC：
</span><span style="color:#75715e"></span>+ (Foo <span style="color:#f92672">*</span>)<span style="color:#a6e22e">someFoo</span> {
    Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [[Foo alloc] init];
    <span style="color:#66d9ef">return</span> objc_autoreleaseReturnValue(foo);
}

Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [Foo someFoo]; <span style="color:#75715e">// return [foo autorelease];
</span><span style="color:#75715e"></span><span style="color:#75715e">// 改为执行 objc_retainAutoreleasedReturnValue 函数：
</span><span style="color:#75715e"></span>_foo <span style="color:#f92672">=</span> objc_retainAutoreleasedReturnValue(foo);

<span style="color:#75715e">// 伪代码
</span><span style="color:#75715e"></span><span style="color:#66d9ef">id</span> <span style="color:#a6e22e">objc_autoreleaseReturnValue</span>(<span style="color:#66d9ef">id</span> object) {
    <span style="color:#75715e">// 具体如何判断需根据处理器的原始机器码指令来判断
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#75715e">/* 若在调用后需在返回对象上执行 retain */</span>) {
        set_flag(object); <span style="color:#75715e">// 设置全局数据结构符号位
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> object; <span style="color:#75715e">// 返回对象本身
</span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span> [foo autorelease];
    }
}

<span style="color:#66d9ef">id</span> <span style="color:#a6e22e">objc_retainAutoreleasedReturnValue</span>(<span style="color:#66d9ef">id</span> object) {
    <span style="color:#66d9ef">if</span> (<span style="color:#75715e">/* 设置过全局数据结构符号位 */</span>) {
        clear_flag(object); <span style="color:#75715e">// 清除符号位
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> object; <span style="color:#75715e">// 返回对象本身
</span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span> [foo <span style="color:#66d9ef">retain</span>];
    }
}

<span style="color:#75715e">// 这样的好处是设置并检测标志位的速度要比调用 autorelease 和 retain 速度更快
</span></code></pre></div><p>ARC 会处理局部变量与实例变量的内存管理：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo</span> : <span style="color:#a6e22e">NSObject</span> {
    <span style="color:#66d9ef">id</span> <span style="color:#66d9ef">__strong</span> _strongObj; <span style="color:#75715e">// 默认，保留值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">id</span> <span style="color:#66d9ef">__weak</span> _weakObj;     <span style="color:#75715e">// 不保留值，但系统回收对象时会自动置为 nil
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">id</span> __unsafe_unretained _unsafeUnretainedObj; <span style="color:#75715e">// 不保留值，但系统回收对象时不会自动置为 nil，不安全
</span><span style="color:#75715e"></span><span style="color:#75715e">//    id __autoreleasing _autureleasingObj; // __autoreleasing 不能直接声明成员变量使用
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 使得值可以在方法返回后自动释放（无需在外界关心其是否释放）
</span><span style="color:#75715e"></span>- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">fooWithParam:</span>(<span style="color:#66d9ef">id</span> <span style="color:#66d9ef">__autoreleasing</span> <span style="color:#f92672">*</span>)_autureleasingObj;
<span style="color:#66d9ef">@end</span>
</code></pre></div><p>ARC 也负责对实例变量的内存管理：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// MRC 下需手动清理
</span><span style="color:#75715e"></span>- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">dealloc</span> {
    [_foo <span style="color:#66d9ef">release</span>];  <span style="color:#75715e">// 释放所有强引用变量
</span><span style="color:#75715e"></span>    [super dealloc]; <span style="color:#75715e">// 调用父类方法
</span><span style="color:#75715e"></span>}
</code></pre></div><p>ARC 下编译器若发现某个对象里含有 C++ 对象，就会生成名为 <code>.cxx_destruct</code> 方法来调用所有 C++ 对象的析构函数；非 Obj-C 对象则仍然需要清理，ARC 会自动在 <code>.cxx_destruct</code> 方法中生成代码并运行，其中会自动调用父类的 <code>dealloc</code> 方法，因此不能再直接调用父类的 <code>dealloc</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// ARC
</span><span style="color:#75715e"></span>- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">dealloc</span> {
    CFRelease(_coreFoundationObject); <span style="color:#75715e">// 手动释放 CoreFoundation 中的对象
</span><span style="color:#75715e"></span>    free(_heapAllocatedMemoryBlob);   <span style="color:#75715e">// 手动释放 malloc() 分配在堆中的内存
</span><span style="color:#75715e"></span>}
</code></pre></div><p>MRC 下为了实现单例可以将 <code>release</code> 方法替换为空操作即可；但在 ARC 不可这样操作，因为这将干扰 ARC 本身。</p>
<h3 id="-dealloc-">在 dealloc 方法中只释放引用并解除监听</h3>
<p>上一节中也提到了一些在 <code>dealloc</code> 方法中所应执行的操作，本节不再赘述。另外还要在其中将当前对象的 <code>NSNotificationCenter</code> 观察者移除，否则在其它地方发送通知时，接收者却已经销毁，将引发崩溃。</p>
<p>需要注意的是，<code>dealloc</code> 中并不建议释放开销较大的资源，因为其调用的具体时机我们无法把握，从而容易导致出现内存泄漏。而建议是将释放方法独立，并由开发者保证在不使用资源时释放资源。但为了防止开发者忘记释放资源，我们仍可以在 <code>dealloc</code> 中根据是否释放过而去兜底释放资源，也可抛出异常。另外系统也不能保证每个对象的 <code>dealloc</code> 方法最终都会被调用，即程序终止时某些对象的 <code>dealloc</code> 方法系统可能就不再去调用了，因此当需要在程序终止时清理某些对象时，可以在 <code>AppDelegate</code> 中的相关方法中操作。</p>
<p><code>dealloc</code> 方法调用时，对象的生命周期已经接近尾声，此时不应随便调用其它方法，尤其是异步方法、特定线程方法、属性 getter &amp; setter：</p>
<ol>
<li>异步方法：当异步方法执行完毕时，系统已经将待回收对象彻底销毁，这将可能导致很多问题；</li>
<li>特定线程方法：调用 <code>dealloc</code> 方法的所在线程将执行最终的释放操作，令对象的引用计数归零；而某些方法必须在特定的线程里（比如主线程里）调用，但此时已经无法保证其会在正确的线程上正确运行，因为对象已经处于正在回收的状态；为指明此状况，运行时系统已经改动了对象的内部数据结构；</li>
<li>属性 getter &amp; setter：getter &amp; setter 有可能会被重写，其中可能会做一些不受控制的操作；另外如果对象的属性处于 KVO 下，此时的改变将使用到即将回收的对象，这将可能导致很多问题。</li>
</ol>
<h3 id="heading-25">编写「异常安全代码时」留意内存管理问题</h3>
<p>纯 C 中不支持异常（Exception），而 C++ 和 Obj-C 均支持异常，且在 Xcode 中两者的异常是互相兼容的（可以互相捕获）。异常安全的代码使得异常抛出但并不会影响程序的继续运行，但这里就会出现内存管理的问题：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">ExceptionMaker</span> : <span style="color:#a6e22e">NSObject</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">generate</span>;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">ExceptionMaker</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">generate</span> {
    <span style="color:#66d9ef">@throw</span> [NSException exceptionWithName:NSInternalInconsistencyException
                                   reason:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">Just generate one exception!</span><span style="color:#e6db74">&#34;</span>
                                 userInfo:nil];
}
<span style="color:#66d9ef">@end</span>

<span style="color:#75715e">// MRC 下：
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@try</span> {
    ExceptionMaker <span style="color:#f92672">*</span>maker <span style="color:#f92672">=</span> [ExceptionMaker new];
    [maker generate];
    [maker <span style="color:#66d9ef">release</span>]; <span style="color:#75715e">// 当异常发生，此行代码将直接跳过，将导致内存泄漏
</span><span style="color:#75715e"></span>} <span style="color:#66d9ef">@catch</span> (NSException <span style="color:#f92672">*</span>excpetion) {
    <span style="color:#75715e">// Do sth with exception
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// ⬇️
</span><span style="color:#75715e"></span>
ExceptionMaker <span style="color:#f92672">*</span>maker;
<span style="color:#66d9ef">@try</span> {
    maker <span style="color:#f92672">=</span> [ExceptionMaker new];
    [maker generate];
} <span style="color:#66d9ef">@catch</span> (NSException <span style="color:#f92672">*</span>excpetion) {
    <span style="color:#75715e">// Do sth with exception
</span><span style="color:#75715e"></span>} <span style="color:#66d9ef">@finally</span> {
    <span style="color:#75715e">// 无论如何，最终均执行释放
</span><span style="color:#75715e"></span>    [maker <span style="color:#66d9ef">release</span>];
}
</code></pre></div><p>ARC 下，内存问题则更加严重：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@try</span> {
    <span style="color:#75715e">// ARC 下这样写很自然，但 maker 定义在当前块内，无法在 finally 中释放
</span><span style="color:#75715e"></span>    ExceptionMaker <span style="color:#f92672">*</span>maker <span style="color:#f92672">=</span> [ExceptionMaker new];
    [maker generate];
} <span style="color:#66d9ef">@catch</span> (NSException <span style="color:#f92672">*</span>excpetion) {
    <span style="color:#75715e">// Do sth with exception
</span><span style="color:#75715e"></span>}
</code></pre></div><p>ARC 下如果要自动处理则需要加入大量样板代码来跟踪待清理的对象，这样的弊端是会影响运行时性能，且会明显增大应用程序的大小，因此该自动处理默认是关闭的。但我们仍然可以通过 <code>-fobjc-arc-expection</code> 编译器标志来开启自动处理。如上文「理解 Objective-C 错误模型」一节中所述，默认不开启自动处理的原因是异常通常是发生严重错误终止程序才应抛出，自然也就无需再考虑内存泄漏问题。如果程序中有许多异常捕获操作时，应当考虑使用 <code>NSError</code> 来进行取代。</p>
<p>另外在 Obj-C++ 模式时，编译器将自动打开 <code>-fobjc-arc-expection</code> 标志。这是因为 C++ 处理异常所用的代码与 ARC 实现的附加代码类似，因此 ARC 加入样板代码来安全处理异常所造成的性能损失可以接受，且 C++/Obj-C++ 可能需要频繁使用异常。</p>
<h3 id="heading-26">以弱引用避免保留环</h3>
<p><code>weak</code> 弱引用可以自动清空，也可不自动清空。自动清空（Autonilling）是随着 ARC 引入的新特性，由运行时实现。</p>
<h3 id="heading-27">以「自动释放池块」降低内存峰值</h3>
<p>自动释放池（Autorelease Pool）用于存放那些需要在稍后某个时刻释放的对象，清空自动释放池时，系统会向其中的对象发送 <code>release</code> 消息。GCD 机制中的线程默认都有自动释放池，每次执行事件循环（Event Loop）时，就会将其清空，因此这里我们不需要自己创建；通常只有在程序的 <code>main</code> 函数入口创建：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// main.m
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Xcode 11 前
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">@autoreleasepool</span> {
        <span style="color:#66d9ef">return</span> UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate <span style="color:#66d9ef">class</span>]));
    }
    <span style="color:#75715e">// 自动释放池的末尾即程序的终止处，此时操作系统会把程序所占的所有内存释放；
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 若不写明则 UIApplicationMain 函数中所需自动释放的对象就没有自动释放池容纳了，系统将有警告来提示；
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这个池可以理解成最外围全部自动释放对象所用的池。
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// Xcode 11
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    NSString <span style="color:#f92672">*</span> appDelegateClassName;
    <span style="color:#66d9ef">@autoreleasepool</span> {
        <span style="color:#75715e">// Setup code that might create autoreleased objects goes here.
</span><span style="color:#75715e"></span>        appDelegateClassName <span style="color:#f92672">=</span> NSStringFromClass([AppDelegate <span style="color:#66d9ef">class</span>]);
    }
    <span style="color:#66d9ef">return</span> UIApplicationMain(argc, argv, nil, appDelegateClassName);
}
</code></pre></div><p>自动释放池可以嵌套：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@autoreleasepool</span> { <span style="color:#75715e">// A
</span><span style="color:#75715e"></span>    NSString <span style="color:#f92672">*</span>string <span style="color:#f92672">=</span> [NSString stringWithFormat:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">kingcos.me</span><span style="color:#e6db74">&#34;</span>];
    <span style="color:#66d9ef">@autoreleasepool</span> { <span style="color:#75715e">// B
</span><span style="color:#75715e"></span>        NSNumber <span style="color:#f92672">*</span>number <span style="color:#f92672">=</span> [NSNumber numberWithInt:<span style="color:#ae81ff">1</span>];
    } <span style="color:#75715e">// B Pool 自动清空，number 收到 release 消息
</span><span style="color:#75715e"></span>} <span style="color:#75715e">// A Pool 自动清空，string 收到 release 消息
</span></code></pre></div><p>自动释放池可以用来降低内存峰值（High-Memory Waterline）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">NSMutableArray <span style="color:#f92672">*</span>arr <span style="color:#f92672">=</span> [NSMutableArray new];
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10000000</span>; i <span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
    <span style="color:#66d9ef">@autoreleasepool</span> { <span style="color:#75715e">// 内部自动释放的对象将放在该池中，而非线程的主池中
</span><span style="color:#75715e"></span>        Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [self generate]; <span style="color:#75715e">// 若不加 @autoreleasepool 将在 for 循环结束后释放，内存占用将持续上涨
</span><span style="color:#75715e"></span>        [arr addObject:foo];
    }
}

<span style="color:#75715e">// MRC 下的 NSAutoreleasePool
</span><span style="color:#75715e"></span>NSMutableArray <span style="color:#f92672">*</span>arr <span style="color:#f92672">=</span> [NSMutableArray new];
NSAutoreleasePool <span style="color:#f92672">*</span>pool <span style="color:#f92672">=</span> [[NSAutoreleasePool alloc] init];
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10000000</span>; i <span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
    Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [self <span style="color:#66d9ef">do</span>];
    [arr addObject:foo];

    <span style="color:#75715e">// 每隔 10 次释放一次
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
        [pool drain];
    }
}
<span style="color:#75715e">// 防止未释放，再手动释放一次
</span><span style="color:#75715e"></span>[pool drain];

<span style="color:#75715e">// @autoreleasepool 语法较于 NSAutoreleasePool 更好的是范围的缺点，避免了在自动释放池清空后再次使用相关对象
</span><span style="color:#75715e"></span>
- (Foo <span style="color:#f92672">*</span>)<span style="color:#a6e22e">generate</span> {
    Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [[Foo alloc] init];
    <span style="color:#75715e">// 放入自动释放池中
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> [foo autorelease];
}
</code></pre></div><p>自动释放池机制类似栈，内部需要放入自动释放池的对象将入栈，而清空自动释放池则相当于将其出栈。自动释放池的建立会带来一定开销，具体是否用来优化效率，需取决于具体情况。</p>
<h3 id="heading-28">用「僵尸对象」调试内存管理问题</h3>
<p>「僵尸对象」功能指的是在运行时系统会将所有已回收的对象转化为僵尸对象，当其再次收到消息时将抛出异常。我们可以在 Xcode - Edit Schemes - Memory Management - Zombie Objects 来开启该功能：</p>
<p><img src="/img/2019/effective_obj-c_2.0_notes/2.png" alt="2"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">Bar <span style="color:#f92672">*</span>bar <span style="color:#f92672">=</span> [[Bar alloc] init];
<span style="color:#75715e">// 1: Bar *
</span><span style="color:#75715e"></span>[bar <span style="color:#66d9ef">release</span>];
<span style="color:#75715e">// 2: _NSZombie_Bar *
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// LLDB:
</span><span style="color:#75715e"></span><span style="color:#75715e">// (lldb) p bar
</span><span style="color:#75715e"></span><span style="color:#75715e">// (Bar *) $0 = 0x00006000009dc040
</span><span style="color:#75715e"></span><span style="color:#75715e">// (lldb) p bar
</span><span style="color:#75715e"></span><span style="color:#75715e">// (_NSZombie_Bar *) $1 = 0x00006000009dc040
</span><span style="color:#75715e"></span><span style="color:#75715e">// (lldb)
</span></code></pre></div><p>僵尸类是从名为 <code>_NSZombie_</code> 的模版类里复制出来的，创建并复制新的僵尸类原因在于，僵尸对象发送消息时，可由此得知该对象原本所属的类型。创建继承自 <code>_NSZombie_</code> 的子类也可行，但效率低于拷贝。伪代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// 伪代码
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 运行时若发现 NSZombieEnabled 环境变量已经设置，将对对象的 dealloc 方法交换为以下方法：
</span><span style="color:#75715e"></span>- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">zombieDealloc</span> {
    <span style="color:#75715e">// 获取将要释放的对象的类对象
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">Class</span> cls <span style="color:#f92672">=</span> object_getClass(self);
    <span style="color:#75715e">// 获取类名
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>clsName <span style="color:#f92672">=</span> class_getName(cls);
    <span style="color:#75715e">// 生成新类名
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>zombieClsName <span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">_NSZombie_</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> clsName;
    <span style="color:#75715e">// 查找是否存在该僵尸类
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">Class</span> zombieCls <span style="color:#f92672">=</span> objc_lookUpClass(zombieClsName);
    <span style="color:#75715e">// 若不存在则需创建
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>zombieCls) {
        <span style="color:#75715e">// 获取僵尸基类（使得后续可得知对象所属的类）
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">Class</span> baseZombieCls <span style="color:#f92672">=</span> objc_lookUpClass(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">_NSZombie_</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#75715e">// 复制僵尸基类为新类名即修改 isa 指针（拷贝而非创建子类的效率更高）
</span><span style="color:#75715e"></span>        zombieCls <span style="color:#f92672">=</span> objc_duplicateClass(baseZombieCls, zombieClsName, <span style="color:#ae81ff">0</span>)
    }
    <span style="color:#75715e">// 执行正常的销毁操作
</span><span style="color:#75715e"></span>    objc_destructInstance(self);
    <span style="color:#75715e">// 将要销毁的对象的类型设置为僵尸类
</span><span style="color:#75715e"></span>    objc_setClass(self, zombieCls);

    <span style="color:#75715e">// 关键之处在于对象本身并未通过 free() 被释放，虽然会内存泄漏，但该功能仅仅在调试阶段开启，可以忽略
</span><span style="color:#75715e"></span>}
</code></pre></div><p><code>_NSZombie_</code> 模版类中并未实现任何方法，且没有超类（类似 <code>NSObject</code>），仅有一个 <code>isa</code> 成员变量，因此发送给该僵尸对象的消息需经由完整的消息转发机制。而完整的消息转发机制中，<code>___forwarding___</code> 是核心，其要检查接受消息的对象所属的类名，若前缀为 <code>_NSZombie_</code> 则消息接收者为僵尸对象，需特殊处理，即打印相关信息并终止程序。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// 获取将要释放的对象的类对象
</span><span style="color:#75715e"></span><span style="color:#66d9ef">Class</span> cls <span style="color:#f92672">=</span> object_getClass(self);
<span style="color:#75715e">// 获取类名
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>clsName <span style="color:#f92672">=</span> class_getName(cls);
<span style="color:#75715e">// 确定是否为僵尸类型
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (string_has_prefix(clsName, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">_NSZombie_</span><span style="color:#e6db74">&#34;</span>)) {
    <span style="color:#75715e">// 截取原始类名
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>originalClsName <span style="color:#f92672">=</span> substring_from(clsName, <span style="color:#ae81ff">10</span>);
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>selectorName <span style="color:#f92672">=</span> sel_getName(_cmd);

    <span style="color:#75715e">// 打印相关信息
</span><span style="color:#75715e"></span>    Log(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">*** -[%s %s]: message sent to deallocated instance %p</span><span style="color:#e6db74">&#34;</span>, originalClsName, selectorName, self);

    <span style="color:#75715e">// 终止程序
</span><span style="color:#75715e"></span>    abort();
}
</code></pre></div><h3 id="-retaincount">不要使用 retainCount</h3>
<p><code>retainCount</code> 是 MRC 下的方法，用来获取对象的引用计数，但其实引用计数的具体值开发者不应特别关心。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// MRC
</span><span style="color:#75715e"></span><span style="color:#66d9ef">while</span> ([obj retainCount]) {
    [obj <span style="color:#66d9ef">release</span>];
}
</code></pre></div><p>以上的写法是错误的：</p>
<ol>
<li><code>retainCount</code> 方法并不会考虑到 <code>autorelease</code> 的情况，因此当跳出循环时引用计数确实归 0，但此时若自动释放池再次进行释放时将导致程序崩溃；</li>
<li><code>retainCount</code> 方法可能永远不返回 <code>0</code>，系统有时会优化对象的释放行为（即使引用计数为 1 时就可能被回收），如果对象已经被回收，但仍然进入循环进行释放，将同样导致程序崩溃。</li>
</ol>
<p>因此，释放对象不应当通过引用计数来判断，而是应该找清楚哪里仍对对象进行了持有，通过内存管理解决问题。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// 64 bit macOS
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 单例对象（编译期常量，编译器将该数据直接放在可执行文件中即可无需创建对象）引用计数不会变
</span><span style="color:#75715e"></span>NSString <span style="color:#f92672">*</span>str1 <span style="color:#f92672">=</span> <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">kingcos.me</span><span style="color:#e6db74">&#34;</span>;
<span style="color:#75715e">// 18446744073709551615
</span><span style="color:#75715e"></span>NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)[str1 retainCount]);

<span style="color:#75715e">// 单例对象（标签指针，运行时在消息派发期间检测并执行相应操作）
</span><span style="color:#75715e"></span>NSNumber <span style="color:#f92672">*</span>num1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">@1</span>;
<span style="color:#75715e">// 9223372036854775807
</span><span style="color:#75715e"></span>NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)[num1 retainCount]);

<span style="color:#75715e">// NSNumber 浮点数没有此类优化
</span><span style="color:#75715e"></span>NSNumber <span style="color:#f92672">*</span>num2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">@3.14</span>;
<span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)[num2 retainCount]);
</code></pre></div><p>综上不建议使用 <code>retainCount</code> 方法。</p>
<h2 id="heading-29">块与大中枢派发</h2>
<h3 id="heading-30">理解「块」这一概念</h3>
<p>略；关于 Block，可详见《<a href="../block_in_obj-c">Obj-C 中的 Block</a>》一文。</p>
<h3 id="-typedef">为常用的块类型创建 <code>typedef</code></h3>
<p>略；关于 Block，可详见《<a href="../block_in_obj-c">Obj-C 中的 Block</a>》一文。</p>
<h3 id="-handler-">用 handler 块降低代码分散程度</h3>
<p>略；关于 Block，可详见《<a href="../block_in_obj-c">Obj-C 中的 Block</a>》一文。</p>
<h3 id="heading-31">用块引用其所属对象时不要出现保留环</h3>
<p>略；关于 Block，可详见《<a href="../block_in_obj-c">Obj-C 中的 Block</a>》一文。</p>
<h3 id="heading-32">多用派发队列，少用同步锁</h3>
<h3 id="-gcd-performselector-">多用 GCD，少用 performSelector 系列方法</h3>
<h3 id="-gcd-">掌握 GCD 及操作队列的时机</h3>
<h3 id="-dispatch-group-">通过 Dispatch Group 机制，根据系统资源状况来执行任务</h3>
<h3 id="-dispatch-once-">使用 dispatch_once 来执行只需运行一次的线程安全代码</h3>
<h3 id="-dispatch-get-current-queue">不要使用 dispatch_get_current_queue</h3>
<h2 id="heading-33">系统框架</h2>
<h3 id="heading-34">熟悉系统框架</h3>
<p>略。</p>
<h3 id="-for-">多用块枚举，少用 for 循环</h3>
<p>遍历集合的方式有如下四种，之后可能会将此部分单独总结，此处不再赘述：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// 1⃣️ FOR-LOOP
</span><span style="color:#75715e"></span>NSDictionary <span style="color:#f92672">*</span>dict <span style="color:#f92672">=</span> <span style="color:#ae81ff">@{</span><span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">A</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">a</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">B</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">C</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">c</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">kingcos.me</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">github.com/kingcos</span><span style="color:#e6db74">&#34;</span>,<span style="color:#ae81ff">}</span>;
NSArray <span style="color:#f92672">*</span>allKeys <span style="color:#f92672">=</span> [dict allKeys]; <span style="color:#75715e">// ⚠️：NSDictionary &amp; NSSet 的元素是无序的
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> allKeys.count; i <span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">&lt;%@, %@&gt;</span><span style="color:#e6db74">&#34;</span>, allKeys[i], dict[allKeys[i]]);
}

<span style="color:#75715e">// - 倒序
</span><span style="color:#75715e"></span>NSArray <span style="color:#f92672">*</span>arr <span style="color:#f92672">=</span> <span style="color:#ae81ff">@[</span><span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">A</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">kingcos.me</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">github.com/kingcos</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">]</span>;
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)arr.count <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">-</span><span style="color:#f92672">-</span>) {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">&lt;%@&gt;</span><span style="color:#e6db74">&#34;</span>, arr[i]);
}

<span style="color:#75715e">// 2⃣️ ENUMERATOR
</span><span style="color:#75715e"></span>NSEnumerator <span style="color:#f92672">*</span>dictEnumerator <span style="color:#f92672">=</span> [dict keyEnumerator];
<span style="color:#66d9ef">id</span> dictNextObj;
<span style="color:#66d9ef">while</span> ((dictNextObj <span style="color:#f92672">=</span> [dictEnumerator nextObject]) <span style="color:#f92672">!</span><span style="color:#f92672">=</span> nil) {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">&lt;%@, %@&gt;</span><span style="color:#e6db74">&#34;</span>, dictNextObj, dict[dictNextObj]);
}

<span style="color:#75715e">// - 倒序
</span><span style="color:#75715e"></span>NSEnumerator <span style="color:#f92672">*</span>arrReversedEnumerator <span style="color:#f92672">=</span> [arr reverseObjectEnumerator];
<span style="color:#66d9ef">id</span> arrNextObj;
<span style="color:#66d9ef">while</span> ((arrNextObj <span style="color:#f92672">=</span> [arrReversedEnumerator nextObject]) <span style="color:#f92672">!</span><span style="color:#f92672">=</span> nil) {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">&lt;%@&gt;</span><span style="color:#e6db74">&#34;</span>, arrNextObj);
}

<span style="color:#75715e">// 3⃣️ FAST-ENUMERATION
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">id</span> obj <span style="color:#66d9ef">in</span> arr) {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">&lt;%@&gt;</span><span style="color:#e6db74">&#34;</span>, obj);
}

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">id</span> obj <span style="color:#66d9ef">in</span> [arr reverseObjectEnumerator]) {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">&lt;%@&gt;</span><span style="color:#e6db74">&#34;</span>, obj);
}

<span style="color:#75715e">// - 自定义类型也可支持快速遍历：
</span><span style="color:#75715e"></span><span style="color:#75715e">//   1. 继承 NSEnumerator 抽象基类，并实现 allObjects &amp; nextObject
</span><span style="color:#75715e"></span><span style="color:#75715e">//   2. 遵守 NSFastEnumeration 协议，并实现 countByEnumeratingWithState:objects:count:
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 4⃣️ 基于 Block
</span><span style="color:#75715e"></span><span style="color:#75715e">// 字典键值同时读取；id 类型使得可以修改方法签名，避免类型转换
</span><span style="color:#75715e"></span>[dict enumerateKeysAndObjectsUsingBlock:<span style="color:#f92672">^</span>(<span style="color:#66d9ef">id</span>  _Nonnull key,
                                          NSString <span style="color:#f92672">*</span> _Nonnull obj,
                                          <span style="color:#66d9ef">BOOL</span> <span style="color:#f92672">*</span> _Nonnull stop) {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">&lt;%@, %@&gt;</span><span style="color:#e6db74">&#34;</span>, key, obj);

    <span style="color:#66d9ef">if</span> ([obj isEqualToString:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">github.com/kingcos</span><span style="color:#e6db74">&#34;</span>]) {
        <span style="color:#75715e">// 可在内部终止
</span><span style="color:#75715e"></span>        <span style="color:#f92672">*</span>stop <span style="color:#f92672">=</span> YES;
    }
}];

<span style="color:#75715e">// NSEnumerationOptions 是枚举
</span><span style="color:#75715e"></span><span style="color:#75715e">// typedef NS_OPTIONS(NSUInteger, NSEnumerationOptions) {
</span><span style="color:#75715e"></span><span style="color:#75715e">//     NSEnumerationConcurrent = (1UL &lt;&lt; 0), // Block 可以并行执行
</span><span style="color:#75715e"></span><span style="color:#75715e">//     NSEnumerationReverse = (1UL &lt;&lt; 1),    // 倒序（仅支持有序的集合结构）
</span><span style="color:#75715e"></span><span style="color:#75715e">// };
</span><span style="color:#75715e"></span>
[arr enumerateObjectsWithOptions:NSEnumerationReverse
                      usingBlock:<span style="color:#f92672">^</span>(NSString <span style="color:#f92672">*</span> _Nonnull obj,
                                   NSUInteger idx,
                                   <span style="color:#66d9ef">BOOL</span> <span style="color:#f92672">*</span> _Nonnull stop) {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">&lt;%@&gt;</span><span style="color:#e6db74">&#34;</span>, obj);
}];
</code></pre></div><!-- https://www.cnblogs.com/zenny-chen/p/3593106.html

http://blog.leichunfeng.com/blog/2016/06/20/objective-c-fast-enumeration-implementation-principle/

https://zhuanlan.zhihu.com/p/25837870

https://www.jianshu.com/p/2ec49d525871 -->
<ul>
<li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Collections/Articles/Enumerators.html">Enumeration: Traversing a Collection’s Elements - Collections Programming Topics</a></li>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2010-04-09-comparison-of-objective-c-enumeration-techniques.html">Friday Q&amp;A 2010-04-09: Comparison of Objective-C Enumeration Techniques - Mike Ash</a></li>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2010-04-16-implementing-fast-enumeration.html">Friday Q&amp;A 2010-04-16: Implementing Fast Enumeration - Mike Ash</a></li>
</ul>
<h3 id="-collection-">对自定义其内存管理语义的 collection 使用无缝桥接</h3>
<p>无缝桥接（Toll-Free Bridging）使得 <code>Foundation</code> 框架中的 Obj-C 类型可以与 <code>CoreFoundation</code> 框架里的 C 语言数据结构之间可以平滑转换。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">NSArray <span style="color:#f92672">*</span>arr <span style="color:#f92672">=</span> <span style="color:#ae81ff">@[</span><span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">A</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">kingcos.me</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">github.com/kingcos</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">]</span>;

CFArrayRef cfArray1 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">__bridge</span> CFArrayRef)arr;
NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%li</span><span style="color:#e6db74">&#34;</span>, CFArrayGetCount(cfArray1));

CFArrayRef cfArray2 <span style="color:#f92672">=</span> (__bridge_retained CFArrayRef)arr;
NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%li</span><span style="color:#e6db74">&#34;</span>, CFArrayGetCount(cfArray2));
CFRelease(cfArray2); <span style="color:#75715e">// 释放
</span><span style="color:#75715e"></span>
CFArrayRef cfArray3 <span style="color:#f92672">=</span> (__bridge_retained CFArrayRef)arr;
NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%li</span><span style="color:#e6db74">&#34;</span>, CFArrayGetCount(cfArray3));
arr <span style="color:#f92672">=</span> (<span style="color:#66d9ef">__bridge_transfer</span> NSArray <span style="color:#f92672">*</span>)cfArray3;

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// 3
</span><span style="color:#75715e"></span><span style="color:#75715e">// 3
</span><span style="color:#75715e"></span><span style="color:#75715e">// 3
</span></code></pre></div><ul>
<li>桥式转换（Bridged Cast）
<ul>
<li><code>__bridge</code>：仅桥接，ARC 仍拥有 Obj-C 对象所有权；</li>
<li><code>__bridge_retained</code>：桥接且持有，ARC 不再拥有对象所有权，交由 <code>CoreFoundation</code> 处理；</li>
<li><code>__bridge_transfer</code>：桥接且转换，ARC 再次拥有对象所有权。</li>
</ul>
</li>
</ul>
<p><code>Foundation</code> 框架与 <code>CoreFoundation</code> 框架的某些功能可以互相补足。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// CFDictionary.h
</span><span style="color:#75715e"></span>CFMutableDictionaryRef <span style="color:#a6e22e">CFDictionaryCreateMutable</span>(CFAllocatorRef allocator, <span style="color:#75715e">// 内存分配器，传 NULL 为默认实现
</span><span style="color:#75715e"></span>                                                 CFIndex capacity,         <span style="color:#75715e">// 初始容量
</span><span style="color:#75715e"></span>                                                 <span style="color:#66d9ef">const</span> CFDictionaryKeyCallBacks <span style="color:#f92672">*</span>keyCallBacks, <span style="color:#75715e">// 指向结构体的指针
</span><span style="color:#75715e"></span>                                                 <span style="color:#66d9ef">const</span> CFDictionaryValueCallBacks <span style="color:#f92672">*</span>valueCallBacks); <span style="color:#75715e">// 同上
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
    CFIndex                version;           <span style="color:#75715e">// 版本号，通常设置为 0
</span><span style="color:#75715e"></span>    CFDictionaryRetainCallBack        <span style="color:#66d9ef">retain</span>; <span style="color:#75715e">// 当事件发送，通过函数指针调用，下同
</span><span style="color:#75715e"></span>    CFDictionaryReleaseCallBack        <span style="color:#66d9ef">release</span>;
    CFDictionaryCopyDescriptionCallBack    copyDescription;
    CFDictionaryEqualCallBack        equal;
    CFDictionaryHashCallBack        hash;
} CFDictionaryKeyCallBacks;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
    CFIndex                version;
    CFDictionaryRetainCallBack        <span style="color:#66d9ef">retain</span>;
    CFDictionaryReleaseCallBack        <span style="color:#66d9ef">release</span>;
    CFDictionaryCopyDescriptionCallBack    copyDescription;
    CFDictionaryEqualCallBack        equal;
} CFDictionaryValueCallBacks;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>    (<span style="color:#f92672">*</span>CFDictionaryRetainCallBack)(CFAllocatorRef allocator, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value);
<span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">void</span>        (<span style="color:#f92672">*</span>CFDictionaryReleaseCallBack)(CFAllocatorRef allocator, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value);
<span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">CFStringRef</span>    (<span style="color:#f92672">*</span>CFDictionaryCopyDescriptionCallBack)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value);
<span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">Boolean</span>        (<span style="color:#f92672">*</span>CFDictionaryEqualCallBack)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value1, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value2);
<span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">CFHashCode</span>    (<span style="color:#f92672">*</span>CFDictionaryHashCallBack)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value);
</code></pre></div><p>比如 <code>Foundation</code> 中的字典对象的键内存管理语义为拷贝，值内存管理语义为保留，那么在键如果是自定义对象则需要遵守 <code>NSCopying</code> 协议。但我们可以在 <code>CoreFoundation</code> 层创建并修改内存管理语义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">DictRetainCallBack</span>(CFAllocatorRef allocator, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value) {
    <span style="color:#66d9ef">return</span> CFRetain(value);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DictReleaseCallBack</span>(CFAllocatorRef allocator, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value) {
    CFRelease(value);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">@autoreleasepool</span> {
        CFDictionaryKeyCallBacks keyCallbacks <span style="color:#f92672">=</span> {
            <span style="color:#ae81ff">0</span>,                   <span style="color:#75715e">// version
</span><span style="color:#75715e"></span>            DictRetainCallBack,  <span style="color:#75715e">// retain
</span><span style="color:#75715e"></span>            DictReleaseCallBack, <span style="color:#75715e">// release
</span><span style="color:#75715e"></span>            NULL,                <span style="color:#75715e">// copyDescription，传 NULL 为默认实现
</span><span style="color:#75715e"></span>            CFEqual,             <span style="color:#75715e">// equal，CFEqual 与默认实现相同，最终调用 NSObject 的 isEqual:
</span><span style="color:#75715e"></span>            CFHash               <span style="color:#75715e">// hash，CFHash 与默认实现相同，最终调用 NSObject 的 hash
</span><span style="color:#75715e"></span>        };

        CFDictionaryValueCallBacks valueCallbacks <span style="color:#f92672">=</span> {
            <span style="color:#ae81ff">0</span>,                   <span style="color:#75715e">// version
</span><span style="color:#75715e"></span>            DictRetainCallBack,  <span style="color:#75715e">// retain
</span><span style="color:#75715e"></span>            DictReleaseCallBack, <span style="color:#75715e">// release
</span><span style="color:#75715e"></span>            NULL,                <span style="color:#75715e">// copyDescription
</span><span style="color:#75715e"></span>            CFEqual,             <span style="color:#75715e">// equal
</span><span style="color:#75715e"></span>        };

        CFMutableDictionaryRef cfDict <span style="color:#f92672">=</span> CFDictionaryCreateMutable(NULL, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>keyCallbacks, <span style="color:#f92672">&amp;</span>valueCallbacks);
        NSMutableDictionary <span style="color:#f92672">*</span>dict <span style="color:#f92672">=</span> (<span style="color:#66d9ef">__bridge_transfer</span> NSMutableDictionary <span style="color:#f92672">*</span>)cfDict;

        Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [[Foo alloc] init];
        <span style="color:#75715e">// dict[foo] = @&#34;foo&#34;; // CRASH: &#39;-[Foo copyWithZone:]: unrecognized selector sent to instance 0x100500670&#39;
</span><span style="color:#75715e"></span>        CFDictionaryAddValue(cfDict, (<span style="color:#66d9ef">__bridge</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)(foo), CFSTR(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">foo</span><span style="color:#e6db74">&#34;</span>));

        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, dict);
    }
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// {
</span><span style="color:#75715e"></span><span style="color:#75715e">//    &#34;&lt;Foo: 0x10059b3c0&gt;&#34; = foo;
</span><span style="color:#75715e"></span><span style="color:#75715e">// }
</span></code></pre></div><h3 id="-nscache--nsdictionary">构建缓存时选用 NSCache 而非 NSDictionary</h3>
<p>当网络数据过大或者其它某些情况，我们可能需要使用到数据结构来做缓存以优化用户体验，此时 <code>NSCache</code> 要比 <code>NSDictionary</code> 好，首先当系统资源即将耗尽时，前者可以按最久未使用（Lease Recently Used，LRU）算法自动删减缓存；其次 <code>NSCache</code> 对键不会做类似 <code>NSDictionary</code> 默认的拷贝操作，而是保留操作；而且 <code>NSCache</code> 是线程安全的，<code>NSDictionary</code> 则无此优势。</p>
<p>开发者可以控制缓存删减其内容的时机，其中有两个尺度可供调整，其一是缓存中的对象总数，其二是所有对象的总开销。缓存的使用目的即是为了更快地响应用户操作，而如果开销值计算是耗时操作就显得本末倒置了，除非是已知数据大小的 <code>NSData</code> 对象。另外控制尺度并非完全严格，其仅对 <code>NSCache</code> 起指导作用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">void</span>(<span style="color:#f92672">^</span>HandlerBlock)(NSData <span style="color:#f92672">*</span>data);

<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo</span> : <span style="color:#a6e22e">NSObject</span>
- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">initWithURL:</span>(NSURL <span style="color:#f92672">*</span>)url;

<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo</span> {
    NSURL <span style="color:#f92672">*</span>_url;
}

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">initWithURL:</span>(NSURL <span style="color:#f92672">*</span>)url {
    self <span style="color:#f92672">=</span> [super init];
    <span style="color:#66d9ef">if</span> (self) {
        _url <span style="color:#f92672">=</span> url;
    }
    <span style="color:#66d9ef">return</span> self;
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">doWithHandler:</span>(HandlerBlock)handler {
    NSData <span style="color:#f92672">*</span>data <span style="color:#f92672">=</span> [_url.absoluteString dataUsingEncoding:NSUTF8StringEncoding];
    handler(data);
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">dealloc</span>
{
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">dealloc</span><span style="color:#e6db74">&#34;</span>);
}

<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Bar</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Bar</span> {
    NSCache <span style="color:#f92672">*</span>_cache;
}

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">init</span> {
    self <span style="color:#f92672">=</span> [super init];
    <span style="color:#66d9ef">if</span> (self) {
        _cache <span style="color:#f92672">=</span> [NSCache new];

        <span style="color:#75715e">// 缓存对象总数上限
</span><span style="color:#75715e"></span>        _cache.countLimit <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
        <span style="color:#75715e">// 缓存总开销上限（单位为字节 B）
</span><span style="color:#75715e"></span>        _cache.totalCostLimit <span style="color:#f92672">=</span> <span style="color:#ae81ff">1024</span>;
    }
    <span style="color:#66d9ef">return</span> self;
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">fetchFromURL:</span>(NSURL <span style="color:#f92672">*</span>)url {
    NSData <span style="color:#f92672">*</span>cachedData <span style="color:#f92672">=</span> [_cache objectForKey:url];
    <span style="color:#66d9ef">if</span> (cachedData) {
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">命中缓存</span><span style="color:#e6db74">&#34;</span>);

        [self dealWithData:cachedData];
    } <span style="color:#66d9ef">else</span> {
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">未命中缓存</span><span style="color:#e6db74">&#34;</span>);

        Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [[Foo alloc] initWithURL:url];

        <span style="color:#66d9ef">__weak</span> <span style="color:#66d9ef">typeof</span>(self) weakSelf <span style="color:#f92672">=</span> self;
        [foo doWithHandler:<span style="color:#f92672">^</span>(NSData <span style="color:#f92672">*</span>data) {
            <span style="color:#75715e">// 防止循环引用
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">__strong</span> <span style="color:#66d9ef">typeof</span>(weakSelf) strongSelf <span style="color:#f92672">=</span> weakSelf;

            <span style="color:#75715e">// 缓存（NSData 长度读取不耗时）
</span><span style="color:#75715e"></span>            [strongSelf<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>_cache setObject:data forKey:url cost:data.length];

            [strongSelf dealWithData:data];
        }];
    }
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">fetchFromURL_2:</span>(NSURL <span style="color:#f92672">*</span>)url {
    <span style="color:#75715e">// NSPurgeableData 继承自 NSMutableData 且实现了 NSDiscardableContent 协议
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 当系统资源紧张时，可以把保存 NSPurgeableData 对象的那块内存释放
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// NSDiscardableContent 协议：
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// - isContentDiscarded：可用来查询相关内存是否已经释放
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// - beginContentAccess：可用来告知此时不应丢弃占据的内存（类似某个计数 + 1）
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// - endContentAccess：可用来告知必要时可以丢弃占据的内存（类似某个计数 - 1，只有为 0 时才可丢弃）
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// NSPurgeableData 对象若加入了 NSCache，那么若其内存被系统丢弃，默认也会自动缓存中移除
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// NSCache 中的 evictsObjectsWithDiscardedContent 用来控制此功能开关
</span><span style="color:#75715e"></span>    NSPurgeableData <span style="color:#f92672">*</span>cachedData <span style="color:#f92672">=</span> [_cache objectForKey:url];
    <span style="color:#66d9ef">if</span> (cachedData) {
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">命中缓存</span><span style="color:#e6db74">&#34;</span>);

        <span style="color:#75715e">// 后面要使用，此时 + 1
</span><span style="color:#75715e"></span>        [cachedData beginContentAccess];

        [self dealWithData:cachedData];

        <span style="color:#75715e">// 使用完毕，此时 - 1
</span><span style="color:#75715e"></span>        [cachedData endContentAccess];
    } <span style="color:#66d9ef">else</span> {
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">未命中缓存</span><span style="color:#e6db74">&#34;</span>);

        Foo <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [[Foo alloc] initWithURL:url];

        <span style="color:#66d9ef">__weak</span> <span style="color:#66d9ef">typeof</span>(self) weakSelf <span style="color:#f92672">=</span> self;
        [foo doWithHandler:<span style="color:#f92672">^</span>(NSData <span style="color:#f92672">*</span>data) {
            <span style="color:#75715e">// 防止循环引用
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">__strong</span> <span style="color:#66d9ef">typeof</span>(weakSelf) strongSelf <span style="color:#f92672">=</span> weakSelf;

            <span style="color:#75715e">// 根据 NSData 获取 NSPurgeableData 对象（创建时无需 beginContentAccess 计数会默认 + 1）
</span><span style="color:#75715e"></span>            NSPurgeableData <span style="color:#f92672">*</span>purgeableData <span style="color:#f92672">=</span> [NSPurgeableData dataWithData:data];

            <span style="color:#75715e">// 缓存 NSPurgeableData 对象
</span><span style="color:#75715e"></span>            [strongSelf<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>_cache setObject:purgeableData forKey:url cost:purgeableData.length];

            [strongSelf dealWithData:data];

            <span style="color:#75715e">// 标记 NSPurgeableData 对象可丢弃（计数 - 1）
</span><span style="color:#75715e"></span>            [purgeableData endContentAccess];
        }];
    }
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">dealWithData:</span>(NSData <span style="color:#f92672">*</span>)data {

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);
}

<span style="color:#66d9ef">@end</span>


<span style="color:#66d9ef">int</span> main(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">@autoreleasepool</span> {
        Bar <span style="color:#f92672">*</span>bar <span style="color:#f92672">=</span> [[Bar alloc] init];

        [bar fetchFromURL:[NSURL URLWithString:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">https://kingcos.me</span><span style="color:#e6db74">&#34;</span>]];
        [bar fetchFromURL:[NSURL URLWithString:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">https://github.com/kingcos</span><span style="color:#e6db74">&#34;</span>]];
        [bar fetchFromURL:[NSURL URLWithString:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">https://kingcos.me</span><span style="color:#e6db74">&#34;</span>]];

        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">---</span><span style="color:#e6db74">&#34;</span>);

        <span style="color:#75715e">// ⚠️ URL 不要和上面完全一致，否则缓存和实际类型有出入
</span><span style="color:#75715e"></span>        [bar fetchFromURL_2:[NSURL URLWithString:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">https://kingcos.me/</span><span style="color:#e6db74">&#34;</span>]];
        [bar fetchFromURL_2:[NSURL URLWithString:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">https://github.com/kingcos/</span><span style="color:#e6db74">&#34;</span>]];
        [bar fetchFromURL_2:[NSURL URLWithString:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">https://kingcos.me/</span><span style="color:#e6db74">&#34;</span>]];
    }
}

<span style="color:#75715e">// 1024 B = 1 KB 缓存 &amp;&amp; countLimit 为 100 时：
</span><span style="color:#75715e"></span><span style="color:#75715e">// 未命中缓存
</span><span style="color:#75715e"></span><span style="color:#75715e">// https://kingcos.me
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span><span style="color:#75715e"></span><span style="color:#75715e">// 未命中缓存
</span><span style="color:#75715e"></span><span style="color:#75715e">// https://github.com/kingcos
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span><span style="color:#75715e"></span><span style="color:#75715e">// 命中缓存
</span><span style="color:#75715e"></span><span style="color:#75715e">// https://kingcos.me
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 1 B 缓存 || countLimit 为 1 时：
</span><span style="color:#75715e"></span><span style="color:#75715e">// 未命中缓存
</span><span style="color:#75715e"></span><span style="color:#75715e">// https://kingcos.me
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span><span style="color:#75715e"></span><span style="color:#75715e">// 未命中缓存
</span><span style="color:#75715e"></span><span style="color:#75715e">// https://github.com/kingcos
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span><span style="color:#75715e"></span><span style="color:#75715e">// 未命中缓存
</span><span style="color:#75715e"></span><span style="color:#75715e">// https://kingcos.me
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// NSPurgeableData（1024 B = 1 KB 缓存 &amp;&amp; countLimit 为 100 时）：
</span><span style="color:#75715e"></span><span style="color:#75715e">// ---
</span><span style="color:#75715e"></span><span style="color:#75715e">// 未命中缓存
</span><span style="color:#75715e"></span><span style="color:#75715e">// https://kingcos.me/
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span><span style="color:#75715e"></span><span style="color:#75715e">// 未命中缓存
</span><span style="color:#75715e"></span><span style="color:#75715e">// https://github.com/kingcos/
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span><span style="color:#75715e"></span><span style="color:#75715e">// 命中缓存
</span><span style="color:#75715e"></span><span style="color:#75715e">// https://kingcos.me/
</span></code></pre></div><!-- https://github.com/AFNetworking/AFNetworking/issues/268 -->
<h3 id="-initialize--load-">精简 initialize 与 load 实现代码</h3>
<p>略；关于 +load，可详见《<a href="../block_in_obj-c">iOS 中的 +load 方法</a>》一文；关于 +initialize，可详见《<a href="../block_in_obj-c">iOS 中的 +initialize 方法</a>》一文。</p>
<h3 id="-nsimer-">别忘了 NSimer 会保留其目标对象</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">NSTimer</span> (BlockCategory)
+ (NSTimer <span style="color:#f92672">*</span>)<span style="color:#a6e22e">bc_scheduledTimerWithTimeInterval:</span>(NSTimeInterval)interval
                                       <span style="color:#a6e22e">repeats:</span>(<span style="color:#66d9ef">BOOL</span>)repeats
                                         <span style="color:#a6e22e">block:</span>(<span style="color:#66d9ef">void</span>(<span style="color:#f92672">^</span>)(<span style="color:#66d9ef">void</span>))block;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">NSTimer</span> (BlockCategory)
+ (NSTimer <span style="color:#f92672">*</span>)<span style="color:#a6e22e">bc_scheduledTimerWithTimeInterval:</span>(NSTimeInterval)interval
                                       <span style="color:#a6e22e">repeats:</span>(<span style="color:#66d9ef">BOOL</span>)repeats
                                         <span style="color:#a6e22e">block:</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>)(<span style="color:#66d9ef">void</span>))block {
    <span style="color:#66d9ef">return</span> [self scheduledTimerWithTimeInterval:interval
                                         target:self <span style="color:#75715e">// target 为 self，而这里的 self 是类对象，但类对象本身即不需要释放
</span><span style="color:#75715e"></span>                                       selector:<span style="color:#66d9ef">@selector</span>(bc_timerBlockInvoked:)
                                       userInfo:[block <span style="color:#66d9ef">copy</span>] <span style="color:#75715e">// 将 Block 拷贝到堆，并保存在 userInfo 中
</span><span style="color:#75715e"></span>                                        repeats:repeats];
}

+ (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">bc_timerBlockInvoked:</span>(NSTimer <span style="color:#f92672">*</span>)timer {
    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> timer.userInfo;
    <span style="color:#66d9ef">if</span> (block) {
        block();
    }
}

<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo</span> : <span style="color:#a6e22e">NSObject</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">start:</span>(NSUInteger)index;
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">stop</span>;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo</span> {
    <span style="color:#75715e">// 当前对象强引用 _timer
</span><span style="color:#75715e"></span>    NSTimer <span style="color:#f92672">*</span>_timer0;
    NSTimer <span style="color:#f92672">*</span>_timer1;
    NSTimer <span style="color:#f92672">*</span>_timer2;

    NSUInteger _currentIndex;
}

- (<span style="color:#66d9ef">instancetype</span>)<span style="color:#a6e22e">init</span>
{
    <span style="color:#66d9ef">return</span> [super init];
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">dealloc</span>
{
    [_timer0 invalidate];
    [_timer1 invalidate];
    [_timer2 invalidate];

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">Timer %lu dealloc</span><span style="color:#e6db74">&#34;</span>, _currentIndex);
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">start:</span>(NSUInteger)index {
    _currentIndex <span style="color:#f92672">=</span> index;

    <span style="color:#66d9ef">switch</span> (index) {
        <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">:</span> {
            <span style="color:#75715e">// _timer 的 target 为 self，因而强引用 self，产生了循环引用
</span><span style="color:#75715e"></span>            _timer0 <span style="color:#f92672">=</span> [NSTimer scheduledTimerWithTimeInterval:<span style="color:#ae81ff">5.0</span>
                                                       target:self
                                                     selector:<span style="color:#66d9ef">@selector</span>(timerInvoked)
                                                     userInfo:nil
                                                      repeats:YES];
        }

            <span style="color:#66d9ef">break</span>;

        <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span> {
            <span style="color:#66d9ef">__weak</span> <span style="color:#66d9ef">typeof</span>(self) weakSelf <span style="color:#f92672">=</span> self;
            _timer1 <span style="color:#f92672">=</span> [NSTimer bc_scheduledTimerWithTimeInterval:<span style="color:#ae81ff">5.0</span>
                                                         repeats:YES
                                                           block:<span style="color:#f92672">^</span>{
                <span style="color:#66d9ef">__strong</span> <span style="color:#66d9ef">typeof</span>(weakSelf) strongSelf <span style="color:#f92672">=</span> weakSelf;

                NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">--- kingcos.me ---</span><span style="color:#e6db74">&#34;</span>);
                NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, strongSelf);
            } ];
        }

            <span style="color:#66d9ef">break</span>;

        <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">:</span> {
            <span style="color:#66d9ef">__weak</span> <span style="color:#66d9ef">typeof</span>(self) weakSelf <span style="color:#f92672">=</span> self;
            _timer2 <span style="color:#f92672">=</span> [NSTimer scheduledTimerWithTimeInterval:<span style="color:#ae81ff">5.0</span>
                                                      repeats:YES
                                                        block:<span style="color:#f92672">^</span>(NSTimer <span style="color:#f92672">*</span> _Nonnull timer) {
                <span style="color:#66d9ef">__strong</span> <span style="color:#66d9ef">typeof</span>(weakSelf) strongSelf <span style="color:#f92672">=</span> weakSelf;

                NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">--- kingcos.me ---</span><span style="color:#e6db74">&#34;</span>);
                NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, strongSelf);
            }];
        }

            <span style="color:#66d9ef">break</span>;

        <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
            <span style="color:#66d9ef">break</span>;
    }
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">timerInvoked</span> {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">--- kingcos.me ---</span><span style="color:#e6db74">&#34;</span>);
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">stop</span> {
    [_timer0 invalidate]; <span style="color:#75715e">// 此时 _timer1 才打破引用循环
</span><span style="color:#75715e"></span>    [_timer1 invalidate];
    [_timer2 invalidate];

    _timer0 <span style="color:#f92672">=</span> nil;
    _timer1 <span style="color:#f92672">=</span> nil;
    _timer2 <span style="color:#f92672">=</span> nil;
}

<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">int</span> main(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">@autoreleasepool</span> {
        [[[Foo alloc] init] start:<span style="color:#ae81ff">0</span>]; <span style="color:#75715e">// 若不调用 stop，_timer1 则发生循环引用
</span><span style="color:#75715e"></span>        [[[Foo alloc] init] start:<span style="color:#ae81ff">1</span>]; <span style="color:#75715e">// 通过自己加分类处理
</span><span style="color:#75715e"></span>        [[[Foo alloc] init] start:<span style="color:#ae81ff">2</span>]; <span style="color:#75715e">// iOS 10 之后可用
</span><span style="color:#75715e"></span>    }
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// Timer 1 dealloc
</span><span style="color:#75715e"></span><span style="color:#75715e">// Timer 2 dealloc
</span></code></pre></div><h2 id="reference">Reference</h2>
<ul>
<li><a href="../ivar_access_control_in_obj-c/">Obj-C 中实例变量和类的访问控制 - kingcos</a></li>
<li><a href="https://stackoverflow.com/questions/17668018/when-to-use-uikit-extern-vs-just-extern">When to use UIKIT_EXTERN vs just extern - StackOverflow</a></li>
<li><a href="../objc_msgsend">浅尝 objc_msgSend - kingcos</a></li>
<li><a href="../objects_in_obj-c/">Obj-C 中的对象 - kingcos</a></li>
<li><a href="../type_introspection_and_reflection/">Obj-C &amp; Swift 的类型内省与反射 - kingcos</a></li>
<li><a href="https://developer.apple.com/documentation/foundation/nszone?language=objc">NSZone - Apple Developer</a></li>
<li><a href="../bit_field_union_in_cpp/">C/C++ 中的位域与共用体 - kingcos</a></li>
<li><a href="../category_in_ios/">iOS 中的 Category - kingcos</a></li>
<li><a href="../block_in_obj-c/">Obj-C 中的 Block - kingcos</a></li>
<li><a href="https://opensource.apple.com/tarballs/objc4/">objc4-756.2.tar.gz - Apple</a></li>
</ul>

    </div>
    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>
        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="/posts/2019/block_in_obj-c/">
                <span class="button__icon">←</span>
                <span class="button__text">Obj-C 中的 Block</span>
              </a>
            </span>
          
          
            <span class="button next">
              <a href="/posts/2019/shopping_1111/">
                <span class="button__text">双 11 买买买 - 开始抢购啦 💰</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    

    

    
    
    <div>
      <div id="github-comment">
      </div>

      <script type="text/javascript">
        function getUtterances(isDark) {
          var utterances = document.createElement('script');
          utterances.type = 'text/javascript';
          utterances.async = true;
          utterances.setAttribute('issue-term', "pathname")
          utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
          utterances.setAttribute('label', "comments")
          isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
          utterances.crossorigin = 'anonymous';
          utterances.src = 'https://utteranc.es/client.js';

          return utterances
        }

        var themeToggle = document.querySelector(".theme-toggle")
        themeToggle.addEventListener("click", function () {
          var getTheme = window.localStorage && window.localStorage.getItem("theme")
          var divNode = document.getElementById('github-comment')
          while(divNode.hasChildNodes()) {
            divNode.removeChild(divNode.firstChild);
          }
          
          
          

          
          
          
          
          
          
          document.getElementById('github-comment').appendChild(getUtterances(getTheme !== "dark"))
        })

        var getTheme = window.localStorage && window.localStorage.getItem("theme")
        document.getElementById('github-comment').appendChild(getUtterances(getTheme === "dark"))
      </script>
    </div>
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">All rights reserved by kingcos.me</div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </body>
</html>
