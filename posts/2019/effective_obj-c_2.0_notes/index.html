<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>《编写高质量 iOS 与 OS X 代码的 52 个有效方法》阅读笔记 :: iBlog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Book ISBN Notes     编写高质量 iOS 与 OS X 代码的 52 个有效方法 9787111451297 -   Date Num. Xcode   2019-05 1-3 10.2.1   2019-06 4 10.2.1   2019-07 5-9 10.2.1    熟悉 Objective-C 了解 Objective-C 语言的起源  消息结构（Message Structure）的语言，运行时执行的代码由运行环境决定；函数调用（Function Calling）的语言，运行时所执行的代码由编译器决定，对于多态，则按照虚函数表（Virtual Method Table）寻找。 运行时组件（Runtime Component） 本质上是一种与开发者所编写代码相链接的「动态库（Dynamic Library），这样的好处是只需要更新运行时组件（无需重新编译）即可提升程序性能。 Obj-C 是 C 的超集。 Obj-C 中的对象所占内存总是分配在堆空间（Heap Stack）；而指向对象的指针所占内存总是分配在栈帧（Stack Frame）中。 堆中的内存需要程序员自己管理，栈中的内存会在其栈帧弹出（Pop）时自动清理。 创建对象相比创建结构体（C 结构体）需要额外开销，例如分配和释放堆内存等。  // ⚠️ 由于 Obj-C 中的字符串（NSString）略有特殊，此处并未使用书中的 NSString 作为范例 // 对象本身被分配在堆上；obj1 &amp;amp; obj2 被分配在栈上 NSObject *obj1 = [[NSObject alloc] init]; NSObject *obj2 = obj1; // (lldb) p obj1 // (NSObject *) $0 = 0x00000001005092b0 // (lldb) p obj2 // (NSObject *) $1 = 0x00000001005092b0 // (lldb) p &amp;amp;obj1 // (NSObject **) $2 = 0x00007ffeefbff508 // (lldb) p &amp;amp;obj2 // (NSObject **) $3 = 0x00007ffeefbff500  在类的头文件中尽量少引入其他头文件  当需要知道有一个类的存在时，而不关心其内部细节时，可以使用向前声明（Forward Declaring）告知编译器，即可以在 ."/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/effective_obj-c_2.0_notes/" />


<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/green.css">



<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="/img/favicon/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="《编写高质量 iOS 与 OS X 代码的 52 个有效方法》阅读笔记 :: iBlog — " />
<meta name="twitter:description" content="Book ISBN Notes     编写高质量 iOS 与 OS X 代码的 52 个有效方法 9787111451297 -   Date Num. Xcode   2019-05 1-3 10.2.1   2019-06 4 10.2.1   2019-07 5-9 10.2.1    熟悉 Objective-C 了解 Objective-C 语言的起源  消息结构（Message Structure）的语言，运行时执行的代码由运行环境决定；函数调用（Function Calling）的语言，运行时所执行的代码由编译器决定，对于多态，则按照虚函数表（Virtual Method Table）寻找。 运行时组件（Runtime Component） 本质上是一种与开发者所编写代码相链接的「动态库（Dynamic Library），这样的好处是只需要更新运行时组件（无需重新编译）即可提升程序性能。 Obj-C 是 C 的超集。 Obj-C 中的对象所占内存总是分配在堆空间（Heap Stack）；而指向对象的指针所占内存总是分配在栈帧（Stack Frame）中。 堆中的内存需要程序员自己管理，栈中的内存会在其栈帧弹出（Pop）时自动清理。 创建对象相比创建结构体（C 结构体）需要额外开销，例如分配和释放堆内存等。  // ⚠️ 由于 Obj-C 中的字符串（NSString）略有特殊，此处并未使用书中的 NSString 作为范例 // 对象本身被分配在堆上；obj1 &amp;amp; obj2 被分配在栈上 NSObject *obj1 = [[NSObject alloc] init]; NSObject *obj2 = obj1; // (lldb) p obj1 // (NSObject *) $0 = 0x00000001005092b0 // (lldb) p obj2 // (NSObject *) $1 = 0x00000001005092b0 // (lldb) p &amp;amp;obj1 // (NSObject **) $2 = 0x00007ffeefbff508 // (lldb) p &amp;amp;obj2 // (NSObject **) $3 = 0x00007ffeefbff500  在类的头文件中尽量少引入其他头文件  当需要知道有一个类的存在时，而不关心其内部细节时，可以使用向前声明（Forward Declaring）告知编译器，即可以在 ." />
<meta name="twitter:site" content="/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="《编写高质量 iOS 与 OS X 代码的 52 个有效方法》阅读笔记 :: iBlog — ">
<meta property="og:description" content="Book ISBN Notes     编写高质量 iOS 与 OS X 代码的 52 个有效方法 9787111451297 -   Date Num. Xcode   2019-05 1-3 10.2.1   2019-06 4 10.2.1   2019-07 5-9 10.2.1    熟悉 Objective-C 了解 Objective-C 语言的起源  消息结构（Message Structure）的语言，运行时执行的代码由运行环境决定；函数调用（Function Calling）的语言，运行时所执行的代码由编译器决定，对于多态，则按照虚函数表（Virtual Method Table）寻找。 运行时组件（Runtime Component） 本质上是一种与开发者所编写代码相链接的「动态库（Dynamic Library），这样的好处是只需要更新运行时组件（无需重新编译）即可提升程序性能。 Obj-C 是 C 的超集。 Obj-C 中的对象所占内存总是分配在堆空间（Heap Stack）；而指向对象的指针所占内存总是分配在栈帧（Stack Frame）中。 堆中的内存需要程序员自己管理，栈中的内存会在其栈帧弹出（Pop）时自动清理。 创建对象相比创建结构体（C 结构体）需要额外开销，例如分配和释放堆内存等。  // ⚠️ 由于 Obj-C 中的字符串（NSString）略有特殊，此处并未使用书中的 NSString 作为范例 // 对象本身被分配在堆上；obj1 &amp;amp; obj2 被分配在栈上 NSObject *obj1 = [[NSObject alloc] init]; NSObject *obj2 = obj1; // (lldb) p obj1 // (NSObject *) $0 = 0x00000001005092b0 // (lldb) p obj2 // (NSObject *) $1 = 0x00000001005092b0 // (lldb) p &amp;amp;obj1 // (NSObject **) $2 = 0x00007ffeefbff508 // (lldb) p &amp;amp;obj2 // (NSObject **) $3 = 0x00007ffeefbff500  在类的头文件中尽量少引入其他头文件  当需要知道有一个类的存在时，而不关心其内部细节时，可以使用向前声明（Forward Declaring）告知编译器，即可以在 ." />
<meta property="og:url" content="/posts/2019/effective_obj-c_2.0_notes/" />
<meta property="og:site_name" content="《编写高质量 iOS 与 OS X 代码的 52 个有效方法》阅读笔记" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-05-01 00:00:00 &#43;0000 UTC" />











</head>
<body class="">


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    iBlog
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About &amp; AMA</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About &amp; AMA</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/2019/effective_obj-c_2.0_notes/">《编写高质量 iOS 与 OS X 代码的 52 个有效方法》阅读笔记</a></h1>
  <div class="post-meta">
    <span class="post-date">
      2019-05-01
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/read/">Read</a>&nbsp;
    
    #<a href="/tags/ios/">iOS</a>&nbsp;
    
    #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    

<table>
<thead>
<tr>
<th align="center">Book</th>
<th align="center">ISBN</th>
<th align="center">Notes</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">编写高质量 iOS 与 OS X 代码的 52 个有效方法</td>
<td align="center">9787111451297</td>
<td align="center">-</td>
</tr>

<tr>
<td align="center"><strong>Date</strong></td>
<td align="center"><strong>Num.</strong></td>
<td align="center"><strong>Xcode</strong></td>
</tr>

<tr>
<td align="center">2019-05</td>
<td align="center">1-3</td>
<td align="center">10.2.1</td>
</tr>

<tr>
<td align="center">2019-06</td>
<td align="center">4</td>
<td align="center">10.2.1</td>
</tr>

<tr>
<td align="center">2019-07</td>
<td align="center">5-9</td>
<td align="center">10.2.1</td>
</tr>
</tbody>
</table>

<h2 id="熟悉-objective-c">熟悉 Objective-C</h2>

<h3 id="了解-objective-c-语言的起源">了解 Objective-C 语言的起源</h3>

<ul>
<li>消息结构（Message Structure）的语言，运行时执行的代码由运行环境决定；函数调用（Function Calling）的语言，运行时所执行的代码由编译器决定，对于多态，则按照虚函数表（Virtual Method Table）寻找。</li>
<li>运行时组件（Runtime Component） 本质上是一种与开发者所编写代码相链接的「动态库（Dynamic Library），这样的好处是只需要更新运行时组件（无需重新编译）即可提升程序性能。</li>
<li>Obj-C 是 C 的超集。</li>
<li>Obj-C 中的对象所占内存总是分配在堆空间（Heap Stack）；而指向对象的指针所占内存总是分配在栈帧（Stack Frame）中。</li>
<li>堆中的内存需要程序员自己管理，栈中的内存会在其栈帧弹出（Pop）时自动清理。</li>
<li>创建对象相比创建结构体（C 结构体）需要额外开销，例如分配和释放堆内存等。</li>
</ul>

<p><img src="/img/2019/effective_obj-c_2.0_notes/1.png" alt="1" /></p>

<pre><code class="language-objectivec">// ⚠️ 由于 Obj-C 中的字符串（NSString）略有特殊，此处并未使用书中的 NSString 作为范例
// 对象本身被分配在堆上；obj1 &amp; obj2 被分配在栈上
NSObject *obj1 = [[NSObject alloc] init];
NSObject *obj2 = obj1;

// (lldb) p obj1
// (NSObject *) $0 = 0x00000001005092b0
// (lldb) p obj2
// (NSObject *) $1 = 0x00000001005092b0
// (lldb) p &amp;obj1
// (NSObject **) $2 = 0x00007ffeefbff508
// (lldb) p &amp;obj2
// (NSObject **) $3 = 0x00007ffeefbff500
</code></pre>

<h3 id="在类的头文件中尽量少引入其他头文件">在类的头文件中尽量少引入其他头文件</h3>

<ul>
<li>当需要知道有一个类的存在时，而不关心其内部细节时，可以使用向前声明（Forward Declaring）告知编译器，即可以在 .h（头文件）中 <code>@class SomeClass</code>；而在 .m（实现文件）中引入实际的 .h。</li>
<li>当在两个头文件中互相引入对方，则会导致「循环引用（Chicken-Egg Situation）」，无法通过编译。</li>
<li>将引入头文件的时机尽量延后，只有在确定有需要时才引入，否则会增加耦合度、拉长编译时间、产生相互依赖等问题。</li>
<li>继承父类和遵循协议则不能使用向前声明，必须引入相应的头文件，因此协议最好声明在单独的头文件中。</li>
<li>由于代理协议（Delegate Protocol）和遵守协议代理的类声明在一起时才有意义，最好在实现文件中声明类遵守了该代理协议，并将实现代码放在 Class-Continuation 分类（Class-Continuation Category）中；因此只需要在实现文件中引入包含代理协议的头文件即可，而不需要将其放在公共头文件（Public Header File）中。</li>
</ul>

<h3 id="多用字面量语法-少用与之等价的方法">多用字面量语法，少用与之等价的方法</h3>

<ul>
<li>字面量（Literal）语法简化了 Obj-C 的部分 API：</li>
</ul>

<pre><code class="language-objectivec">NSString *strValue = @&quot;str&quot;;
NSNumber *intValue = @1;
NSNumber *doubleValue = @3.14;
NSArray *arrValue = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;];
NSString *firstValueForArr = arrValue[0];
// ⚠️ 字面量创建的数组、字典都是不可变的
NSMutableArray *mutableArrValue = [@[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;] mutableCopy];
mutableArrValue[0] = @&quot;maimieng.com&quot;;
NSDictionary *dictValue = @{@&quot;key&quot; : @100};
NSNumber *valueForDictByKey  = dictValue[@&quot;key&quot;];
NSMutableDictionary *mutableDictValue = [@{@&quot;key&quot; : @100} mutableCopy];
mutableDictValue[@&quot;key&quot;] = @200;
</code></pre>

<ul>
<li>字面量语法在 <code>NSArray</code>、<code>NSDictionary</code> 等类中插入 <code>nil</code> 对象时会直接崩溃，而直接使用 API 则会发生「截断」，对于这两个用法差异务必要注意：</li>
</ul>

<pre><code class="language-objectivec">id nilObj = nil;
// *** -[__NSPlaceholderArray initWithObjects:count:]: attempt to insert nil object from objects[3]
NSArray *arrWithNilObject1 = @[@0, nilObj, @2];
// (0)
NSArray *arrWithNilObject2 = [NSArray arrayWithObjects:@0, nil, @2, nil];
// *** -[__NSPlaceholderDictionary initWithObjects:forKeys:count:]: attempt to insert nil object from objects[0]
NSDictionary *dictWithNilObject1 = @{@&quot;a&quot; : @&quot;A&quot;, @&quot;b&quot; : nilObj, @&quot;c&quot; : @&quot;C&quot;};
// { a = A; }
NSDictionary *dictWithNilObject2 = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;A&quot;, @&quot;a&quot;, nilObj, @&quot;b&quot;, @&quot;C&quot;, @&quot;c&quot;, nil];
</code></pre>

<ul>
<li>除了字符串，字面量语法仅适用于 Foundation 框架中，即我们自定义继承自上述支持字面量的类时，将不再支持使用字面量。</li>
</ul>

<h3 id="多用类型常量-少用-define-预处理指令">多用类型常量，少用 #define 预处理指令</h3>

<ul>
<li><code>#define</code> 预处理指令没有类型信息，且会在引用到包含该指令的所有文件中进行替换，因此更加推荐使用类型常量。</li>
</ul>

<pre><code class="language-objectivec">// 预处理指令（编译前进行直接替换）
#define ANIMATION_DURATION 0.3

// Some.m

// 类型常量
// const 决定了其为常量，不可被再次改变
// static 决定了其作用域，即当前文件（因此如果将其定义在 *.h 中，其他引入该头文件的文件也可以访问到）
static const NSTimeInterval kAnimationDuration = 0.3;

// 如果不使用 static 修饰，编译器会创建一个外部符号（External Symbols）
const NSTimeInterval SomeAnimationDuration = 0.3;
// 此时如果在其他文件内声明同名常量，则会报错「duplicate symbol」
// Another.m
const NSTimeInterval SomeAnimationDuration = 0.5;

// ---

// main.m
// 声明为 `static` 和 `const` 的变量，编译器不会为其再创建符号
#import &lt;Foundation/Foundation.h&gt;

int foo = 1;

// static const + int
static const int k1 = 1;
// static const + int *
// 对于指针，既要使其本身的内容不能改变，也不能改变其指向的内存地址，否则这个指针还是有可能改变的
static int const * const k2 = &amp;foo;
// static const + NSString *
static NSString * const k3 = @&quot;&quot;;
static NSString const * const k4 = @&quot;&quot;;

// const
const int k5 = 3;
// static
static int k6 = 4;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // 为了防止编译器优化未用到的符号，我们这里简单输出以上定义的变量
        NSLog(@&quot;%d&quot;, k1);
        NSLog(@&quot;%d&quot;, *k2);
        NSLog(@&quot;%@&quot;, k3);
        NSLog(@&quot;%@&quot;, k4);
        NSLog(@&quot;%d&quot;, k5);
        NSLog(@&quot;%d&quot;, k6);
    }
    return 0;
}

// 输出所有符号
// ➜  Debug nm -C Demo
// 通过以下输出可以得出由 static 和 const 修饰的 k1，k2 编译器都没有为其产生符号
// 但 NSString * 是个例外（Why? 猜测是编译器认为该常量后续还要被修改的可能，因此需要保留其符号）
//                  U _NSLog
//                  U ___CFConstantStringClassReference
// 0000000100000000 T __mh_execute_header
// 00000001000010a0 D _foo
// 0000000100001028 s _k3
// 0000000100001030 s _k4
// 0000000100000fb4 S _k5
// 00000001000010a4 d _k6
// 0000000100000eb0 T _main
//                  U _objc_autoreleasePoolPop
//                  U _objc_autoreleasePoolPush
//                  U dyld_stub_binder

// 仅输出外部符号
// ➜  Debug nm -gC Demo
// 所有使用 static 修饰的变量均不在外部符号中，说明 static 将这些符号的作用域限制在当前文件中
//                  U _NSLog
//                  U ___CFConstantStringClassReference
// 0000000100000000 T __mh_execute_header
// 00000001000010a0 D _foo
// 0000000100000fb4 S _k5
// 0000000100000eb0 T _main
//                  U _objc_autoreleasePoolPop
//                  U _objc_autoreleasePoolPush
//                  U dyld_stub_binder
</code></pre>

<ul>
<li><p>类型常量的命名规则：</p>

<ul>
<li>若常量局限于某个编译单元（Translation Unit，即实现文件 <code>*.m</code>），则需要以小写字母 <code>k</code> 开头；</li>
<li>若常量在类之外也可见，则通常需要以类名开头。</li>
</ul></li>

<li><p>关于 <code>nm</code> 命令的基本使用，可以参考 <a href="/posts/2019/ivar_access_control_in_obj-c/">Obj-C 中实例变量和类的访问控制</a>一文。</p></li>
</ul>

<pre><code class="language-objectivec">// Some.h
// extern 告知编译器全局符号表中存在该符号，允许外界使用
extern NSString * const SomeConstant;

// Some.m
// 外界需要访问则不能声明为 static；外界不可变更，因此声明为 const
// 这里的 const 修饰的是 NSString *（即 const 从右向左原则），SomeConstant 保存的内存地址不能再改变（即不能指向另外一个 NSString 对象）
// 编译器会在数据段（Data Section）为字符串分配存储空间，链接器会将目标文件相互链接，生成最终的可执行文件
// 全局符号命名规则：范围（通常使用类名）+ 名称
NSString * const SomeConstant = @&quot;SomeConstant&quot;;

// 在 Obj-C 中，除了 C 中原有的 extern 还存在以下相关的宏定义
// FOUNDATION_EXTERN、FOUNDATION_EXPORT、FOUNDATION_IMPORT、UIKIT_EXTERN

// NSObjCRuntime.h
#if defined(__cplusplus)
// C++ 下兼容 C++ 的 extern
#define FOUNDATION_EXTERN extern &quot;C&quot;
#else
#define FOUNDATION_EXTERN extern
#endif


    #define FOUNDATION_EXPORT  FOUNDATION_EXTERN
    #define FOUNDATION_IMPORT FOUNDATION_EXTERN

// UIKitDefines.h
// UIKIT_EXTERN 还声明了符号的可见范围
#ifdef __cplusplus
#define UIKIT_EXTERN		extern &quot;C&quot; __attribute__((visibility (&quot;default&quot;)))
#else
#define UIKIT_EXTERN	        extern __attribute__((visibility (&quot;default&quot;)))
#endif
</code></pre>

<ul>
<li><p>对于选择 <code>extern</code> 还是以上 <code>SOME_EXTERN</code>，c 得出以下的结论：</p>

<ul>
<li>对于这些固定前缀的 <code>extern</code> 应当在其范围下使用，即 <code>FOUNDATION_*</code> 在 Foundation 框架内部使用，<code>UIKIT_*</code> 在 <code>UIKit</code> 内部使用，在我们自己的库内应当推荐自定义 <code>SOME_*</code> 来使用，而不是直接套用其他库内的宏定义；</li>
<li>默认的 <code>extern</code> 由于可能不兼容 C++，那么在库中需要兼容 C++ 时应当使用 <code>extern &quot;C&quot;</code>。</li>
</ul></li>
</ul>

<h3 id="用枚举表示状态-选项-状态码">用枚举表示状态、选项、状态码</h3>

<ul>
<li>Obj-C 中的枚举（<code>enum</code>）来自 C 语言，而 C++11 标准使得枚举可以定义其底层数据类型（Underlying Type）。</li>
</ul>

<pre><code class="language-objectivec">// 实现枚举所用的数据类型取决于编译器
// 枚举的底层数据类型不是固定的，其二进制位（bit）的个数必须能完全表示下枚举编号
// 比如 ImageSourceType 可以使用 char 类型（但在 Xcode 里其底层数据类型是第一项默认为 0 的 int 类型）
enum ImageSourceType {
    ImageSourceTypeCamera,
    ImageSourceTypeGallery
};

enum ImageSourceType type1 = ImageSourceTypeCamera;

// typedef 可以简化枚举类型声明
typedef enum ImageSourceType ImageSourceType;
ImageSourceType type2 = ImageSourceTypeGallery;

// C++ 11 标准，显式声明枚举底层数据类型
enum NetworkType: NSInteger {
    NetworkTypeUnknown = -1, // 显式为从 -1 开始
    NetworkTypeWiFi   // 0 递增
    NetworkCellular   // 1
};

// 枚举的向前声明（在 .m 中引入或实现即可）
// Some.h
enum NetworkType: NSInteger;
</code></pre>

<ul>
<li>枚举中使用按位或操作符（Bitwise OR Operator）可以使得枚举的每个选项均可启用或禁用：</li>
</ul>

<pre><code class="language-objectivec">// UIViewAutoresizingNone 是无法与其他项目同时存在，因此为 0

// UIView.h
typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) {
    UIViewAutoresizingNone                 = 0,
    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,
    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,
    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,
    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,
    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,
    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5
};

// 使用时可以使用按位或来组合多个选项：
UIViewAutoresizing resize = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;

// 判断时使用按位与（Bitwise AND Operator）即可
if (resize &amp; UIViewAutoresizingFlexibleWidth) {
    NSLog(@&quot;UIViewAutoresizingFlexibleWidth&quot;);
}
if (resize &amp; UIViewAutoresizingFlexibleHeight) {
    NSLog(@&quot;UIViewAutoresizingFlexibleHeight&quot;);
}

// OUTPUT:
// UIViewAutoresizingFlexibleWidth
// UIViewAutoresizingFlexibleHeight
</code></pre>

<pre><code class="language-objectivec">/* NS_ENUM supports the use of one or two arguments. The first argument is always the integer type used for the values of the enum. The second argument is an optional type name for the macro. When specifying a type name, you must precede the macro with 'typedef' like so:

typedef NS_ENUM(NSInteger, NSComparisonResult) {
    ...
};

If you do not specify a type name, do not use 'typedef'. For example:

NS_ENUM(NSInteger) {
    ...
};
*/
#define NS_ENUM(...) CF_ENUM(__VA_ARGS__)
#define NS_OPTIONS(_type, _name) CF_OPTIONS(_type, _name)

// CFAvailability.h
#define CF_ENUM(...) __CF_ENUM_GET_MACRO(__VA_ARGS__, __CF_NAMED_ENUM, __CF_ANON_ENUM, )(__VA_ARGS__)
// 根据是否按照 C++ 模式编译而不同
#define __CF_ENUM_GET_MACRO(_1, _2, NAME, ...) NAME
#if (__cplusplus &amp;&amp; __cplusplus &gt;= 201103L &amp;&amp; (__has_extension(cxx_strong_enums) || __has_feature(objc_fixed_enum))) || (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum))
    #define __CF_NAMED_ENUM(_type, _name)     enum __CF_ENUM_ATTRIBUTES _name : _type _name; enum _name : _type
    #define __CF_ANON_ENUM(_type)             enum __CF_ENUM_ATTRIBUTES : _type
    #define CF_CLOSED_ENUM(_type, _name)      enum __CF_CLOSED_ENUM_ATTRIBUTES _name : _type _name; enum _name : _type
    #if (__cplusplus)
        #define CF_OPTIONS(_type, _name) _type _name; enum __CF_OPTIONS_ATTRIBUTES : _type
    #else
        #define CF_OPTIONS(_type, _name) enum __CF_OPTIONS_ATTRIBUTES _name : _type _name; enum _name : _type
    #endif
#else
    #define __CF_NAMED_ENUM(_type, _name) _type _name; enum
    #define __CF_ANON_ENUM(_type) enum
    #define CF_CLOSED_ENUM(_type, _name) _type _name; enum
    #define CF_OPTIONS(_type, _name) _type _name; enum
#endif

// Some.mm
typedef enum Direction: int FooDirection;
enum Direction: int {
    Up      = 1 &lt;&lt; 0,
    Down    = 1 &lt;&lt; 1,
    Left    = 1 &lt;&lt; 2,
    Right   = 1 &lt;&lt; 3
};

// 在使用或运算操作两个枚举值时，C++ 认为运算结果的数据类型应当是枚举的底层数据类型，即 `NSUInteger`，且 C++ 不支持将底层数据类型隐式转换为枚举类型本身
// ERROR: Cannot initialize a variable of type 'FooDirection' (aka 'Direction') with an rvalue of type 'int'
// FooDirection direct = Up | Left;
</code></pre>

<ul>
<li>Foundation 框架中枚举的辅助宏具备向后兼容（Backward Compatibility）能力，即根据目标平台决定相应的语法；</li>
<li>凡是需要按位或操作来组合的枚举都应当使用 <code>NS_OPTIONS</code> 来定义；否则使用 <code>NS_ENUM</code>。</li>
</ul>

<h2 id="对象-消息-运行期">对象、消息、运行期</h2>

<h3 id="理解-属性-这一概念">理解「属性」这一概念</h3>

<ul>
<li>应用程序二进制接口（Application Binary Interface，即 ABI）定义了很多内容，其中有生成代码时所应遵循的规范。</li>
<li>Obj-C 中实例变量（ivar）的内存布局在编译时刻固定，因此访问实例变量时，编译器会将其替换为偏移量（Offset），而偏移量是硬编码，表示其距离内存起始地址的长度；</li>
<li>如果代码使用了编译时刻计算的偏移量，那么在修改类定义之后必须重新编译，即重新计算偏移量；</li>

<li><p>对于旧的类定义链接了新的类定义会出现不兼容情况，Obj-C 的做法如下：</p>

<ul>
<li>将实例变量当作一种存储偏移量所用的特殊变量，交由类对象保管，偏移量将在运行时查找，这样即使类定义变化了，也能找到正确的偏移量，甚至可以在运行时新增实例变量；</li>
<li>尽量不要直接访问实例变量，而是通过 getter &amp; setter，Obj-C 中可以使用 <code>@property</code> 语法；</li>
</ul></li>

<li><p>自动合成（Autosynthesis）：编译器会自动为 Obj-C 中的属性便携其所需的方法，该过程由编译器在编译时刻执行；</p></li>

<li><p>编译器还会自动为 Obj-C 中的属性添加适当类型的实例变量，并在属性名前加 <code>_</code> 前缀作为实例变量名。</p></li>
</ul>

<pre><code class="language-objectivec">// Some.h
@property NSString *foo;
@property NSString *bar;

// Some.m
// @dynamic 将不会自动合成，也不会创建实例变量
// 但使用 getter &amp; setter 可以编译，因为其相信会在运行时找到这些方法
@dynamic bar;

// @synthesize 指定了属性的实例变量名
@synthesize foo = _foooo;

self-&gt;_foooo = @&quot;Foo&quot;;
NSLog(@&quot;%@&quot;, [self foo]);
</code></pre>

<ul>
<li><p>原子性</p>

<ul>
<li>在化学中，原子是不可分割的最小粒子，因此可以理解为一个原子操作是不会被中断的，即线程安全的（但这并不代表 <code>atomic</code> 的属性是线程安全的）；</li>
<li>默认情况下（即不明确指定原子性时），由编译器所合成的方法（即 getter &amp; setter）会通过锁定机制确保其原子性（Atomicity）；</li>
<li>自己实现的 getter &amp; setter 需要自己来保证相应的原子性（即自己实现时与声明的原子性没有关系）；</li>
<li>若属性为 <code>nonatomic</code> 则不使用同步锁，iOS 中使用同步锁开销较大，可能带来性能问题，因此 <code>nonatomic</code> 性能会好点且 <code>atomic</code> 并不能保证操作是原子的，因此通常都使用 <code>nonatomic</code>。</li>
</ul></li>

<li><p>读写权限</p>

<ul>
<li><code>readwrite</code> 即拥有 getter &amp; setter，<code>readonly</code> 即仅拥有 <code>getter</code>；</li>
<li><code>readwrite</code> 可以用在 <code>.h</code> 声明为 <code>readonly</code> 但内部类扩展中声明为 <code>readwrite</code> 来允许内部设置的情况。</li>
</ul></li>

<li><p>内存管理语义</p>

<ul>
<li><code>assign</code>：setter 只会针对纯量类型（Scalar Type）例如 <code>CGFloat</code>、<code>NSInteger</code> 等的简单赋值操作；</li>
<li><code>strong</code>：定义一种拥有关系，为这种属性设置新值时，setter 会先保留新值，并释放旧值，然后再将新值设置上去；</li>
<li><code>weak</code>：定义一种非拥有关系，为这种属性设置新值时，setter 既不保留新值，也不释放旧值，类似 <code>assign</code>，但当属性所指向的对象销毁时，属性值也会置为 <code>nil</code>；</li>
<li><code>unsafe_unretained</code>：内存语义与 <code>assign</code> 相同，但适用于对象类型，定义一种非拥有（不保留）关系，但当属性所指向的对象销毁时，属性值<strong>不会</strong>置为 <code>nil</code>（与 <code>weak</code> 的差异；</li>
<li><code>copy</code>：类似 <code>strong</code>，但 setter 不保留新值，而是将其拷贝；当属性类型为 <code>NSString *</code> 时，可以使用 <code>copy</code> 保护其封装性，因为 setter 接收的新值有可能是指向 <code>NSMutableString</code> 的实例，若不拷贝则可能会被外界随时更改，因此需要拷贝为不可变的情况；</li>
</ul></li>

<li><p>方法名</p>

<ul>
<li><code>getter=&lt;name&gt;</code> 可以指定 getter 名称；</li>
<li><code>setter=&lt;name&gt;</code> 可以指定 setter 名称；</li>
</ul></li>

<li><p>属性特性（Attribute）只在自动生成时有效，自己实现的 getter &amp; setter 要保证其具备相应的属性特性。</p></li>
</ul>

<pre><code class="language-objectivec">@interface Foo : NSObject
// 即使 readonly 也要注明 copy，因为在 init 中进行了 copy
@property (copy, readonly) NSString *bar;
@end

@implementation Foo

- (instancetype)initWithBar:(NSString *)bar
{
    self = [super init];
    if (self) {
        // 要保证属性的内存语义
        _bar = [bar copy];
    }
    return self;
}

@end
</code></pre>

<h3 id="在对象内部尽量直接访问实例变量">在对象内部尽量直接访问实例变量</h3>

<ul>
<li>直接访问实例变量（ivar）与通过属性（getter &amp; setter）访问的区别：

<ul>
<li>直接访问不经过方法派发，速度更快；</li>
<li>直接访问不经过所定义的内存管理语义（例如 <code>copy</code>）；</li>
<li>直接访问不经过 KVO；</li>
<li>通过属性访问便于 Debug（可以打断点）。</li>
</ul></li>
<li>因此建议读取时直接访问，写入时通过属性，当然具体问题见仁见智。</li>
</ul>

<pre><code class="language-objectivec">// 懒加载的属性必须要通过 getter 访问
- (NSObject *)foo {
    if (!_foo) {
        _foo = [NSObject new];
        return _foo;
    }
}
</code></pre>

<h3 id="理解-对象等同性-这一概念">理解「对象等同性」这一概念</h3>

<ul>
<li>对于 Obj-C 中的对象类型，<code>==</code> 比较的是两个指针本身的值（即存储的地址）是否一致。</li>
<li>NSString 类中的 <code>isEqualToString:</code> 比 <code>isEqual:</code> 方法速度更快（但其实差别不大）。</li>
</ul>

<pre><code class="language-objectivec">- (BOOL)isEqual:(id)object {
    // 地址一致，则必然一样
    if (self == object) return YES;
    // 如果非同类，则不相等（子父类之间比较视情况而定）
    if ([self class] != [object class]) return NO;

    Foo *foo = (Foo *)object;
    if (![_bar isEqualToString:foo.bar])
        return NO;

    if (_baz != foo.baz)
        return NO;

    return YES;
}
</code></pre>

<ul>
<li>若两个对象相等，<code>hash</code> 也相等；<code>hash</code> 相等，但两个对象并不一定相等。</li>
<li>实现 <code>hash</code> 方法要在减少碰撞与降低运算复杂程度（性能影响）之间权衡：</li>
</ul>

<pre><code class="language-objectivec">// 返回固定值
// 可行，但在 collection 中使用该类型对象将产生性能问题，因为 collection 检索哈希表（Hash Table）时，会用对象的哈希码（Hash Code）做索引。
// 假如某个 collection 是用 set 实现的，其可能会根据哈希码把对象分装到不同的数组中。
// 若每个对象都返回相同的哈希码，则需要将所有对象全部扫描。
- (NSUInteger)hash {
    return 1024;
}

// 属性拼接字符串并 hash
// 但需承担创建字符串的开销；添加到 collection 中由于必须计算哈希码也会产生性能问题
- (NSUInteger)hash {
    NSString *str = [NSString stringWithFormat:@&quot;%@:%i&quot;, _bar, _baz];
    return [str hash];
}

// 效率高，范围确定
// 虽然会碰撞，但允许
- (NSUInteger)hash {
    NSUInteger bar = [_bar hash];
    NSUInteger baz = _baz;
    return bar ^ baz;
}
</code></pre>

<ul>
<li>编写特定类的等同性判定方法（比如 <code>isEqualToString:</code>）时，应一并重写 <code>isEqual:</code> 方法：</li>
</ul>

<pre><code class="language-objectivec">- (BOOL)isEqualToFoo:(Foo *)foo {
    if (self == object) return YES;

    if (![_bar isEqualToString:foo.bar])
        return NO;

    if (_baz != foo.baz)
        return NO;

    return YES;
}

- (BOOL)isEqual:(id)object {
    // 相同类则自己判断
    if ([self class] == [object class]) {
        return [self isEqualToFoo:(Foo *)object];
    }

    // 不同类则交给父类
    return [super isEqual:object];
}
</code></pre>

<ul>
<li>等同性判定的执行深度取决于受测对象，即若有某个 ID 字段则可以直接根据该 ID 来判定。</li>
</ul>

<pre><code class="language-objectivec">// 将对象放入 collection 中，不应再改变其哈希码，即需要确保哈希码并非根据对象的可变部分计算得出
NSMutableSet *set = [NSMutableSet new];
NSMutableArray *arr1 = [@[@1] mutableCopy];
NSMutableArray *arr2 = [@[@1, @2] mutableCopy];

[set addObject:arr1];
[set addObject:arr2];

// {((1), (1,2))}
NSLog(@&quot;%@&quot;, set);

// Set 中存在了两个完全相同的结构
// {((1,2), (1,2))}
[arr1 addObject:@2];
NSLog(@&quot;%@&quot;, set);
</code></pre>

<h3 id="以-类族模式-隐藏实现细节">以「类族模式」隐藏实现细节</h3>

<ul>
<li>类族（Class Cluster，又称类簇）是一种隐藏抽象基类背后的实现细节的模式（例如 <code>UIButton</code> 的 <code>buttonWithType:</code> 类方法）。</li>
</ul>

<pre><code class="language-swift">// 模式是不限定于语言的，因此这里使用了 Swift 来简单实现

enum FooType {
    case first
    case second
}

class Foo {
    static func build(_ type: FooType) -&gt; Foo {
        switch type {
        case .first: return FooFirst()
        case .second: return FooSecond()
        }
    }

    func bar() {
        fatalError(&quot;bar should be implemented in subclasses.&quot;)
    }
}

class FooFirst: Foo {
    override func bar() {
        print(#function)
    }
}

class FooSecond: Foo {
    override func bar() {
        print(#function)
    }
}

// 类族模式目的是隐藏内部实现的细节，因此外界创建的变量虽然是工厂类的类型，但实际上其实是内部子类的类型。
// 因此在 Obj-C 中使用 isMemberOfClass 判断类是否为工厂类本身，则会返回 NO。
// foo 在 Swift 中被推断为 Foo
let foo = Foo.build(.first)

print(foo is Foo)
print(foo is FooFirst)
print(foo is FooSecond)

// OUTPUT:
// true
// true
// false
</code></pre>

<ul>
<li>系统框架中有许多类族，比如大部分的 collection 类（比如 <code>NSArray</code>）；</li>
<li>由于 <code>NSArray</code> 是类族，因此 <code>[fooArr class] == [NSArray class]</code> 将一直返回 <code>false</code>，但可使用 <code>[fooArr isKindOfClass:[NSArray class]]</code>。</li>
<li>向类族中新增实体子类需要遵守以下规则：

<ul>
<li>子类应该继承自类族中的抽象基类；</li>
<li>子类应该定义自己的数据存储方式：类族只是定义了通用的接口，实际存储的方式则由背后具体的实体子类承担；</li>
<li>子类应当覆写超类文档中指明需要覆写的方法：类族中的通用接口需要子类实现。</li>
</ul></li>
</ul>

<h3 id="在既有类中使用关联对象存放自定义数据">在既有类中使用关联对象存放自定义数据</h3>

<ul>
<li>略；关于关联对象，可详见 <a href="/posts/2019/associated_objects_in_ios">iOS 中的关联对象</a>一文。</li>
</ul>

<h3 id="理解-objc-msgsend-的作用">理解 objc_msgSend 的作用</h3>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="/posts/2019/ivar_access_control_in_obj-c/">Obj-C 中实例变量和类的访问控制</a></li>
<li><a href="https://stackoverflow.com/questions/17668018/when-to-use-uikit-extern-vs-just-extern">When to use UIKIT_EXTERN vs just extern - StackOverflow</a></li>
</ul>

  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span
        class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      <span class="button previous">
        <a href="/posts/2019/url_loading_system/">
          <span class="button__icon">←</span>
          <span class="button__text">[译]URL 加载系统</span>
        </a>
      </span>
      
      
      <span class="button next">
        <a href="/posts/2019/&#43;initialize_in_ios/">
          <span class="button__text">iOS 中的 &#43;initialize 方法</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo="kingcos/kingcos.github.io"
            issue-term="pathname"
            label="comments"
            theme="github-dark"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2019 · <a href="http://github.com/kingcos">kingcos</a></span>
      </div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>





  
</div>

</body>
</html>
