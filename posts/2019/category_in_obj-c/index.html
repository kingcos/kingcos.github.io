<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>iOS 中的 Category :: iBlog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Source Code Demo     2019-04-16 优化结构 - -   2019-04-13 首次提交 objc4-750、xnu-4903.221.2 Category in Obj-C    Preface Obj-C 中的 Category 中文常译作分类、类别（为表述统一，本文将使用 Category 特指该技术）。我们经常会使用 Category 来对一个类进行扩展，使得在不破坏主类结构的同时可以具备更多的功能；也可以使用 Category 对一个类进行拆分，使得其结构更加清晰条理。本文将从 What - How - Why 谈谈 iOS 中 Category。
What 什么是 Category 呢？
Category 是 Obj-C 语言中所提供的一项功能，它可以为 Obj-C 类添加额外的属性、方法，也可以遵守其他协议。
Xcode 中已经为 Category 已经提供了模版来建立，只需要指定 Category 的名称以及被添加 Category 类名即可。当然，我们也可以手动来自己建立，Category 的语法与类的声明与实现比较类似：
@interface Foo (Bar) &amp;lt;SomeProtocol&amp;gt; - (void)foo; @end @implementation Foo (Bar) - (void)foo {} - (void)someMethodFromProtocol {} @end  How Category 通常都有哪些用处呢？"/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/category_in_obj-c/" />


<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/green.css">



<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="iOS 中的 Category :: iBlog — " />
<meta name="twitter:description" content="Date Notes Source Code Demo     2019-04-16 优化结构 - -   2019-04-13 首次提交 objc4-750、xnu-4903.221.2 Category in Obj-C    Preface Obj-C 中的 Category 中文常译作分类、类别（为表述统一，本文将使用 Category 特指该技术）。我们经常会使用 Category 来对一个类进行扩展，使得在不破坏主类结构的同时可以具备更多的功能；也可以使用 Category 对一个类进行拆分，使得其结构更加清晰条理。本文将从 What - How - Why 谈谈 iOS 中 Category。
What 什么是 Category 呢？
Category 是 Obj-C 语言中所提供的一项功能，它可以为 Obj-C 类添加额外的属性、方法，也可以遵守其他协议。
Xcode 中已经为 Category 已经提供了模版来建立，只需要指定 Category 的名称以及被添加 Category 类名即可。当然，我们也可以手动来自己建立，Category 的语法与类的声明与实现比较类似：
@interface Foo (Bar) &amp;lt;SomeProtocol&amp;gt; - (void)foo; @end @implementation Foo (Bar) - (void)foo {} - (void)someMethodFromProtocol {} @end  How Category 通常都有哪些用处呢？" />
<meta name="twitter:site" content="/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="iOS 中的 Category :: iBlog — ">
<meta property="og:description" content="Date Notes Source Code Demo     2019-04-16 优化结构 - -   2019-04-13 首次提交 objc4-750、xnu-4903.221.2 Category in Obj-C    Preface Obj-C 中的 Category 中文常译作分类、类别（为表述统一，本文将使用 Category 特指该技术）。我们经常会使用 Category 来对一个类进行扩展，使得在不破坏主类结构的同时可以具备更多的功能；也可以使用 Category 对一个类进行拆分，使得其结构更加清晰条理。本文将从 What - How - Why 谈谈 iOS 中 Category。
What 什么是 Category 呢？
Category 是 Obj-C 语言中所提供的一项功能，它可以为 Obj-C 类添加额外的属性、方法，也可以遵守其他协议。
Xcode 中已经为 Category 已经提供了模版来建立，只需要指定 Category 的名称以及被添加 Category 类名即可。当然，我们也可以手动来自己建立，Category 的语法与类的声明与实现比较类似：
@interface Foo (Bar) &amp;lt;SomeProtocol&amp;gt; - (void)foo; @end @implementation Foo (Bar) - (void)foo {} - (void)someMethodFromProtocol {} @end  How Category 通常都有哪些用处呢？" />
<meta property="og:url" content="/posts/2019/category_in_obj-c/" />
<meta property="og:site_name" content="iOS 中的 Category" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-04-13 00:00:00 &#43;0000 UTC" />











</head>
<body class="">


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    iBlog
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/2019/category_in_obj-c/">iOS 中的 Category</a></h1>
  <div class="post-meta">
    <span class="post-date">
      2019-04-13
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/focus/">Focus</a>&nbsp;
    
    #<a href="/tags/ios/">iOS</a>&nbsp;
    
    #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Source Code</th>
<th align="center">Demo</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2019-04-16</td>
<td align="center">优化结构</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>

<tr>
<td align="center">2019-04-13</td>
<td align="center">首次提交</td>
<td align="center"><a href="https://opensource.apple.com/tarballs/objc4/">objc4-750</a>、<a href="https://opensource.apple.com/tarballs/xnu/">xnu-4903.221.2</a></td>
<td align="center"><a href="https://github.com/kingcos/Perspective/tree/writing/Posts/Focus/Category_in_Obj-C/">Category in Obj-C</a></td>
</tr>
</tbody>
</table>

<h2 id="preface">Preface</h2>

<p>Obj-C 中的 Category 中文常译作分类、类别（为表述统一，本文将使用 Category 特指该技术）。我们经常会使用 Category 来对一个类进行扩展，使得在不破坏主类结构的同时可以具备更多的功能；也可以使用 Category 对一个类进行拆分，使得其结构更加清晰条理。本文将从 What - How - Why 谈谈 iOS 中 Category。</p>

<h2 id="what">What</h2>

<p>什么是 Category 呢？</p>

<p>Category 是 Obj-C 语言中所提供的一项功能，它可以为 Obj-C 类添加额外的属性、方法，也可以遵守其他协议。</p>

<p><img src="/img/2019/Category_in_Obj-C/1.png" alt="" /></p>

<p>Xcode 中已经为 Category 已经提供了模版来建立，只需要指定 Category 的名称以及被添加 Category 类名即可。当然，我们也可以手动来自己建立，Category 的语法与类的声明与实现比较类似：</p>

<pre><code class="language-objectivec">@interface Foo (Bar) &lt;SomeProtocol&gt;
- (void)foo;
@end

@implementation Foo (Bar)
- (void)foo {}

- (void)someMethodFromProtocol {}
@end
</code></pre>

<h2 id="how">How</h2>

<p>Category 通常都有哪些用处呢？</p>

<h3 id="解耦">解耦</h3>

<p>假如有一个人（Person），他需要工作（Work）和生活（Life），而工作和生活所做的事情显然是不一样的，那么我们就可以使用 Category 将人的这它们进行解耦：</p>

<pre><code class="language-objectivec">@interface Person
@property (nonatomic, copy) NSString *name;
@end

@implementation Person
@end

// ---

@interface Person (Life)
- (void)playWithPet;
@end

@implementation Person (Life)
- (void)playWithPet {}
@end

// ---

@interface Person (Work)
- (void)codeForWork;
@end

@implementation Person (Work)
- (void)codeForWork {}
@end
</code></pre>

<p>这样，Person+Life 中可以定义与生活相关的方法，而 Person+Work 中将专注于工作。而且当人需要运动（Sports）时，只需要再为 Person 添加 Person+Sports 的 Category 即可，而不需要改动主类原本的结果就能实现。</p>

<h3 id="私有化">私有化</h3>

<p>使用 Xcode 模版新建 Category 后，将会自动创建两个文件：ClassName+CategoryName.h &amp; ClassName+CategoryName.m。当不希望某个 Category 在外界访问时，只需要不作为公共头文件（Public Header）暴露出去即可，也就实现了私有化。需要注意的是，同样可以实现私有化的方案是使用类扩展（Class Extension），其因语法相似但没有名称被很多人称为「匿名分类（Category）」。不过本质上说，Category 和类扩展是完全不同的。</p>

<pre><code class="language-objectivec">// Class Extension
@interface Person ()
- (void)secret;
@end
</code></pre>

<p>类扩展是可以定义在单独的 .h 或者 .m 中，其主要可以使得外界无法直接访问到定义的成员变量、属性或方法。关于类扩展与访问控制相关更加详细的内容，可以参考「Obj-C 中成员变量和类的访问控制」一文。</p>

<h3 id="反私有化">反私有化</h3>

<p>Category 不仅可以私有化，其实也可以反私有化。我们可以在 Person 内部 .m 中实现一个吃（<code>eat</code>）和一个喝（<code>drink</code>）的方法，却不声明在 .h 中。而我们在外界如果得知了方法名，而且想要调用到该方法，却又不能破坏内部结构，那我们就可以在 Category 或者类扩展中声明出去。当然，「反私有化」的做法还是会有一定的风险性，因为内部方法的隐藏一定是有原因的，如果非必要请避免这样做。</p>

<pre><code class="language-objectivec">// Person.h
@interface Person : NSObject
@end

// Person.m
@implementation Person
- (void)eat {
    NSLog(@&quot;%s&quot;, __func__);
}

- (void)drink {
    NSLog(@&quot;%s&quot;, __func__);
}
@end

// Person+Category.h
@interface Person (Category)
- (void)eat;
@end

// Person+Extension.h
@interface Person ()
- (void)drink;
@end
</code></pre>

<h3 id="多继承">「多继承」</h3>

<p>因为 Category 是支持遵守协议（Protocol）的，那么不同的 Category 就可以遵守不同的协议，实现类似「多继承」的特性。但为什么是加引号的「多继承」呢？因为这样的协议遵守只能获得方法的声明，却无法获得父类的具体实现。</p>

<pre><code class="language-objectivec">@protocol LifeProtocol &lt;NSObject&gt;
- (void)playWithPet;
@end

@interface Person (Life) &lt;LifeProtocol&gt;
@end

@implementation Person (Life)
- (void)playWithPet {}
@end

// ---

@protocol WorkProtocol &lt;NSObject&gt;
- (void) workHard;
@end

@interface Person (Work) &lt;WorkProtocol&gt;
@end

@implementation Person (Work)
- (void)workHard {}
@end
</code></pre>

<h2 id="why">Why</h2>

<p>Obj-C 中的 Category 底层是如何实现的呢？</p>

<h3 id="结构">结构</h3>

<pre><code class="language-objectivec">// Person+Life.h
/**
 LifeProtocol
 */
@protocol LifeProtocol &lt;NSObject&gt;
- (void)eat;
@end

/**
 Person+Life
 */
@interface Person (Life) &lt;LifeProtocol&gt;

@property (nonatomic, copy) NSString *name;

// Instance method
- (void)run;

// Class method
+ (void)foo;

// Protocol method
- (void)eat;

@end
</code></pre>

<p>定义一个完整的 Person 类，它遵守了协议，存储了属性，并定义实现了对象方法和类方法。为了便于下面的分析，我们使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc Person+Life.m</code> 命令将 Person+Life.m 翻译为 C/C++ 代码（Person+Life.cpp），关于翻译 Obj-C 代码的细节可以参考文末的「将 Obj-C 代码翻译为 C++ 代码」一文。</p>

<pre><code class="language-cpp">// Person+Life.cpp
struct _category_t {
	const char *name;                               // 类名
	struct _class_t *cls;                           // 类指针
	const struct _method_list_t *instance_methods;  // 对象方法列表指针
	const struct _method_list_t *class_methods;     // 类方法列表指针
	const struct _protocol_list_t *protocols;       // 协议列表指针
	const struct _prop_list_t *properties;          // 属性列表指针
};

static struct _category_t _OBJC_$_CATEGORY_Person_$_Life __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = 
{
	&quot;Person&quot;,
	0, // &amp;OBJC_CLASS_$_Person,
	(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Life,
	(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_Person_$_Life,
	(const struct _protocol_list_t *)&amp;_OBJC_CATEGORY_PROTOCOLS_$_Person_$_Life,
	(const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_Person_$_Life,
};

// 对象方法列表
static struct /*_method_list_t*/ {
	unsigned int entsize;  // sizeof(struct _objc_method)
	unsigned int method_count;
	struct _objc_method method_list[2];
} _OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Life __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = {
	sizeof(_objc_method),
	2,
	{{(struct objc_selector *)&quot;run&quot;, &quot;v16@0:8&quot;, (void *)_I_Person_Life_run},
	{(struct objc_selector *)&quot;eat&quot;, &quot;v16@0:8&quot;, (void *)_I_Person_Life_eat}}
};

// 类方法列表
static struct /*_method_list_t*/ {
	unsigned int entsize;  // sizeof(struct _objc_method)
	unsigned int method_count;
	struct _objc_method method_list[1];
} _OBJC_$_CATEGORY_CLASS_METHODS_Person_$_Life __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = {
	sizeof(_objc_method),
	1,
	{{(struct objc_selector *)&quot;foo&quot;, &quot;v16@0:8&quot;, (void *)_C_Person_Life_foo}}
};

// 协议列表
static struct /*_protocol_list_t*/ {
	long protocol_count;  // Note, this is 32/64 bit
	struct _protocol_t *super_protocols[1];
} _OBJC_CATEGORY_PROTOCOLS_$_Person_$_Life __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = {
	1,
	&amp;_OBJC_PROTOCOL_LifeProtocol
};

// 属性列表
static struct /*_prop_list_t*/ {
	unsigned int entsize;  // sizeof(struct _prop_t)
	unsigned int count_of_properties;
	struct _prop_t prop_list[1];
} _OBJC_$_PROP_LIST_Person_$_Life __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = {
	sizeof(_prop_t),
	1,
	{{&quot;name&quot;,&quot;T@\&quot;NSString\&quot;,C,N&quot;}}
};
</code></pre>

<p>在翻译后的 C++ 源代码中，我们可以发现一个名称和 Category 相关的结构体定义：<code>_category_t</code>，该结构体表示了 Obj-C 中 Category 的实际结构；<code>_OBJC_$_CATEGORY_Person_$_Life</code> 则就是我们定义的 Person+Life Category。<code>_category_t</code> 结构体中存储了类名、类指针、对象方法列表指针、类方法列表指针、协议列表指针、以及属性列表指针，所以 Category 中支持遵守协议、声明属性、以及定义实现对象方法和类方法（不支持定义成员变量）。当然，在 Apple 开源的 objc4 中，也可以找到 <code>category_t</code> 结构体：</p>

<pre><code class="language-cpp">// objc-runtime-new.h
struct category_t {
    const char *name;
    classref_t cls;
    struct method_list_t *instanceMethods;
    struct method_list_t *classMethods;
    struct protocol_list_t *protocols;
    struct property_list_t *instanceProperties;
    // Fields below this point are not always present on disk.
    // 以下内容并不能保证会在磁盘中展示
    struct property_list_t *_classProperties;

    method_list_t *methodsForMeta(bool isMeta) {
        if (isMeta) return classMethods;
        else return instanceMethods;
    }

    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);
};
</code></pre>

<h3 id="实现原理">实现原理</h3>

<p>当我们的代码编译完，Category 中的信息就将被存储在 <code>category_t</code> 的结构体中，那么运行时的 Category 又会变成什么样呢？</p>

<h4 id="what-1">What</h4>

<p>我们尝试分别在 <code>Person</code> 主类、Person+Life 和 Person+Work Category 中定义并实现完全相同的 <code>smile</code> 方法。有个细节是，我们在 Category 中实现主类中已经实现的方法时，编译器会警告「Category is implementing a method which will also be implemented by its primary class」，这又是为什么呢？</p>

<pre><code class="language-objectivec">// Person.h
@interface Person : NSObject
- (void)smile;
@end

// Person+Life.h
@interface Person (Life) &lt;LifeProtocol&gt;
// ...

- (void)smile;
@end

// Person+Work.h
@interface Person (Work)
- (void)smile;
@end

// main.m
Person *p = [[Person alloc] init];
[p smile];

// OUTPUT:
// Person (Work) - -[Person(Work) smile]
</code></pre>

<p>当我们运行程序，发现最终只输出了一句，并且是调用到了 Person+Work Category 中的方法。那么先说结论：<strong>当 Category 中实现了主类中同一个方法时，将总是调用 Category 中的方法（这也是为何编译器警告的原因）；当存在多个 Category 实现同一个方法时，将总是调用最后被编译的 Category 中的方法</strong>。如何查看文件的编译顺序呢？在 Xcode -「Build Phases」-「Compile Sources」中，靠前的即是最先被编译的：</p>

<p><img src="/img/2019/Category_in_Obj-C/2.png" alt="" /></p>

<h4 id="why-1">Why</h4>

<p>为了证明上述结论，我们需要在 objc4 的源码中，从 Obj-C 运行时初始化的入口着手，即 <code>_objc_init</code>：</p>

<pre><code class="language-objectivec">// objc-os.mm
/***********************************************************************
* _objc_init
* Bootstrap initialization. Registers our image notifier with dyld.
* 引导初始化。使用 dyld 注册镜像通知器。
* Called by libSystem BEFORE library initialization time
* 在库初始化时间之前由 libSystem 调用
**********************************************************************/

void _objc_init(void)
{
    static bool initialized = false;
    if (initialized) return;
    initialized = true;
    
    // fixme defer initialization until an objc-using image is found?
    environ_init();
    tls_init();
    static_init();
    lock_init();
    exception_init();

    // ➡️ dyld 注册通知；map_images：映射镜像，load_images：加载镜像，unmap_image：反映射镜像
    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);
}

// objc-runtime-new.mm
/***********************************************************************
* map_images
* Process the given images which are being mapped in by dyld.
* 由 dyld 处理给定将要映射的镜像。
* Calls ABI-agnostic code after taking ABI-specific locks.
* 加上指定 ABI 锁后调用 ABI 无关（agnostic）的代码。
*
* Locking: write-locks runtimeLock
* 锁：写锁 runtimeLock
**********************************************************************/
void
map_images(unsigned count, const char * const paths[],
           const struct mach_header * const mhdrs[])
{
    // 互斥锁
    mutex_locker_t lock(runtimeLock);
    // ➡️ map_images_nolock：映射镜像（无锁）
    return map_images_nolock(count, paths, mhdrs);
}

// objc-os.mm
void 
map_images_nolock(unsigned mhCount, const char * const mhPaths[],
                  const struct mach_header * const mhdrs[])
{
    static bool firstTime = YES;
    header_info *hList[mhCount];
    uint32_t hCount;
    size_t selrefCount = 0;

    // Perform first-time initialization if necessary.
    // 必要时执行首次初始化。
    // This function is called before ordinary library initializers.
    // 在普通库构造方法之前调用该函数。
    // fixme defer initialization until an objc-using image is found?
    if (firstTime) {
        preopt_init();
    }

    // Xcode 中 OBJC_PRINT_IMAGES 环境变量值为 YES 时，将可在控制台打印该信息
    // OPTION(PrintImages, OBJC_PRINT_IMAGES, &quot;log image and library names as they are loaded&quot;)
    if (PrintImages) {
        _objc_inform(&quot;IMAGES: processing %u newly-mapped images...\n&quot;, mhCount);
    }


    // Find all images with Objective-C metadata.
    // 使用 Obj-C 元数据查找所有镜像。
    hCount = 0;

    // Count classes. Size various table based on the total.
    // 计算类。根据总数计算不同的表。
    int totalClasses = 0;
    int unoptimizedTotalClasses = 0;
    {
        uint32_t i = mhCount;
        // 遍历 mach-o header
        while (i--) {
            const headerType *mhdr = (const headerType *)mhdrs[i];

            // ➡️ addHeader：添加头部信息（计算类的总数、未优化的类总数）
            auto hi = addHeader(mhdr, mhPaths[i], totalClasses, unoptimizedTotalClasses);
            if (!hi) {
                // no objc data in this entry
                // 若 hi 为空，则该条目没有 Obj-C 数据
                continue;
            }
            
            // 判断文件类型是否是可执行文件
            // #define	MH_EXECUTE	0x2		/* demand paged executable file */
            if (mhdr-&gt;filetype == MH_EXECUTE) {
                // Size some data structures based on main executable's size
                // 根据主可执行文件的大小调整一些数据结构的大小
#if __OBJC2__
                size_t count;
                
                // 在 __objc_selrefs 节获取 SEL 引用（此处可参考 Mach-O 或 Link Map 文件中 Sections 部分）
                // GETSECT(_getObjc2SelectorRefs,        SEL,             &quot;__objc_selrefs&quot;); 
                _getObjc2SelectorRefs(hi, &amp;count);
                selrefCount += count;
                // 在 __objc_msgrefs 节获取消息引用
                // GETSECT(_getObjc2MessageRefs,         message_ref_t,   &quot;__objc_msgrefs&quot;); 
                _getObjc2MessageRefs(hi, &amp;count);
                selrefCount += count;
#else
                _getObjcSelectorRefs(hi, &amp;selrefCount);
#endif
                
#if SUPPORT_GC_COMPAT
                // Halt if this is a GC app.
                if (shouldRejectGCApp(hi)) {
                    _objc_fatal_with_reason
                        (OBJC_EXIT_REASON_GC_NOT_SUPPORTED, 
                         OS_REASON_FLAG_CONSISTENT_FAILURE, 
                         &quot;Objective-C garbage collection &quot; 
                         &quot;is no longer supported.&quot;);
                }
#endif
            }
            
            // hList 保存 hi 并 hCount 自增
            hList[hCount++] = hi;
            
            if (PrintImages) {
                _objc_inform(&quot;IMAGES: loading image for %s%s%s%s%s\n&quot;, 
                             hi-&gt;fname(),
                             mhdr-&gt;filetype == MH_BUNDLE ? &quot; (bundle)&quot; : &quot;&quot;,
                             hi-&gt;info()-&gt;isReplacement() ? &quot; (replacement)&quot; : &quot;&quot;,
                             hi-&gt;info()-&gt;hasCategoryClassProperties() ? &quot; (has class properties)&quot; : &quot;&quot;,
                             hi-&gt;info()-&gt;optimizedByDyld()?&quot; (preoptimized)&quot;:&quot;&quot;);
            }
        }
    }

    // Perform one-time runtime initialization that must be deferred until 
    // the executable itself is found. This needs to be done before 
    // further initialization.
    // (The executable may not be present in this infoList if the 
    // executable does not contain Objective-C code but Objective-C 
    // is dynamically loaded later.
    // 在找到可执行文件本身之前必须延迟执行一次性运行时初始化。
    // 这需要在进一步初始化之前完成。
    // （如果可执行文件不包含 Obj-C 代码但 Obj-C 在之后动态加载，则 infoList 中可能不包含该可执行文件。）
    if (firstTime) {
        sel_init(selrefCount);
        arr_init();

#if SUPPORT_GC_COMPAT
        // Reject any GC images linked to the main executable.
        // We already rejected the app itself above.
        // Images loaded after launch will be rejected by dyld.

        for (uint32_t i = 0; i &lt; hCount; i++) {
            auto hi = hList[i];
            auto mh = hi-&gt;mhdr();
            if (mh-&gt;filetype != MH_EXECUTE  &amp;&amp;  shouldRejectGCImage(mh)) {
                _objc_fatal_with_reason
                    (OBJC_EXIT_REASON_GC_NOT_SUPPORTED, 
                     OS_REASON_FLAG_CONSISTENT_FAILURE, 
                     &quot;%s requires Objective-C garbage collection &quot;
                     &quot;which is no longer supported.&quot;, hi-&gt;fname());
            }
        }
#endif

#if TARGET_OS_OSX
        // Disable +initialize fork safety if the app is too old (&lt; 10.13).
        // Disable +initialize fork safety if the app has a
        //   __DATA,__objc_fork_ok section.

        if (dyld_get_program_sdk_version() &lt; DYLD_MACOSX_VERSION_10_13) {
            DisableInitializeForkSafety = true;
            if (PrintInitializing) {
                _objc_inform(&quot;INITIALIZE: disabling +initialize fork &quot;
                             &quot;safety enforcement because the app is &quot;
                             &quot;too old (SDK version &quot; SDK_FORMAT &quot;)&quot;,
                             FORMAT_SDK(dyld_get_program_sdk_version()));
            }
        }

        for (uint32_t i = 0; i &lt; hCount; i++) {
            auto hi = hList[i];
            auto mh = hi-&gt;mhdr();
            if (mh-&gt;filetype != MH_EXECUTE) continue;
            unsigned long size;
            if (getsectiondata(hi-&gt;mhdr(), &quot;__DATA&quot;, &quot;__objc_fork_ok&quot;, &amp;size)) {
                DisableInitializeForkSafety = true;
                if (PrintInitializing) {
                    _objc_inform(&quot;INITIALIZE: disabling +initialize fork &quot;
                                 &quot;safety enforcement because the app has &quot;
                                 &quot;a __DATA,__objc_fork_ok section&quot;);
                }
            }
            break;  // assume only one MH_EXECUTE image
        }
#endif

    }

    if (hCount &gt; 0) {
        // ➡️ 读取镜像（传入 header_info 列表，数量，类的总数，未优化的类的总数）
        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);
    }

    // 第一次执行完毕后，置为 NO
    firstTime = NO;
}

// objc-os.mm
static header_info * addHeader(const headerType *mhdr, const char *path, int &amp;totalClasses, int &amp;unoptimizedTotalClasses)
{
    header_info *hi;

    if (bad_magic(mhdr)) return NULL;

    bool inSharedCache = false;

    // Look for hinfo from the dyld shared cache.
    // 在 dyld 共享缓存中寻找 hinfo（关于 dyld 共享缓存可参考文末「谈谈 iOS 中的 dyld_shared_cache」一文）。
    // 为头部预优化 hinfo
    hi = preoptimizedHinfoForHeader(mhdr);
    if (hi) {
        // Found an hinfo in the dyld shared cache.
        // 在 dyld 共享缓存中找到 hinfo

        // Weed out duplicates.
        // 去除重复（若该 hi 已被加载，则返回空）。
        if (hi-&gt;isLoaded()) {
            return NULL;
        }

        inSharedCache = true;

        // Initialize fields not set by the shared cache
        // 初始化未由共享缓存设置的域
        // hi-&gt;next is set by appendHeader
        // hi-&gt;next 由 appendHeader 设置
        // 设置已加载为 true
        hi-&gt;setLoaded(true);

        // Xcode 中 OBJC_PRINT_PREOPTIMIZATION 环境变量值为 YES 时，将可在控制台打印该信息
        // OPTION(PrintPreopt, OBJC_PRINT_PREOPTIMIZATION, &quot;log preoptimization courtesy of dyld shared cache&quot;)
        if (PrintPreopt) {
            _objc_inform(&quot;PREOPTIMIZATION: honoring preoptimized header info at %p for %s&quot;, hi, hi-&gt;fname());
        }

#if !__OBJC2__
        _objc_fatal(&quot;shouldn't be here&quot;);
#endif
#if DEBUG
        // Verify image_info
        // DEBUG 模式校验 image_info
        size_t info_size = 0;
        const objc_image_info *image_info = _getObjcImageInfo(mhdr,&amp;info_size);
        assert(image_info == hi-&gt;info());
#endif
    }
    else 
    {
        // Didn't find an hinfo in the dyld shared cache.
        // 在 dyld 共享缓存中未找到 hinfo。

        // Weed out duplicates
        // 去除重复
        for (hi = FirstHeader; hi; hi = hi-&gt;getNext()) {
            if (mhdr == hi-&gt;mhdr()) return NULL;
        }

        // Locate the __OBJC segment
        // 定位 __OBJC 段（Segment）
        size_t info_size = 0;
        unsigned long seg_size;
        // _getObjcImageInfo：内部实际是获取 __objc_imageinfo 数据（__DATA 或 __DATA_CONST 或 __DATA_DIRTY）节（Section）信息
        const objc_image_info *image_info = _getObjcImageInfo(mhdr,&amp;info_size);
        // getsegmentdata：获取 __OBJC 段数据
        // #define	SEG_OBJC	&quot;__OBJC&quot;	/* objective-C runtime segment */
        const uint8_t *objc_segment = getsegmentdata(mhdr,SEG_OBJC,&amp;seg_size);
        // 若都没有获取到，返回空
        if (!objc_segment  &amp;&amp;  !image_info) return NULL;

        // Allocate a header_info entry.
        // 分配一个 header_info。
        // Note we also allocate space for a single header_info_rw in the
        // rw_data[] inside header_info.
        // 注意我们在 header_info 内部的 rw_data[] 也为单个 header_info_rw 分配了空间。
        hi = (header_info *)calloc(sizeof(header_info) + sizeof(header_info_rw), 1);

        // Set up the new header_info entry.
        // 设置新的 header_info。
        hi-&gt;setmhdr(mhdr);
#if !__OBJC2__
        // mhdr must already be set
        hi-&gt;mod_count = 0;
        hi-&gt;mod_ptr = _getObjcModules(hi, &amp;hi-&gt;mod_count);
#endif
        // Install a placeholder image_info if absent to simplify code elsewhere
        // 如果没有在其他地方简化代码则安装占位符 image_info
        static const objc_image_info emptyInfo = {0, 0};
        hi-&gt;setinfo(image_info ?: &amp;emptyInfo);

        // 设置已加载为 true
        hi-&gt;setLoaded(true);
        hi-&gt;setAllClassesRealized(NO);
    }

#if __OBJC2__
    {
        size_t count = 0;
        // 在 __objc_classlist 节获取类列表
        // GETSECT(_getObjc2ClassList,           classref_t,      &quot;__objc_classlist&quot;);
        if (_getObjc2ClassList(hi, &amp;count)) {
            // totalClasses 设置为获取到的类数量
            totalClasses += (int)count;
            // 若获取的 header_info 不在共享缓存中，则视为未优化类，更新 unoptimizedTotalClasses
            if (!inSharedCache) unoptimizedTotalClasses += count;
        }
    }
#endif

    appendHeader(hi);
    
    return hi;
}

// objc-runtime-new.mm
/***********************************************************************
* _read_images
* Perform initial processing of the headers in the linked 
* list beginning with headerList. 
* 从 headerList 开始为链表中的头部执行初始处理。
*
* Called by: map_images_nolock
* 由 map_images_nolock 调用
*
* Locking: runtimeLock acquired by map_images
* 锁：由 map_images 获得的 runtimeLock
**********************************************************************/
void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)
{
    header_info *hi;
    uint32_t hIndex;
    size_t count;
    size_t i;
    Class *resolvedFutureClasses = nil;
    size_t resolvedFutureClassCount = 0;
    static bool doneOnce;
    TimeLogger ts(PrintImageTimes);

    runtimeLock.assertLocked();

#define EACH_HEADER \
    hIndex = 0;         \
    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \
    hIndex++

    if (!doneOnce) {
        doneOnce = YES;

#if SUPPORT_NONPOINTER_ISA
        // Disable non-pointer isa under some conditions.

# if SUPPORT_INDEXED_ISA
        // Disable nonpointer isa if any image contains old Swift code
        for (EACH_HEADER) {
            if (hi-&gt;info()-&gt;containsSwift()  &amp;&amp;
                hi-&gt;info()-&gt;swiftVersion() &lt; objc_image_info::SwiftVersion3)
            {
                DisableNonpointerIsa = true;
                if (PrintRawIsa) {
                    _objc_inform(&quot;RAW ISA: disabling non-pointer isa because &quot;
                                 &quot;the app or a framework contains Swift code &quot;
                                 &quot;older than Swift 3.0&quot;);
                }
                break;
            }
        }
# endif

# if TARGET_OS_OSX
        // Disable non-pointer isa if the app is too old
        // (linked before OS X 10.11)
        if (dyld_get_program_sdk_version() &lt; DYLD_MACOSX_VERSION_10_11) {
            DisableNonpointerIsa = true;
            if (PrintRawIsa) {
                _objc_inform(&quot;RAW ISA: disabling non-pointer isa because &quot;
                             &quot;the app is too old (SDK version &quot; SDK_FORMAT &quot;)&quot;,
                             FORMAT_SDK(dyld_get_program_sdk_version()));
            }
        }

        // Disable non-pointer isa if the app has a __DATA,__objc_rawisa section
        // New apps that load old extensions may need this.
        for (EACH_HEADER) {
            if (hi-&gt;mhdr()-&gt;filetype != MH_EXECUTE) continue;
            unsigned long size;
            if (getsectiondata(hi-&gt;mhdr(), &quot;__DATA&quot;, &quot;__objc_rawisa&quot;, &amp;size)) {
                DisableNonpointerIsa = true;
                if (PrintRawIsa) {
                    _objc_inform(&quot;RAW ISA: disabling non-pointer isa because &quot;
                                 &quot;the app has a __DATA,__objc_rawisa section&quot;);
                }
            }
            break;  // assume only one MH_EXECUTE image
        }
# endif

#endif

        if (DisableTaggedPointers) {
            disableTaggedPointers();
        }
        
        initializeTaggedPointerObfuscator();

        if (PrintConnecting) {
            _objc_inform(&quot;CLASS: found %d classes during launch&quot;, totalClasses);
        }

        // namedClasses
        // Preoptimized classes don't go in this table.
        // 4/3 is NXMapTable's load factor
        int namedClassesSize = 
            (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * 4 / 3;
        gdb_objc_realized_classes =
            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);
        
        allocatedClasses = NXCreateHashTable(NXPtrPrototype, 0, nil);
        
        ts.log(&quot;IMAGE TIMES: first time tasks&quot;);
    }


    // Discover classes. Fix up unresolved future classes. Mark bundle classes.

    for (EACH_HEADER) {
        classref_t *classlist = _getObjc2ClassList(hi, &amp;count);
        
        if (! mustReadClasses(hi)) {
            // Image is sufficiently optimized that we need not call readClass()
            continue;
        }

        bool headerIsBundle = hi-&gt;isBundle();
        bool headerIsPreoptimized = hi-&gt;isPreoptimized();

        for (i = 0; i &lt; count; i++) {
            Class cls = (Class)classlist[i];
            Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);

            if (newCls != cls  &amp;&amp;  newCls) {
                // Class was moved but not deleted. Currently this occurs 
                // only when the new class resolved a future class.
                // Non-lazily realize the class below.
                resolvedFutureClasses = (Class *)
                    realloc(resolvedFutureClasses, 
                            (resolvedFutureClassCount+1) * sizeof(Class));
                resolvedFutureClasses[resolvedFutureClassCount++] = newCls;
            }
        }
    }

    ts.log(&quot;IMAGE TIMES: discover classes&quot;);

    // Fix up remapped classes
    // Class list and nonlazy class list remain unremapped.
    // Class refs and super refs are remapped for message dispatching.
    
    if (!noClassesRemapped()) {
        for (EACH_HEADER) {
            Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);
            for (i = 0; i &lt; count; i++) {
                remapClassRef(&amp;classrefs[i]);
            }
            // fixme why doesn't test future1 catch the absence of this?
            classrefs = _getObjc2SuperRefs(hi, &amp;count);
            for (i = 0; i &lt; count; i++) {
                remapClassRef(&amp;classrefs[i]);
            }
        }
    }

    ts.log(&quot;IMAGE TIMES: remap classes&quot;);

    // Fix up @selector references
    static size_t UnfixedSelectors;
    {
        mutex_locker_t lock(selLock);
        for (EACH_HEADER) {
            if (hi-&gt;isPreoptimized()) continue;
            
            bool isBundle = hi-&gt;isBundle();
            SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);
            UnfixedSelectors += count;
            for (i = 0; i &lt; count; i++) {
                const char *name = sel_cname(sels[i]);
                sels[i] = sel_registerNameNoLock(name, isBundle);
            }
        }
    }

    ts.log(&quot;IMAGE TIMES: fix up selector references&quot;);

#if SUPPORT_FIXUP
    // Fix up old objc_msgSend_fixup call sites
    for (EACH_HEADER) {
        message_ref_t *refs = _getObjc2MessageRefs(hi, &amp;count);
        if (count == 0) continue;

        if (PrintVtables) {
            _objc_inform(&quot;VTABLES: repairing %zu unsupported vtable dispatch &quot;
                         &quot;call sites in %s&quot;, count, hi-&gt;fname());
        }
        for (i = 0; i &lt; count; i++) {
            fixupMessageRef(refs+i);
        }
    }

    ts.log(&quot;IMAGE TIMES: fix up objc_msgSend_fixup&quot;);
#endif

    // Discover protocols. Fix up protocol refs.
    for (EACH_HEADER) {
        extern objc_class OBJC_CLASS_$_Protocol;
        Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;
        assert(cls);
        NXMapTable *protocol_map = protocols();
        bool isPreoptimized = hi-&gt;isPreoptimized();
        bool isBundle = hi-&gt;isBundle();

        protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;count);
        for (i = 0; i &lt; count; i++) {
            readProtocol(protolist[i], cls, protocol_map, 
                         isPreoptimized, isBundle);
        }
    }

    ts.log(&quot;IMAGE TIMES: discover protocols&quot;);

    // Fix up @protocol references
    // Preoptimized images may have the right 
    // answer already but we don't know for sure.
    for (EACH_HEADER) {
        protocol_t **protolist = _getObjc2ProtocolRefs(hi, &amp;count);
        for (i = 0; i &lt; count; i++) {
            remapProtocolRef(&amp;protolist[i]);
        }
    }

    ts.log(&quot;IMAGE TIMES: fix up @protocol references&quot;);

    // Realize non-lazy classes (for +load methods and static instances)
    for (EACH_HEADER) {
        classref_t *classlist = 
            _getObjc2NonlazyClassList(hi, &amp;count);
        for (i = 0; i &lt; count; i++) {
            Class cls = remapClass(classlist[i]);
            if (!cls) continue;

            // hack for class __ARCLite__, which didn't get this above
#if TARGET_OS_SIMULATOR
            if (cls-&gt;cache._buckets == (void*)&amp;_objc_empty_cache  &amp;&amp;  
                (cls-&gt;cache._mask  ||  cls-&gt;cache._occupied)) 
            {
                cls-&gt;cache._mask = 0;
                cls-&gt;cache._occupied = 0;
            }
            if (cls-&gt;ISA()-&gt;cache._buckets == (void*)&amp;_objc_empty_cache  &amp;&amp;  
                (cls-&gt;ISA()-&gt;cache._mask  ||  cls-&gt;ISA()-&gt;cache._occupied)) 
            {
                cls-&gt;ISA()-&gt;cache._mask = 0;
                cls-&gt;ISA()-&gt;cache._occupied = 0;
            }
#endif
            
            addClassTableEntry(cls);
            realizeClass(cls);
        }
    }

    ts.log(&quot;IMAGE TIMES: realize non-lazy classes&quot;);

    // Realize newly-resolved future classes, in case CF manipulates them
    if (resolvedFutureClasses) {
        for (i = 0; i &lt; resolvedFutureClassCount; i++) {
            realizeClass(resolvedFutureClasses[i]);
            resolvedFutureClasses[i]-&gt;setInstancesRequireRawIsa(false/*inherited*/);
        }
        free(resolvedFutureClasses);
    }    

    ts.log(&quot;IMAGE TIMES: realize future classes&quot;);

    // ➡️ Category
    // Discover categories.
    // 发现 Category。
    // 遍历 hList 中的 header_info
    for (EACH_HEADER) {
        // 在 __objc_catlist 节获取 Category 列表
        // GETSECT(_getObjc2CategoryList,        category_t *,    &quot;__objc_catlist&quot;);
        category_t **catlist = 
            _getObjc2CategoryList(hi, &amp;count);
        bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();

        // 遍历 Category
        for (i = 0; i &lt; count; i++) {
            // 获取第 i 个 Category，类型为 category_t
            category_t *cat = catlist[i];
            // 根据 Category 的 cls 重新映射类
            Class cls = remapClass(cat-&gt;cls);

            // 类为空时
            if (!cls) {
                // Category's target class is missing (probably weak-linked).
                // Category 的目标类丢失（可能为弱链接）。
                // Disavow any knowledge of this category.
                // 否认对此 Category 的任何了解。
                // 将 Category 置为 nil
                catlist[i] = nil;
                if (PrintConnecting) {
                    _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;
                                 &quot;missing weak-linked target class&quot;, 
                                 cat-&gt;name, cat);
                }
                continue;
            }
            
            // 类非空时

            // Process this category. 
            // First, register the category with its target class. 
            // Then, rebuild the class's method lists (etc) if 
            // the class is realized. 
            // 处理该 Category。
            // 首先，使用目标类注册 Category。
            // 然后，如果实现了类，则重建类的方法列表（等）。
            bool classExists = NO;
            // 判断 Category 中存在对象方法、协议、或属性
            if (cat-&gt;instanceMethods ||  cat-&gt;protocols  
                ||  cat-&gt;instanceProperties) 
            {
                // 记录未附加上的 Category
                addUnattachedCategoryForClass(cat, cls, hi);
                if (cls-&gt;isRealized()) {
                    // ➡️ 如果实现了类，重建类
                    remethodizeClass(cls);
                    classExists = YES;
                }
                if (PrintConnecting) {
                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;, 
                                 cls-&gt;nameForLogging(), cat-&gt;name, 
                                 classExists ? &quot;on existing class&quot; : &quot;&quot;);
                }
            }

            // 判断 Category 中存在类方法、协议、或类属性
            if (cat-&gt;classMethods  ||  cat-&gt;protocols  
                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) 
            {
                // 记录未附加上的 Category
                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);
                if (cls-&gt;ISA()-&gt;isRealized()) {
                    // ➡️  如果实现了元类，重建元类
                    remethodizeClass(cls-&gt;ISA());
                }
                if (PrintConnecting) {
                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;, 
                                 cls-&gt;nameForLogging(), cat-&gt;name);
                }
            }
        }
    }

    ts.log(&quot;IMAGE TIMES: discover categories&quot;);

    // Category discovery MUST BE LAST to avoid potential races 
    // when other threads call the new category code before 
    // this thread finishes its fixups.

    // +load handled by prepare_load_methods()

    if (DebugNonFragileIvars) {
        realizeAllClasses();
    }


    // Print preoptimization statistics
    if (PrintPreopt) {
        static unsigned int PreoptTotalMethodLists;
        static unsigned int PreoptOptimizedMethodLists;
        static unsigned int PreoptTotalClasses;
        static unsigned int PreoptOptimizedClasses;

        for (EACH_HEADER) {
            if (hi-&gt;isPreoptimized()) {
                _objc_inform(&quot;PREOPTIMIZATION: honoring preoptimized selectors &quot;
                             &quot;in %s&quot;, hi-&gt;fname());
            }
            else if (hi-&gt;info()-&gt;optimizedByDyld()) {
                _objc_inform(&quot;PREOPTIMIZATION: IGNORING preoptimized selectors &quot;
                             &quot;in %s&quot;, hi-&gt;fname());
            }

            classref_t *classlist = _getObjc2ClassList(hi, &amp;count);
            for (i = 0; i &lt; count; i++) {
                Class cls = remapClass(classlist[i]);
                if (!cls) continue;

                PreoptTotalClasses++;
                if (hi-&gt;isPreoptimized()) {
                    PreoptOptimizedClasses++;
                }
                
                const method_list_t *mlist;
                if ((mlist = ((class_ro_t *)cls-&gt;data())-&gt;baseMethods())) {
                    PreoptTotalMethodLists++;
                    if (mlist-&gt;isFixedUp()) {
                        PreoptOptimizedMethodLists++;
                    }
                }
                if ((mlist=((class_ro_t *)cls-&gt;ISA()-&gt;data())-&gt;baseMethods())) {
                    PreoptTotalMethodLists++;
                    if (mlist-&gt;isFixedUp()) {
                        PreoptOptimizedMethodLists++;
                    }
                }
            }
        }

        _objc_inform(&quot;PREOPTIMIZATION: %zu selector references not &quot;
                     &quot;pre-optimized&quot;, UnfixedSelectors);
        _objc_inform(&quot;PREOPTIMIZATION: %u/%u (%.3g%%) method lists pre-sorted&quot;,
                     PreoptOptimizedMethodLists, PreoptTotalMethodLists, 
                     PreoptTotalMethodLists
                     ? 100.0*PreoptOptimizedMethodLists/PreoptTotalMethodLists 
                     : 0.0);
        _objc_inform(&quot;PREOPTIMIZATION: %u/%u (%.3g%%) classes pre-registered&quot;,
                     PreoptOptimizedClasses, PreoptTotalClasses, 
                     PreoptTotalClasses 
                     ? 100.0*PreoptOptimizedClasses/PreoptTotalClasses
                     : 0.0);
        _objc_inform(&quot;PREOPTIMIZATION: %zu protocol references not &quot;
                     &quot;pre-optimized&quot;, UnfixedProtocolReferences);
    }

#undef EACH_HEADER
}

// objc-runtime-new.mm
/***********************************************************************
* remethodizeClass
* Attach outstanding categories to an existing class.
* 将未完成的 Category 附加到现有类。
* Fixes up cls's method list, protocol list, and property list.
* 修复 cls 的方法列表、协议列表、以及属性列表。
* Updates method caches for cls and its subclasses.
* 更新 cls 以及其子类的方法缓存。
* Locking: runtimeLock must be held by the caller
* 锁：调用者必须持有 runtimeLock
**********************************************************************/
static void remethodizeClass(Class cls)
{
    // Category 列表
    category_list *cats;
    bool isMeta;

    runtimeLock.assertLocked();

    // 是否为元类
    isMeta = cls-&gt;isMetaClass();

    // Re-methodizing: check for more categories
    // 重新方法化：检查更多的 Category
    if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) {
        if (PrintConnecting) {
            _objc_inform(&quot;CLASS: attaching categories to class '%s' %s&quot;, 
                         cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);
        }
        
        // ➡️ 附加 Category（类/元类，Category，是否刷新缓存）
        attachCategories(cls, cats, true /*flush caches*/);        
        free(cats);
    }
}

// objc-runtime-new.mm
// Attach method lists and properties and protocols from categories to a class.
// 将所有 Category 的方法列表、属性列表、协议列表附加到类上。
// Assumes the categories in cats are all loaded and sorted by load order, 
// oldest categories first.
// 假设 cats 中的 Category 都已加载并由加载顺序排序，则最后（编译）的 Category 排在最先。
static void 
attachCategories(Class cls, category_list *cats, bool flush_caches)
{
    if (!cats) return;
    // ➡️ Xcode 中 OBJC_PRINT_REPLACED_METHODS 环境变量值为 YES 时，将可在控制台打印该信息
    // OPTION(PrintReplacedMethods, OBJC_PRINT_REPLACED_METHODS, &quot;log methods replaced by category implementations&quot;)
    if (PrintReplacedMethods) printReplacements(cls, cats);

    // 是否是元类
    bool isMeta = cls-&gt;isMetaClass();

    // fixme rearrange to remove these intermediate allocations
    // 方法列表（指向指针的指针，存储了两维：eg. [[cat_1-&gt;method_a, cat_1-&gt;method_b], [cat_2-&gt;method_c, cat_2-&gt;method_d]]）
    method_list_t **mlists = (method_list_t **)
        malloc(cats-&gt;count * sizeof(*mlists));
    // 属性列表
    property_list_t **proplists = (property_list_t **)
        malloc(cats-&gt;count * sizeof(*proplists));
    // 协议列表
    protocol_list_t **protolists = (protocol_list_t **)
        malloc(cats-&gt;count * sizeof(*protolists));

    // Count backwards through cats to get newest categories first
    int mcount = 0;
    int propcount = 0;
    int protocount = 0;
    // i = Category 的个数
    int i = cats-&gt;count;
    bool fromBundle = NO;
    // ➡️ 将所有 Category 中的方法、属性、协议提取出
    // 倒数 i
    while (i--) {
        // entry = 一个 Category
        auto&amp; entry = cats-&gt;list[i];

        // mlist = Category 中的方法列表
        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);
        if (mlist) {
            mlists[mcount++] = mlist;
            fromBundle |= entry.hi-&gt;isBundle();
        }

        // proplist = Category 中的属性列表
        property_list_t *proplist = 
            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);
        if (proplist) {
            proplists[propcount++] = proplist;
        }

        // protolist = Category 中的协议列表
        protocol_list_t *protolist = entry.cat-&gt;protocols;
        if (protolist) {
            protolists[protocount++] = protolist;
        }
    }

    // rw = 类/元类对象的 class_rw_t *data()
    auto rw = cls-&gt;data();

    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);
    // ➡️ Category 方法列表 -&gt; 类/元类方法列表，方法列表数量（上述二维中第一维的大小）
    rw-&gt;methods.attachLists(mlists, mcount);
    free(mlists);
    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);

    // ➡️ Category 属性列表 -&gt; 类/元类属性列表，属性列表数量（上述二维中第一维的大小）
    rw-&gt;properties.attachLists(proplists, propcount);
    free(proplists);

    // ➡️ Category 协议列表 -&gt; 类/元类协议列表，协议列表数量（上述二维中第一维的大小）
    rw-&gt;protocols.attachLists(protolists, protocount);
    free(protolists);
}

// objc-runtime-new.h
class list_array_tt {
 public:
    void attachLists(List* const * addedLists, uint32_t addedCount) {
        if (addedCount == 0) return;

        if (hasArray()) {
            // many lists -&gt; many lists
            // oldCount = 原有的大小
            uint32_t oldCount = array()-&gt;count;
            // newCount = 原有 + 新增
            uint32_t newCount = oldCount + addedCount;
            // realloc 重新分配内存空间（扩容）
            setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));
            // 设置为新大小
            array()-&gt;count = newCount;
            // array()-&gt;lists 为原有列表的指针
            // 将指针指向的内存内容向后偏移 addedCount
            // void    *memmove(void *__dst, const void *__src, size_t __len);
            memmove(array()-&gt;lists + addedCount, array()-&gt;lists, 
                    oldCount * sizeof(array()-&gt;lists[0]));
            // addedLists 为所有 Category 中相应列表（如方法列表等）的指针
            // 将指针指向的内存内容拷贝到原有列表的指针地址处
            // void    *memcpy(void *__dst, const void *__src, size_t __n);
            memcpy(array()-&gt;lists, addedLists, 
                   addedCount * sizeof(array()-&gt;lists[0]));
        }
        else if (!list  &amp;&amp;  addedCount == 1) {
            // 0 lists -&gt; 1 list
            list = addedLists[0];
        } 
        else {
            // 1 list -&gt; many lists
            List* oldList = list;
            uint32_t oldCount = oldList ? 1 : 0;
            uint32_t newCount = oldCount + addedCount;
            setArray((array_t *)malloc(array_t::byteSize(newCount)));
            array()-&gt;count = newCount;
            if (oldList) array()-&gt;lists[addedCount] = oldList;
            memcpy(array()-&gt;lists, addedLists, 
                   addedCount * sizeof(array()-&gt;lists[0]));
        }
    }
};
</code></pre>

<p>从 <code>realloc</code> 到 <code>memmove</code> 和 <code>memcpy</code> 部分可以参考下图：</p>

<p><img src="/img/2019/Category_in_Obj-C/3.png" alt="" /></p>

<p>因此，对于 Category 在运行时将其中的方法、属性、协议加载到主类的过程搞明白后，之前的结论就水落石出。越靠后编译的 Category，其方法列表最终就越靠前。因此在调用时，虽然主类和其他 Category 中的方法并没有被覆盖，但会因为在前面已经被找到并调用而无法调用到。也是因为方法并没有被覆盖，如果我们在 Category 中仅声明却不实现，运行时仍将找到主类中的实现。从上面源码分析中我们也可以发现，在 Xcode 设置 <code>OBJC_PRINT_REPLACED_METHODS</code> 环境变量为 <code>YES</code> 后，就可以在运行时输出所有被替换的方法（若添加后仍未输出我们自定义类的替换信息，可以在尝试主类和所有 Category 中添加 <code>+ (void)load</code> 方法实现后重试）：</p>

<pre><code>objc[17895]: REPLACED: -[Person smile]  by category Life  (IMP was 0x100001b90 (/Users/kingcos/Library/Developer/Xcode/DerivedData/Category_in_Obj-C-cgesibqaizbvgnckrzeofmpfkmmy/Build/Products/Debug/Category_in_Obj-C), now 0x100001b00 (/Users/kingcos/Library/Developer/Xcode/DerivedData/Category_in_Obj-C-cgesibqaizbvgnckrzeofmpfkmmy/Build/Products/Debug/Category_in_Obj-C))
objc[17895]: REPLACED: -[Person smile]  by category Work  (IMP was 0x100001b00 (/Users/kingcos/Library/Developer/Xcode/DerivedData/Category_in_Obj-C-cgesibqaizbvgnckrzeofmpfkmmy/Build/Products/Debug/Category_in_Obj-C), now 0x100001b40 (/Users/kingcos/Library/Developer/Xcode/DerivedData/Category_in_Obj-C-cgesibqaizbvgnckrzeofmpfkmmy/Build/Products/Debug/Category_in_Obj-C))
</code></pre>

<p>第一条的替换，是指 Person+Life 替换了 Person 中的 <code>smile</code> 方法，而第二条指 Person+Work 再次替换了 Person+Life 中的 <code>smile</code> 方法，因此最终也由 Person+Work 中的方法被调用，最终也与我们的结论一致。</p>

<h3 id="memmove-memcpy"><code>memmove</code> &amp; <code>memcpy</code></h3>

<p>上一节中，Category 中内容列表与主类融合时，调用了 <code>memmove</code> 和 <code>memcpy</code> 函数，它们其实是 C 语言标准库中的函数，目的都是将一定长度的源内存地址的内容拷贝到目标内存地址中。在 Apple 开源的 XNU - libsyscall 中，<code>memmove</code> 和 <code>memcpy</code> 本质其实是一致的：</p>

<pre><code class="language-c">// _libc_funcptr.c
__attribute__((visibility(&quot;hidden&quot;)))
void *
memmove(void *dst, const void *src, size_t n)
{
	return _libkernel_string_functions-&gt;memmove(dst, src, n);
}

__attribute__((visibility(&quot;hidden&quot;)))
void *
memcpy(void *dst, const void *src, size_t n)
{
	return _libkernel_string_functions-&gt;memmove(dst, src, n);
}

// _libc_funcptr.c
/*
 * Upcalls to optimized libplatform string functions
 */

static const struct _libkernel_string_functions
		_libkernel_generic_string_functions = {
	.bzero = _libkernel_bzero,
	.memmove = _libkernel_memmove,
	.memset = _libkernel_memset,
	.strchr = _libkernel_strchr,
	.strcmp = _libkernel_strcmp,
	.strcpy = _libkernel_strcpy,
	.strlcpy = _libkernel_strlcpy,
	.strlen = _libkernel_strlen,
};
static _libkernel_string_functions_t _libkernel_string_functions =
		&amp;_libkernel_generic_string_functions;

// memcpy.c
/*
 * sizeof(word) MUST BE A POWER OF TWO
 * SO THAT wmask BELOW IS ALL ONES
 */
typedef    int word;        /* &quot;word&quot; used for optimal copy speed &quot;字&quot;用作优化拷贝速度 */

#define    wsize    sizeof(word)
#define    wmask    (wsize - 1)

/*
 * Copy a block of memory, handling overlap.
 * 拷贝一块内存，并处理重叠部分。
 * This is the routine that actually implements
 * (the portable versions of) bcopy, memcpy, and memmove.
 * 这是个实际实现了（可移植版本的）bcopy、memcpy、以及 memmove 的例行程序。
 */

// visibility(&quot;hidden&quot;)：隐藏函数符号
__attribute__((visibility(&quot;hidden&quot;)))
void * _libkernel_memmove(void *dst0, const void *src0, size_t length)
{
    // 保存一份目标、源，但源是常量，而目标是可变的
    char *dst = dst0;
    const char *src = src0;
    size_t t;
    
    // 长度为 0 或目标等于源时，无需移动
    if (length == 0 || dst == src)        /* nothing to do */
        goto done;
    
    /*
     * Macros: loop-t-times; and loop-t-times, t&gt;0
     * 定义循环宏，t 大于 0 时，循环 t 次
     */
#define    TLOOP(s) if (t) TLOOP1(s)
#define    TLOOP1(s) do { s; } while (--t)
    
    // 如果源 &gt; 目标（高地址 -&gt; 低地址，小端就是向前）
    printf(&quot;(unsigned long)dst: %lu; (unsigned long)src: %lu\n&quot;, (unsigned long)dst, (unsigned long)src);
    if ((unsigned long)dst &lt; (unsigned long)src) {
        /*
         * Copy forward.
         * 正向拷贝。
         */
        // typedef unsigned long           uintptr_t;
        t = (uintptr_t)src;    /* only need low bits 只需要低位 */
        printf(&quot;(t | (uintptr_t)dst) &amp; wmask: %lu\n&quot;, (t | (uintptr_t)dst) &amp; wmask);
        if ((t | (uintptr_t)dst) &amp; wmask) {
            /*
             * Try to align operands.  This cannot be done
             * unless the low bits match.
             * 尝试对齐操作数。除非低位匹配，否则不可这样做。
             */
            if ((t ^ (uintptr_t)dst) &amp; wmask || length &lt; wsize)
                t = length;
            else
                t = wsize - (t &amp; wmask);
            length -= t;
            //
//            TLOOP1(*dst++ = *src++);
            do {
                *dst++ = *src++;
            } while (--t);
        }
        /*
         * Copy whole words, then mop up any trailing bytes.
         * 拷贝整个字，然后删除所有尾字节。
         */
        t = length / wsize;
        printf(&quot;t: %zu\n&quot;, t);
//        TLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);
        if (t) {
            do {
                // 更改指针指向的一个字长的内容（src -&gt; dst）
                *(word *)dst = *(word *)src;
                // dst &amp; src 向前移动一个字长
                src += wsize;
                dst += wsize;
            } while (--t);
        }
        printf(&quot;(unsigned long)dst: %lu; (unsigned long)src: %lu\n&quot;, (unsigned long)dst, (unsigned long)src);
        
        t = length &amp; wmask;
        printf(&quot;t: %zu\n&quot;, t);
//        TLOOP(*dst++ = *src++);
        if (t) {
            do {
                *dst++ = *src++;
            } while (--t);
        }
    } else {
        /*
         * Copy backwards.  Otherwise essentially the same.
         * Alignment works as before, except that it takes
         * (t&amp;wmask) bytes to align, not wsize-(t&amp;wmask).
         * 反向拷贝。否则基本一致。
         * 与之前一样对齐，除了它是以 (t&amp;wmask) 字节对齐，而非 wsize-(t&amp;wmask)。
         */
        src += length;
        dst += length;
        t = (uintptr_t)src;
        printf(&quot;(t | (uintptr_t)dst) &amp; wmask: %lu\n&quot;, (t | (uintptr_t)dst) &amp; wmask);
        if ((t | (uintptr_t)dst) &amp; wmask) {
            if ((t ^ (uintptr_t)dst) &amp; wmask || length &lt;= wsize)
                t = length;
            else
                t &amp;= wmask;
            length -= t;
//            TLOOP1(*--dst = *--src);
            do {
                *--dst = *--src;
            } while (--t);
        }
        t = length / wsize;
//        TLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);
        if (t) {
            do {
                src -= wsize;
                dst -= wsize;
                *(word *)dst = *(word *)src;
            } while (--t);
        }
        
        t = length &amp; wmask;
//        TLOOP(*--dst = *--src);
        if (t) {
            do {
                *--dst = *--src;
            } while (--t);
        }
    }
done:
    printf(&quot;(unsigned long)dst: %lu; (unsigned long)src: %lu\n&quot;, (unsigned long)dst, (unsigned long)src);
    return (dst0);
}
</code></pre>

<p>我已经将该函数移植到 Demo 中，可以尝试低地址拷贝到高地址，也可以将高地址拷贝到低地址：</p>

<pre><code class="language-objectivec">// b -&gt; a
int a = 10;
int b = 20;
NSLog(@&quot;Before: a: %d, b: %d&quot;, a, b);
_libkernel_memmove(&amp;a, &amp;b, sizeof(int));
// memmove(&amp;a, &amp;b, sizeof(int));
// memcpy(&amp;a, &amp;b, sizeof(int));
NSLog(@&quot;After: a: %d, b: %d&quot;, a, b);

// OUTPUT:
// Before: a: 10, b: 20
// After: a: 20, b: 20
    
// c -&gt; d
int c = 30;
int d = 40;
NSLog(@&quot;Before: c: %d, d: %d&quot;, c, d);
// _libkernel_memmove2 是个简化版本的 _libkernel_memmove
_libkernel_memmove2(&amp;d, &amp;c, sizeof(int));
NSLog(@&quot;After: c: %d, d: %d&quot;, c, d);

// OUTPUT:
// Before: c: 30, d: 40
// After: c: 30, d: 30
</code></pre>

<p>但在有些编译器中，由于不同的标准库具体实现可能会有所不同。其中最主要的差别便是 <code>memcpy</code> 的实现通常并非一定是安全的，当源内存和目标内存存在重叠时，<code>memcpy</code> 将发生错误：</p>

<pre><code class="language-c">#include &lt;stddef.h&gt; /* size_t */
void *c_memcpy(void *dest, const void *src, size_t n)
{
    char *dp = dest;
    const char *sp = src;
    while (n--)
        *dp++ = *sp++;
    return dest;
}
</code></pre>

<p>上面是 C99 标准库中的实现。下面尝试下，将一个数组的前半截拷贝到其中间的地址，这样源地址与目标地址就出现了重叠部分。需要注意的是，开发者要保证内存是已经分配好的，如果目标地址无法容纳足够长的源地址内容长度，则仍将溢出，发生崩溃。</p>

<pre><code class="language-objectivec">// e[0, 1] -&gt; e[1, 2]
int e[5] = {1, 2, 3};
NSLog(@&quot;Before: e[0]: %d, e[1]: %d, e[2]: %d, e[3]: %d, e[4]: %d&quot;, e[0], e[1], e[2], e[3], e[4]);
_libkernel_memmove3(&amp;e[2], &amp;e[0], sizeof(int) * 3);
NSLog(@&quot;After: e[0]: %d, e[1]: %d, e[2]: %d, e[3]: %d, e[4]: %d&quot;, e[0], e[1], e[2], e[3], e[4]);

/ OUTPUT:
// Before: e[0]: 1, e[1]: 2, e[2]: 3, e[3]: 0, e[4]: 0
// After: e[0]: 1, e[1]: 2, e[2]: 1, e[3]: 2, e[4]: 3

// f[0, 1] -&gt; f[1, 2]
int f[5] = {1, 2, 3};
NSLog(@&quot;Before: f[0]: %d, f[1]: %d, f[2]: %d, f[3]: %d, f[4]: %d&quot;, f[0], f[1], f[2], f[3], f[4]);
v_memcpy(&amp;f[2], &amp;f[0], sizeof(int) * 3);
NSLog(@&quot;After: f[0]: %d, f[1]: %d, f[2]: %d, f[3]: %d, f[4]: %d&quot;, f[0], f[1], f[2], f[3], f[4]);

// OUTPUT:
// Before: f[0]: 1, f[1]: 2, f[2]: 3, f[3]: 0, f[4]: 0
// After: f[0]: 1, f[1]: 2, f[2]: 1, f[3]: 2, f[4]: 1
</code></pre>

<p>结果很明显，<code>c_memcpy</code>（C99 标准库实现的 <code>memcpy</code>）在重叠部分出现了差错，而 <code>memmove</code> 却能够正确的处理。这是因为在 <code>memmove</code> 内部会判断源地址和目标地址的大小，进而进行正向或反向拷贝，从而避免了丢弃数据。</p>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="https://github.com/kingcos/Perspective/issues/72">将 Obj-C 代码翻译为 C++ 代码</a></li>
<li><a href="https://maimieng.com/posts/2018/dyld_shared_cache/">谈谈 iOS 中的 dyld_shared_cache</a></li>
<li><a href="https://maimieng.com/posts/2019/link_map_file_in_xcode/">Xcode 中的 Link Map 文件</a></li>
<li><a href="https://maimieng.com/posts/2019/ivar_access_control_in_obj-c/">Obj-C 中成员变量和类的访问控制</a></li>
<li><a href="https://stackoverflow.com/questions/1201319/what-is-the-difference-between-memmove-and-memcpy">What is the difference between memmove and memcpy? - StackOverflow</a></li>
<li><a href="https://clc-wiki.net/wiki/memcpy">memcpy - clc-wiki</a></li>
<li><a href="https://tech.meituan.com/2018/11/08/ios-category-module-communicate.html">Category 特性在 iOS 组件化中的应用与管控</a></li>
</ul>

  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span
        class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      
      <span class="button next">
        <a href="/posts/2019/type_introspection_and_reflection/">
          <span class="button__text">Obj-C &amp; Swift 的类型内省与反射</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo="kingcos/kingcos.github.io"
            issue-term="pathname"
            label="comments"
            theme="github-dark"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2019 · <a href="http://github.com/kingcos">kingcos</a></span>
      </div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>





  
</div>

</body>
</html>
