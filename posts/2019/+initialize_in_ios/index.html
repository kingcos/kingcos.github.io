<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>iOS 中的 &#43;initialize 方法 :: iBlog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Source Code Demo     2019-04-21 首次提交 objc4-750 -   2019-05-01 补充细节 - Initialize_Demo    Preface 在 iOS 中，经常与 &#43;load 相提并论的一个方法便是 &#43;initialize。从方法名来看，它的作用是进行初始化，但不同于平时使用的 init，&#43;initialize 是一个类方法。那么它的本质到底是什么呢？
为了更好地叙述 &#43;initialize 的特点，本文部分描述尝试与 &#43;load 方法对比，建议阅读本文前先阅读「iOS 中的 &#43;load 方法」。
What // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { &#43; (void)initialize; }  Obj-C 中的 &#43;initialize 方法指的是 NSObject 中的 &#43; (void)initialize 类方法。官方文档中的 &#43;initialize 如下：
 Initializes the class before it receives its first message."/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/&#43;initialize_in_ios/" />


<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/green.css">



<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="/img/favicon/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="iOS 中的 &#43;initialize 方法 :: iBlog — " />
<meta name="twitter:description" content="Date Notes Source Code Demo     2019-04-21 首次提交 objc4-750 -   2019-05-01 补充细节 - Initialize_Demo    Preface 在 iOS 中，经常与 &#43;load 相提并论的一个方法便是 &#43;initialize。从方法名来看，它的作用是进行初始化，但不同于平时使用的 init，&#43;initialize 是一个类方法。那么它的本质到底是什么呢？
为了更好地叙述 &#43;initialize 的特点，本文部分描述尝试与 &#43;load 方法对比，建议阅读本文前先阅读「iOS 中的 &#43;load 方法」。
What // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { &#43; (void)initialize; }  Obj-C 中的 &#43;initialize 方法指的是 NSObject 中的 &#43; (void)initialize 类方法。官方文档中的 &#43;initialize 如下：
 Initializes the class before it receives its first message." />
<meta name="twitter:site" content="/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="iOS 中的 &#43;initialize 方法 :: iBlog — ">
<meta property="og:description" content="Date Notes Source Code Demo     2019-04-21 首次提交 objc4-750 -   2019-05-01 补充细节 - Initialize_Demo    Preface 在 iOS 中，经常与 &#43;load 相提并论的一个方法便是 &#43;initialize。从方法名来看，它的作用是进行初始化，但不同于平时使用的 init，&#43;initialize 是一个类方法。那么它的本质到底是什么呢？
为了更好地叙述 &#43;initialize 的特点，本文部分描述尝试与 &#43;load 方法对比，建议阅读本文前先阅读「iOS 中的 &#43;load 方法」。
What // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { &#43; (void)initialize; }  Obj-C 中的 &#43;initialize 方法指的是 NSObject 中的 &#43; (void)initialize 类方法。官方文档中的 &#43;initialize 如下：
 Initializes the class before it receives its first message." />
<meta property="og:url" content="/posts/2019/&#43;initialize_in_ios/" />
<meta property="og:site_name" content="iOS 中的 &#43;initialize 方法" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-04-21 00:00:00 &#43;0000 UTC" />











</head>
<body class="">


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    iBlog
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/2019/&#43;initialize_in_ios/">iOS 中的 +initialize 方法</a></h1>
  <div class="post-meta">
    <span class="post-date">
      2019-04-21
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/focus/">Focus</a>&nbsp;
    
    #<a href="/tags/ios/">iOS</a>&nbsp;
    
    #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Source Code</th>
<th align="center">Demo</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2019-04-21</td>
<td align="center">首次提交</td>
<td align="center"><a href="https://opensource.apple.com/tarballs/objc4/">objc4-750</a></td>
<td align="center">-</td>
</tr>

<tr>
<td align="center">2019-05-01</td>
<td align="center">补充细节</td>
<td align="center">-</td>
<td align="center"><a href="https://github.com/kingcos/Perspective/tree/writing/Posts/Practice/%2Binitialize_in_iOS">Initialize_Demo</a></td>
</tr>
</tbody>
</table>

<h2 id="preface">Preface</h2>

<p>在 iOS 中，经常与 +load 相提并论的一个方法便是 +initialize。从方法名来看，它的作用是进行初始化，但不同于平时使用的 <code>init</code>，+initialize 是一个类方法。那么它的本质到底是什么呢？</p>

<p>为了更好地叙述 +initialize 的特点，本文部分描述尝试与 +load 方法对比，建议阅读本文前先阅读「iOS 中的 +load 方法」。</p>

<h2 id="what">What</h2>

<pre><code class="language-objectivec">// NSObject.h
@interface NSObject &lt;NSObject&gt; {
+ (void)initialize;
}
</code></pre>

<p>Obj-C 中的 +initialize 方法指的是 NSObject 中的 <code>+ (void)initialize</code> 类方法。官方文档中的 +initialize 如下：</p>

<blockquote>
<p>Initializes the class before it receives its first message.</p>

<p>The runtime sends <code>initialize</code> to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses.</p>

<p>The runtime sends the <code>initialize</code> message to classes in a thread-safe manner. That is, <code>initialize</code> is run by the first thread to send a message to a class, and any other thread that tries to send a message to that class will block until <code>initialize</code> completes.</p>

<p>The superclass implementation may be called multiple times if subclasses do not implement <code>initialize</code>—the runtime will call the inherited implementation—or if subclasses explicitly call <code>[super initialize]</code>. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:</p>

<pre><code class="language-objectivec">+ (void)initialize {
  if (self == [ClassName self]) {
    // ... do the initialization ...
  }
}
</code></pre>

<p>Because <code>initialize</code> is called in a blocking manner, it’s important to limit method implementations to the minimum amount of work necessary possible. Specifically, any code that takes locks that might be required by other classes in their <code>initialize</code> methods is liable to lead to deadlocks. Therefore, you should not rely on <code>initialize</code> for complex initialization, and should instead limit it to straightforward, class local initialization.</p>

<p><code>initialize</code> is invoked only once per class. If you want to perform independent initialization for the class and for categories of the class, you should implement <a href="https://developer.apple.com/documentation/objectivec/nsobject/1418815-load?language=objc"><code>load</code></a> methods.</p>

<p>—— Documentation, Apple Developer</p>

<p>译：</p>

<p>在类收到第一条消息前初始化。</p>

<p>在类和所有子类接收第一条消息前，运行时发送 <code>initialize</code> 消息到程序中每个类。父类在子类之前接收到该消息。</p>

<p>运行时以线程安全的方式发送 <code>initialize</code> 消息到类。即 <code>initialize</code> 由第一个线程运行来发送消息到一个类，并且其它任何尝试发送消息的线程都将会被阻塞，直到 <code>initialize</code> 完成。</p>

<p>如果子类未实现 <code>initialize</code> 则父类的实现可能会被调用多次 —— 运行时将会调用继承（自父类）的实现 —— 或者如果子类明确调用 <code>[super initialize]</code>。如果不希望运行多次，可以参考如下实现：</p>

<pre><code class="language-objectivec">+ (void)initialize {
  if (self == [ClassName self]) {
    // ... do the initialization ...
  }
}
</code></pre>

<p>由于 <code>initialize</code> 以阻塞的方式被调用，因此将方法实现限制为最小工作量是很有必要的。尤其是在 <code>initialize</code> 中使用任何可能被其它类所必需锁的代码都有可能会导致死锁。因此不应当依赖 <code>initialize</code> 做复杂的初始化，相反应该将其限制为简单的类本地初始化。</p>

<p><code>initialize</code> 在每个类中只会被调用一次。如果希望为类以及分类执行独立的初始化，应当实现 <a href="https://developer.apple.com/documentation/objectivec/nsobject/1418815-load?language=objc"><code>load</code></a> 方法。</p>

<p>—— 文档，苹果开发者</p>
</blockquote>

<h2 id="how">How</h2>

<p>根据官方文档的描述，我们可以尝试定义一个继承自 <code>NSObject</code> 的 <code>Person</code> 类，并对其添加两个分类 <code>Life</code> 和 <code>Work</code>；再定义一个 <code>Student</code> 类继承自 <code>Person</code>，并对其添加 <code>School</code> 分类；最后定义一个 <code>Programmer</code> 类继承自 <code>Person</code>。在以上除了 <code>Programmer</code> 的类和分类中，均实现 +initialize：</p>

<pre><code class="language-objectivec">// Person.m
#import &quot;Person.h&quot;

@implementation Person
+ (void)initialize {
    NSLog(@&quot;Person %s&quot;, __func__);
}
@end

// Person+Life.m
#import &quot;Person+Life.h&quot;

@implementation Person (Life)
+ (void)initialize {
    NSLog(@&quot;Person+Life %s&quot;, __func__);
}
@end

//  Person+Work.m
#import &quot;Person+Work.h&quot;

@implementation Person (Work)
+ (void)initialize {
    NSLog(@&quot;Person+Work %s&quot;, __func__);
}
@end

//  Student.m
#import &quot;Student.h&quot;

@implementation Student
+ (void)initialize {
    NSLog(@&quot;Student %s&quot;, __func__);
}
@end

//  Student+School.m
#import &quot;Student+School.h&quot;

@implementation Student (School)
+ (void)initialize {
    NSLog(@&quot;Student+School %s&quot;, __func__);
}
@end

//  Programmer.m
#import &quot;Programmer.h&quot;

@implementation Programmer
@end

// OUTPUT:
// Hello, World!
</code></pre>

<p>首先我们不更改 main.m，尝试运行程序，结果只输出了 <code>main</code> 函数 <code>Hello, World!</code>，因为 +initialize 并不像 +load 一样是在 <code>main</code> 函数前调用的，而没有输出的原因是这些类还没有收到一条消息。众所周知，Obj-C 中大部分方法调用的本质都是消息发送（Message Sending），<code>[SomeClass classMethod]</code> 是向 <code>SomeClass</code> 类对象发送 <code>classMethod</code> 消息；<code>[SomeObject instanceMethod]</code> 是向 <code>SomeObject</code> 实例对象发送 <code>instanceMethod</code> 方法；由于如果要调用对象方法，也必须要先进行 <code>alloc</code> 并 <code>init</code>（或者 <code>new</code>）才能创建完一个实例对象，因此可以认为类接收到的第一条消息永远是类方法。这次我们尝试向它们发送消息：</p>

<pre><code class="language-objectivec">// main.m
#import &lt;Foundation/Foundation.h&gt;

#import &quot;Person.h&quot;
#import &quot;Student.h&quot;
#import &quot;Programmer.h&quot;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSLog(@&quot;---&quot;);
        Student *stu = [Student alloc];
        NSLog(@&quot;---&quot;);
        stu = [stu init];
        
        NSLog(@&quot;---&quot;);
        [Programmer load];
    }
    return 0;
}


// OUTPUT:
// ---
// Person+Work +[Person(Work) initialize]
// Student+School +[Student(School) initialize]
// ---
// ---
// Person+Work +[Person(Work) initialize]
</code></pre>

<p>通过以上代码的输出，虽然我们并没有主动调用这些类的 +initialize 方法，但 +initialize 确实被自动调用了。我们先抛出结论：<strong>+initialize 方法在类（类对象）接收到第一条消息（类方法）前被调用；子类中如果实现了该方法，会先父类再子类；且遵守分类（Category）「覆盖」主类的 +initialize；若子类未实现 +initialize，将调用父类中的该方法，因此一个类中的 +initialize 并不能保证只被调用一次，但对于某个类，只会被调用一次</strong>。</p>

<h2 id="why">Why</h2>

<h4 id="实现原理">实现原理</h4>

<p>上面我们先抛出了结论，那么该如何验证呢？Talk is cheap, show me the code:</p>

<pre><code class="language-objectivec">// objc-class.mm
/***********************************************************************
* class_getClassMethod.  Return the class method for the specified
* class and selector.
* 为指定的类和方法选择器返回相应的类方法。
**********************************************************************/
Method class_getClassMethod(Class cls, SEL sel)
{
    if (!cls  ||  !sel) return nil;

    // ➡️ 返回元类的方法
    // 因为类对象和元类对象的结构一致（均为 Class），因此元类的类方法和类的对象方法存储在同样的结构中
    return class_getInstanceMethod(cls-&gt;getMeta(), sel);
}

// objc-runtime-new.mm
/***********************************************************************
* class_getInstanceMethod.  Return the instance method for the
* specified class and selector.
* 为指定的类和方法选择器返回相应的对象方法。
**********************************************************************/
Method class_getInstanceMethod(Class cls, SEL sel)
{
    if (!cls  ||  !sel) return nil;

    // This deliberately avoids +initialize because it historically did so.
    // 由于历史原因，这里故意避免 +initialize。

    // This implementation is a bit weird because it's the only place that 
    // wants a Method instead of an IMP.
    // 这里的实现有点奇怪，因为这是唯一需要 Method 而非 IMP 的地方。

#warning fixme build and search caches
        
    // Search method lists, try method resolver, etc.
    // 搜索方法列表，尝试方法解析器等。
    // ➡️ 查找 IMP
    lookUpImpOrNil(cls, sel, nil, 
                   NO/*initialize*/, NO/*cache*/, YES/*resolver*/);

#warning fixme build and search caches

    return _class_getMethod(cls, sel);
}

// objc-runtime-new.mm
/***********************************************************************
* lookUpImpOrNil.
* Like lookUpImpOrForward, but returns nil instead of _objc_msgForward_impcache
* 类似 lookUpImpOrForward，但返回 nil 替代 _objc_msgForward_impcache
**********************************************************************/
IMP lookUpImpOrNil(Class cls, SEL sel, id inst, 
                   bool initialize, bool cache, bool resolver)
{
    // ➡️ 查找 IMP
    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);
    // 当 IMP 为 _objc_msgForward_impcache 时，返回 nil
    if (imp == _objc_msgForward_impcache) return nil;
    else return imp;
}

// objc-runtime-new.mm
/***********************************************************************
* lookUpImpOrForward.
* The standard IMP lookup. 
* 标准 IMP 查找。
* initialize==NO tries to avoid +initialize (but sometimes fails)
* initialize==NO 尝试避免 +initialize（但有时会失败）
* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)
* cache==NO 跳过乐观解锁查找（但有时仍会使用缓存）
* Most callers should use initialize==YES and cache==YES.
* 大多数调用者应当使用 initialize==YES 且 cache==YES。
* inst is an instance of cls or a subclass thereof, or nil if none is known. 
* inst 是 cls 或其子类，如果没有，则为 nil。
*   If cls is an un-initialized metaclass then a non-nil inst is faster.
*   如果 cls 是未初始化的元类，那么非 nil 的 inst 更快。
* May return _objc_msgForward_impcache. IMPs destined for external use 
*   must be converted to _objc_msgForward or _objc_msgForward_stret.
* 可能返回 _objc_msgForward_impcache。外部使用 IMP 则注定必须被转换为 _objc_msgForward 或 _objc_msgForward_stret。
*   If you don't want forwarding at all, use lookUpImpOrNil() instead.
*   如果根本不需要转发，使用 lookUpImpOrNil() 替代。
**********************************************************************/
IMP lookUpImpOrForward(Class cls, SEL sel, id inst, 
                       bool initialize, bool cache, bool resolver)
{
    IMP imp = nil;
    bool triedResolver = NO;
    
    // 断言解锁
    runtimeLock.assertUnlocked();

    // Optimistic cache lookup
    // 乐观缓存查找
    if (cache) {
        imp = cache_getImp(cls, sel);
        if (imp) return imp;
    }

    // runtimeLock is held during isRealized and isInitialized checking
    // to prevent races against concurrent realization.
    // 在 isRealized 和 isInitialized 检查期间保持 runtimeLock，防止并发实化竞争。

    // runtimeLock is held during method search to make
    // method-lookup + cache-fill atomic with respect to method addition.
    // 关于方法添加，在方法搜索期间保持 runtimeLock，使得方法查找和缓存填充原子化（不可再分割）。
    // Otherwise, a category could be added but ignored indefinitely because
    // the cache was re-filled with the old value after the cache flush on
    // behalf of the category.
    // 否则，分类可以被添加但总会被忽略，因为分类的缓存在刷新后会被旧值重复填充。

    runtimeLock.lock();
    checkIsKnownClass(cls);

    // 如果未实化，进行实化
    if (!cls-&gt;isRealized()) {
        realizeClass(cls);
    }

    // 如果需要初始化但未初始化，进行初始化
    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) {
        runtimeLock.unlock();
        // ➡️ 类初始化
        _class_initialize (_class_getNonMetaClass(cls, inst));
        runtimeLock.lock();
        // If sel == initialize, _class_initialize will send +initialize and 
        // then the messenger will send +initialize again after this 
        // procedure finishes. Of course, if this is not being called 
        // from the messenger then it won't happen. 2778172
        // 如果 sel 等于 initialize，_class_initialize 将发送 +initialize 消息，
        // 之后发送者将会在该过程完成后再次发送 +initialize。当然，如果不是发送者调用，则不会发生。
    }

    
 retry:    
    runtimeLock.assertLocked();

    // Try this class's cache.

    imp = cache_getImp(cls, sel);
    if (imp) goto done;

    // Try this class's method lists.
    {
        Method meth = getMethodNoSuper_nolock(cls, sel);
        if (meth) {
            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);
            imp = meth-&gt;imp;
            goto done;
        }
    }

    // Try superclass caches and method lists.
    {
        unsigned attempts = unreasonableClassCount();
        for (Class curClass = cls-&gt;superclass;
             curClass != nil;
             curClass = curClass-&gt;superclass)
        {
            // Halt if there is a cycle in the superclass chain.
            if (--attempts == 0) {
                _objc_fatal(&quot;Memory corruption in class list.&quot;);
            }
            
            // Superclass cache.
            imp = cache_getImp(curClass, sel);
            if (imp) {
                if (imp != (IMP)_objc_msgForward_impcache) {
                    // Found the method in a superclass. Cache it in this class.
                    log_and_fill_cache(cls, imp, sel, inst, curClass);
                    goto done;
                }
                else {
                    // Found a forward:: entry in a superclass.
                    // Stop searching, but don't cache yet; call method 
                    // resolver for this class first.
                    break;
                }
            }
            
            // Superclass method list.
            Method meth = getMethodNoSuper_nolock(curClass, sel);
            if (meth) {
                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);
                imp = meth-&gt;imp;
                goto done;
            }
        }
    }

    // No implementation found. Try method resolver once.

    if (resolver  &amp;&amp;  !triedResolver) {
        runtimeLock.unlock();
        _class_resolveMethod(cls, sel, inst);
        runtimeLock.lock();
        // Don't cache the result; we don't hold the lock so it may have 
        // changed already. Re-do the search from scratch instead.
        triedResolver = YES;
        goto retry;
    }

    // No implementation found, and method resolver didn't help. 
    // Use forwarding.

    imp = (IMP)_objc_msgForward_impcache;
    cache_fill(cls, sel, imp, inst);

 done:
    runtimeLock.unlock();

    return imp;
}

// objc-initialize.mm
/***********************************************************************
* class_initialize.  Send the '+initialize' message on demand to any
* uninitialized class. Force initialization of superclasses first.
* class_initialize。按需发送「+initialize」消息到所有未初始化的类。强制父类最先初始化。
**********************************************************************/
void _class_initialize(Class cls)
{
    // 断言非元类
    assert(!cls-&gt;isMetaClass());

    Class supercls;
    bool reallyInitialize = NO;

    // Make sure super is done initializing BEFORE beginning to initialize cls.
    // 在开始初始化 cls 前确保父类已经完成初始化。
    // See note about deadlock above.
    // 查看上面死锁的备注。
    // 取得父类
    supercls = cls-&gt;superclass;
    // 如果父类存在，且未初始化
    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) {
    	 // 递归初始化父类
        _class_initialize(supercls);
    }
    
    // Try to atomically set CLS_INITIALIZING.
    // 原子化地设置 CLS_INITIALIZING。
    {
        monitor_locker_t lock(classInitLock);
        if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) {
            cls-&gt;setInitializing();
            reallyInitialize = YES;
        }
    }
    
    if (reallyInitialize) {
        // We successfully set the CLS_INITIALIZING bit. Initialize the class.
        // 成功设置 CLS_INITIALIZING 位。初始化类。
        
        // Record that we're initializing this class so we can message it.
        // 记录我们正在初始化该类，以便可以发送这个消息。
        _setThisThreadIsInitializingClass(cls);

        if (MultithreadedForkChild) {
            // LOL JK we don't really call +initialize methods after fork().
            performForkChildInitialize(cls, supercls);
            return;
        }
        
        // Send the +initialize message.
        // 发送 +initialize 消息。
        // Note that +initialize is sent to the superclass (again) if 
        // this class doesn't implement +initialize. 2157218
        // 如果该类未实现 +initialize，需要注意 +initialize（再次）被发送到了父类
        // Xcode 中 OBJC_PRINT_INITIALIZE_METHODS 环境变量值为 YES 时，将可在控制台打印该信息
        // OPTION(PrintInitializing, OBJC_PRINT_INITIALIZE_METHODS, &quot;log calls to class +initialize methods&quot;)
        if (PrintInitializing) {
            _objc_inform(&quot;INITIALIZE: thread %p: calling +[%s initialize]&quot;,
                         pthread_self(), cls-&gt;nameForLogging());
        }

        // Exceptions: A +initialize call that throws an exception 
        // is deemed to be a complete and successful +initialize.
        //
        // Only __OBJC2__ adds these handlers. !__OBJC2__ has a
        // bootstrapping problem of this versus CF's call to
        // objc_exception_set_functions().
#if __OBJC2__
        @try
#endif
        {
            // ➡️ 调用 +initialize
            callInitialize(cls);

            if (PrintInitializing) {
                _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;,
                             pthread_self(), cls-&gt;nameForLogging());
            }
        }
#if __OBJC2__
        @catch (...) {
            if (PrintInitializing) {
                _objc_inform(&quot;INITIALIZE: thread %p: +[%s initialize] &quot;
                             &quot;threw an exception&quot;,
                             pthread_self(), cls-&gt;nameForLogging());
            }
            @throw;
        }
        @finally
#endif
        {
            // Done initializing.
            lockAndFinishInitializing(cls, supercls);
        }
        return;
    }
    
    else if (cls-&gt;isInitializing()) {
        // We couldn't set INITIALIZING because INITIALIZING was already set.
        // If this thread set it earlier, continue normally.
        // If some other thread set it, block until initialize is done.
        // It's ok if INITIALIZING changes to INITIALIZED while we're here, 
        //   because we safely check for INITIALIZED inside the lock 
        //   before blocking.
        if (_thisThreadIsInitializingClass(cls)) {
            return;
        } else if (!MultithreadedForkChild) {
            waitForInitializeToComplete(cls);
            return;
        } else {
            // We're on the child side of fork(), facing a class that
            // was initializing by some other thread when fork() was called.
            _setThisThreadIsInitializingClass(cls);
            performForkChildInitialize(cls, supercls);
        }
    }
    
    else if (cls-&gt;isInitialized()) {
        // Set CLS_INITIALIZING failed because someone else already 
        //   initialized the class. Continue normally.
        // NOTE this check must come AFTER the ISINITIALIZING case.
        // Otherwise: Another thread is initializing this class. ISINITIALIZED 
        //   is false. Skip this clause. Then the other thread finishes 
        //   initialization and sets INITIALIZING=no and INITIALIZED=yes. 
        //   Skip the ISINITIALIZING clause. Die horribly.
        return;
    }
    
    else {
        // We shouldn't be here. 
        _objc_fatal(&quot;thread-safe class init in objc runtime is buggy!&quot;);
    }
}

// objc-initialize.mm
void callInitialize(Class cls)
{
    // 💡 向 cls 发送 SEL_initialize 消息
    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);
    asm(&quot;&quot;);
}
</code></pre>

<p>追根溯源，我们可以看到 +initialize 的本质其实是 objc_msgSend，即消息发送机制，不同于 +load 直接根据 IMP 指针进行调用。这也就解释了在 Demo 中，我们首先尝试向 <code>Student</code> 类发送一个 <code>alloc</code> 消息，运行时会先找到父类 <code>Person</code> 的 +initialize 方法进行调用，而由于父类又存在分类，最后编译的 <code>Person+Work</code> 分类「覆盖」了其它分类和主类中相同的方法而得以调用；随后调用子类自身的 +initialize 方法，而 <code>Student+School</code> 分类「覆盖」了主类中相同的方法而得以调用；而向 <code>Programmer</code> 类手动发送 +load 消息时（当然，一般我们不会这么做），由于该类本身没有实现 +initialize 方法，因此最终通过父类的 <code>Person+Work</code> 分类调用了 +initialize 方法。</p>

<p><img src="/img/2019/+initialize_in_iOS/1.png" alt="" /></p>

<p>如上所述，一个类的 +initialize 方法并不能保证只会被调用一次，所以如果我们不希望多次调用，可以在 +initialize 方法中进行判断 <code>self == [ClassName self]</code>。</p>

<h2 id="objc-print-initialize-methods"><code>OBJC_PRINT_INITIALIZE_METHODS</code></h2>

<p>为了便于 Debug 运行时的 +initialize 方法，将 <code>OBJC_PRINT_INITIALIZE_METHODS</code> 在 Xcode 中设置为 YES 后，可以打印出很多 + initialize 方法执行时的信息：</p>

<pre><code>objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSObject initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSObject initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSObject is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_dispatch_data initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_dispatch_data initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_dispatch_data is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_object initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_object initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_object is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_xpc_object initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_xpc_object initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_xpc_object is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_xpc_string initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_xpc_string initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_xpc_string is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_xpc_data initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_xpc_data initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_xpc_data is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_xpc_dictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_xpc_dictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_xpc_dictionary is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_xpc_serializer initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_xpc_serializer initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_xpc_serializer is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_dispatch_object initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_dispatch_object initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_dispatch_object is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_dispatch_mach_msg initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_dispatch_mach_msg initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_dispatch_mach_msg is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_xpc_array initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_xpc_array initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_xpc_array is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSCFType initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSCFType initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSCFType is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSCFString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSCFString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSCFString is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSArray initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSArray initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSArray is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSMutableArray initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSMutableArray initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSMutableArray is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSPlaceholderArray initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSPlaceholderArray initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSPlaceholderArray is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSSingleObjectArrayI initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSSingleObjectArrayI initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSSingleObjectArrayI is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSDictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSDictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSDictionary is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSDictionary0 initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSDictionary0 initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSDictionary0 is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSMutableDictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSMutableDictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSMutableDictionary is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSArray0 initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSArray0 initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSArray0 is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSEnumerator initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSEnumerator initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSEnumerator is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSEnumerator0 initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSEnumerator0 initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSEnumerator0 is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSLock initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSLock initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSLock is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSRecursiveLock initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSRecursiveLock initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSRecursiveLock is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSThread initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSThread initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSThread is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSCFDictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSCFDictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSCFDictionary is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[_NSThreadData initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[_NSThreadData initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: _NSThreadData is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSPlaceholderDictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSPlaceholderDictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSPlaceholderDictionary is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSDictionaryM initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSDictionaryM initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSDictionaryM is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSCFArray initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSCFArray initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSCFArray is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSSet initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSSet initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSSet is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSMutableSet initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSMutableSet initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSMutableSet is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSPlaceholderSet initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSSetI initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSSetI initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSSetI is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSPlaceholderSet initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSPlaceholderSet is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSSetM initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSSetM initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSSetM is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSBindingSelectionMarker initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSBindingSelectionMarker initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSBindingSelectionMarker is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[_NSStateMarker initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[_NSStateMarker initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: _NSStateMarker is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSCFConstantString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSPlaceholderString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSPlaceholderString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: class NSPlaceholderString will be marked as fully +initialized after superclass +[NSString initialize] completes
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSTaggedPointerString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSTaggedPointerString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: class NSTaggedPointerString will be marked as fully +initialized after superclass +[NSString initialize] completes
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSString is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSTaggedPointerString is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSPlaceholderString is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSMutableString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSPlaceholderMutableString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSPlaceholderMutableString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: class NSPlaceholderMutableString will be marked as fully +initialized after superclass +[NSMutableString initialize] completes
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSMutableString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSMutableString is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSPlaceholderMutableString is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSCFConstantString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSCFConstantString is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSBundle initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSBundle initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSBundle is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[_CFXPreferencesHandle initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[_CFXPreferencesHandle initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: _CFXPreferencesHandle is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[_CFXPreferences initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[_CFXPreferences initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: _CFXPreferences is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSURL initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSURL initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSURL is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[CFPrefsSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[CFPrefsSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: CFPrefsSource is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[CFPrefsSearchListSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[CFPrefsSearchListSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: CFPrefsSearchListSource is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[CFPrefsPlistSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[CFPrefsPlistSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: CFPrefsPlistSource is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[CFPrefsManagedSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[CFPrefsManagedSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: CFPrefsManagedSource is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSArrayM initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSArrayM initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSArrayM is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_xpc_mach_send initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_xpc_mach_send initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_xpc_mach_send is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_xpc_uuid initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_xpc_uuid initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_xpc_uuid is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_xpc_int64 initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_xpc_int64 initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_xpc_int64 is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_voucher initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_voucher initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_voucher is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[CFPrefsSuiteSearchListSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[CFPrefsSuiteSearchListSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: CFPrefsSuiteSearchListSource is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[NSData initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: blocking until +[NSData initialize] completes
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[NSData initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: NSData is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[NSMutableData initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: blocking until +[NSMutableData initialize] completes
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[NSMutableData initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: NSMutableData is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[__NSCFData initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: blocking until +[__NSCFData initialize] completes
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[__NSCFData initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: __NSCFData is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[_NSDispatchData initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[_NSDispatchData initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: _NSDispatchData is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[NSDate initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[NSDate initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: NSDate is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[__NSPlaceholderDate initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[__NSPlaceholderDate initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: __NSPlaceholderDate is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[__NSTaggedDate initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[__NSTaggedDate initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: __NSTaggedDate is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[__NSDate initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[__NSDate initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: __NSDate is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[NSValue initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[NSNumber initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[NSNumber initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: class NSNumber will be marked as fully +initialized after superclass +[NSValue initialize] completes
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[NSPlaceholderValue initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[NSPlaceholderValue initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: class NSPlaceholderValue will be marked as fully +initialized after superclass +[NSNumber initialize] completes
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[NSPlaceholderNumber initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[NSPlaceholderNumber initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: class NSPlaceholderNumber will be marked as fully +initialized after superclass +[NSPlaceholderValue initialize] completes
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[NSValue initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: NSValue is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: NSNumber is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: NSPlaceholderValue is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: NSPlaceholderNumber is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[__NSCFNumber initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[__NSCFNumber initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: __NSCFNumber is fully +initialized
2019-05-01 00:07:04.813693+0800 Initialize_Demo[23971:21942131] ---
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[Person initialize]
2019-05-01 00:07:04.814048+0800 Initialize_Demo[23971:21942131] Person+Work +[Person(Work) initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[Person initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: Person is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[Student initialize]
2019-05-01 00:07:04.814168+0800 Initialize_Demo[23971:21942131] Student+School +[Student(School) initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[Student initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: Student is fully +initialized
2019-05-01 00:07:04.814271+0800 Initialize_Demo[23971:21942131] ---
2019-05-01 00:07:04.814297+0800 Initialize_Demo[23971:21942131] ---
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[Programmer initialize]
2019-05-01 00:07:04.814347+0800 Initialize_Demo[23971:21942131] Person+Work +[Person(Work) initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[Programmer initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: Programmer is fully +initialized
</code></pre>

<h2 id="开销">开销</h2>

<p>+initialize 方法不同于 +load 方法，不会使得程序将时间过多地浪费在启动过程中，因此我们可以将一些合适的操作下沉到 +initialize 中完成。但 +initialize 是以阻塞的方式被调用，也不适合做特别多繁重尤其是可能导致死锁的操作。</p>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="https://maimieng.com/posts/2019/+load_in_ios/">iOS 中的 +load 方法</a></li>
</ul>

  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span
        class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      <span class="button previous">
        <a href="/posts/2019/effective_objc_2.0_notes/">
          <span class="button__icon">←</span>
          <span class="button__text">《编写高质量 iOS 与 OS X 代码的 52 个有效方法》阅读笔记</span>
        </a>
      </span>
      
      
      <span class="button next">
        <a href="/posts/2019/&#43;load_in_ios/">
          <span class="button__text">iOS 中的 &#43;load 方法</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo="kingcos/kingcos.github.io"
            issue-term="pathname"
            label="comments"
            theme="github-dark"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2019 · <a href="http://github.com/kingcos">kingcos</a></span>
      </div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>





  
</div>

</body>
</html>
