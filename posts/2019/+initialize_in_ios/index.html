<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>iOS 中的 &#43;initialize 方法 :: iBlog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Source Code Demo     2019-04-21 首次提交 objc4-750     Preface 在 iOS 中，经常与 &#43;load 相提并论的一个方法便是 &#43;initialize。从方法名来看，它的作用是进行初始化，但不同于平时使用的 init，&#43;initialize 是一个类方法。那么它的本质到底是什么呢？建议阅读本文前，先阅读「iOS 中的 &#43;load 方法」。
What // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { &#43; (void)initialize; }  Obj-C 中的 &#43;initialize 方法指的是 NSObject 中的 &#43; (void)initialize 类方法。官方文档中的 &#43;initialize 如下：
 Initializes the class before it receives its first message.
The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program."/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/&#43;initialize_in_ios/" />


<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/green.css">



<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="/img/favicon/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="iOS 中的 &#43;initialize 方法 :: iBlog — " />
<meta name="twitter:description" content="Date Notes Source Code Demo     2019-04-21 首次提交 objc4-750     Preface 在 iOS 中，经常与 &#43;load 相提并论的一个方法便是 &#43;initialize。从方法名来看，它的作用是进行初始化，但不同于平时使用的 init，&#43;initialize 是一个类方法。那么它的本质到底是什么呢？建议阅读本文前，先阅读「iOS 中的 &#43;load 方法」。
What // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { &#43; (void)initialize; }  Obj-C 中的 &#43;initialize 方法指的是 NSObject 中的 &#43; (void)initialize 类方法。官方文档中的 &#43;initialize 如下：
 Initializes the class before it receives its first message.
The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program." />
<meta name="twitter:site" content="/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="iOS 中的 &#43;initialize 方法 :: iBlog — ">
<meta property="og:description" content="Date Notes Source Code Demo     2019-04-21 首次提交 objc4-750     Preface 在 iOS 中，经常与 &#43;load 相提并论的一个方法便是 &#43;initialize。从方法名来看，它的作用是进行初始化，但不同于平时使用的 init，&#43;initialize 是一个类方法。那么它的本质到底是什么呢？建议阅读本文前，先阅读「iOS 中的 &#43;load 方法」。
What // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { &#43; (void)initialize; }  Obj-C 中的 &#43;initialize 方法指的是 NSObject 中的 &#43; (void)initialize 类方法。官方文档中的 &#43;initialize 如下：
 Initializes the class before it receives its first message.
The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program." />
<meta property="og:url" content="/posts/2019/&#43;initialize_in_ios/" />
<meta property="og:site_name" content="iOS 中的 &#43;initialize 方法" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-04-21 00:00:00 &#43;0000 UTC" />











</head>
<body class="">


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    iBlog
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
      
        <ul class="menu__sub-inner">
          <li class="menu__sub-inner-more-trigger">Show more ▾</li>

          <ul class="menu__sub-inner-more hidden">
            
              
                <li><a href="/perspective">Perspective</a></li>
              
            
          </ul>
        </ul>
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/2019/&#43;initialize_in_ios/">iOS 中的 +initialize 方法</a></h1>
  <div class="post-meta">
    <span class="post-date">
      2019-04-21
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/focus/">Focus</a>&nbsp;
    
    #<a href="/tags/ios/">iOS</a>&nbsp;
    
    #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Source Code</th>
<th align="center">Demo</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2019-04-21</td>
<td align="center">首次提交</td>
<td align="center"><a href="https://opensource.apple.com/tarballs/objc4/">objc4-750</a></td>
<td align="center"></td>
</tr>
</tbody>
</table>

<h2 id="preface">Preface</h2>

<p>在 iOS 中，经常与 +load 相提并论的一个方法便是 +initialize。从方法名来看，它的作用是进行初始化，但不同于平时使用的 <code>init</code>，+initialize 是一个类方法。那么它的本质到底是什么呢？建议阅读本文前，先阅读「iOS 中的 +load 方法」。</p>

<h2 id="what">What</h2>

<pre><code class="language-objectivec">// NSObject.h
@interface NSObject &lt;NSObject&gt; {
+ (void)initialize;
}
</code></pre>

<p>Obj-C 中的 +initialize 方法指的是 NSObject 中的 <code>+ (void)initialize</code> 类方法。官方文档中的 +initialize 如下：</p>

<blockquote>
<p>Initializes the class before it receives its first message.</p>

<p>The runtime sends <code>initialize</code> to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses.</p>

<p>The runtime sends the <code>initialize</code> message to classes in a thread-safe manner. That is, <code>initialize</code> is run by the first thread to send a message to a class, and any other thread that tries to send a message to that class will block until <code>initialize</code> completes.</p>

<p>The superclass implementation may be called multiple times if subclasses do not implement <code>initialize</code>—the runtime will call the inherited implementation—or if subclasses explicitly call <code>[super initialize]</code>. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:</p>

<pre><code class="language-objectivec">+ (void)initialize {
  if (self == [ClassName self]) {
    // ... do the initialization ...
  }
}
</code></pre>

<p>Because <code>initialize</code> is called in a blocking manner, it’s important to limit method implementations to the minimum amount of work necessary possible. Specifically, any code that takes locks that might be required by other classes in their <code>initialize</code> methods is liable to lead to deadlocks. Therefore, you should not rely on <code>initialize</code> for complex initialization, and should instead limit it to straightforward, class local initialization.</p>

<p><code>initialize</code> is invoked only once per class. If you want to perform independent initialization for the class and for categories of the class, you should implement <a href="https://developer.apple.com/documentation/objectivec/nsobject/1418815-load?language=objc"><code>load</code></a> methods.</p>

<p>—— Documentation, Apple Developer</p>

<p>译：</p>

<p>在类收到第一条消息前初始化。</p>

<p>在类和所有子类接收第一条消息前，运行时发送 <code>initialize</code> 消息到程序中每个类。父类在子类之前接收到该消息。</p>

<p>运行时以线程安全的方式发送 <code>initialize</code> 消息到类。即 <code>initialize</code> 由第一个线程运行来发送消息到一个类，并且其它任何尝试发送消息的线程都将会被阻塞，直到 <code>initialize</code> 完成。</p>

<p>如果子类未实现 <code>initialize</code> 则父类的实现可能会被调用多次 —— 运行时将会调用继承（自父类）的实现 —— 或者如果子类明确调用 <code>[super initialize]</code>。如果不希望运行多次，可以参考如下实现：</p>

<pre><code class="language-objectivec">+ (void)initialize {
  if (self == [ClassName self]) {
    // ... do the initialization ...
  }
}
</code></pre>

<p>由于 <code>initialize</code> 以阻塞的方式被调用，因此将方法实现限制为最小工作量是很有必要的。尤其是在 <code>initialize</code> 中使用任何可能被其它类所必需锁的代码都有可能会导致死锁。因此不应当依赖 <code>initialize</code> 做复杂的初始化，相反应该将其限制为简单的类本地初始化。</p>

<p><code>initialize</code> 在每个类中只会被调用一次。如果希望为类以及分类执行独立的初始化，应当实现 <a href="https://developer.apple.com/documentation/objectivec/nsobject/1418815-load?language=objc"><code>load</code></a> 方法。</p>

<p>—— 文档，苹果开发者</p>
</blockquote>

<h2 id="how">How</h2>

<p>根据官方文档的描述，我们可以尝试定义一个继承自 <code>NSObject</code> 的 <code>Person</code> 类，并对其添加两个分类 <code>Life</code> 和 <code>Work</code>；再定义一个 <code>Student</code> 类继承自 <code>Person</code>，并对其添加 <code>School</code> 分类；最后定义一个 <code>Programmer</code> 类继承自 <code>Person</code>。在以上除了 <code>Programmer</code> 的类和分类中，均实现 +initialize：</p>

<pre><code class="language-objectivec">// Person.m
#import &quot;Person.h&quot;

@implementation Person
+ (void)initialize {
    NSLog(@&quot;Person %s&quot;, __func__);
}
@end

// Person+Life.m
#import &quot;Person+Life.h&quot;

@implementation Person (Life)
+ (void)initialize {
    NSLog(@&quot;Person+Life %s&quot;, __func__);
}
@end

//  Person+Work.m
#import &quot;Person+Work.h&quot;

@implementation Person (Work)
+ (void)initialize {
    NSLog(@&quot;Person+Work %s&quot;, __func__);
}
@end

//  Student.m
#import &quot;Student.h&quot;

@implementation Student
+ (void)initialize {
    NSLog(@&quot;Student %s&quot;, __func__);
}
@end

//  Student+School.m
#import &quot;Student+School.h&quot;

@implementation Student (School)
+ (void)initialize {
    NSLog(@&quot;Student+School %s&quot;, __func__);
}
@end

//  Programmer.m
#import &quot;Programmer.h&quot;

@implementation Programmer
@end

// OUTPUT:
// Hello, World!
</code></pre>

<p>首先我们不更改 main.m，尝试运行程序，结果只输出了 <code>Hello, World!</code>，看来 +initialize 并不像 +load 一样是在 <code>main</code> 函数前调用的。我们注意到官方文档中第一句：「Initializes the class before it receives its first message.」，没有输出的原因是这些类还没有收到一条消息。众所周知，Obj-C 中大部分方法调用的本质都是消息发送（Message Sending），<code>[SomeClass classMethod]</code> 是向 <code>SomeClass</code> 类对象发送 <code>classMethod</code> 消息，<code>[SomeObject instanceMethod]</code> 是向 <code>SomeObject</code> 实例对象发送 <code>instanceMethod</code> 方法。我们尝试在 <code>main</code> 中向它们发送消息。</p>

<pre><code class="language-objectivec">// main.m
#import &lt;Foundation/Foundation.h&gt;

#import &quot;Person.h&quot;
#import &quot;Student.h&quot;
#import &quot;Programmer.h&quot;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSLog(@&quot;---&quot;);
        Student *stu = [Student alloc];
        NSLog(@&quot;---&quot;);
        stu = [stu init];
        
        NSLog(@&quot;---&quot;);
        [Programmer load];
    }
    return 0;
}


// OUTPUT:
// ---
// Person+Work +[Person(Work) initialize]
// Student+School +[Student(School) initialize]
// ---
// ---
// Person+Work +[Person(Work) initialize]
</code></pre>

<p>由于如果要调用对象方法，必须要先进行 <code>alloc</code> 并 <code>init</code> 才能创建完一个实例对象，因此类接收到的第一条消息一定是一个类方法。所以正如官方所述，即<strong>+initialize 方法在类（类对象）接收到第一条消息（类方法）前被调用；子类中如果实现了该方法，会先父类再子类；且遵守分类（Category）覆盖主类的 +initialize；若子类未实现 +initialize，将调用父类中的该方法，因此一个类中的 +initialize 并不能保证只被调用一次，但对于某个类，只会被调用一次</strong>。</p>

<h2 id="why">Why</h2>

<h4 id="实现原理">实现原理</h4>

<p>在上述 Demo 中，我们发现了输出的结果与 +load 的差异，但与分类的相似性。因此我们可以很大概率肯定 iOS 中的 +initialize 方法是消息发送，而非类似 +load 通过方法指针（IMP）直接调用。那么如何验证我们的猜想呢？</p>

<pre><code class="language-objectivec">// objc-class.mm
/***********************************************************************
* class_getClassMethod.  Return the class method for the specified
* class and selector.
* 为指定的类和方法选择器返回相应的类方法。
**********************************************************************/
Method class_getClassMethod(Class cls, SEL sel)
{
    if (!cls  ||  !sel) return nil;

    // ➡️ 返回元类的方法（因为类对象和元类对象的结构一致）
    return class_getInstanceMethod(cls-&gt;getMeta(), sel);
}

// objc-runtime-new.mm
/***********************************************************************
* class_getInstanceMethod.  Return the instance method for the
* specified class and selector.
* 为指定的类和方法选择器返回相应的对象方法。
**********************************************************************/
Method class_getInstanceMethod(Class cls, SEL sel)
{
    if (!cls  ||  !sel) return nil;

    // This deliberately avoids +initialize because it historically did so.
    // 历史原因，这里故意避免 +initialize。

    // This implementation is a bit weird because it's the only place that 
    // wants a Method instead of an IMP.
    // 这里的实现有点奇怪，因为这是唯一需要 Method 而非 IMP 的地方。

#warning fixme build and search caches
        
    // Search method lists, try method resolver, etc.
    // 搜索方法列表，尝试方法解析器等。
    // ➡️ 查找 IMP 或 Nil
    lookUpImpOrNil(cls, sel, nil, 
                   NO/*initialize*/, NO/*cache*/, YES/*resolver*/);

#warning fixme build and search caches

    return _class_getMethod(cls, sel);
}

// objc-runtime-new.mm
/***********************************************************************
* lookUpImpOrNil.
* Like lookUpImpOrForward, but returns nil instead of _objc_msgForward_impcache
* 类似 lookUpImpOrForward，但返回 nil 替代 _objc_msgForward_impcache
**********************************************************************/
IMP lookUpImpOrNil(Class cls, SEL sel, id inst, 
                   bool initialize, bool cache, bool resolver)
{
    // 查找 IMP 或向前
    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);
    // ➡️ 当 IMP 为 _objc_msgForward_impcache 时，返回 nil
    if (imp == _objc_msgForward_impcache) return nil;
    else return imp;
}

// objc-runtime-new.mm
/***********************************************************************
* lookUpImpOrForward.
* The standard IMP lookup. 
* 标准 IMP 查找。
* initialize==NO tries to avoid +initialize (but sometimes fails)
* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)
* Most callers should use initialize==YES and cache==YES.
* inst is an instance of cls or a subclass thereof, or nil if none is known. 
*   If cls is an un-initialized metaclass then a non-nil inst is faster.
* May return _objc_msgForward_impcache. IMPs destined for external use 
*   must be converted to _objc_msgForward or _objc_msgForward_stret.
*   If you don't want forwarding at all, use lookUpImpOrNil() instead.
**********************************************************************/
IMP lookUpImpOrForward(Class cls, SEL sel, id inst, 
                       bool initialize, bool cache, bool resolver)
{
    IMP imp = nil;
    bool triedResolver = NO;

    runtimeLock.assertUnlocked();

    // Optimistic cache lookup
    if (cache) {
        imp = cache_getImp(cls, sel);
        if (imp) return imp;
    }

    // runtimeLock is held during isRealized and isInitialized checking
    // to prevent races against concurrent realization.

    // runtimeLock is held during method search to make
    // method-lookup + cache-fill atomic with respect to method addition.
    // Otherwise, a category could be added but ignored indefinitely because
    // the cache was re-filled with the old value after the cache flush on
    // behalf of the category.

    runtimeLock.lock();
    checkIsKnownClass(cls);

    if (!cls-&gt;isRealized()) {
        realizeClass(cls);
    }

    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) {
        runtimeLock.unlock();
        _class_initialize (_class_getNonMetaClass(cls, inst));
        runtimeLock.lock();
        // If sel == initialize, _class_initialize will send +initialize and 
        // then the messenger will send +initialize again after this 
        // procedure finishes. Of course, if this is not being called 
        // from the messenger then it won't happen. 2778172
    }

    
 retry:    
    runtimeLock.assertLocked();

    // Try this class's cache.

    imp = cache_getImp(cls, sel);
    if (imp) goto done;

    // Try this class's method lists.
    {
        Method meth = getMethodNoSuper_nolock(cls, sel);
        if (meth) {
            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);
            imp = meth-&gt;imp;
            goto done;
        }
    }

    // Try superclass caches and method lists.
    {
        unsigned attempts = unreasonableClassCount();
        for (Class curClass = cls-&gt;superclass;
             curClass != nil;
             curClass = curClass-&gt;superclass)
        {
            // Halt if there is a cycle in the superclass chain.
            if (--attempts == 0) {
                _objc_fatal(&quot;Memory corruption in class list.&quot;);
            }
            
            // Superclass cache.
            imp = cache_getImp(curClass, sel);
            if (imp) {
                if (imp != (IMP)_objc_msgForward_impcache) {
                    // Found the method in a superclass. Cache it in this class.
                    log_and_fill_cache(cls, imp, sel, inst, curClass);
                    goto done;
                }
                else {
                    // Found a forward:: entry in a superclass.
                    // Stop searching, but don't cache yet; call method 
                    // resolver for this class first.
                    break;
                }
            }
            
            // Superclass method list.
            Method meth = getMethodNoSuper_nolock(curClass, sel);
            if (meth) {
                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);
                imp = meth-&gt;imp;
                goto done;
            }
        }
    }

    // No implementation found. Try method resolver once.

    if (resolver  &amp;&amp;  !triedResolver) {
        runtimeLock.unlock();
        _class_resolveMethod(cls, sel, inst);
        runtimeLock.lock();
        // Don't cache the result; we don't hold the lock so it may have 
        // changed already. Re-do the search from scratch instead.
        triedResolver = YES;
        goto retry;
    }

    // No implementation found, and method resolver didn't help. 
    // Use forwarding.

    imp = (IMP)_objc_msgForward_impcache;
    cache_fill(cls, sel, imp, inst);

 done:
    runtimeLock.unlock();

    return imp;
}

// objc-initialize.mm
/***********************************************************************
* class_initialize.  Send the '+initialize' message on demand to any
* uninitialized class. Force initialization of superclasses first.
**********************************************************************/
void _class_initialize(Class cls)
{
    assert(!cls-&gt;isMetaClass());

    Class supercls;
    bool reallyInitialize = NO;

    // Make sure super is done initializing BEFORE beginning to initialize cls.
    // See note about deadlock above.
    supercls = cls-&gt;superclass;
    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) {
        _class_initialize(supercls);
    }
    
    // Try to atomically set CLS_INITIALIZING.
    {
        monitor_locker_t lock(classInitLock);
        if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) {
            cls-&gt;setInitializing();
            reallyInitialize = YES;
        }
    }
    
    if (reallyInitialize) {
        // We successfully set the CLS_INITIALIZING bit. Initialize the class.
        
        // Record that we're initializing this class so we can message it.
        _setThisThreadIsInitializingClass(cls);

        if (MultithreadedForkChild) {
            // LOL JK we don't really call +initialize methods after fork().
            performForkChildInitialize(cls, supercls);
            return;
        }
        
        // Send the +initialize message.
        // Note that +initialize is sent to the superclass (again) if 
        // this class doesn't implement +initialize. 2157218
        if (PrintInitializing) {
            _objc_inform(&quot;INITIALIZE: thread %p: calling +[%s initialize]&quot;,
                         pthread_self(), cls-&gt;nameForLogging());
        }

        // Exceptions: A +initialize call that throws an exception 
        // is deemed to be a complete and successful +initialize.
        //
        // Only __OBJC2__ adds these handlers. !__OBJC2__ has a
        // bootstrapping problem of this versus CF's call to
        // objc_exception_set_functions().
#if __OBJC2__
        @try
#endif
        {
            callInitialize(cls);

            if (PrintInitializing) {
                _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;,
                             pthread_self(), cls-&gt;nameForLogging());
            }
        }
#if __OBJC2__
        @catch (...) {
            if (PrintInitializing) {
                _objc_inform(&quot;INITIALIZE: thread %p: +[%s initialize] &quot;
                             &quot;threw an exception&quot;,
                             pthread_self(), cls-&gt;nameForLogging());
            }
            @throw;
        }
        @finally
#endif
        {
            // Done initializing.
            lockAndFinishInitializing(cls, supercls);
        }
        return;
    }
    
    else if (cls-&gt;isInitializing()) {
        // We couldn't set INITIALIZING because INITIALIZING was already set.
        // If this thread set it earlier, continue normally.
        // If some other thread set it, block until initialize is done.
        // It's ok if INITIALIZING changes to INITIALIZED while we're here, 
        //   because we safely check for INITIALIZED inside the lock 
        //   before blocking.
        if (_thisThreadIsInitializingClass(cls)) {
            return;
        } else if (!MultithreadedForkChild) {
            waitForInitializeToComplete(cls);
            return;
        } else {
            // We're on the child side of fork(), facing a class that
            // was initializing by some other thread when fork() was called.
            _setThisThreadIsInitializingClass(cls);
            performForkChildInitialize(cls, supercls);
        }
    }
    
    else if (cls-&gt;isInitialized()) {
        // Set CLS_INITIALIZING failed because someone else already 
        //   initialized the class. Continue normally.
        // NOTE this check must come AFTER the ISINITIALIZING case.
        // Otherwise: Another thread is initializing this class. ISINITIALIZED 
        //   is false. Skip this clause. Then the other thread finishes 
        //   initialization and sets INITIALIZING=no and INITIALIZED=yes. 
        //   Skip the ISINITIALIZING clause. Die horribly.
        return;
    }
    
    else {
        // We shouldn't be here. 
        _objc_fatal(&quot;thread-safe class init in objc runtime is buggy!&quot;);
    }
}
</code></pre>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="https://maimieng.com/posts/2019/+load_in_ios/">iOS 中的 +load 方法</a></li>
</ul>

  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span
        class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      
      <span class="button next">
        <a href="/posts/2019/&#43;load_in_ios/">
          <span class="button__text">iOS 中的 &#43;load 方法</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo="kingcos/kingcos.github.io"
            issue-term="pathname"
            label="comments"
            theme="github-dark"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2019 · <a href="http://github.com/kingcos">kingcos</a></span>
      </div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>





  
</div>

</body>
</html>
