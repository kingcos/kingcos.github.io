<!DOCTYPE html>
<html lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="kingcos" />
	
	
	
	<title>iOS 中的 &#43;initialize 方法 ｜ 萌面大道</title>
	
    
    
    <meta name="description" content="在 iOS 中，经常与 &#43;load 相提并论的一个方法便是 &#43;initialize。从方法名来看，它的作用是进行初始化，但不同于平时使用的 `init`，&#43;initialize 是一个类方法。那么它的本质到底是什么呢？" />
    

    
    
    <meta name="keywords" content="Hugo, theme, zozo" />
    

	
    
    <link rel="shortcut icon" href="https://kingcos.me/images/favicon.png" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/highlight.css" />

    
    
</head>

<script data-ad-client="ca-pub-9925978992661955" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<body>
    <div class="main animate__animated animate__fadeInDown">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/posts/">Archive</a>
            </li>
            
            <li>
                <a href="/tags/">Tags</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>

<style>
.nav_container {
  height: 1rem;
}
table {
    width: 100%;
    table-layout: fixed;
}
.markdown code {
    white-space: normal;
    word-wrap: break-word;
     
}

.menu_icon a {
    font-size: 20px;
}

 

body {
    font-family: 'Hiragino Sans GB', 'Heiti SC';
}

.markdown strong, .markdown b, .markdown em {
    font-weight: bold;
}

</style>

        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://kingcos.me/">
                    <span>萌面大道</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">专注、坚持</p>
            <div class="my_socials">
                
                
                <a href="https://github.com/kingcos" title="github" target="_blank"><i class="ri-github-fill"></i></a>
                
                
                
                <a href="https://www.instagram.com/kingcos_v/" title="instagram" target="_blank"><i class="ri-instagram-fill"></i></a>
                
                
                
                <a href="https://twitter.com/kingcos_v" title="twitter" target="_blank"><i class="ri-twitter-fill"></i></a>
                
                
                
                <a href="https://weibo.com/u/1798410923" title="weibo" target="_blank"><i class="ri-weibo-fill"></i></a>
                
                
                <a href="https://kingcos.me/index.xml" type="application/rss+xml" title="rss" target="_blank"><i
                        class="ri-rss-fill"></i></a>
            </div>
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/posts/2019/&#43;initialize_in_ios/'>iOS 中的 &#43;initialize 方法</a></h2>
                        <span class="date">2019.04.21</span>
                    </div>
                    <div class="post_content markdown"><table>
<thead>
<tr>
<th style="text-align:center">Date</th>
<th style="text-align:center">Notes</th>
<th style="text-align:center">Source Code</th>
<th style="text-align:center">Demo</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2019-04-21</td>
<td style="text-align:center">首次提交</td>
<td style="text-align:center"><a href="https://opensource.apple.com/tarballs/objc4/">objc4-750</a></td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">2019-05-01</td>
<td style="text-align:center">补充细节</td>
<td style="text-align:center">-</td>
<td style="text-align:center"><a href="https://github.com/kingcos/Perspective/tree/writing/Posts/Practice/%2Binitialize_in_iOS">Initialize_Demo</a></td>
</tr>
</tbody>
</table>
<h2 id="preface">Preface</h2>
<p>在 iOS 中，经常与 +load 相提并论的一个方法便是 +initialize。从方法名来看，它的作用是进行初始化，但不同于平时使用的 <code>init</code>，+initialize 是一个类方法。那么它的本质到底是什么呢？</p>
<p>为了更好地叙述 +initialize 的特点，本文部分描述尝试与 +load 方法对比，建议阅读本文前先阅读「iOS 中的 +load 方法」。</p>
<h2 id="what">What</h2>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// NSObject.h
</span><span class="c1"></span><span class="k">@interface</span> <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="o">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">initialize</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Obj-C 中的 +initialize 方法指的是 NSObject 中的 <code>+ (void)initialize</code> 类方法。官方文档中的 +initialize 如下：</p>
<blockquote>
<p>Initializes the class before it receives its first message.</p>
<p>The runtime sends <code>initialize</code> to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses.</p>
<p>The runtime sends the <code>initialize</code> message to classes in a thread-safe manner. That is, <code>initialize</code> is run by the first thread to send a message to a class, and any other thread that tries to send a message to that class will block until <code>initialize</code> completes.</p>
<p>The superclass implementation may be called multiple times if subclasses do not implement <code>initialize</code>—the runtime will call the inherited implementation—or if subclasses explicitly call <code>[super initialize]</code>. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">initialize</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">self</span> <span class="o">==</span> <span class="p">[</span><span class="n">ClassName</span> <span class="nb">self</span><span class="p">])</span> <span class="p">{</span>
    <span class="c1">// ... do the initialization ...
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>Because <code>initialize</code> is called in a blocking manner, it’s important to limit method implementations to the minimum amount of work necessary possible. Specifically, any code that takes locks that might be required by other classes in their <code>initialize</code> methods is liable to lead to deadlocks. Therefore, you should not rely on <code>initialize</code> for complex initialization, and should instead limit it to straightforward, class local initialization.</p>
<p><code>initialize</code> is invoked only once per class. If you want to perform independent initialization for the class and for categories of the class, you should implement <a href="https://developer.apple.com/documentation/objectivec/nsobject/1418815-load?language=objc"><code>load</code></a> methods.</p>
<p>—— Documentation, Apple Developer</p>
<p>译：</p>
<p>在类收到第一条消息前初始化。</p>
<p>在类和所有子类接收第一条消息前，运行时发送 <code>initialize</code> 消息到程序中每个类。父类在子类之前接收到该消息。</p>
<p>运行时以线程安全的方式发送 <code>initialize</code> 消息到类。即 <code>initialize</code> 由第一个线程运行来发送消息到一个类，并且其它任何尝试发送消息的线程都将会被阻塞，直到 <code>initialize</code> 完成。</p>
<p>如果子类未实现 <code>initialize</code> 则父类的实现可能会被调用多次 —— 运行时将会调用继承（自父类）的实现 —— 或者如果子类明确调用 <code>[super initialize]</code>。如果不希望运行多次，可以参考如下实现：</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">initialize</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">self</span> <span class="o">==</span> <span class="p">[</span><span class="n">ClassName</span> <span class="nb">self</span><span class="p">])</span> <span class="p">{</span>
    <span class="c1">// ... do the initialization ...
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>由于 <code>initialize</code> 以阻塞的方式被调用，因此将方法实现限制为最小工作量是很有必要的。尤其是在 <code>initialize</code> 中使用任何可能被其它类所必需锁的代码都有可能会导致死锁。因此不应当依赖 <code>initialize</code> 做复杂的初始化，相反应该将其限制为简单的类本地初始化。</p>
<p><code>initialize</code> 在每个类中只会被调用一次。如果希望为类以及分类执行独立的初始化，应当实现 <a href="https://developer.apple.com/documentation/objectivec/nsobject/1418815-load?language=objc"><code>load</code></a> 方法。</p>
<p>—— 文档，苹果开发者</p>
</blockquote>
<h2 id="how">How</h2>
<p>根据官方文档的描述，我们可以尝试定义一个继承自 <code>NSObject</code> 的 <code>Person</code> 类，并对其添加两个分类 <code>Life</code> 和 <code>Work</code>；再定义一个 <code>Student</code> 类继承自 <code>Person</code>，并对其添加 <code>School</code> 分类；最后定义一个 <code>Programmer</code> 类继承自 <code>Person</code>。在以上除了 <code>Programmer</code> 的类和分类中，均实现 +initialize：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// Person.m
</span><span class="c1"></span><span class="cp">#import &#34;Person.h&#34;
</span><span class="cp"></span>
<span class="k">@implementation</span> <span class="nc">Person</span>
<span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">initialize</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;Person %s&#34;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="c1">// Person+Life.m
</span><span class="c1"></span><span class="cp">#import &#34;Person+Life.h&#34;
</span><span class="cp"></span>
<span class="k">@implementation</span> <span class="nc">Person</span> <span class="nl">(Life)</span>
<span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">initialize</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;Person+Life %s&#34;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="c1">//  Person+Work.m
</span><span class="c1"></span><span class="cp">#import &#34;Person+Work.h&#34;
</span><span class="cp"></span>
<span class="k">@implementation</span> <span class="nc">Person</span> <span class="nl">(Work)</span>
<span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">initialize</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;Person+Work %s&#34;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="c1">//  Student.m
</span><span class="c1"></span><span class="cp">#import &#34;Student.h&#34;
</span><span class="cp"></span>
<span class="k">@implementation</span> <span class="nc">Student</span>
<span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">initialize</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;Student %s&#34;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="c1">//  Student+School.m
</span><span class="c1"></span><span class="cp">#import &#34;Student+School.h&#34;
</span><span class="cp"></span>
<span class="k">@implementation</span> <span class="nc">Student</span> <span class="nl">(School)</span>
<span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">initialize</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;Student+School %s&#34;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="c1">//  Programmer.m
</span><span class="c1"></span><span class="cp">#import &#34;Programmer.h&#34;
</span><span class="cp"></span>
<span class="k">@implementation</span> <span class="nc">Programmer</span>
<span class="k">@end</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// Hello, World!
</span></code></pre></div><p>首先我们不更改 main.m，尝试运行程序，结果只输出了 <code>main</code> 函数 <code>Hello, World!</code>，因为 +initialize 并不像 +load 一样是在 <code>main</code> 函数前调用的，而没有输出的原因是这些类还没有收到一条消息。众所周知，Obj-C 中大部分方法调用的本质都是消息发送（Message Sending），<code>[SomeClass classMethod]</code> 是向 <code>SomeClass</code> 类对象发送 <code>classMethod</code> 消息；<code>[SomeObject instanceMethod]</code> 是向 <code>SomeObject</code> 实例对象发送 <code>instanceMethod</code> 方法；由于如果要调用对象方法，也必须要先进行 <code>alloc</code> 并 <code>init</code>（或者 <code>new</code>）才能创建完一个实例对象，因此可以认为类接收到的第一条消息永远是类方法。这次我们尝试向它们发送消息：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// main.m
</span><span class="c1"></span><span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="cp"></span>
<span class="cp">#import &#34;Person.h&#34;
</span><span class="cp">#import &#34;Student.h&#34;
</span><span class="cp">#import &#34;Programmer.h&#34;
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;---&#34;</span><span class="p">);</span>
        <span class="n">Student</span> <span class="o">*</span><span class="n">stu</span> <span class="o">=</span> <span class="p">[</span><span class="n">Student</span> <span class="n">alloc</span><span class="p">];</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;---&#34;</span><span class="p">);</span>
        <span class="n">stu</span> <span class="o">=</span> <span class="p">[</span><span class="n">stu</span> <span class="n">init</span><span class="p">];</span>

        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;---&#34;</span><span class="p">);</span>
        <span class="p">[</span><span class="n">Programmer</span> <span class="n">load</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// OUTPUT:
</span><span class="c1">// ---
</span><span class="c1">// Person+Work +[Person(Work) initialize]
</span><span class="c1">// Student+School +[Student(School) initialize]
</span><span class="c1">// ---
</span><span class="c1">// ---
</span><span class="c1">// Person+Work +[Person(Work) initialize]
</span></code></pre></div><p>通过以上代码的输出，虽然我们并没有主动调用这些类的 +initialize 方法，但 +initialize 确实被自动调用了。我们先抛出结论：<strong>+initialize 方法在类（类对象）接收到第一条消息（类方法）前被调用；子类中如果实现了该方法，会先父类再子类；且遵守分类（Category）「覆盖」主类的 +initialize；若子类未实现 +initialize，将调用父类中的该方法，因此一个类中的 +initialize 并不能保证只被调用一次，但对于某个类，只会被调用一次</strong>。</p>
<h2 id="why">Why</h2>
<h4 id="实现原理">实现原理</h4>
<p>上面我们先抛出了结论，那么该如何验证呢？Talk is cheap, show me the code:</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// objc-class.mm
</span><span class="c1"></span><span class="cm">/***********************************************************************
</span><span class="cm">* class_getClassMethod.  Return the class method for the specified
</span><span class="cm">* class and selector.
</span><span class="cm">* 为指定的类和方法选择器返回相应的类方法。
</span><span class="cm">**********************************************************************/</span>
<span class="n">Method</span> <span class="nf">class_getClassMethod</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">sel</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span>  <span class="o">||</span>  <span class="o">!</span><span class="n">sel</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>

    <span class="c1">// ➡️ 返回元类的方法
</span><span class="c1"></span>    <span class="c1">// 因为类对象和元类对象的结构一致（均为 Class），因此元类的类方法和类的对象方法存储在同样的结构中
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">getMeta</span><span class="p">(),</span> <span class="n">sel</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// objc-runtime-new.mm
</span><span class="c1"></span><span class="cm">/***********************************************************************
</span><span class="cm">* class_getInstanceMethod.  Return the instance method for the
</span><span class="cm">* specified class and selector.
</span><span class="cm">* 为指定的类和方法选择器返回相应的对象方法。
</span><span class="cm">**********************************************************************/</span>
<span class="n">Method</span> <span class="nf">class_getInstanceMethod</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">sel</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span>  <span class="o">||</span>  <span class="o">!</span><span class="n">sel</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>

    <span class="c1">// This deliberately avoids +initialize because it historically did so.
</span><span class="c1"></span>    <span class="c1">// 由于历史原因，这里故意避免 +initialize。
</span><span class="c1"></span>
    <span class="c1">// This implementation is a bit weird because it&#39;s the only place that
</span><span class="c1"></span>    <span class="c1">// wants a Method instead of an IMP.
</span><span class="c1"></span>    <span class="c1">// 这里的实现有点奇怪，因为这是唯一需要 Method 而非 IMP 的地方。
</span><span class="c1"></span>
<span class="cp">#warning fixme build and search caches
</span><span class="cp"></span>
    <span class="c1">// Search method lists, try method resolver, etc.
</span><span class="c1"></span>    <span class="c1">// 搜索方法列表，尝试方法解析器等。
</span><span class="c1"></span>    <span class="c1">// ➡️ 查找 IMP
</span><span class="c1"></span>    <span class="n">lookUpImpOrNil</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span>
                   <span class="nb">NO</span><span class="cm">/*initialize*/</span><span class="p">,</span> <span class="nb">NO</span><span class="cm">/*cache*/</span><span class="p">,</span> <span class="nb">YES</span><span class="cm">/*resolver*/</span><span class="p">);</span>

<span class="cp">#warning fixme build and search caches
</span><span class="cp"></span>
    <span class="k">return</span> <span class="n">_class_getMethod</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">sel</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// objc-runtime-new.mm
</span><span class="c1"></span><span class="cm">/***********************************************************************
</span><span class="cm">* lookUpImpOrNil.
</span><span class="cm">* Like lookUpImpOrForward, but returns nil instead of _objc_msgForward_impcache
</span><span class="cm">* 类似 lookUpImpOrForward，但返回 nil 替代 _objc_msgForward_impcache
</span><span class="cm">**********************************************************************/</span>
<span class="kt">IMP</span> <span class="nf">lookUpImpOrNil</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">sel</span><span class="p">,</span> <span class="kt">id</span> <span class="n">inst</span><span class="p">,</span>
                   <span class="kt">bool</span> <span class="n">initialize</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cache</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">resolver</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ➡️ 查找 IMP
</span><span class="c1"></span>    <span class="kt">IMP</span> <span class="n">imp</span> <span class="o">=</span> <span class="n">lookUpImpOrForward</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="n">inst</span><span class="p">,</span> <span class="n">initialize</span><span class="p">,</span> <span class="n">cache</span><span class="p">,</span> <span class="n">resolver</span><span class="p">);</span>
    <span class="c1">// 当 IMP 为 _objc_msgForward_impcache 时，返回 nil
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">imp</span> <span class="o">==</span> <span class="n">_objc_msgForward_impcache</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">imp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// objc-runtime-new.mm
</span><span class="c1"></span><span class="cm">/***********************************************************************
</span><span class="cm">* lookUpImpOrForward.
</span><span class="cm">* The standard IMP lookup.
</span><span class="cm">* 标准 IMP 查找。
</span><span class="cm">* initialize==NO tries to avoid +initialize (but sometimes fails)
</span><span class="cm">* initialize==NO 尝试避免 +initialize（但有时会失败）
</span><span class="cm">* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)
</span><span class="cm">* cache==NO 跳过乐观解锁查找（但有时仍会使用缓存）
</span><span class="cm">* Most callers should use initialize==YES and cache==YES.
</span><span class="cm">* 大多数调用者应当使用 initialize==YES 且 cache==YES。
</span><span class="cm">* inst is an instance of cls or a subclass thereof, or nil if none is known.
</span><span class="cm">* inst 是 cls 或其子类，如果没有，则为 nil。
</span><span class="cm">*   If cls is an un-initialized metaclass then a non-nil inst is faster.
</span><span class="cm">*   如果 cls 是未初始化的元类，那么非 nil 的 inst 更快。
</span><span class="cm">* May return _objc_msgForward_impcache. IMPs destined for external use
</span><span class="cm">*   must be converted to _objc_msgForward or _objc_msgForward_stret.
</span><span class="cm">* 可能返回 _objc_msgForward_impcache。外部使用 IMP 则注定必须被转换为 _objc_msgForward 或 _objc_msgForward_stret。
</span><span class="cm">*   If you don&#39;t want forwarding at all, use lookUpImpOrNil() instead.
</span><span class="cm">*   如果根本不需要转发，使用 lookUpImpOrNil() 替代。
</span><span class="cm">**********************************************************************/</span>
<span class="kt">IMP</span> <span class="nf">lookUpImpOrForward</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">sel</span><span class="p">,</span> <span class="kt">id</span> <span class="n">inst</span><span class="p">,</span>
                       <span class="kt">bool</span> <span class="n">initialize</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cache</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">resolver</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">IMP</span> <span class="n">imp</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">triedResolver</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>

    <span class="c1">// 断言解锁
</span><span class="c1"></span>    <span class="n">runtimeLock</span><span class="p">.</span><span class="n">assertUnlocked</span><span class="p">();</span>

    <span class="c1">// Optimistic cache lookup
</span><span class="c1"></span>    <span class="c1">// 乐观缓存查找
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">imp</span> <span class="o">=</span> <span class="n">cache_getImp</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">sel</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">imp</span><span class="p">)</span> <span class="k">return</span> <span class="n">imp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// runtimeLock is held during isRealized and isInitialized checking
</span><span class="c1"></span>    <span class="c1">// to prevent races against concurrent realization.
</span><span class="c1"></span>    <span class="c1">// 在 isRealized 和 isInitialized 检查期间保持 runtimeLock，防止并发实化竞争。
</span><span class="c1"></span>
    <span class="c1">// runtimeLock is held during method search to make
</span><span class="c1"></span>    <span class="c1">// method-lookup + cache-fill atomic with respect to method addition.
</span><span class="c1"></span>    <span class="c1">// 关于方法添加，在方法搜索期间保持 runtimeLock，使得方法查找和缓存填充原子化（不可再分割）。
</span><span class="c1"></span>    <span class="c1">// Otherwise, a category could be added but ignored indefinitely because
</span><span class="c1"></span>    <span class="c1">// the cache was re-filled with the old value after the cache flush on
</span><span class="c1"></span>    <span class="c1">// behalf of the category.
</span><span class="c1"></span>    <span class="c1">// 否则，分类可以被添加但总会被忽略，因为分类的缓存在刷新后会被旧值重复填充。
</span><span class="c1"></span>
    <span class="n">runtimeLock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="n">checkIsKnownClass</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>

    <span class="c1">// 如果未实化，进行实化
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">isRealized</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">realizeClass</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 如果需要初始化但未初始化，进行初始化
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">initialize</span>  <span class="o">&amp;&amp;</span>  <span class="o">!</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">isInitialized</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">runtimeLock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="c1">// ➡️ 类初始化
</span><span class="c1"></span>        <span class="n">_class_initialize</span> <span class="p">(</span><span class="n">_class_getNonMetaClass</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">inst</span><span class="p">));</span>
        <span class="n">runtimeLock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="c1">// If sel == initialize, _class_initialize will send +initialize and
</span><span class="c1"></span>        <span class="c1">// then the messenger will send +initialize again after this
</span><span class="c1"></span>        <span class="c1">// procedure finishes. Of course, if this is not being called
</span><span class="c1"></span>        <span class="c1">// from the messenger then it won&#39;t happen. 2778172
</span><span class="c1"></span>        <span class="c1">// 如果 sel 等于 initialize，_class_initialize 将发送 +initialize 消息，
</span><span class="c1"></span>        <span class="c1">// 之后发送者将会在该过程完成后再次发送 +initialize。当然，如果不是发送者调用，则不会发生。
</span><span class="c1"></span>    <span class="p">}</span>


 <span class="nl">retry</span><span class="p">:</span>
    <span class="n">runtimeLock</span><span class="p">.</span><span class="n">assertLocked</span><span class="p">();</span>

    <span class="c1">// Try this class&#39;s cache.
</span><span class="c1"></span>
    <span class="n">imp</span> <span class="o">=</span> <span class="n">cache_getImp</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">sel</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">imp</span><span class="p">)</span> <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

    <span class="c1">// Try this class&#39;s method lists.
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">Method</span> <span class="n">meth</span> <span class="o">=</span> <span class="n">getMethodNoSuper_nolock</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">sel</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">meth</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">log_and_fill_cache</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">meth</span><span class="o">-&gt;</span><span class="n">imp</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="n">inst</span><span class="p">,</span> <span class="n">cls</span><span class="p">);</span>
            <span class="n">imp</span> <span class="o">=</span> <span class="n">meth</span><span class="o">-&gt;</span><span class="n">imp</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Try superclass caches and method lists.
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="n">attempts</span> <span class="o">=</span> <span class="n">unreasonableClassCount</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">Class</span> <span class="n">curClass</span> <span class="o">=</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">superclass</span><span class="p">;</span>
             <span class="n">curClass</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">;</span>
             <span class="n">curClass</span> <span class="o">=</span> <span class="n">curClass</span><span class="o">-&gt;</span><span class="n">superclass</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Halt if there is a cycle in the superclass chain.
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">attempts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">_objc_fatal</span><span class="p">(</span><span class="s">&#34;Memory corruption in class list.&#34;</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// Superclass cache.
</span><span class="c1"></span>            <span class="n">imp</span> <span class="o">=</span> <span class="n">cache_getImp</span><span class="p">(</span><span class="n">curClass</span><span class="p">,</span> <span class="n">sel</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">imp</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">imp</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">IMP</span><span class="p">)</span><span class="n">_objc_msgForward_impcache</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// Found the method in a superclass. Cache it in this class.
</span><span class="c1"></span>                    <span class="n">log_and_fill_cache</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">imp</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="n">inst</span><span class="p">,</span> <span class="n">curClass</span><span class="p">);</span>
                    <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// Found a forward:: entry in a superclass.
</span><span class="c1"></span>                    <span class="c1">// Stop searching, but don&#39;t cache yet; call method
</span><span class="c1"></span>                    <span class="c1">// resolver for this class first.
</span><span class="c1"></span>                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// Superclass method list.
</span><span class="c1"></span>            <span class="n">Method</span> <span class="n">meth</span> <span class="o">=</span> <span class="n">getMethodNoSuper_nolock</span><span class="p">(</span><span class="n">curClass</span><span class="p">,</span> <span class="n">sel</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">meth</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">log_and_fill_cache</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">meth</span><span class="o">-&gt;</span><span class="n">imp</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="n">inst</span><span class="p">,</span> <span class="n">curClass</span><span class="p">);</span>
                <span class="n">imp</span> <span class="o">=</span> <span class="n">meth</span><span class="o">-&gt;</span><span class="n">imp</span><span class="p">;</span>
                <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// No implementation found. Try method resolver once.
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="n">resolver</span>  <span class="o">&amp;&amp;</span>  <span class="o">!</span><span class="n">triedResolver</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">runtimeLock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="n">_class_resolveMethod</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="n">inst</span><span class="p">);</span>
        <span class="n">runtimeLock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="c1">// Don&#39;t cache the result; we don&#39;t hold the lock so it may have
</span><span class="c1"></span>        <span class="c1">// changed already. Re-do the search from scratch instead.
</span><span class="c1"></span>        <span class="n">triedResolver</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// No implementation found, and method resolver didn&#39;t help.
</span><span class="c1"></span>    <span class="c1">// Use forwarding.
</span><span class="c1"></span>
    <span class="n">imp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">IMP</span><span class="p">)</span><span class="n">_objc_msgForward_impcache</span><span class="p">;</span>
    <span class="n">cache_fill</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="n">imp</span><span class="p">,</span> <span class="n">inst</span><span class="p">);</span>

 <span class="nl">done</span><span class="p">:</span>
    <span class="n">runtimeLock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">imp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// objc-initialize.mm
</span><span class="c1"></span><span class="cm">/***********************************************************************
</span><span class="cm">* class_initialize.  Send the &#39;+initialize&#39; message on demand to any
</span><span class="cm">* uninitialized class. Force initialization of superclasses first.
</span><span class="cm">* class_initialize。按需发送「+initialize」消息到所有未初始化的类。强制父类最先初始化。
</span><span class="cm">**********************************************************************/</span>
<span class="kt">void</span> <span class="nf">_class_initialize</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 断言非元类
</span><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">isMetaClass</span><span class="p">());</span>

    <span class="kt">Class</span> <span class="n">supercls</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">reallyInitialize</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>

    <span class="c1">// Make sure super is done initializing BEFORE beginning to initialize cls.
</span><span class="c1"></span>    <span class="c1">// 在开始初始化 cls 前确保父类已经完成初始化。
</span><span class="c1"></span>    <span class="c1">// See note about deadlock above.
</span><span class="c1"></span>    <span class="c1">// 查看上面死锁的备注。
</span><span class="c1"></span>    <span class="c1">// 取得父类
</span><span class="c1"></span>    <span class="n">supercls</span> <span class="o">=</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">superclass</span><span class="p">;</span>
    <span class="c1">// 如果父类存在，且未初始化
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">supercls</span>  <span class="o">&amp;&amp;</span>  <span class="o">!</span><span class="n">supercls</span><span class="o">-&gt;</span><span class="n">isInitialized</span><span class="p">())</span> <span class="p">{</span>
    	 <span class="c1">// 递归初始化父类
</span><span class="c1"></span>        <span class="n">_class_initialize</span><span class="p">(</span><span class="n">supercls</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Try to atomically set CLS_INITIALIZING.
</span><span class="c1"></span>    <span class="c1">// 原子化地设置 CLS_INITIALIZING。
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">monitor_locker_t</span> <span class="n">lock</span><span class="p">(</span><span class="n">classInitLock</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">isInitialized</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">isInitializing</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">cls</span><span class="o">-&gt;</span><span class="n">setInitializing</span><span class="p">();</span>
            <span class="n">reallyInitialize</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">reallyInitialize</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// We successfully set the CLS_INITIALIZING bit. Initialize the class.
</span><span class="c1"></span>        <span class="c1">// 成功设置 CLS_INITIALIZING 位。初始化类。
</span><span class="c1"></span>
        <span class="c1">// Record that we&#39;re initializing this class so we can message it.
</span><span class="c1"></span>        <span class="c1">// 记录我们正在初始化该类，以便可以发送这个消息。
</span><span class="c1"></span>        <span class="n">_setThisThreadIsInitializingClass</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">MultithreadedForkChild</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// LOL JK we don&#39;t really call +initialize methods after fork().
</span><span class="c1"></span>            <span class="n">performForkChildInitialize</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">supercls</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Send the +initialize message.
</span><span class="c1"></span>        <span class="c1">// 发送 +initialize 消息。
</span><span class="c1"></span>        <span class="c1">// Note that +initialize is sent to the superclass (again) if
</span><span class="c1"></span>        <span class="c1">// this class doesn&#39;t implement +initialize. 2157218
</span><span class="c1"></span>        <span class="c1">// 如果该类未实现 +initialize，需要注意 +initialize（再次）被发送到了父类
</span><span class="c1"></span>        <span class="c1">// Xcode 中 OBJC_PRINT_INITIALIZE_METHODS 环境变量值为 YES 时，将可在控制台打印该信息
</span><span class="c1"></span>        <span class="c1">// OPTION(PrintInitializing, OBJC_PRINT_INITIALIZE_METHODS, &#34;log calls to class +initialize methods&#34;)
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">PrintInitializing</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;INITIALIZE: thread %p: calling +[%s initialize]&#34;</span><span class="p">,</span>
                         <span class="n">pthread_self</span><span class="p">(),</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">nameForLogging</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="c1">// Exceptions: A +initialize call that throws an exception
</span><span class="c1"></span>        <span class="c1">// is deemed to be a complete and successful +initialize.
</span><span class="c1"></span>        <span class="c1">//
</span><span class="c1"></span>        <span class="c1">// Only __OBJC2__ adds these handlers. !__OBJC2__ has a
</span><span class="c1"></span>        <span class="c1">// bootstrapping problem of this versus CF&#39;s call to
</span><span class="c1"></span>        <span class="c1">// objc_exception_set_functions().
</span><span class="c1"></span><span class="cp">#if __OBJC2__
</span><span class="cp"></span>        <span class="k">@try</span>
<span class="cp">#endif
</span><span class="cp"></span>        <span class="p">{</span>
            <span class="c1">// ➡️ 调用 +initialize
</span><span class="c1"></span>            <span class="n">callInitialize</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">PrintInitializing</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;INITIALIZE: thread %p: finished +[%s initialize]&#34;</span><span class="p">,</span>
                             <span class="n">pthread_self</span><span class="p">(),</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">nameForLogging</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
<span class="cp">#if __OBJC2__
</span><span class="cp"></span>        <span class="k">@catch</span> <span class="p">(...)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">PrintInitializing</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;INITIALIZE: thread %p: +[%s initialize] &#34;</span>
                             <span class="s">&#34;threw an exception&#34;</span><span class="p">,</span>
                             <span class="n">pthread_self</span><span class="p">(),</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">nameForLogging</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="k">@throw</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">@finally</span>
<span class="cp">#endif
</span><span class="cp"></span>        <span class="p">{</span>
            <span class="c1">// Done initializing.
</span><span class="c1"></span>            <span class="n">lockAndFinishInitializing</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">supercls</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">isInitializing</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// We couldn&#39;t set INITIALIZING because INITIALIZING was already set.
</span><span class="c1"></span>        <span class="c1">// If this thread set it earlier, continue normally.
</span><span class="c1"></span>        <span class="c1">// If some other thread set it, block until initialize is done.
</span><span class="c1"></span>        <span class="c1">// It&#39;s ok if INITIALIZING changes to INITIALIZED while we&#39;re here,
</span><span class="c1"></span>        <span class="c1">//   because we safely check for INITIALIZED inside the lock
</span><span class="c1"></span>        <span class="c1">//   before blocking.
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">_thisThreadIsInitializingClass</span><span class="p">(</span><span class="n">cls</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MultithreadedForkChild</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">waitForInitializeToComplete</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// We&#39;re on the child side of fork(), facing a class that
</span><span class="c1"></span>            <span class="c1">// was initializing by some other thread when fork() was called.
</span><span class="c1"></span>            <span class="n">_setThisThreadIsInitializingClass</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
            <span class="n">performForkChildInitialize</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">supercls</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">isInitialized</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// Set CLS_INITIALIZING failed because someone else already
</span><span class="c1"></span>        <span class="c1">//   initialized the class. Continue normally.
</span><span class="c1"></span>        <span class="c1">// NOTE this check must come AFTER the ISINITIALIZING case.
</span><span class="c1"></span>        <span class="c1">// Otherwise: Another thread is initializing this class. ISINITIALIZED
</span><span class="c1"></span>        <span class="c1">//   is false. Skip this clause. Then the other thread finishes
</span><span class="c1"></span>        <span class="c1">//   initialization and sets INITIALIZING=no and INITIALIZED=yes.
</span><span class="c1"></span>        <span class="c1">//   Skip the ISINITIALIZING clause. Die horribly.
</span><span class="c1"></span>        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// We shouldn&#39;t be here.
</span><span class="c1"></span>        <span class="n">_objc_fatal</span><span class="p">(</span><span class="s">&#34;thread-safe class init in objc runtime is buggy!&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// objc-initialize.mm
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">callInitialize</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 💡 向 cls 发送 SEL_initialize 消息
</span><span class="c1"></span>    <span class="p">((</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">Class</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">cls</span><span class="p">,</span> <span class="n">SEL_initialize</span><span class="p">);</span>
    <span class="k">asm</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>追根溯源，我们可以看到 +initialize 的本质其实是 objc_msgSend，即消息发送机制，不同于 +load 直接根据 IMP 指针进行调用。这也就解释了在 Demo 中，我们首先尝试向 <code>Student</code> 类发送一个 <code>alloc</code> 消息，运行时会先找到父类 <code>Person</code> 的 +initialize 方法进行调用，而由于父类又存在分类，最后编译的 <code>Person+Work</code> 分类「覆盖」了其它分类和主类中相同的方法而得以调用；随后调用子类自身的 +initialize 方法，而 <code>Student+School</code> 分类「覆盖」了主类中相同的方法而得以调用；而向 <code>Programmer</code> 类手动发送 +load 消息时（当然，一般我们不会这么做），由于该类本身没有实现 +initialize 方法，因此最终通过父类的 <code>Person+Work</code> 分类调用了 +initialize 方法。</p>
<p><img src="/img/2019/+initialize_in_ios/1.png" alt=""></p>
<p>如上所述，一个类的 +initialize 方法并不能保证只会被调用一次，所以如果我们不希望多次调用，可以在 +initialize 方法中进行判断 <code>self == [ClassName self]</code>。</p>
<h2 id="objc_print_initialize_methods">OBJC_PRINT_INITIALIZE_METHODS</h2>
<p>为了便于 Debug 运行时的 +initialize 方法，将 <code>OBJC_PRINT_INITIALIZE_METHODS</code> 在 Xcode 中设置为 YES 后，可以打印出很多 + initialize 方法执行时的信息：</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSObject initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSObject initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSObject is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_dispatch_data initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_dispatch_data initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_dispatch_data is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_object initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_object initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_object is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_xpc_object initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_xpc_object initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_xpc_object is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_xpc_string initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_xpc_string initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_xpc_string is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_xpc_data initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_xpc_data initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_xpc_data is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_xpc_dictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_xpc_dictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_xpc_dictionary is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_xpc_serializer initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_xpc_serializer initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_xpc_serializer is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_dispatch_object initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_dispatch_object initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_dispatch_object is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_dispatch_mach_msg initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_dispatch_mach_msg initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_dispatch_mach_msg is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_xpc_array initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_xpc_array initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_xpc_array is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSCFType initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSCFType initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSCFType is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSCFString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSCFString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSCFString is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSArray initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSArray initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSArray is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSMutableArray initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSMutableArray initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSMutableArray is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSPlaceholderArray initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSPlaceholderArray initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSPlaceholderArray is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSSingleObjectArrayI initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSSingleObjectArrayI initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSSingleObjectArrayI is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSDictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSDictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSDictionary is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSDictionary0 initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSDictionary0 initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSDictionary0 is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSMutableDictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSMutableDictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSMutableDictionary is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSArray0 initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSArray0 initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSArray0 is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSEnumerator initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSEnumerator initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSEnumerator is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSEnumerator0 initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSEnumerator0 initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSEnumerator0 is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSLock initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSLock initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSLock is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSRecursiveLock initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSRecursiveLock initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSRecursiveLock is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSThread initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSThread initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSThread is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSCFDictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSCFDictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSCFDictionary is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[_NSThreadData initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[_NSThreadData initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: _NSThreadData is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSPlaceholderDictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSPlaceholderDictionary initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSPlaceholderDictionary is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSDictionaryM initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSDictionaryM initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSDictionaryM is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSCFArray initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSCFArray initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSCFArray is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSSet initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSSet initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSSet is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSMutableSet initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSMutableSet initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSMutableSet is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSPlaceholderSet initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSSetI initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSSetI initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSSetI is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSPlaceholderSet initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSPlaceholderSet is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSSetM initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSSetM initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSSetM is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSBindingSelectionMarker initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSBindingSelectionMarker initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSBindingSelectionMarker is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[_NSStateMarker initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[_NSStateMarker initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: _NSStateMarker is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSCFConstantString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSPlaceholderString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSPlaceholderString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: class NSPlaceholderString will be marked as fully +initialized after superclass +[NSString initialize] completes
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSTaggedPointerString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSTaggedPointerString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: class NSTaggedPointerString will be marked as fully +initialized after superclass +[NSString initialize] completes
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSString is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSTaggedPointerString is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSPlaceholderString is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSMutableString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSPlaceholderMutableString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSPlaceholderMutableString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: class NSPlaceholderMutableString will be marked as fully +initialized after superclass +[NSMutableString initialize] completes
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSMutableString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSMutableString is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSPlaceholderMutableString is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSCFConstantString initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSCFConstantString is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSBundle initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSBundle initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSBundle is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[_CFXPreferencesHandle initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[_CFXPreferencesHandle initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: _CFXPreferencesHandle is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[_CFXPreferences initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[_CFXPreferences initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: _CFXPreferences is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[NSURL initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[NSURL initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: NSURL is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[CFPrefsSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[CFPrefsSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: CFPrefsSource is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[CFPrefsSearchListSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[CFPrefsSearchListSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: CFPrefsSearchListSource is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[CFPrefsPlistSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[CFPrefsPlistSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: CFPrefsPlistSource is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[CFPrefsManagedSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[CFPrefsManagedSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: CFPrefsManagedSource is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[__NSArrayM initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[__NSArrayM initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: __NSArrayM is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_xpc_mach_send initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_xpc_mach_send initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_xpc_mach_send is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_xpc_uuid initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_xpc_uuid initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_xpc_uuid is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_xpc_int64 initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_xpc_int64 initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_xpc_int64 is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[OS_voucher initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[OS_voucher initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: OS_voucher is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[CFPrefsSuiteSearchListSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[CFPrefsSuiteSearchListSource initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: CFPrefsSuiteSearchListSource is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[NSData initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: blocking until +[NSData initialize] completes
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[NSData initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: NSData is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[NSMutableData initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: blocking until +[NSMutableData initialize] completes
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[NSMutableData initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: NSMutableData is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[__NSCFData initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: blocking until +[__NSCFData initialize] completes
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[__NSCFData initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: __NSCFData is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[_NSDispatchData initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[_NSDispatchData initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: _NSDispatchData is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[NSDate initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[NSDate initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: NSDate is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[__NSPlaceholderDate initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[__NSPlaceholderDate initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: __NSPlaceholderDate is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[__NSTaggedDate initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[__NSTaggedDate initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: __NSTaggedDate is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[__NSDate initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[__NSDate initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: __NSDate is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[NSValue initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[NSNumber initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[NSNumber initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: class NSNumber will be marked as fully +initialized after superclass +[NSValue initialize] completes
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[NSPlaceholderValue initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[NSPlaceholderValue initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: class NSPlaceholderValue will be marked as fully +initialized after superclass +[NSNumber initialize] completes
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[NSPlaceholderNumber initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[NSPlaceholderNumber initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: class NSPlaceholderNumber will be marked as fully +initialized after superclass +[NSPlaceholderValue initialize] completes
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[NSValue initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: NSValue is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: NSNumber is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: NSPlaceholderValue is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: NSPlaceholderNumber is fully +initialized
objc[23971]: INITIALIZE: thread 0x700009500000: calling +[__NSCFNumber initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: finished +[__NSCFNumber initialize]
objc[23971]: INITIALIZE: thread 0x700009500000: __NSCFNumber is fully +initialized
2019-05-01 00:07:04.813693+0800 Initialize_Demo[23971:21942131] ---
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[Person initialize]
2019-05-01 00:07:04.814048+0800 Initialize_Demo[23971:21942131] Person+Work +[Person(Work) initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[Person initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: Person is fully +initialized
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[Student initialize]
2019-05-01 00:07:04.814168+0800 Initialize_Demo[23971:21942131] Student+School +[Student(School) initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[Student initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: Student is fully +initialized
2019-05-01 00:07:04.814271+0800 Initialize_Demo[23971:21942131] ---
2019-05-01 00:07:04.814297+0800 Initialize_Demo[23971:21942131] ---
objc[23971]: INITIALIZE: thread 0x1000aa5c0: calling +[Programmer initialize]
2019-05-01 00:07:04.814347+0800 Initialize_Demo[23971:21942131] Person+Work +[Person(Work) initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: finished +[Programmer initialize]
objc[23971]: INITIALIZE: thread 0x1000aa5c0: Programmer is fully +initialized
</code></pre></div><h2 id="开销">开销</h2>
<p>+initialize 方法不同于 +load 方法，不会使得程序将时间过多地浪费在启动过程中，因此我们可以将一些合适的操作下沉到 +initialize 中完成。但 +initialize 是以阻塞的方式被调用，也不适合做特别多繁重尤其是可能导致死锁的操作。</p>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="/posts/2019/+load_in_ios/">iOS 中的 +load 方法</a></li>
</ul>
</div>
                    <div class="post_footer">
                        
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    <a href="https://kingcos.me/tags/focus/">Focus</a>
                                    
                                    <a href="https://kingcos.me/tags/ios/">iOS</a>
                                    
                                    <a href="https://kingcos.me/tags/obj-c/">Obj-C</a>
                                    
                                </span>
                            </div>
                        </div>
                        
                    </div>
                </div>
                
                
                <div class="doc_comments"><div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "kingcos" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div>
                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://kingcos.me">Powered by kingcos with love.</a>
    </div>

    <div class="footer_slogan">
        <span>❤️</span>
    </div>
</footer>
    <script src="https://kingcos.me/js/jquery-3.5.1.min.js"></script>
<link href="https://kingcos.me/css/fancybox.min.css" rel="stylesheet">
<script src="https://kingcos.me/js/fancybox.min.js"></script>
<script src="https://kingcos.me/js/zozo.js"></script>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</body>

</html>