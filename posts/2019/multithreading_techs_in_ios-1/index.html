<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>iOS 多线程技术实践之 pthreads（一） :: iBlog</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Swift Xcode     2019-03-08 首次提交 4.2 10.1   2019-12-14 内容重整 5.1 10.3    Preface 在现代计算机中，操作系统一般都会支持多进程（Process）以及多线程（Thread）技术，使得其可以同时运行多个程序且效率更高。而我们在开发 iOS app 中也时常需要利用到这些特性，以为用户提供更加良好的使用体验。通常来说，一个 iOS app 为一个进程，其中又至少有一个线程，即主线程；前者进程由操作系统创建我们很难干预，而线程则「自由」许多，可以为我们所用。iOS 中实现多线程（Multithreading）技术通常可以使用以下几种 API：pthreads、NSThread、GCD（Grand Central Dispatch）以及 NSOperation。由于多线程技术内容较多，我将把相关内容有效整理分割，并独立发文，本文作为该系列第一篇，先来看一看 pthreads。
What  POSIX Threads, usually referred to as pthreads, is an execution model that exists independently from a language, as well as a parallel execution model. It allows a program to control multiple different flows of work that overlap in time."/>
<meta name="keywords" content="kingcos.me,maimieng.comios,swift,objective-c,obj-c,objc,oc,geek,python,ruby,golang,go,apple,mac"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/multithreading_techs_in_ios-1/" />





<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="iOS 多线程技术实践之 pthreads（一）"/>
<meta name="twitter:description" content="在现代计算机中，操作系统一般都会支持多进程以及多线程技术，使得其可以同时运行多个程序且效率更高。而我们在开发 iOS app 中也时常需要利用到这些特性，以为用户提供更加良好的使用体验。通常来说，一个 iOS app 为一个进程，其中又至少有一个线程，即主线程；前者进程由操作系统创建我们很难干预，而线程则「自由」许多，可以为我们所用。iOS 中实现多线程技术通常可以使用以下几种 API：pthreads、`NSThread`、GCD 以及 `NSOperation`。由于多线程技术内容较多，我将把相关内容有效整理分割，并独立发文，本文作为该系列第一篇，先来看一看 pthreads。"/>



<meta property="og:title" content="iOS 多线程技术实践之 pthreads（一）" />
<meta property="og:description" content="在现代计算机中，操作系统一般都会支持多进程以及多线程技术，使得其可以同时运行多个程序且效率更高。而我们在开发 iOS app 中也时常需要利用到这些特性，以为用户提供更加良好的使用体验。通常来说，一个 iOS app 为一个进程，其中又至少有一个线程，即主线程；前者进程由操作系统创建我们很难干预，而线程则「自由」许多，可以为我们所用。iOS 中实现多线程技术通常可以使用以下几种 API：pthreads、`NSThread`、GCD 以及 `NSOperation`。由于多线程技术内容较多，我将把相关内容有效整理分割，并独立发文，本文作为该系列第一篇，先来看一看 pthreads。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2019/multithreading_techs_in_ios-1/" />
<meta property="article:published_time" content="2019-12-14T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-12-14T00:00:00+00:00" /><meta property="og:site_name" content="iBlog" />




<script data-ad-client="ca-pub-9925978992661955" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">kingcos.me</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="post">
    <h2 class="post-title"><a href="/posts/2019/multithreading_techs_in_ios-1/">iOS 多线程技术实践之 pthreads（一）</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            2019-12-14
        </span>
      
      
      
        <span class="post-read-time">— 9 min read</span>
      
    </div>

    
      <span class="post-tags">
        
          #<a href="/tags/practice/">Practice</a>&nbsp;
        
          #<a href="/tags/ios/">iOS</a>&nbsp;
        
          #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
        
          #<a href="/tags/swift/">Swift</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      <table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Swift</th>
<th align="center">Xcode</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">2019-03-08</td>
<td align="center">首次提交</td>
<td align="center">4.2</td>
<td align="center">10.1</td>
</tr>
<tr>
<td align="center">2019-12-14</td>
<td align="center">内容重整</td>
<td align="center">5.1</td>
<td align="center">10.3</td>
</tr>
</tbody>
</table>
<p><img src="/img/2019/multithreading_techs_in_ios-1/0.png" alt="0"></p>
<h2 id="preface">Preface</h2>
<p>在现代计算机中，操作系统一般都会支持多进程（Process）以及多线程（Thread）技术，使得其可以同时运行多个程序且效率更高。而我们在开发 iOS app 中也时常需要利用到这些特性，以为用户提供更加良好的使用体验。通常来说，一个 iOS app 为一个进程，其中又至少有一个线程，即主线程；前者进程由操作系统创建我们很难干预，而线程则「自由」许多，可以为我们所用。iOS 中实现多线程（Multithreading）技术通常可以使用以下几种 API：pthreads、<code>NSThread</code>、GCD（Grand Central Dispatch）以及 <code>NSOperation</code>。由于多线程技术内容较多，我将把相关内容有效整理分割，并独立发文，本文作为该系列第一篇，先来看一看 pthreads。</p>
<h2 id="what">What</h2>
<blockquote>
<p>POSIX Threads, usually referred to as pthreads, is an execution model that exists independently from a language, as well as a parallel execution model. It allows a program to control multiple different flows of work that overlap in time. Each flow of work is referred to as a thread, and creation and control over these flows is achieved by making calls to the POSIX Threads API.</p>
<p>&ndash; POSIX Threads, Wikipedia</p>
<p>译：</p>
<p>POSIX（Portable Operating System Interface of UNIX，可移植操作系统接口）线程，即 pthreads，是一种不依赖于语言的执行模型，也称作并行（Parallel）执行模型。其允许一个程序控制多个时间重叠的不同工作流。每个工作流即为一个线程，通过调用 POSIX 线程 API 创建并控制这些流。</p>
<p>&ndash; POSIX 线程，维基百科</p>
</blockquote>
<p>如上所述，pthreads 即 POSIX Threads，是一套跨平台的多线程 API，由 C 语言编写。在 Xcode 中，使用 <code>#import &lt;pthread.h&gt;</code> 即可引入 pthreads 相关的 API。但正是由于纯 C 的 API，使用起来不够友好，也需要手动管理线程的整个生命周期。</p>
<h2 id="heading">线程创建</h2>
<p>想要开辟一条新的线程来执行任务，我们首先要知道如何创建线程。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">PTHREAD_CREATE(3)        BSD Library Functions Manual        PTHREAD_CREATE(3)

NAME
     pthread_create -- create a new thread

SYNOPSIS
     #include &lt;pthread.h&gt;

     int
     pthread_create(pthread_t *restrict thread,
         const pthread_attr_t *restrict attr, void *(*start_routine)(void *),
         void *restrict arg);

DESCRIPTION
     The pthread_create() function is used to create a new thread, with
     attributes specified by attr, within a process.  If attr is NULL, the
     default attributes are used.  If the attributes specified by attr are
     modified later, the thread&#39;s attributes are not affected.  Upon success-ful successful
     ful completion, pthread_create() will store the ID of the created thread
     in the location specified by thread.

     Upon its creation, the thread executes start_routine, with arg as its
     sole argument.  If start_routine returns, the effect is as if there was
     an implicit call to pthread_exit(), using the return value of
     start_routine as the exit status.  Note that the thread in which main()
     was originally invoked differs from this.  When it returns from main(),
     the effect is as if there was an implicit call to exit(), using the
     return value of main() as the exit status.

     The signal state of the new thread is initialized as:

           oo   The signal mask is inherited from the creating thread.

           oo   The set of signals pending for the new thread is empty.

RETURN VALUES
     If successful,  the pthread_create() function will return zero.  Other-wise, Otherwise,
     wise, an error number will be returned to indicate the error.

ERRORS
     pthread_create() will fail if:

     [EAGAIN]           The system lacked the necessary resources to create
                        another thread, or the system-imposed limit on the
                        total number of threads in a process
                        [PTHREAD_THREADS_MAX] would be exceeded.

     [EINVAL]           The value specified by attr is invalid.

SEE ALSO
     fork(2), pthread_cleanup_pop(3), pthread_cleanup_push(3),
     pthread_exit(3), pthread_join(3)

STANDARDS
     pthread_create() conforms to ISO/IEC 9945-1:1996 (``POSIX.1&#39;&#39;).

BSD                              April 4, 1996                             BSD
</code></pre></div><p>pthreads 通过 <code>pthread_create</code> 函数来创建新的线程：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// pthreads.h
</span><span style="color:#75715e"></span>
<span style="color:#75715e">/* &lt;rdar://problem/25944576&gt; */</span>
<span style="color:#75715e">#</span><span style="color:#75715e">define _PTHREAD_SWIFT_IMPORTER_NULLABILITY_COMPAT \</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">	defined(SWIFT_CLASS_EXTRA) &amp;&amp; (!defined(SWIFT_SDK_OVERLAY_PTHREAD_EPOCH) || (SWIFT_SDK_OVERLAY_PTHREAD_EPOCH &lt; 1))</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
__API_AVAILABLE(macos(<span style="color:#ae81ff">10.4</span>), ios(<span style="color:#ae81ff">2.0</span>))
<span style="color:#75715e">#</span><span style="color:#75715e">if !_PTHREAD_SWIFT_IMPORTER_NULLABILITY_COMPAT</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> pthread_create(pthread_t _Nullable <span style="color:#f92672">*</span> _Nonnull __restrict,
		<span style="color:#66d9ef">const</span> pthread_attr_t <span style="color:#f92672">*</span> _Nullable __restrict,
		<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> _Nullable (<span style="color:#f92672">*</span> _Nonnull)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> _Nullable),
		<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> _Nullable __restrict);
<span style="color:#75715e">#</span><span style="color:#75715e">else</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pthread_create</span>(pthread_t <span style="color:#f92672">*</span> __restrict,
		<span style="color:#66d9ef">const</span> pthread_attr_t <span style="color:#f92672">*</span> _Nullable __restrict,
		<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span> _Nonnull)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>), <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> _Nullable __restrict);
<span style="color:#75715e">#</span><span style="color:#75715e">endif </span><span style="color:#75715e">// _PTHREAD_SWIFT_IMPORTER_NULLABILITY_COMPAT
</span></code></pre></div><blockquote>
<p>⚠️</p>
<p>可以注意到的是，<code>pthread.h</code> 中关于 <code>pthread_create</code> 函数的声明使用了 <code>_PTHREAD_SWIFT_IMPORTER_NULLABILITY_COMPAT</code> 宏进行了区分。关于该宏以及其内部判断条件其实没有太多资料可以参考，但大体上可以理解是为了兼容 Swift 中的可选类型，但两种声明本质上并无其他区别。</p>
</blockquote>
<p>以 Obj-C 中实际使用的 <code>pthread_create(pthread_t _Nullable *restrict _Nonnull, const pthread_attr_t *restrict _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void *restrict _Nullable)</code> 声明为例，其中 <code>_Nullable</code> 和 <code>_Nonnull</code> 是 Obj-C 桥接 Swift 可选（Optional）类型时是否隐式或显式的标志；<code>__restrict</code> 是 C99 标准引入的关键字，类似于 <code>restrict</code>，可以用在指针声明处，使得编译器只能通过该指针本身才能修改指向的内容，便于其优化。去掉这些不影响函数本身功能的标志，补全参数名即 <code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)</code>。</p>
<h3 id="pthread-t">pthread_t</h3>
<p><code>pthread_create</code> 中的第一个参数是 <code>pthread_t *thread</code>，即指向 <code>pthread_t</code> 的指针。<code>pthread_t</code> 的本质是 <code>_opaque_pthread_t</code> 结构体，这里的 <code>opaque</code>（不透明）意味着外界通常无需关心其内部实现细节：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// sys/_pthread/_pthread_t.h
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> __darwin_pthread_t pthread_t;

<span style="color:#75715e">// sys/_pthread/_pthread_types.h
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> _opaque_pthread_t {
	<span style="color:#66d9ef">long</span> __sig;
	<span style="color:#66d9ef">struct</span> __darwin_pthread_handler_rec  <span style="color:#f92672">*</span>__cleanup_stack;
	<span style="color:#66d9ef">char</span> __opaque[__PTHREAD_SIZE__];
};

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _opaque_pthread_t <span style="color:#f92672">*</span>__darwin_pthread_t;
</code></pre></div><p>我们可以将这个参数理解为线程的引用即可，当 <code>pthread_create</code> 成功创建好线程，传入的 <code>pthread_t</code> 地址即为一个新的线程。</p>
<h3 id="pthread-attr-t">pthread_attr_t</h3>
<p><code>pthread_create</code> 中的第二个参数是 <code>const pthread_attr_t *attr</code>，即指向 <code>pthread_attr_t</code> 的指针。 <code>pthread_attr_t</code> 的本质是 <code>_opaque_pthread_attr_t</code> 结构体，也是一个不透明类型：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// sys/_pthread/_pthread_attr_t.h
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> __darwin_pthread_attr_t pthread_attr_t;

<span style="color:#75715e">// sys/_pthread/_pthread_types.h
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> _opaque_pthread_attr_t {
	<span style="color:#66d9ef">long</span> __sig;
	<span style="color:#66d9ef">char</span> __opaque[__PTHREAD_ATTR_SIZE__];
};

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _opaque_pthread_attr_t __darwin_pthread_attr_t;
</code></pre></div><p><code>pthread_attr_t</code> 指的是线程属性，我们可以使用 <code>pthread_attr_init</code> 函数来初始化，以及使用 <code>pthread_attr_set</code> 开头的函数来进行设置：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// 声明 pthread_attr_t
</span><span style="color:#75715e"></span>pthread_attr_t attr;

<span style="color:#75715e">// 初始化
</span><span style="color:#75715e"></span>pthread_attr_init(<span style="color:#f92672">&amp;</span>attr);

<span style="color:#75715e">// 设置
</span><span style="color:#75715e"></span>pthread_attr_setscope(<span style="color:#f92672">&amp;</span>attr, <span style="color:#66d9ef">int</span>);                                       <span style="color:#75715e">// 作用域
</span><span style="color:#75715e"></span>pthread_attr_setstack(<span style="color:#f92672">&amp;</span>attr, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> _Nonnull, size_t);                   <span style="color:#75715e">// 栈
</span><span style="color:#75715e"></span>pthread_attr_setguardsize(<span style="color:#f92672">&amp;</span>attr, size_t);                                <span style="color:#75715e">// 栈末尾的警戒缓冲区大小
</span><span style="color:#75715e"></span>pthread_attr_setstackaddr(<span style="color:#f92672">&amp;</span>attr, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> _Nonnull);                       <span style="color:#75715e">// 栈地址
</span><span style="color:#75715e"></span>pthread_attr_setstacksize(<span style="color:#f92672">&amp;</span>attr, size_t);                                <span style="color:#75715e">// 栈大小
</span><span style="color:#75715e"></span>pthread_attr_setschedparam(<span style="color:#f92672">&amp;</span>attr,
                           <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> sched_param <span style="color:#f92672">*</span><span style="color:#66d9ef">restrict</span> _Nonnull); <span style="color:#75715e">// 调度参数
</span><span style="color:#75715e"></span>pthread_attr_setdetachstate(<span style="color:#f92672">&amp;</span>attr, <span style="color:#66d9ef">int</span>);                                 <span style="color:#75715e">// 分离状态
</span><span style="color:#75715e"></span>pthread_attr_setschedpolicy(<span style="color:#f92672">&amp;</span>attr, <span style="color:#66d9ef">int</span>);                                 <span style="color:#75715e">// 调度策略
</span><span style="color:#75715e"></span>pthread_attr_setinheritsched(<span style="color:#f92672">&amp;</span>attr, <span style="color:#66d9ef">int</span>);                                <span style="color:#75715e">// 继承
</span><span style="color:#75715e"></span>pthread_attr_set_qos_class_np(<span style="color:#f92672">&amp;</span>attr,
                              qos_class_t __qos_class,
                              <span style="color:#66d9ef">int</span> __relative_priority);                  <span style="color:#75715e">// 分配 QoS 类
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 创建线程时将 attr 地址传入
</span><span style="color:#75715e"></span><span style="color:#75715e">// pthread_create(&amp;thread, &amp;attr, ...);
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 使用完毕销毁
</span><span style="color:#75715e"></span>pthread_attr_destroy(<span style="color:#f92672">&amp;</span>attr);
</code></pre></div><p>通常我们不太会去自定义这里的属性，因此可以将 <code>pthread_create</code> 中的该参数传 <code>NULL</code> 即可使用默认属性来创建线程。</p>
<h3 id="pthread-create">pthread_create</h3>
<p><code>pthread_create</code> 中的最后两个参数是 <code>void *(*start_routine) (void *)</code> 和 <code>void *arg</code>。<code>start_routine()</code> 是新线程运行时所执行的函数，<code>arg</code> 是传入 <code>start_routine()</code> 的唯一参数。当 <code>start_routine()</code> 执行终止或者线程被明确杀死，线程也将会终止；<code>pthread_create</code> 的返回值是 <code>int</code> 类型，当返回 <code>0</code> 时，创建成功，否则将返回错误码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">#</span><span style="color:#75715e">import &lt;pthread.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">runForThread_1</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>arg) {
    <span style="color:#75715e">// pthread_self()：返回当前线程 pthread_t
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s (%p) is running.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, arg, pthread_self());
    <span style="color:#75715e">// 退出线程
</span><span style="color:#75715e"></span>    pthread_exit(arg);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">runForThread_2</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg) {
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s (%p) is running.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, arg, pthread_self());
    <span style="color:#75715e">// 函数返回自动退出线程
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 声明两个线程 thread_1 &amp; thread_2
</span><span style="color:#75715e"></span>pthread_t thread_1, thread_2;

<span style="color:#75715e">// 创建 thread_1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> result_1 <span style="color:#f92672">=</span> pthread_create(<span style="color:#f92672">&amp;</span>thread_1, NULL, (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)runForThread_1, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">thread_1</span><span style="color:#e6db74">&#34;</span>);

<span style="color:#75715e">// 打印 thread_1 创建函数返回值 &amp; 线程地址
</span><span style="color:#75715e"></span>printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">result_1 - %d - %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, result_1, thread_1);

<span style="color:#75715e">// 检查线程是否创建成功
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (result_1 <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">pthread_create thread_1 error.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
}

<span style="color:#75715e">// 声明线程属性 attr
</span><span style="color:#75715e"></span>pthread_attr_t attr;
<span style="color:#75715e">// 初始化线程属性
</span><span style="color:#75715e"></span>pthread_attr_init(<span style="color:#f92672">&amp;</span>attr);
<span style="color:#75715e">// 销毁线程属性
</span><span style="color:#75715e"></span>pthread_attr_destroy(<span style="color:#f92672">&amp;</span>attr);

<span style="color:#75715e">// 使用 attr 创建 thread_2
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> result_2 <span style="color:#f92672">=</span> pthread_create(<span style="color:#f92672">&amp;</span>thread_2, <span style="color:#f92672">&amp;</span>attr, (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)runForThread_2, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">thread_2</span><span style="color:#e6db74">&#34;</span>);

printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">result_2 - %d - %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, result_2, thread_2);

<span style="color:#66d9ef">if</span> (result_2 <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">pthread_create thread_2 error.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// result_1 - 0 - 0x70000799e000
</span><span style="color:#75715e"></span><span style="color:#75715e">// result_2 - 22 - 0x0
</span><span style="color:#75715e"></span><span style="color:#75715e">// pthread_create thread_2 error.
</span><span style="color:#75715e"></span><span style="color:#75715e">// thread_1 (0x70000799e000) is running.
</span></code></pre></div><p>这里我们使用默认属性 <code>NULL</code> 即可创建通用化的线程；而如果使用已经销毁的线程属性 <code>pthread_attr_t</code> 来创建线程时，就会出现错误而无法创建线程。</p>
<h3 id="pthread-create-in-swift">pthread_create in Swift</h3>
<p>如上文所述，pthreads API 在 Swift 中也可以使用。首先，我们需要通过桥接文件引入 <code>pthread.h</code> 头文件：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// Multithreading_pthreads-Bridging-Header.h
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#</span><span style="color:#75715e">import &lt;pthread.h&gt;</span><span style="color:#75715e">
</span></code></pre></div><p>然后我们可以在 Swift 中 <code>pthread_create</code> 函数声明处发现，其四个参数均与 <code>Unsafe...Pointer</code> 相关的类型有关，这样的命名是因为 Swift 中的指针语法也被抽象为类型而非 <code>*</code>，并通过 <code>Unsafe</code> 告知开发者其中可能存在隐患。而这里由于 <code>pthread_create</code> 本质是一个 C 语言函数，但 Swift 又无法直接与 C/C++ 进行混编，因此需要做一些转换：</p>
<table>
<thead>
<tr>
<th align="center">C 语法</th>
<th align="center">Swift 语法</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>const Type *</code></td>
<td align="center"><code>UnsafePointer&lt;Type&gt;</code></td>
</tr>
<tr>
<td align="center"><code>Type *</code></td>
<td align="center"><code>UnsafeMutablePointer&lt;Type&gt;</code></td>
</tr>
<tr>
<td align="center"><code>Type * const *</code></td>
<td align="center"><code>UnsafePointer&lt;Type&gt;</code></td>
</tr>
<tr>
<td align="center"><code>Type * __strong *</code></td>
<td align="center"><code>UnsafeMutablePointer&lt;Type&gt;</code></td>
</tr>
<tr>
<td align="center"><code>Type **</code></td>
<td align="center"><code>AutoreleasingUnsafeMutablePointer&lt;Type&gt;</code></td>
</tr>
<tr>
<td align="center"><code>const void *</code></td>
<td align="center"><code>UnsafeRawPointer</code></td>
</tr>
<tr>
<td align="center"><code>void *</code></td>
<td align="center"><code>UnsafeMutableRawPointer</code></td>
</tr>
</tbody>
</table>
<p><code>pthread_create</code> 函数中，第一个参数 <code>pthread_t *thread</code> 在 Swift 中将被表示为 <code>UnsafeMutablePointer&lt;pthread_t&gt;</code>，第二个参数 <code>const pthread_attr_t *attr</code> 将被表示为 <code>UnsafePointer&lt;pthread_attr_t&gt;</code>，第三个参数 <code>void *(*start_routine) (void *)</code> 被表示为 <code>(UnsafeMutableRawPointer) -&gt; (UnsafeMutableRawPointer)</code>，以及最后一个参数 <code>void *arg</code> 将被表示为 <code>UnsafeMutableRawPointer</code>，这些参数再加上可空性对应的可选类型，最终形成了 Swift 中 <code>pthread_create</code> 函数的 API：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift">@available(iOS <span style="color:#ae81ff">2.0</span>, <span style="color:#f92672">*</span>)
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">pthread_create</span>(<span style="color:#66d9ef">_</span>: UnsafeMutablePointer&lt;pthread_t?<span style="color:#f92672">&gt;!</span>, <span style="color:#66d9ef">_</span>: UnsafePointer&lt;pthread_attr_t&gt;?, <span style="color:#66d9ef">_</span>: @convention(c) (UnsafeMutableRawPointer) -&gt; UnsafeMutableRawPointer?, <span style="color:#66d9ef">_</span>: UnsafeMutableRawPointer?) -&gt; Int32
<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">_</span><span style="color:#75715e">P</span><span style="color:#75715e">T</span><span style="color:#75715e">H</span><span style="color:#75715e">R</span><span style="color:#75715e">E</span><span style="color:#75715e">A</span><span style="color:#75715e">D</span><span style="color:#75715e">_</span><span style="color:#75715e">S</span><span style="color:#75715e">W</span><span style="color:#75715e">I</span><span style="color:#75715e">F</span><span style="color:#75715e">T</span><span style="color:#75715e">_</span><span style="color:#75715e">I</span><span style="color:#75715e">M</span><span style="color:#75715e">P</span><span style="color:#75715e">O</span><span style="color:#75715e">R</span><span style="color:#75715e">T</span><span style="color:#75715e">E</span><span style="color:#75715e">R</span><span style="color:#75715e">_</span><span style="color:#75715e">N</span><span style="color:#75715e">U</span><span style="color:#75715e">L</span><span style="color:#75715e">L</span><span style="color:#75715e">A</span><span style="color:#75715e">B</span><span style="color:#75715e">I</span><span style="color:#75715e">L</span><span style="color:#75715e">I</span><span style="color:#75715e">T</span><span style="color:#75715e">Y</span><span style="color:#75715e">_</span><span style="color:#75715e">C</span><span style="color:#75715e">O</span><span style="color:#75715e">M</span><span style="color:#75715e">P</span><span style="color:#75715e">A</span><span style="color:#75715e">T</span>
</code></pre></div><p>前两个参数我们在 Swift 中仍然可以使用 <code>&amp;</code> 来按地址传递，那么后两个参数 C 语言函数和参数该如何传递呢？</p>
<p>为了兼容 Swift 中的各种类型，我们可以将值封装在一个支持泛型的 <code>Box</code> 类型中；并额外定义两个方法，一是 <code>encode</code>：将 Swift 中的值封装在 <code>UnsafeMutableRawPointer</code> 指针类型中，二是 <code>decode</code>：将 <code>UnsafeMutableRawPointer</code> 指针类型中真正的值取出。这两个方法需要成对使用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Box</span>&lt;T&gt; {
    <span style="color:#66d9ef">let</span> value: T

    <span style="color:#66d9ef">init</span>(<span style="color:#66d9ef">_</span> value: T) {
        <span style="color:#66d9ef">self</span>.value = value
    }
}

<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">decode</span>&lt;T&gt;(<span style="color:#66d9ef">_</span> memory: UnsafeMutableRawPointer) -&gt; T {
    <span style="color:#66d9ef">let</span> unmanaged = Unmanaged&lt;Box&lt;T&gt;<span style="color:#f92672">&gt;</span>.fromOpaque(memory)
    <span style="color:#66d9ef">defer</span> { unmanaged.release() } <span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">延</span><span style="color:#75715e">迟</span><span style="color:#75715e">释</span><span style="color:#75715e">放</span>
    <span style="color:#66d9ef">return</span> unmanaged.takeUnretainedValue().value
}

<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">encode</span>&lt;T&gt;(<span style="color:#66d9ef">_</span> t: T) -&gt; UnsafeMutableRawPointer {
    <span style="color:#66d9ef">return</span> Unmanaged.passRetained(Box(t)).toOpaque()
}
</code></pre></div><p>接下来的使用就十分类似 Obj-C 了：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">需</span><span style="color:#75715e">声</span><span style="color:#75715e">明</span><span style="color:#75715e"> </span><span style="color:#75715e">S</span><span style="color:#75715e">w</span><span style="color:#75715e">i</span><span style="color:#75715e">f</span><span style="color:#75715e">t</span><span style="color:#75715e"> </span><span style="color:#75715e">类</span><span style="color:#75715e">外</span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">runForThread_1</span>(<span style="color:#66d9ef">_</span> arg: UnsafeMutableRawPointer) -&gt; UnsafeMutableRawPointer? {
    print(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>decode<span style="color:#e6db74">(</span>arg<span style="color:#e6db74">)</span> <span style="color:#66d9ef">as</span> String<span style="color:#e6db74">)</span><span style="color:#e6db74"> (</span><span style="color:#e6db74">\(</span>pthread_self<span style="color:#e6db74">(</span><span style="color:#e6db74">)</span><span style="color:#e6db74">)</span><span style="color:#e6db74">) is running.</span><span style="color:#e6db74">&#34;</span>)

    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}

<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">声</span><span style="color:#75715e">明</span><span style="color:#75715e">两</span><span style="color:#75715e">个</span><span style="color:#75715e">线</span><span style="color:#75715e">程</span><span style="color:#75715e"> </span><span style="color:#75715e">t</span><span style="color:#75715e">h</span><span style="color:#75715e">r</span><span style="color:#75715e">e</span><span style="color:#75715e">a</span><span style="color:#75715e">d</span><span style="color:#75715e">_</span><span style="color:#75715e">1</span><span style="color:#75715e"> </span><span style="color:#75715e">&amp;</span><span style="color:#75715e"> </span><span style="color:#75715e">t</span><span style="color:#75715e">h</span><span style="color:#75715e">r</span><span style="color:#75715e">e</span><span style="color:#75715e">a</span><span style="color:#75715e">d</span><span style="color:#75715e">_</span><span style="color:#75715e">2</span>
<span style="color:#66d9ef">var</span> thread_1, thread_2: pthread_t!

<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">创</span><span style="color:#75715e">建</span><span style="color:#75715e"> </span><span style="color:#75715e">t</span><span style="color:#75715e">h</span><span style="color:#75715e">r</span><span style="color:#75715e">e</span><span style="color:#75715e">a</span><span style="color:#75715e">d</span><span style="color:#75715e">_</span><span style="color:#75715e">1</span>
<span style="color:#66d9ef">let</span> result_1 = pthread_create(&amp;thread_1, <span style="color:#66d9ef">nil</span>, runForThread_1, encode(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">thread_1</span><span style="color:#e6db74">&#34;</span>))

print(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">result_1 - </span><span style="color:#e6db74">\(</span>result_1<span style="color:#e6db74">)</span><span style="color:#e6db74"> - </span><span style="color:#e6db74">\(</span>String<span style="color:#e6db74">(</span>describing: thread_1<span style="color:#e6db74">)</span><span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>);

<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">检</span><span style="color:#75715e">查</span><span style="color:#75715e">线</span><span style="color:#75715e">程</span><span style="color:#75715e">是</span><span style="color:#75715e">否</span><span style="color:#75715e">创</span><span style="color:#75715e">建</span><span style="color:#75715e">成</span><span style="color:#75715e">功</span>
<span style="color:#66d9ef">if</span> result_1 <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
    print(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">pthread_create thread_1 error.</span><span style="color:#e6db74">&#34;</span>)
}

<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">声</span><span style="color:#75715e">明</span><span style="color:#75715e">线</span><span style="color:#75715e">程</span><span style="color:#75715e">属</span><span style="color:#75715e">性</span><span style="color:#75715e"> </span><span style="color:#75715e">a</span><span style="color:#75715e">t</span><span style="color:#75715e">t</span><span style="color:#75715e">r</span><span style="color:#75715e">，</span><span style="color:#75715e">注</span><span style="color:#75715e">意</span><span style="color:#75715e">这</span><span style="color:#75715e">里</span><span style="color:#75715e">需</span><span style="color:#75715e">要</span>
<span style="color:#66d9ef">var</span> attr = pthread_attr_t()
<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">初</span><span style="color:#75715e">始</span><span style="color:#75715e">化</span><span style="color:#75715e">线</span><span style="color:#75715e">程</span><span style="color:#75715e">属</span><span style="color:#75715e">性</span>
pthread_attr_init(&amp;attr)
<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">销</span><span style="color:#75715e">毁</span><span style="color:#75715e">线</span><span style="color:#75715e">程</span><span style="color:#75715e">属</span><span style="color:#75715e">性</span>
pthread_attr_destroy(&amp;attr)

<span style="color:#66d9ef">let</span> result_2 = pthread_create(&amp;thread_2, &amp;attr, runForThread_1, encode(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">thread_1</span><span style="color:#e6db74">&#34;</span>))

print(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">result_2 - </span><span style="color:#e6db74">\(</span>result_2<span style="color:#e6db74">)</span><span style="color:#e6db74"> - </span><span style="color:#e6db74">\(</span>String<span style="color:#e6db74">(</span>describing: thread_2<span style="color:#e6db74">)</span><span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>);

<span style="color:#66d9ef">if</span> result_2 <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
    print(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">pthread_create thread_2 error.</span><span style="color:#e6db74">&#34;</span>)
}

<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">O</span><span style="color:#75715e">U</span><span style="color:#75715e">T</span><span style="color:#75715e">P</span><span style="color:#75715e">U</span><span style="color:#75715e">T</span><span style="color:#75715e">:</span>
<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">r</span><span style="color:#75715e">e</span><span style="color:#75715e">s</span><span style="color:#75715e">u</span><span style="color:#75715e">l</span><span style="color:#75715e">t</span><span style="color:#75715e">_</span><span style="color:#75715e">1</span><span style="color:#75715e"> </span><span style="color:#75715e">-</span><span style="color:#75715e"> </span><span style="color:#75715e">0</span><span style="color:#75715e"> </span><span style="color:#75715e">-</span><span style="color:#75715e"> </span><span style="color:#75715e">O</span><span style="color:#75715e">p</span><span style="color:#75715e">t</span><span style="color:#75715e">i</span><span style="color:#75715e">o</span><span style="color:#75715e">n</span><span style="color:#75715e">a</span><span style="color:#75715e">l</span><span style="color:#75715e">(</span><span style="color:#75715e">0</span><span style="color:#75715e">x</span><span style="color:#75715e">0</span><span style="color:#75715e">0</span><span style="color:#75715e">0</span><span style="color:#75715e">0</span><span style="color:#75715e">7</span><span style="color:#75715e">0</span><span style="color:#75715e">0</span><span style="color:#75715e">0</span><span style="color:#75715e">0</span><span style="color:#75715e">2</span><span style="color:#75715e">c</span><span style="color:#75715e">d</span><span style="color:#75715e">8</span><span style="color:#75715e">0</span><span style="color:#75715e">0</span><span style="color:#75715e">0</span><span style="color:#75715e">)</span>
<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">t</span><span style="color:#75715e">h</span><span style="color:#75715e">r</span><span style="color:#75715e">e</span><span style="color:#75715e">a</span><span style="color:#75715e">d</span><span style="color:#75715e">_</span><span style="color:#75715e">1</span><span style="color:#75715e"> </span><span style="color:#75715e">(</span><span style="color:#75715e">0</span><span style="color:#75715e">x</span><span style="color:#75715e">0</span><span style="color:#75715e">0</span><span style="color:#75715e">0</span><span style="color:#75715e">0</span><span style="color:#75715e">7</span><span style="color:#75715e">0</span><span style="color:#75715e">0</span><span style="color:#75715e">0</span><span style="color:#75715e">0</span><span style="color:#75715e">2</span><span style="color:#75715e">c</span><span style="color:#75715e">d</span><span style="color:#75715e">8</span><span style="color:#75715e">0</span><span style="color:#75715e">0</span><span style="color:#75715e">0</span><span style="color:#75715e">)</span><span style="color:#75715e"> </span><span style="color:#75715e">i</span><span style="color:#75715e">s</span><span style="color:#75715e"> </span><span style="color:#75715e">r</span><span style="color:#75715e">u</span><span style="color:#75715e">n</span><span style="color:#75715e">n</span><span style="color:#75715e">i</span><span style="color:#75715e">n</span><span style="color:#75715e">g</span><span style="color:#75715e">.</span>
<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">r</span><span style="color:#75715e">e</span><span style="color:#75715e">s</span><span style="color:#75715e">u</span><span style="color:#75715e">l</span><span style="color:#75715e">t</span><span style="color:#75715e">_</span><span style="color:#75715e">2</span><span style="color:#75715e"> </span><span style="color:#75715e">-</span><span style="color:#75715e"> </span><span style="color:#75715e">2</span><span style="color:#75715e">2</span><span style="color:#75715e"> </span><span style="color:#75715e">-</span><span style="color:#75715e"> </span><span style="color:#75715e">n</span><span style="color:#75715e">i</span><span style="color:#75715e">l</span>
<span style="color:#75715e">//</span><span style="color:#75715e"> </span><span style="color:#75715e">p</span><span style="color:#75715e">t</span><span style="color:#75715e">h</span><span style="color:#75715e">r</span><span style="color:#75715e">e</span><span style="color:#75715e">a</span><span style="color:#75715e">d</span><span style="color:#75715e">_</span><span style="color:#75715e">c</span><span style="color:#75715e">r</span><span style="color:#75715e">e</span><span style="color:#75715e">a</span><span style="color:#75715e">t</span><span style="color:#75715e">e</span><span style="color:#75715e"> </span><span style="color:#75715e">t</span><span style="color:#75715e">h</span><span style="color:#75715e">r</span><span style="color:#75715e">e</span><span style="color:#75715e">a</span><span style="color:#75715e">d</span><span style="color:#75715e">_</span><span style="color:#75715e">2</span><span style="color:#75715e"> </span><span style="color:#75715e">e</span><span style="color:#75715e">r</span><span style="color:#75715e">r</span><span style="color:#75715e">o</span><span style="color:#75715e">r</span><span style="color:#75715e">.</span>
</code></pre></div><h2 id="heading-1">线程执行</h2>
<!-- raw HTML omitted -->
<h2 id="heading-2">线程间同步</h2>
<p>假如我们当前位于某一条线程里，此时又开辟了新的线程去做一些其它操作，此时会是怎么样呢？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">runForThread</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>arg) {
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s (%p) is running.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, arg, pthread_self());

    pthread_t another_thread;

    <span style="color:#66d9ef">if</span> (pthread_create(<span style="color:#f92672">&amp;</span>another_thread, NULL, (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)runForAnotherThread, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">another_thread</span><span style="color:#e6db74">&#34;</span>) <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
        printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">pthread_create thread_1 error.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    }

    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">pthread_create finished.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">runForAnotherThread</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg) {
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s (%p) is running.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, arg, pthread_self());

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">100</span>;
}

pthread_t <span style="color:#66d9ef">thread</span>;
<span style="color:#66d9ef">if</span> (pthread_create(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">thread</span>, NULL, (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)runForThread, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">thread</span><span style="color:#e6db74">&#34;</span>) <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">pthread_create thread error.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// thread (0x700003197000) is running.
</span><span style="color:#75715e"></span><span style="color:#75715e">// pthread_create finished.
</span><span style="color:#75715e"></span><span style="color:#75715e">// another_thread (0x70000321a000) is running.
</span></code></pre></div><p>虽然 <code>thread</code> 线程中的 <code>another_thread</code> 线程得到了执行，但是如何在 <code>thread</code> 线程中得到 <code>another_thread</code> 线程执行的结果呢？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">PTHREAD_JOIN(3)          BSD Library Functions Manual          PTHREAD_JOIN(3)

NAME
     pthread_join -- wait for thread termination

SYNOPSIS
     #include &lt;pthread.h&gt;

     int
     pthread_join(pthread_t thread, void **value_ptr);

DESCRIPTION
     The pthread_join() function suspends execution of the calling thread
     until the target thread terminates, unless the target thread has already
     terminated.

     On return from a successful pthread_join() call with a non-NULL value_ptr
     argument, the value passed to pthread_exit() by the terminating thread is
     stored in the location referenced by value_ptr.  When a pthread_join()
     returns successfully, the target thread has been terminated.  The results
     of multiple simultaneous calls to pthread_join(), specifying the same
     target thread, are undefined.  If the thread calling pthread_join() is
     cancelled, the target thread is not detached.

RETURN VALUES
     If successful,  the pthread_join() function will return zero.  Otherwise,
     an error number will be returned to indicate the error.

ERRORS
     pthread_join() will fail if:

     [EDEADLK]          A deadlock was detected or the value of thread speci-fies specifies
                        fies the calling thread.

     [EINVAL]           The implementation has detected that the value speci-fied specified
                        fied by thread does not refer to a joinable thread.

     [ESRCH]            No thread could be found corresponding to that speci-fied specified
                        fied by the given thread ID, thread.

SEE ALSO
     wait(2), pthread_create(3)

STANDARDS
     pthread_join() conforms to ISO/IEC 9945-1:1996 (``POSIX.1&#39;&#39;).

BSD                              April 4, 1996                             BSD
</code></pre></div><hr>
<p>那如何保证主线程在子线程还没有结束的时候，不执行完呢？首先可以想到的就是让主线程休息一会儿。在 <code>exit(3);</code> 之前加一句 <code>sleep(1);</code> 让主线程休眠一秒钟，这样子线程的程序就有足够的时间执行完。但这样真的好吗？如果子线程的执行时间小于一秒，那么我们的时间就浪费了；而当大于一秒时，这个方法就没用了。这时候就需要另外一个函数，<code>int pthread_join(pthread_t , void * _Nullable * _Nullable)</code>，即 <code>int pthread_join(pthread_t thread, void **retval);</code>，其作用是阻塞当前线程运行，直到参数线程 <code>thread</code> 终止，参数 <code>retval</code> 保存了线程函数的返回值。与 <code>pthread_create</code> 一样，当返回 <code>0</code> 时，参与成功，否则将返回错误码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">#</span><span style="color:#75715e">import &#34;POSIXThreadManager.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#</span><span style="color:#75715e">import &lt;pthread.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">run_for_pthread_join_demo</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> arg) {
    <span style="color:#75715e">// 返回参数
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// return arg;
</span><span style="color:#75715e"></span>    pthread_exit(arg);
}

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">POSIXThreadManager</span>

+ (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">pthread_join_demo</span> {
    <span style="color:#75715e">// 声明 thread_1 &amp; thread_2
</span><span style="color:#75715e"></span>    pthread_t thread_1, thread_2;

    <span style="color:#75715e">// 创建 thread_1
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> result_1 <span style="color:#f92672">=</span> pthread_create(<span style="color:#f92672">&amp;</span>thread_1, NULL, run_for_pthread_join_demo, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">thread_1</span><span style="color:#e6db74">&#34;</span>);

    <span style="color:#75715e">// 打印 thread_1 创建函数返回值 &amp; __opaque 属性的地址
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">result_1 - %d - %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, result_1, <span style="color:#f92672">&amp;</span>thread_1<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__opaque);

    <span style="color:#75715e">// 检查线程是否创建成功
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (result_1 <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">pthread_create thread_1 error.</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#75715e">// 线程创建失败退出码为 1
</span><span style="color:#75715e"></span>        exit(<span style="color:#ae81ff">1</span>);
    }

    <span style="color:#75715e">// 创建 thread_2
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> result_2 <span style="color:#f92672">=</span> pthread_create(<span style="color:#f92672">&amp;</span>thread_2, NULL, run_for_pthread_join_demo, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">thread_2</span><span style="color:#e6db74">&#34;</span>);

    <span style="color:#75715e">// 打印 thread_2 创建函数返回值 &amp; __opaque 属性的地址
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">result_2 - %d - %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, result_2, <span style="color:#f92672">&amp;</span>thread_2<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__opaque);

    <span style="color:#66d9ef">if</span> (result_2 <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">pthread_create thread_2 error.</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#75715e">// 线程创建失败退出码为 1
</span><span style="color:#75715e"></span>        exit(<span style="color:#ae81ff">1</span>);
    }

    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> result;
    <span style="color:#66d9ef">if</span> (pthread_join(thread_1, <span style="color:#f92672">&amp;</span>result) <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">pthread_join thread_1 error.</span><span style="color:#e6db74">&#34;</span>);
    }
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, result);

    <span style="color:#66d9ef">if</span> (pthread_join(thread_2, <span style="color:#f92672">&amp;</span>result) <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">pthread_join thread_2 error.</span><span style="color:#e6db74">&#34;</span>);
    }
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, result);

    <span style="color:#75715e">// 主线程退出码为 3
</span><span style="color:#75715e"></span>    exit(<span style="color:#ae81ff">3</span>);
}

<span style="color:#66d9ef">@end</span>
</code></pre></div><p>这样主线程就能等待子线程全部执行完毕后再接着执行了，而且通过第二个参数也可以使我们在线程间进行数据传输。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// result_1 - 0 - 0x70000c9e5010 // 主线程输出
</span><span style="color:#75715e"></span><span style="color:#75715e">// result_2 - 0 - 0x70000ca68010 // 主线程输出
</span><span style="color:#75715e"></span><span style="color:#75715e">// thread_1 // 主线程拿到了子线程调用函数的返回值并输出
</span><span style="color:#75715e"></span><span style="color:#75715e">// thread_2 // 主线程拿到了子线程调用函数的返回值并输出
</span><span style="color:#75715e"></span><span style="color:#75715e">// Program ended with exit code: 3 // 主线程结束程序
</span></code></pre></div><h2 id="semaphore">信号量（Semaphore）</h2>
<p>信号量的概念很难从字面直接理解，常用的比喻是信号灯：一段马路（即资源）对车辆（即线程）的承载量是有限的，当承载量达到限度时，红灯会亮起阻止进入；当承载量未达到时，绿灯会亮起允许进入。关于互斥锁和信号量的区别，简而言之，互斥锁通常处理多个线程对一个资源的争夺，意味着总是按顺序获取和释放。而信号量则应当用在一个任务到另一个任务的信号，其中的任务要么发送信号要么等待信号。我在 <a href="https://github.com/kingcos/WWDCHelper">WWDCHelper</a> 中也用到了信号量，函数返回的数据需要等待下载任务完成后才可以得到，所以当下载任务完成后发送信号，等待的信号收到后便继续前行。</p>
<p>我们创建两个线程，线程 2 中人为等待 1 秒代表处理任务，任务完成后发送信号，线程 1 中等待信号，等信号发出再执行自己的任务：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">#</span><span style="color:#75715e">import &#34;POSIXThreadManager.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#</span><span style="color:#75715e">import &lt;pthread.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">import &lt;sys</span><span style="color:#75715e">/</span><span style="color:#75715e">semaphore.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 声明信号量
</span><span style="color:#75715e"></span>sem_t <span style="color:#f92672">*</span> semaphore;

<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">run_for_semaphore_demo_1</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> arg) {
    <span style="color:#75715e">// 等待信号
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (sem_wait(semaphore) <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">sem_wait error.</span><span style="color:#e6db74">&#34;</span>);
        exit(<span style="color:#ae81ff">1</span>);
    }

    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Running - %s.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, arg);

    pthread_exit(NULL);
}

<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">run_for_semaphore_demo_2</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> arg) {
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Running - %s.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, arg);

    sleep(<span style="color:#ae81ff">1</span>);
    <span style="color:#75715e">// 发送信号
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (sem_post(semaphore) <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">sem_post error.</span><span style="color:#e6db74">&#34;</span>);
        exit(<span style="color:#ae81ff">1</span>);
    }

    pthread_exit(NULL);
}

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">POSIXThreadManager</span>

+ (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">semaphore_demo</span> {
    <span style="color:#75715e">// sem_init 初始化匿名信号量在 macOS 中已被废弃
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// semaphore = sem_init(&amp;semaphore, 0, 0);
</span><span style="color:#75715e"></span>    semaphore <span style="color:#f92672">=</span> sem_open(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">sem</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);

    pthread_t thread_1, thread_2;
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> result;

    <span style="color:#66d9ef">if</span> (pthread_create(<span style="color:#f92672">&amp;</span>thread_1, NULL, run_for_semaphore_demo_1, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Thread 1</span><span style="color:#e6db74">&#34;</span>) <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">pthread_create thread_1 error.</span><span style="color:#e6db74">&#34;</span>);
        exit(<span style="color:#ae81ff">1</span>);
    }

    <span style="color:#66d9ef">if</span> (pthread_create(<span style="color:#f92672">&amp;</span>thread_2, NULL, run_for_semaphore_demo_2, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Thread 2</span><span style="color:#e6db74">&#34;</span>) <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">pthread_create thread_2 error.</span><span style="color:#e6db74">&#34;</span>);
        exit(<span style="color:#ae81ff">1</span>);
    }

    pthread_join(thread_1, <span style="color:#f92672">&amp;</span>result);
    pthread_join(thread_2, <span style="color:#f92672">&amp;</span>result);
}

<span style="color:#66d9ef">@end</span>
</code></pre></div><h2 id="reference">Reference</h2>
<ul>
<li><a href="https://www.cs.nmsu.edu/~jcook/Tools/pthreads/library.html">NMSU - The Pthreads Library</a></li>
<li><a href="../nullability_in_obj-c/">[译] 在 Objective-C API 中指定可空性 - kingcos</a></li>
<li><a href="https://en.wikipedia.org/wiki/Restrict">Wikipedia - restrict</a></li>
<li><a href="https://stackoverflow.com/questions/34519/what-is-a-semaphore">StackOverflow - What is a semaphore?</a></li>
<li><a href="https://barrgroup.com/Embedded-Systems/How-To/RTOS-Mutex-Semaphore">Michael Barr - Mutexes and Semaphores Demystified</a></li>
<li><a href="https://see.stanford.edu/materials/icsppcs107/23-Concurrency-Examples.pdf">Stanford - Thread and Semaphore Examples</a></li>
<li><a href="https://github.com/kingcos/WWDCHelper">WWDCHelper</a></li>
<li><a href="https://stackoverflow.com/questions/1413785/sem-init-on-os-x">StackOverflow - sem_init on OS X</a></li>
<li><a href="https://github.com/ZewoGraveyard/POSIX">GitHub - ZewoGraveyard/POSIX</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/pthread_create.3.html">pthread_create - iOS Manual Pages</a></li>
<li><a href="https://www.ibm.com/support/knowledgecenter/en/ssw_ibm_i_71/apis/concep17.htm">Thread ID vs. Pthread Handle (pthread_t) - IBM</a></li>
<li><a href="https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/using_imported_c_functions_in_swift">Using Imported C Functions in Swift - Apple</a></li>
</ul>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->

    </div>
    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>
        <div class="pagination__buttons">
          
          
            <span class="button next">
              <a href="/posts/2019/dive_into_mustoverride/">
                <span class="button__text">MustOverride 源码解读</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    

    

    
    
    <div>
      <div id="github-comment">
      </div>

      <script type="text/javascript">
        function getUtterances(isDark) {
          var utterances = document.createElement('script');
          utterances.type = 'text/javascript';
          utterances.async = true;
          utterances.setAttribute('issue-term', "pathname")
          utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
          utterances.setAttribute('label', "comments")
          isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
          utterances.crossorigin = 'anonymous';
          utterances.src = 'https://utteranc.es/client.js';

          return utterances
        }

        var themeToggle = document.querySelector(".theme-toggle")
        themeToggle.addEventListener("click", function () {
          var getTheme = window.localStorage && window.localStorage.getItem("theme")
          var divNode = document.getElementById('github-comment')
          while(divNode.hasChildNodes()) {
            divNode.removeChild(divNode.firstChild);
          }
          
          
          

          
          
          
          
          
          
          document.getElementById('github-comment').appendChild(getUtterances(getTheme !== "dark"))
        })

        var getTheme = window.localStorage && window.localStorage.getItem("theme")
        document.getElementById('github-comment').appendChild(getUtterances(getTheme === "dark"))
      </script>
    </div>
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">All rights reserved by kingcos.me</div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </body>
</html>
