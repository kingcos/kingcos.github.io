<!DOCTYPE html>
<html lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="kingcos" />
	
	
	
	<title>iOS 多线程技术实践之 pthreads（一） ｜ kingcos</title>
	
    
    
    <meta name="description" content="在现代计算机中，操作系统一般都会支持多进程以及多线程技术，使得其可以同时运行多个程序且效率更高。而我们在开发 iOS app 中也时常需要利用到这些特性，以为用户提供更加良好的使用体验。通常来说，一个 iOS app 为一个进程，其中又至少有一个线程，即主线程；前者进程由操作系统创建我们很难干预，而线程则「自由」许多，可以为我们所用。由于多线程技术内容较多，我将把相关内容进行拆分，本文作为该系列第一篇，先从 pthreads 说起。" />
    

    
    
    <meta name="keywords" content="Hugo, theme, zozo" />
    

	
    
    <link rel="shortcut icon" href="https://kingcos.me/images/favicon.png" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/highlight.css" />

    
    
</head>

<script data-ad-client="ca-pub-9925978992661955" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<body>
    <div class="main animate__animated animate__fadeInDown">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/posts/">Archive</a>
            </li>
            
            <li>
                <a href="/tags/">Tags</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>


<link rel="stylesheet" href="https://kingcos.me/scss/main.min.7b6e5090dd63f35c42913c169ca8464a3ba4c70a9de89e9ca3535ce45de13d3d.css" integrity="sha256-e25QkN1j81xCkTwWnKhGSjukxwqd6J6co1Nc5F3hPT0=" media="screen">

<style>
.nav_container {
  height: 1rem;
}
 
table {
    width: 100%;
    table-layout: fixed;
}

 
.markdown code {
    white-space: normal;
    word-wrap: break-word;
    line-height: 1.5em;
    font-size: 0.85em;
    font-weight: bold;
    display: inline-block;
     
}

 
.menu_icon a {
    font-size: 16px;
}

 
body {
    font-family: 'Hiragino Sans GB', 'SFMono', 'Lato', '-apple-system';
    -webkit-font-smoothing: 'antialiased';
}

 
.markdown strong, .markdown b, .markdown em {
    font-weight: bold;
}

.post .post_content p {
     

    line-height: 1.75em;
}

 
.markdown img {
     
    margin: 0 auto;
    display: block;
}

 
.ri-stack-line {
    vertical-align: middle;
}

 
.ri-map-pin-time-line {
    vertical-align: middle;
}

 

 
.markdown .book-hint::before {
    content: none;
}

.markdown .book-hint {
    margin: 1rem 0;
    padding: 0.5rem 1rem 0.5rem 0.75rem;

    border-inline-start: 0.25rem solid #e9ecef;
    border-radius: 0.25rem;

    font-style: normal;
     
}

.book-hint strong {
    background-color: transparent;
}

.markdown .book-hint.info {
    border-left-color:#6bf;
    background-color:rgba(102,187,255,.1);
}

.markdown .book-hint.warning {
    border-left-color:#fd6;
    background-color:rgba(255,221,102,.1);
}

.markdown .book-hint.danger {
    border-left-color:#f66;
    background-color:rgba(255,102,102,.1);
}

</style>

        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            
                <a href="https://kingcos.me/">
                    
                    <img class="kingcos" style="margin-top: -15px; margin-left: -10px;" src="/title.svg" width="150px">
                </a>
            
        </div>
        <div class="description">
            <p class="sub_title">专注、坚持</p>
            <div class="my_socials">
                
                
                <a href="https://github.com/kingcos" title="github" target="_blank"><i class="ri-github-fill"></i></a>
                
                
                
                <a href="https://www.instagram.com/kingcos_v/" title="instagram" target="_blank"><i class="ri-instagram-fill"></i></a>
                
                
                
                <a href="https://twitter.com/kingcos_v" title="twitter" target="_blank"><i class="ri-twitter-fill"></i></a>
                
                
                
                <a href="https://weibo.com/u/1798410923" title="weibo" target="_blank"><i class="ri-weibo-fill"></i></a>
                
                
                
            </div>
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/posts/2019/multithreading_techs_in_ios-1/'>iOS 多线程技术实践之 pthreads（一）</a></h2>
                        <span class="date">2019.12.14</span>
                        <span>by kingcos</span>
                        
                        
                        
                    </div>
                    <div class="post_content markdown"><table>
<thead>
<tr>
<th style="text-align:center">Date</th>
<th style="text-align:center">Notes</th>
<th style="text-align:center">Swift</th>
<th style="text-align:center">Xcode</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2019-03-08</td>
<td style="text-align:center">首次提交</td>
<td style="text-align:center">4.2</td>
<td style="text-align:center">10.1</td>
</tr>
<tr>
<td style="text-align:center">2019-12-14</td>
<td style="text-align:center">内容重整</td>
<td style="text-align:center">5.1</td>
<td style="text-align:center">10.3</td>
</tr>
</tbody>
</table>
<p><img src="/img/2019/multithreading_techs_in_ios-1/0.png" alt="0"></p>
<h2 id="preface">Preface</h2>
<p>在现代计算机中，操作系统一般都会支持多进程（Process）以及多线程（Thread）技术，使得其可以同时运行多个程序且效率更高。而我们在开发 iOS app 中也时常需要利用到这些特性，以为用户提供更加良好的使用体验。通常来说，一个 iOS app 为一个进程，其中又至少有一个线程，即主线程；前者进程由操作系统创建我们很难干预，而线程则「自由」许多，可以为我们所用。由于多线程技术内容较多，我将把相关内容进行拆分，本文作为该系列第一篇，先从 pthreads 说起。</p>
<h2 id="what">What</h2>
<blockquote>
<p>POSIX Threads, usually referred to as pthreads, is an execution model that exists independently from a language, as well as a parallel execution model. It allows a program to control multiple different flows of work that overlap in time. Each flow of work is referred to as a thread, and creation and control over these flows is achieved by making calls to the POSIX Threads API.</p>
<p>&ndash; POSIX Threads, Wikipedia</p>
<p>译：</p>
<p>POSIX（Portable Operating System Interface of UNIX，可移植操作系统接口）线程，即 pthreads，是一种不依赖于语言的执行模型，也称作并行（Parallel）执行模型。其允许一个程序控制多个时间重叠的不同工作流。每个工作流即为一个线程，通过调用 POSIX 线程 API 创建并控制这些流。</p>
<p>&ndash; POSIX 线程，维基百科</p>
</blockquote>
<p>如上所述，pthreads 即 POSIX Threads，是一套跨平台的多线程 API，由 C 语言编写。在 Xcode 中，使用 <code>#import &lt;pthread.h&gt;</code> 即可引入 pthreads 相关的 API。但正是由于纯 C 的 API，使用起来不够友好，也需要手动管理线程的整个生命周期。</p>
<h2 id="线程创建">线程创建</h2>
<p>想要开辟一条新的线程来执行任务，我们首先要知道如何创建线程。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">PTHREAD_CREATE(3)        BSD Library Functions Manual        PTHREAD_CREATE(3)

NAME
     pthread_create -- create a new thread

SYNOPSIS
     #include &lt;pthread.h&gt;

     int
     pthread_create(pthread_t *restrict thread,
         const pthread_attr_t *restrict attr, void *(*start_routine)(void *),
         void *restrict arg);

DESCRIPTION
     The pthread_create() function is used to create a new thread, with
     attributes specified by attr, within a process.  If attr is NULL, the
     default attributes are used.  If the attributes specified by attr are
     modified later, the thread&#39;s attributes are not affected.  Upon success-ful successful
     ful completion, pthread_create() will store the ID of the created thread
     in the location specified by thread.

     Upon its creation, the thread executes start_routine, with arg as its
     sole argument.  If start_routine returns, the effect is as if there was
     an implicit call to pthread_exit(), using the return value of
     start_routine as the exit status.  Note that the thread in which main()
     was originally invoked differs from this.  When it returns from main(),
     the effect is as if there was an implicit call to exit(), using the
     return value of main() as the exit status.

     The signal state of the new thread is initialized as:

           oo   The signal mask is inherited from the creating thread.

           oo   The set of signals pending for the new thread is empty.

RETURN VALUES
     If successful,  the pthread_create() function will return zero.  Other-wise, Otherwise,
     wise, an error number will be returned to indicate the error.

ERRORS
     pthread_create() will fail if:

     [EAGAIN]           The system lacked the necessary resources to create
                        another thread, or the system-imposed limit on the
                        total number of threads in a process
                        [PTHREAD_THREADS_MAX] would be exceeded.

     [EINVAL]           The value specified by attr is invalid.

SEE ALSO
     fork(2), pthread_cleanup_pop(3), pthread_cleanup_push(3),
     pthread_exit(3), pthread_join(3)

STANDARDS
     pthread_create() conforms to ISO/IEC 9945-1:1996 (``POSIX.1&#39;&#39;).

BSD                              April 4, 1996                             BSD
</code></pre></div><p>pthreads 通过 <code>pthread_create</code> 函数来创建新的线程：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// pthreads.h
</span><span class="c1"></span>
<span class="cm">/* &lt;rdar://problem/25944576&gt; */</span>
<span class="cp">#define _PTHREAD_SWIFT_IMPORTER_NULLABILITY_COMPAT \
</span><span class="cp">	defined(SWIFT_CLASS_EXTRA) &amp;&amp; (!defined(SWIFT_SDK_OVERLAY_PTHREAD_EPOCH) || (SWIFT_SDK_OVERLAY_PTHREAD_EPOCH &lt; 1))
</span><span class="cp"></span>
<span class="n">__API_AVAILABLE</span><span class="p">(</span><span class="n">macos</span><span class="p">(</span><span class="mf">10.4</span><span class="p">),</span> <span class="n">ios</span><span class="p">(</span><span class="mf">2.0</span><span class="p">))</span>
<span class="cp">#if !_PTHREAD_SWIFT_IMPORTER_NULLABILITY_COMPAT
</span><span class="cp"></span><span class="kt">int</span> <span class="n">pthread_create</span><span class="p">(</span><span class="n">pthread_t</span> <span class="n">_Nullable</span> <span class="o">*</span> <span class="n">_Nonnull</span> <span class="n">__restrict</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">pthread_attr_t</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="n">__restrict</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="p">(</span><span class="o">*</span> <span class="n">_Nonnull</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">_Nullable</span><span class="p">),</span>
		<span class="kt">void</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="n">__restrict</span><span class="p">);</span>
<span class="cp">#else
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="n">pthread_t</span> <span class="o">*</span> <span class="n">__restrict</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">pthread_attr_t</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="n">__restrict</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span> <span class="n">_Nonnull</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="n">__restrict</span><span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// _PTHREAD_SWIFT_IMPORTER_NULLABILITY_COMPAT
</span></code></pre></div><blockquote>
<p>⚠️ 注意：</p>
<p>可以注意到的是，<code>pthread.h</code> 中关于 <code>pthread_create</code> 函数的声明使用了 <code>_PTHREAD_SWIFT_IMPORTER_NULLABILITY_COMPAT</code> 宏进行了区分。关于该宏以及其内部判断条件其实没有太多资料可以参考，但大体上可以理解是为了兼容 Swift 中的可选类型，但两种声明本质上并无其他区别。</p>
</blockquote>
<p>以 Obj-C 中实际使用的 <code>pthread_create(pthread_t _Nullable *restrict _Nonnull, const pthread_attr_t *restrict _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void *restrict _Nullable)</code> 声明为例，其中 <code>_Nullable</code> 和 <code>_Nonnull</code> 是 Obj-C 桥接 Swift 可选（Optional）类型时是否隐式或显式可选的标志；<code>__restrict</code> 是 C99 标准引入的关键字，类似于 <code>restrict</code>，可以用在指针声明处，使得编译器将只能通过该指针本身修改指向的内容，便于其优化。去掉这些不影响函数本身功能的标志，补全参数名即 <code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)</code>。</p>
<h3 id="pthread_t">pthread_t</h3>
<p><code>pthread_create</code> 中的第一个参数是 <code>pthread_t *thread</code>，即指向 <code>pthread_t</code> 的指针。<code>pthread_t</code> 的本质是 <code>_opaque_pthread_t</code> 结构体，这里的 <code>opaque</code>（不透明）意味着外界通常无需关心其内部实现细节：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// sys/_pthread/_pthread_t.h
</span><span class="c1"></span>
<span class="k">typedef</span> <span class="n">__darwin_pthread_t</span> <span class="n">pthread_t</span><span class="p">;</span>

<span class="c1">// sys/_pthread/_pthread_types.h
</span><span class="c1"></span>
<span class="k">struct</span> <span class="n">_opaque_pthread_t</span> <span class="p">{</span>
	<span class="kt">long</span> <span class="n">__sig</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">__darwin_pthread_handler_rec</span>  <span class="o">*</span><span class="n">__cleanup_stack</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">__opaque</span><span class="p">[</span><span class="n">__PTHREAD_SIZE__</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_opaque_pthread_t</span> <span class="o">*</span><span class="n">__darwin_pthread_t</span><span class="p">;</span>
</code></pre></div><p>我们可以将这个参数理解为线程的引用即可，当 <code>pthread_create</code> 成功创建好线程，传入的 <code>pthread_t</code> 地址即为一个新的线程。</p>
<h3 id="pthread_attr_t">pthread_attr_t</h3>
<p><code>pthread_create</code> 中的第二个参数是 <code>const pthread_attr_t *attr</code>，即指向 <code>pthread_attr_t</code> 的指针。 <code>pthread_attr_t</code> 的本质是 <code>_opaque_pthread_attr_t</code> 结构体，也是一个不透明类型：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// sys/_pthread/_pthread_attr_t.h
</span><span class="c1"></span>
<span class="k">typedef</span> <span class="n">__darwin_pthread_attr_t</span> <span class="n">pthread_attr_t</span><span class="p">;</span>

<span class="c1">// sys/_pthread/_pthread_types.h
</span><span class="c1"></span>
<span class="k">struct</span> <span class="n">_opaque_pthread_attr_t</span> <span class="p">{</span>
	<span class="kt">long</span> <span class="n">__sig</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">__opaque</span><span class="p">[</span><span class="n">__PTHREAD_ATTR_SIZE__</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_opaque_pthread_attr_t</span> <span class="n">__darwin_pthread_attr_t</span><span class="p">;</span>
</code></pre></div><p><code>pthread_attr_t</code> 指的是线程属性，我们可以使用 <code>pthread_attr_init</code> 函数来初始化，以及使用 <code>pthread_attr_set</code> 开头的函数来进行设置：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 声明 pthread_attr_t
</span><span class="c1"></span><span class="n">pthread_attr_t</span> <span class="n">attr</span><span class="p">;</span>

<span class="c1">// 初始化
</span><span class="c1"></span><span class="n">pthread_attr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>

<span class="c1">// 设置
</span><span class="c1"></span><span class="n">pthread_attr_setscope</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>                     <span class="c1">// 作用域
</span><span class="c1"></span><span class="n">pthread_attr_setstack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">_Nonnull</span><span class="p">,</span> <span class="n">size_t</span><span class="p">);</span> <span class="c1">// 栈
</span><span class="c1"></span><span class="n">pthread_attr_setguardsize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">size_t</span><span class="p">);</span>              <span class="c1">// 栈末尾的警戒缓冲区大小
</span><span class="c1"></span><span class="n">pthread_attr_setstackaddr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">_Nonnull</span><span class="p">);</span>     <span class="c1">// 栈地址
</span><span class="c1"></span><span class="n">pthread_attr_setstacksize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">size_t</span><span class="p">);</span>              <span class="c1">// 栈大小
</span><span class="c1"></span><span class="n">pthread_attr_setschedparam</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">_Nonnull</span><span class="p">);</span> <span class="c1">// 调度参数
</span><span class="c1"></span><span class="n">pthread_attr_setdetachstate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>               <span class="c1">// 分离状态
</span><span class="c1"></span><span class="n">pthread_attr_setschedpolicy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>               <span class="c1">// 调度策略
</span><span class="c1"></span><span class="n">pthread_attr_setinheritsched</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>              <span class="c1">// 继承
</span><span class="c1"></span><span class="n">pthread_attr_set_qos_class_np</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">qos_class_t</span> <span class="n">__qos_class</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__relative_priority</span><span class="p">);</span> <span class="c1">// 分配 QoS 类
</span><span class="c1"></span>
<span class="c1">// 创建线程时将 attr 地址传入
</span><span class="c1">// pthread_create(&amp;thread, &amp;attr, ...);
</span><span class="c1"></span>
<span class="c1">// 使用完毕销毁
</span><span class="c1"></span><span class="n">pthread_attr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
</code></pre></div><p>如果我们不太会去自定义这里的属性，可以将 <code>pthread_create</code> 中的该参数传 <code>NULL</code> 即可使用默认属性来创建线程。</p>
<h3 id="pthread_create">pthread_create</h3>
<p><code>pthread_create</code> 中的最后两个参数是 <code>void *(*start_routine) (void *)</code> 和 <code>void *arg</code>。<code>start_routine()</code> 是新线程运行时所执行的函数，<code>arg</code> 是传入 <code>start_routine()</code> 的唯一参数。当 <code>start_routine()</code> 执行终止或者线程被明确杀死，线程也将会终止；<code>pthread_create</code> 的返回值是 <code>int</code> 类型，当返回 <code>0</code> 时为成功，否则将返回错误码：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="cp">#import &lt;pthread.h&gt;
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">runForThread_1</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// pthread_self()：返回当前线程 pthread_t
</span><span class="c1"></span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s (%p) is running.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>
    <span class="c1">// 退出线程
</span><span class="c1"></span>    <span class="n">pthread_exit</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">runForThread_2</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s (%p) is running.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>
    <span class="c1">// 函数返回则自动退出线程
</span><span class="c1"></span><span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// 声明两个线程 thread_1 &amp; thread_2
</span><span class="c1"></span>    <span class="n">pthread_t</span> <span class="n">thread_1</span><span class="p">,</span> <span class="n">thread_2</span><span class="p">;</span>

    <span class="c1">// 使用默认属性创建 thread_1
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">result_1</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread_1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">runForThread_1</span><span class="p">,</span> <span class="s">&#34;thread_1&#34;</span><span class="p">);</span>

    <span class="c1">// 打印 thread_1 创建函数返回值 &amp; 线程地址
</span><span class="c1"></span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;result_1 - %d - %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">result_1</span><span class="p">,</span> <span class="n">thread_1</span><span class="p">);</span>

    <span class="c1">// 检查线程是否创建成功
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">result_1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;pthread_create thread_1 error.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 声明线程属性 attr
</span><span class="c1"></span>    <span class="n">pthread_attr_t</span> <span class="n">attr</span><span class="p">;</span>
    <span class="c1">// 初始化线程属性
</span><span class="c1"></span>    <span class="n">pthread_attr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
    <span class="c1">// 销毁线程属性
</span><span class="c1"></span>    <span class="n">pthread_attr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>

    <span class="c1">// 使用 attr 创建 thread_2
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">result_2</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread_2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">runForThread_2</span><span class="p">,</span> <span class="s">&#34;thread_2&#34;</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;result_2 - %d - %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">result_2</span><span class="p">,</span> <span class="n">thread_2</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">result_2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;pthread_create thread_2 error.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 人为休息 1 秒
</span><span class="c1"></span>    <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// result_1 - 0 - 0x70000799e000
</span><span class="c1">// result_2 - 22 - 0x0
</span><span class="c1">// pthread_create thread_2 error.
</span><span class="c1">// thread_1 (0x70000799e000) is running.
</span></code></pre></div><p>这里我们使用默认属性 <code>NULL</code> 即可创建通用化的线程；而如果使用已经销毁的线程属性 <code>pthread_attr_t</code> 来创建线程时，就会出现错误从而无法成功创建线程。</p>
<p>需要注意的一点是，<code>pthread_create</code> 函数的第四个参数声明的类型是 <code>void *</code>，即可以指向任意类型的指针。但当我们直接传入 <code>int</code> 等类型的变量时，虽然执行没有问题，但编译器将总是有类似这样的警告 <code>Incompatible integer to pointer conversion passing 'int' to parameter of type 'void *'</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="cp">#import &lt;pthread.h&gt;
</span><span class="cp"></span>
<span class="cp">#define N 5
</span><span class="cp"></span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// WARNING: Format specifies type &#39;int&#39; but the argument has type &#39;void *&#39;
</span><span class="c1"></span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;arg = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">pthread_t</span> <span class="n">threads</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// WARNING: Incompatible integer to pointer conversion passing &#39;int&#39; to parameter of type &#39;void *&#39;
</span><span class="c1"></span>         <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thread_func</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 人为休息 1 秒
</span><span class="c1"></span>    <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// arg = 1
</span><span class="c1">// arg = 2
</span><span class="c1">// arg = 3
</span><span class="c1">// arg = 4
</span><span class="c1">// arg = 0
</span></code></pre></div><p>首先可以想到的是强制类型转换，即 <code>(void *)i</code> 即可将 <code>int</code> 类型的 <code>i</code> 转换为 <code>void *</code> 来满足需要。但由于 <code>int</code> 类型只占用 4 个字节，小于 <code>void *</code> 指针占用的 8 个字节，因此这里又有了新的警告 <code>Cast to 'void *' from smaller integer type 'int'</code>；另外一个可以想到的方法是将变量的地址即 <code>&amp;i</code> 传入，这正好符合此处对于类型的要求，因此警告可以消除，线程函数内部使用时也需要将参数进行取值操作：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="cp">#import &lt;pthread.h&gt;
</span><span class="cp"></span>
<span class="cp">#define N 5
</span><span class="cp"></span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;arg = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">pthread_t</span> <span class="n">threads</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thread_func</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 人为休息 1 秒
</span><span class="c1"></span>    <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// arg = 3
</span><span class="c1">// arg = 0
</span><span class="c1">// arg = 4
</span><span class="c1">// arg = 0
</span><span class="c1">// arg = 4
</span></code></pre></div><p>但我们发现最后的输出似乎有些重复，这是因为传入地址是有隐患的，按地址传入会使得外界更改变量值时，线程内部使用的参数也会被同时改变。</p>
<p>那么如何仍然使用按值传递又可以避免警告呢？其实只需要将 <code>int</code> 类型先转为 8 个字节长度的 <code>long</code> 或 <code>intptr_t</code> 类型，再转为 <code>void *</code> 即可：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="cp">#import &lt;pthread.h&gt;
</span><span class="cp"></span>
<span class="cp">#define N 5
</span><span class="cp"></span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;arg = %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="n">intptr_t</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">pthread_t</span> <span class="n">threads</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thread_func</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">intptr_t</span><span class="p">)</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 人为休息 1 秒
</span><span class="c1"></span>    <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// arg = 0
</span><span class="c1">// arg = 3
</span><span class="c1">// arg = 1
</span><span class="c1">// arg = 2
</span><span class="c1">// arg = 4
</span></code></pre></div><h3 id="pthread_create-in-swift">pthread_create in Swift</h3>
<p>如上文所述，pthreads API 在 Swift 中也可以使用。我们可以在 Swift 中 <code>pthread_create</code> 函数声明处发现，其四个参数均与 <code>Unsafe...Pointer</code> 相关的类型有关，这样的命名是因为 Swift 中的指针语法也被抽象为类型而非 <code>*</code>，并通过 <code>Unsafe</code> 告知开发者其中可能存在隐患。而这里由于 <code>pthread_create</code> 本质是一个 C 语言函数，但 Swift 又无法直接与 C/C++ 进行混编，因此需要做一些转换：</p>
<table>
<thead>
<tr>
<th style="text-align:center">C 语法</th>
<th style="text-align:center">Swift 语法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>const Type *</code></td>
<td style="text-align:center"><code>UnsafePointer&lt;Type&gt;</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Type *</code></td>
<td style="text-align:center"><code>UnsafeMutablePointer&lt;Type&gt;</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Type * const *</code></td>
<td style="text-align:center"><code>UnsafePointer&lt;Type&gt;</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Type * __strong *</code></td>
<td style="text-align:center"><code>UnsafeMutablePointer&lt;Type&gt;</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Type **</code></td>
<td style="text-align:center"><code>AutoreleasingUnsafeMutablePointer&lt;Type&gt;</code></td>
</tr>
<tr>
<td style="text-align:center"><code>const void *</code></td>
<td style="text-align:center"><code>UnsafeRawPointer</code></td>
</tr>
<tr>
<td style="text-align:center"><code>void *</code></td>
<td style="text-align:center"><code>UnsafeMutableRawPointer</code></td>
</tr>
</tbody>
</table>
<p><code>pthread_create</code> 函数中，第一个参数 <code>pthread_t *thread</code> 在 Swift 中将被表示为 <code>UnsafeMutablePointer&lt;pthread_t&gt;</code>，第二个参数 <code>const pthread_attr_t *attr</code> 将被表示为 <code>UnsafePointer&lt;pthread_attr_t&gt;</code>，第三个参数 <code>void *(*start_routine) (void *)</code> 被表示为 <code>(UnsafeMutableRawPointer) -&gt; (UnsafeMutableRawPointer)</code>，以及最后一个参数 <code>void *arg</code> 将被表示为 <code>UnsafeMutableRawPointer</code>，这些参数再加上可空性对应的可选类型，最终形成了 Swift 中 <code>pthread_create</code> 函数的 API：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="p">@</span><span class="n">available</span><span class="p">(</span><span class="n">iOS</span> <span class="mf">2.0</span><span class="p">,</span> <span class="o">*</span><span class="p">)</span>
<span class="kd">public</span> <span class="kd">func</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="kc">_</span><span class="p">:</span> <span class="nb">UnsafeMutablePointer</span><span class="p">&lt;</span><span class="n">pthread_t</span><span class="p">?</span><span class="o">&gt;!</span><span class="p">,</span> <span class="kc">_</span><span class="p">:</span> <span class="nb">UnsafePointer</span><span class="p">&lt;</span><span class="n">pthread_attr_t</span><span class="p">&gt;?,</span> <span class="kc">_</span><span class="p">:</span> <span class="p">@</span><span class="n">convention</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">(</span><span class="n">UnsafeMutableRawPointer</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">UnsafeMutableRawPointer</span><span class="p">?,</span> <span class="kc">_</span><span class="p">:</span> <span class="n">UnsafeMutableRawPointer</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Int32</span>
<span class="c1">// _PTHREAD_SWIFT_IMPORTER_NULLABILITY_COMPAT</span>
</code></pre></div><p>前两个参数我们在 Swift 中仍然可以使用 <code>&amp;</code> 来按地址传递，那么后两个参数 C 语言函数和参数该如何传递呢？</p>
<p>为了兼容 Swift 中的各种类型，我们可以将值封装在一个支持泛型的 <code>Box</code> 类型中；并额外定义两个方法，一是 <code>encode</code>：将 Swift 中的值封装在 <code>UnsafeMutableRawPointer</code> 指针类型中，二是 <code>decode</code>：将 <code>UnsafeMutableRawPointer</code> 指针类型中真正的值取出。这两个方法需要成对使用：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="nc">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">value</span><span class="p">:</span> <span class="n">T</span>

    <span class="kd">init</span><span class="p">(</span><span class="kc">_</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">value</span> <span class="p">=</span> <span class="n">value</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kd">func</span> <span class="nf">decode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">memory</span><span class="p">:</span> <span class="n">UnsafeMutableRawPointer</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">unmanaged</span> <span class="p">=</span> <span class="nb">Unmanaged</span><span class="p">&lt;</span><span class="n">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span><span class="p">.</span><span class="n">fromOpaque</span><span class="p">(</span><span class="n">memory</span><span class="p">)</span>
    <span class="k">defer</span> <span class="p">{</span> <span class="n">unmanaged</span><span class="p">.</span><span class="n">release</span><span class="p">()</span> <span class="p">}</span> <span class="c1">// 延迟释放</span>
    <span class="k">return</span> <span class="n">unmanaged</span><span class="p">.</span><span class="n">takeUnretainedValue</span><span class="p">().</span><span class="n">value</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kd">func</span> <span class="nf">encode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">UnsafeMutableRawPointer</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Unmanaged</span><span class="p">.</span><span class="n">passRetained</span><span class="p">(</span><span class="n">Box</span><span class="p">(</span><span class="n">t</span><span class="p">)).</span><span class="n">toOpaque</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>接下来的使用就十分类似 Obj-C 了：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// 需声明 Swift 类外</span>
<span class="kd">func</span> <span class="nf">runForThread_1</span><span class="p">(</span><span class="kc">_</span> <span class="n">arg</span><span class="p">:</span> <span class="n">UnsafeMutableRawPointer</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">UnsafeMutableRawPointer</span><span class="p">?</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">decode</span><span class="si">(</span><span class="n">arg</span><span class="si">)</span> <span class="k">as</span> <span class="nb">String</span><span class="si">)</span><span class="s"> (</span><span class="si">\(</span><span class="n">pthread_self</span><span class="si">())</span><span class="s">) is running.&#34;</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 声明两个线程 thread_1 &amp; thread_2</span>
<span class="kd">var</span> <span class="nv">thread_1</span><span class="p">,</span> <span class="n">thread_2</span><span class="p">:</span> <span class="n">pthread_t</span><span class="p">!</span>

<span class="c1">// 创建 thread_1</span>
<span class="kd">let</span> <span class="nv">result_1</span> <span class="p">=</span> <span class="n">pthread_create</span><span class="p">(&amp;</span><span class="n">thread_1</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">runForThread_1</span><span class="p">,</span> <span class="n">encode</span><span class="p">(</span><span class="s">&#34;thread_1&#34;</span><span class="p">))</span>

<span class="bp">print</span><span class="p">(</span><span class="s">&#34;result_1 - </span><span class="si">\(</span><span class="n">result_1</span><span class="si">)</span><span class="s"> - </span><span class="si">\(</span><span class="nb">String</span><span class="si">(</span><span class="n">describing</span><span class="p">:</span> <span class="n">thread_1</span><span class="si">))</span><span class="s">&#34;</span><span class="p">);</span>

<span class="c1">// 检查线程是否创建成功</span>
<span class="k">if</span> <span class="n">result_1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;pthread_create thread_1 error.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 声明线程属性 attr，注意这里需要使用 pthread_attr_t 构造</span>
<span class="kd">var</span> <span class="nv">attr</span> <span class="p">=</span> <span class="n">pthread_attr_t</span><span class="p">()</span>
<span class="c1">// 初始化线程属性</span>
<span class="n">pthread_attr_init</span><span class="p">(&amp;</span><span class="n">attr</span><span class="p">)</span>
<span class="c1">// 销毁线程属性</span>
<span class="n">pthread_attr_destroy</span><span class="p">(&amp;</span><span class="n">attr</span><span class="p">)</span>

<span class="kd">let</span> <span class="nv">result_2</span> <span class="p">=</span> <span class="n">pthread_create</span><span class="p">(&amp;</span><span class="n">thread_2</span><span class="p">,</span> <span class="p">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">runForThread_1</span><span class="p">,</span> <span class="n">encode</span><span class="p">(</span><span class="s">&#34;thread_1&#34;</span><span class="p">))</span>

<span class="bp">print</span><span class="p">(</span><span class="s">&#34;result_2 - </span><span class="si">\(</span><span class="n">result_2</span><span class="si">)</span><span class="s"> - </span><span class="si">\(</span><span class="nb">String</span><span class="si">(</span><span class="n">describing</span><span class="p">:</span> <span class="n">thread_2</span><span class="si">))</span><span class="s">&#34;</span><span class="p">);</span>

<span class="k">if</span> <span class="n">result_2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;pthread_create thread_2 error.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 人为休息 1 秒</span>
<span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">// OUTPUT:</span>
<span class="c1">// result_1 - 0 - Optional(0x0000700002cd8000)</span>
<span class="c1">// thread_1 (0x0000700002cd8000) is running.</span>
<span class="c1">// result_2 - 22 - nil</span>
<span class="c1">// pthread_create thread_2 error.</span>
</code></pre></div><h2 id="线程执行">线程执行</h2>
<p>在「线程创建」一节中，我们可以发现 <code>pthread_create</code> 函数不仅创建了新的线程，其也会执行线程函数，而不像某些 API 的创建与执行是分开的。</p>
<p>其实当 <code>pthread_create</code> 函数返回 <code>0</code> 时，它只能保证线程被成功创建，但并不能保证线程可以得到立即执行。只有当新的线程获得了 CPU 的时间片（Timeslice），其才可以得到执行。而是否能够优先获得时间片，则取决于线程的优先级。线程默认属性的调度策略是 <code>SCHED_OTHER</code>，该策略下没有优先级选择，因此我们可以通过 <code>pthread_attr_setschedpolicy</code> 更改调度策略：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// pthread/pthread_impl.h
</span><span class="c1"></span>
<span class="cm">/*
</span><span class="cm"> * POSIX scheduling policies
</span><span class="cm"> */</span>
<span class="cp">#define SCHED_OTHER                1
</span><span class="cp">#define SCHED_FIFO                 4
</span><span class="cp">#define SCHED_RR                   2
</span><span class="cp"></span>
<span class="c1">// main.m
</span><span class="c1"></span>
<span class="n">pthread_attr_setschedpolicy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">SCHED_RR</span><span class="p">);</span>
</code></pre></div><h2 id="线程同步">线程同步</h2>
<h3 id="pthread_join">pthread_join</h3>
<p>在上面代码示例中的 <code>main</code> 函数中，都在末尾会有这么一句 <code>sleep(1)</code>，作用是让当前线程休息 1 秒，这是为什么呢？我们可以尝试注释掉这一行 <code>sleep()</code> 函数的调用再运行一次：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="cp">#import &lt;pthread.h&gt;
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">runForThread</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s (%p) is running.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// 输出主线程信息
</span><span class="c1"></span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;(%p) is running.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>

    <span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="kr">thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">runForThread</span><span class="p">,</span> <span class="s">&#34;thread&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;pthread_create thread error.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// sleep(1);
</span><span class="c1"></span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// (0x1000d2dc0) is running.
</span></code></pre></div><p>此时将只有主线程的输出，而新创建的子线程 <code>thread</code> 却没有输出。这是因为主线程执行结束即程序结束， <code>thread</code> 子线程根本来不及去执行。所以 <code>sleep(1)</code> 目的是人为将主线程休眠 1 秒，等待子线程去执行，但这样硬核去休眠固定的时间并不是合理的操作。其实 pthreads 为我们提供了 <code>pthread_join</code> API 来阻塞当前线程，等待目标线程执行完毕后再继续执行当前线程：</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">PTHREAD_JOIN(3)          BSD Library Functions Manual          PTHREAD_JOIN(3)

NAME
     pthread_join -- wait for thread termination

SYNOPSIS
     #include &lt;pthread.h&gt;

     int
     pthread_join(pthread_t thread, void **value_ptr);

DESCRIPTION
     The pthread_join() function suspends execution of the calling thread
     until the target thread terminates, unless the target thread has already
     terminated.

     On return from a successful pthread_join() call with a non-NULL value_ptr
     argument, the value passed to pthread_exit() by the terminating thread is
     stored in the location referenced by value_ptr.  When a pthread_join()
     returns successfully, the target thread has been terminated.  The results
     of multiple simultaneous calls to pthread_join(), specifying the same
     target thread, are undefined.  If the thread calling pthread_join() is
     cancelled, the target thread is not detached.

RETURN VALUES
     If successful,  the pthread_join() function will return zero.  Otherwise,
     an error number will be returned to indicate the error.

ERRORS
     pthread_join() will fail if:

     [EDEADLK]          A deadlock was detected or the value of thread speci-fies specifies
                        fies the calling thread.

     [EINVAL]           The implementation has detected that the value speci-fied specified
                        fied by thread does not refer to a joinable thread.

     [ESRCH]            No thread could be found corresponding to that speci-fied specified
                        fied by the given thread ID, thread.

SEE ALSO
     wait(2), pthread_create(3)

STANDARDS
     pthread_join() conforms to ISO/IEC 9945-1:1996 (``POSIX.1&#39;&#39;).

BSD                              April 4, 1996                             BSD
</code></pre></div><p><code>pthread_join</code> 函数在 Obj-C 下的声明如下，其中，第一个参数即等待的目标线程；第二个参数保存了线程函数的返回值；返回值是 <code>int</code> 类型，当返回 <code>0</code> 时为成功，否则将返回错误码：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// pthread.h
</span><span class="c1"></span>
<span class="n">__API_AVAILABLE</span><span class="p">(</span><span class="n">macos</span><span class="p">(</span><span class="mf">10.4</span><span class="p">),</span> <span class="n">ios</span><span class="p">(</span><span class="mf">2.0</span><span class="p">))</span>
<span class="kt">int</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">pthread_t</span> <span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="o">*</span> <span class="n">_Nullable</span><span class="p">)</span>
		<span class="n">__DARWIN_ALIAS_C</span><span class="p">(</span><span class="n">pthread_join</span><span class="p">);</span>
</code></pre></div><p>我们尝试使用 <code>pthread_join</code> 改写上面的代码示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="cp">#import &lt;pthread.h&gt;
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">runForThread</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s (%p) is running.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;(%p) is running.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>

    <span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="kr">thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">runForThread</span><span class="p">,</span> <span class="s">&#34;thread&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;pthread_create thread error.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">pthread_join</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;main thread exit.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// (0x1000d2dc0) is running.
</span><span class="c1">// thread (0x70000289c000) is running.
</span><span class="c1">// main thread exit.
</span></code></pre></div><p>这次主线程将一直等待 <code>thread</code> 子线程执行结束后才继续执行，这种两个或多个线程协作执行，可以称之为线程同步。当然，<code>pthread_join</code> 只是线程同步的一种方式。</p>
<p><code>pthread_join</code> 中仍需注意的一点是，其第二个参数类型是 <code>void **</code>，因此传入的应当是 <code>void *</code> 变量的地址：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="cp">#import &lt;pthread.h&gt;
</span><span class="cp"></span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">runForThread</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s (%p) is running.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>

    <span class="c1">// 使用 malloc 分配内存
</span><span class="c1"></span>    <span class="kt">double</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
    <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>

    <span class="c1">// 将结果作为线程退出函数的参数，或直接返回结果
</span><span class="c1"></span>    <span class="c1">// pthread_exit((void *)result);
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;(%p) is running.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pthread_self</span><span class="p">());</span>

    <span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="kr">thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">runForThread</span><span class="p">,</span> <span class="s">&#34;thread&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;pthread_create thread error.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;thread result - %lf</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span><span class="n">result</span><span class="p">);</span>

    <span class="c1">// 使用 free 释放内存
</span><span class="c1"></span>    <span class="n">free</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;main thread exit.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// (0x1000d2dc0) is running.
</span><span class="c1">// thread (0x70000537e000) is running.
</span><span class="c1">// thread result - 3.140000
</span><span class="c1">// main thread exit.
</span></code></pre></div><p>Swift 下的 <code>pthread_join</code> 用法基本一致：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">runForThread</span><span class="p">(</span><span class="kc">_</span> <span class="n">arg</span><span class="p">:</span> <span class="n">UnsafeMutableRawPointer</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">UnsafeMutableRawPointer</span><span class="p">?</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">decode</span><span class="si">(</span><span class="n">arg</span><span class="si">)</span> <span class="k">as</span> <span class="nb">String</span><span class="si">)</span><span class="s"> (</span><span class="si">\(</span><span class="n">pthread_self</span><span class="si">())</span><span class="s">) is running.&#34;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">encode</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="s">&#34;(</span><span class="si">\(</span><span class="n">pthread_self</span><span class="si">())</span><span class="s">) is running.&#34;</span><span class="p">)</span>

<span class="kd">var</span> <span class="nv">thread</span><span class="p">:</span> <span class="n">pthread_t</span><span class="p">!</span>

<span class="k">if</span> <span class="n">pthread_create</span><span class="p">(&amp;</span><span class="n">thread</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">runForThread</span><span class="p">,</span> <span class="n">encode</span><span class="p">(</span><span class="s">&#34;thread&#34;</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;pthread_create thread error.&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">res</span><span class="p">:</span> <span class="n">UnsafeMutableRawPointer</span><span class="p">!</span>
<span class="n">pthread_join</span><span class="p">(</span><span class="n">thread</span><span class="p">,</span> <span class="p">&amp;</span><span class="n">res</span><span class="p">)</span>

<span class="bp">print</span><span class="p">(</span><span class="s">&#34;res - </span><span class="si">\(</span><span class="n">decode</span><span class="si">(</span><span class="n">res</span><span class="si">)</span> <span class="k">as</span> <span class="nb">Double</span><span class="si">)</span><span class="s">&#34;</span><span class="p">)</span>

<span class="bp">print</span><span class="p">(</span><span class="s">&#34;main thread exit.&#34;</span><span class="p">)</span>

<span class="c1">// OUTPUT:</span>
<span class="c1">// (0x00000001000d6dc0) is running.</span>
<span class="c1">// thread (0x0000700007bb2000) is running.</span>
<span class="c1">// res - 3.14</span>
<span class="c1">// main thread exit.</span>
</code></pre></div><h3 id="互斥锁">互斥锁</h3>
<p>pthreads 中还提供了互斥锁（Mutex）来实现线程同步，但由于锁相关的内容将会统一整理，本文不再赘述。</p>
<h3 id="条件变量">条件变量</h3>
<p>由于条件变量内容与互斥锁有所关联，一并统一整理，本文不再赘述。</p>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/pthreads">POSIX Threads - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Restrict">restrict - Wikipedia</a></li>
<li><a href="../nullability_in_obj-c/">[译] 在 Objective-C API 中指定可空性 - kingcos</a></li>
<li><a href="https://stackoverflow.com/questions/1413785/sem-init-on-os-x">sem_init on OS X - StackOverflow</a></li>
<li><a href="https://github.com/ZewoGraveyard/POSIX">ZewoGraveyard/POSIX - GitHub</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/pthread.3.html#//apple_ref/doc/man/3/pthread">pthread - iOS Manual Pages</a></li>
<li><a href="https://www.ibm.com/support/knowledgecenter/en/ssw_ibm_i_71/apis/concep17.htm">Thread ID vs. Pthread Handle (pthread_t) - IBM</a></li>
<li><a href="https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/using_imported_c_functions_in_swift">Using Imported C Functions in Swift - Apple</a></li>
<li><a href="https://stackoverflow.com/questions/8487380/how-to-cast-an-integer-to-void-pointer">How to cast an integer to void pointer? - StackOverflow</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/EnergyGuide-iOS">Energy Efficiency Guide for iOS Apps - Apple</a></li>
<li><a href="https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html">POSIX thread (pthread) libraries - CMU</a></li>
<li><a href="https://stackoverflow.com/questions/23051676/does-pthread-create-start-the-created-thread/23051731">Does pthread_create start the created thread? - StackOverflow</a></li>
<li><a href="https://stackoverflow.com/questions/3649281/how-to-increase-thread-priority-in-pthreads">How to increase thread priority in pthreads? - StackOverflow</a></li>
</ul>
<!-- ## 信号量

信号量（Semaphore）的概念很难从字面直接理解，其也被称为信号灯：一段马路（即资源）对车辆（即线程）的承载量是有限的，当承载量达到限度时，红灯会亮起阻止进入；当承载量未达到时，绿灯会亮起允许进入。关于互斥锁和信号量的区别，简而言之，互斥锁通常处理多个线程对一个资源的争夺，意味着总是按顺序获取和释放；而信号量则应当用在一个任务到另一个任务的信号，其中的任务要么发送信号要么等待信号。我在开发 [WWDCHelper](https://github.com/kingcos/WWDCHelper) 命令行程序中也用到了信号量，函数返回的数据需要等待下载任务完成后才可以得到，所以当下载任务完成后发送信号，等待的信号收到后便继续前行。

我们创建两个线程，`thread_2` 中人为等待 1 秒代表处理耗时任务，任务完成后发送信号，`thread_1` 中等待信号，等信号发出再执行自己的任务：

```objectivec
#import <Foundation/Foundation.h>

#import <pthread.h>
#import <sys/semaphore.h>

// 声明信号量
sem_t * sem;

void * run_thread(void *arg) {
    NSLog(@"--- run_thread ---\n");

    sleep(2);

    NSLog(@"--- sem_post ---\n");

    // 发射信号
    if (sem_post(sem) != 0) {
        perror("sem_post error.");
        exit(1);
    }

    pthread_exit(NULL);
}

int main(int argc, const char * argv[]) {
    sem = sem_open("kingcos.me", O_CREAT, 0666, 1);

    if (sem == SEM_FAILED) {
         perror("sem_open error");
         exit(-1);
    }

    pthread_t thread;

    if (pthread_create(&thread, NULL, run_thread, NULL) != 0) {
        printf("pthread_create thread error.\n");
    }

    // 等待信号
    if (sem_wait(sem) != 0) {
        perror("sem_wait error.");
        exit(-1);
    }

    NSLog(@"goon\n");

    // 关闭信号量
    sem_close(sem);
    // 取消链接信号量
    sem_unlink("kingcos.me");

    return 0;
}

// OUTPUT:
// --- run_thread ---
// --- sem_post ---
// goon
``` -->
<!-- PTHREAD_MUTEX_INITIALIZER -->
<!-- https://developer.apple.com/library/archive/documentation/Performance/Conceptual/power_efficiency_guidelines_osx/PrioritizeWorkAtTheTaskLevel.html#//apple_ref/doc/uid/TP40013929-CH35-SW1
https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html



- [StackOverflow - What is a semaphore?](https://stackoverflow.com/questions/34519/what-is-a-semaphore)
- [Michael Barr - Mutexes and Semaphores Demystified](https://barrgroup.com/Embedded-Systems/How-To/RTOS-Mutex-Semaphore)
- [Stanford - Thread and Semaphore Examples](https://see.stanford.edu/materials/icsppcs107/23-Concurrency-Examples.pdf)
- [WWDCHelper](https://github.com/kingcos/WWDCHelper)

http://www.cppblog.com/Solstice/archive/2013/09/09/203094.html
https://gist.github.com/chenshuo/6430925
-->
</div>
                    <div class="post_footer">
                        
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    <a href="https://kingcos.me/tags/practice/">Practice</a>
                                    
                                    <a href="https://kingcos.me/tags/ios/">iOS</a>
                                    
                                    <a href="https://kingcos.me/tags/obj-c/">Obj-C</a>
                                    
                                    <a href="https://kingcos.me/tags/swift/">Swift</a>
                                    
                                </span>
                            </div>
                        </div>
                        
                    </div>
                </div>
                <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<table style="border: 0;">
  <tr>
  <td style="border: 0; width: 30%;">
    <img width='100%' src='/img/about/1.jpg'>
  </td>
  <td style="border: 0; width: 50%;">
    <ins class="adsbygoogle"
     style="display:block;width:100%;"
     data-ad-client="ca-pub-9925978992661955"
     data-ad-slot="3213735320"
     data-ad-format="rectangle"
     data-full-width-responsive="false"></ins>
  </td>
  </tr>
</table>

<hr>

<script>
    (adsbygoogle = window.adsbygoogle || []).push({});
</script>
                
                
                <div class="doc_comments"><div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "kingcos" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div>
                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://kingcos.me">Powered by kingcos with love.</a>
    </div>

    <div class="footer_slogan">
        <span>❤️</span>
    </div>
</footer>
    <script src="https://kingcos.me/js/jquery-3.5.1.min.js"></script>
<link href="https://kingcos.me/css/fancybox.min.css" rel="stylesheet">
<script src="https://kingcos.me/js/fancybox.min.js"></script>
<script src="https://kingcos.me/js/zozo.js"></script>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</body>

</html>