<!DOCTYPE html>
<html lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="kingcos" />
	
	
	
	<title>MustOverride 源码解读 ｜ kingcos</title>
	
    
    
    <meta name="description" content="[MustOverride](https://github.com/nicklockwood/MustOverride) 是 [nicklockwood](https://github.com/nicklockwood) 多年前开源的一个 Obj-C 库。其作用正如其名「MustOverride」即可以使得子类必须重写父类中的某些方法，防止子类因未实现父类的某些方法而出现不可预知的错误。" />
    

    
    
    <meta name="keywords" content="Hugo, theme, zozo" />
    

	
    
    <link rel="shortcut icon" href="https://kingcos.me/images/favicon.png" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/highlight.css" />

    
    
</head>

<script data-ad-client="ca-pub-9925978992661955" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<body>
    <div class="main animate__animated animate__fadeInDown">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/posts/">Archive</a>
            </li>
            
            <li>
                <a href="/tags/">Tags</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>


<link rel="stylesheet" href="https://kingcos.me/scss/main.min.75b49085bfb07b1bf150a1d59b4773d857e0452a747e37243805218b528a4045.css" integrity="sha256-dbSQhb&#43;wexvxUKHVm0dz2FfgRSp0fjckOAUhi1KKQEU=" media="screen">

<style>
.nav_container {
  height: 1rem;
}
 
table {
    width: 100%;
    table-layout: fixed;
}

 
.markdown code {
    white-space: normal;
    word-wrap: break-word;
    word-break: break-word;
    line-height: 1.5em;
    font-size: 0.85em;
    font-weight: bold;
    display: inline-block;
     
}

 
.menu_icon a {
    font-size: 16px;
}

 
body {
    font-family: 'Hiragino Sans GB', 'SFMono', 'Lato', '-apple-system';
    -webkit-font-smoothing: 'antialiased';
}

 
.markdown strong, .markdown b, .markdown em {
    font-weight: bold;
}

.post .post_content p {
     

    line-height: 1.75em;
}

 
.markdown img {
    max-width: 100%;
    margin: 0 auto;
    display: block;
    border-radius: 0.25rem;
}

 
.ri-stack-line {
    vertical-align: middle;
}

 
.ri-map-pin-time-line {
    vertical-align: middle;
}

 

 
.markdown .book-hint::before {
    content: none;
}

.markdown .book-hint {
    margin: 1rem 0;
    padding: 0.5rem 1rem 0.5rem 0.75rem;

    border-inline-start: 0.25rem solid #e9ecef;
    border-radius: 0.25rem;

    font-style: normal;
     
}

.book-hint strong {
    background-color: transparent;
}

.markdown .book-hint.info {
    border-left-color:#6bf;
    background-color:rgba(102,187,255,.1);
}

.markdown .book-hint.warning {
    border-left-color:#fd6;
    background-color:rgba(255,221,102,.1);
}

.markdown .book-hint.danger {
    border-left-color:#f66;
    background-color:rgba(255,102,102,.1);
}

</style>

        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            
                <a href="https://kingcos.me/">
                    
                    <img class="kingcos" style="margin-top: -20px; margin-left: -10px;" src="/title.svg" width="150px">
                </a>
            
        </div>
        <div class="description">
            <p class="sub_title">专注、坚持</p>
            <div class="my_socials">
                
                
                <a href="https://github.com/kingcos" title="github" target="_blank"><i class="ri-github-fill"></i></a>
                
                
                
                <a href="https://www.instagram.com/kingcos_v/" title="instagram" target="_blank"><i class="ri-instagram-fill"></i></a>
                
                
                
                <a href="https://twitter.com/kingcos_v" title="twitter" target="_blank"><i class="ri-twitter-fill"></i></a>
                
                
                
                <a href="https://weibo.com/u/1798410923" title="weibo" target="_blank"><i class="ri-weibo-fill"></i></a>
                
                
                
            </div>
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/posts/2019/dive_into_mustoverride/'>MustOverride 源码解读</a></h2>
                        <span class="date">2020.01.05</span>
                        <span>by kingcos</span>
                        
                        
                        
                        
                    </div>
                    <div class="post_content markdown">
<div class="book-expand">
  <label>
    <div class="book-expand-head flex justify-between">
      <span>Release Notes</span>
      <span>↕</span>
    </div>
    <input type="checkbox" class="hidden" />
    <div class="book-expand-content markdown-inner">
      <table>
<thead>
<tr>
<th style="text-align:center">Date</th>
<th style="text-align:center">Notes</th>
<th style="text-align:center">Source Code</th>
<th style="text-align:center">Commit / Tag</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2019-12-07</td>
<td style="text-align:center">首次提交</td>
<td style="text-align:center"><a href="https://github.com/nicklockwood/MustOverride">nicklockwood/MustOverride</a></td>
<td style="text-align:center">c63007e / 1.1</td>
</tr>
<tr>
<td style="text-align:center">2020-01-05</td>
<td style="text-align:center">增加 Extension 一节</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>

    </div>
  </label>
</div>

<p><img src="/img/2019/dive_into_mustoverride/0.png" alt="0"></p>
<h2 id="preface">Preface</h2>
<p><a href="https://github.com/nicklockwood/MustOverride">MustOverride</a> 是 <a href="https://github.com/nicklockwood">nicklockwood</a> 多年前开源的一个 Obj-C 库。其作用正如其名「MustOverride」即可以使得子类必须重写父类中的某些方法，防止子类因未实现父类的某些方法而出现不可预知的错误。</p>
<h2 id="how">How</h2>
<p>这个库的使用非常简单，如果是 CocoaPods 管理依赖的项目，直接通过 <code>pod 'MustOverride'</code> 即可引入；之后引入 <code>MustOverride.h</code> 头文件并在需要必须子类重写的父类（或父类的分类）方法中放入 <code>SUBCLASS_MUST_OVERRIDE;</code> 宏即可：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// Foo.m
</span><span class="c1"></span>
<span class="cp">#import &#34;Foo.h&#34;
</span><span class="cp">#import &#34;MustOverride.h&#34;
</span><span class="cp"></span>
<span class="k">@implementation</span> <span class="nc">Foo</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">foo</span> <span class="p">{</span>
    <span class="n">SUBCLASS_MUST_OVERRIDE</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="c1">// Foo+Ext.m
</span><span class="c1"></span>
<span class="cp">#import &#34;Foo+Ext.h&#34;
</span><span class="cp">#import &#34;MustOverride.h&#34;
</span><span class="cp"></span>
<span class="k">@implementation</span> <span class="nc">Foo</span> <span class="nl">(Ext)</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">fooExt</span> <span class="p">{</span>
    <span class="n">SUBCLASS_MUST_OVERRIDE</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span>
</code></pre></div><p>这样，即使 <code>Foo</code> 父类及 <code>SubFoo</code> 子类的方法没有被调用到，只要子类没有实现相应的方法，程序也会在启动时立刻崩溃，便于第一时间发现问题：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">*** Terminating app due to uncaught exception <span class="s1">&#39;NSInternalInconsistencyException&#39;</span>, reason: <span class="s1">&#39;2 method override errors:
</span><span class="s1">SubFoo does not implement required method -fooExt
</span><span class="s1">SubFoo does not implement required method -foo&#39;</span>
</code></pre></div><h2 id="why">Why</h2>
<h3 id="结构">结构</h3>
<p>「MustOverride」库的结构很简单，只有以下两个文件以及不超过 200 行的代码，很容易着手：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">➜  MustOverride tree
.
├── MustOverride.h
└── MustOverride.m

<span class="m">0</span> directories, <span class="m">2</span> files
</code></pre></div><h3 id="mustoverrideh">MustOverride.h</h3>
<p>我们先从 <code>MustOverride.h</code> 开始：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// MustOverride.h
</span><span class="c1"></span>
<span class="cm">/**
</span><span class="cm"> * Include this macro inside any class or instance method that MUST be overridden
</span><span class="cm"> * by its subclass(es). The app will then crash immediately on launch with an
</span><span class="cm"> * assertion if the method is not overridden (even if it is never called).
</span><span class="cm"> */</span>
<span class="cp">#define SUBCLASS_MUST_OVERRIDE __attribute__((used, section(&#34;__DATA,MustOverride&#34; \
</span><span class="cp">))) static const char *__must_override_entry__ = __func__
</span></code></pre></div><p>其中定义了我们前面示例中所用到的 <code>SUBCLASS_MUST_OVERRIDE</code> 宏，即简化了后面的指令 <code>__attribute__((used, section(&quot;__DATA,MustOverride&quot;))) static const char *__must_override_entry__ = __func__</code>，下面我们来仔细分析下这条指令。</p>
<h4 id="__attribute__">__attribute__</h4>
<p><code>__attribute__</code> 是一个用于 GCC 或兼容 GCC 的编译器指令，可以让开发者对编译器的一些属性进行设置，使得编译器能够支持更多的错误检查或高级优化等操作。正如其名，<code>__attribute__</code> 即属性，其根据修饰对象的不同分为函数属性、变量属性、类型属性等。当多个属性同时使用时，可以通过 <code>__attribute__ ((attribute-list))</code> 语法嵌套使用。</p>
<p>目前 Xcode 使用 <code>clang</code> 编译器来编译 C/C++/Obj-C/Obj-C++ 代码，而 <code>clang</code> 也支持了 <code>__attribute__</code> 语法，甚至还有一小部分的特有属性，关于这些特有属性可以详见文末 Reference 中的《Attributes in Clang - LLVM》文档。而这里的 <code>__attribute__((used, section(&quot;__DATA,MustOverride&quot;)))</code> 同时使用了 <code>used</code> 和 <code>section</code> 这两个常见的变量属性，我们可以在 GNU 官方文档中查到两者的内容：</p>
<blockquote>
<p><code>used</code></p>
<p>This attribute, attached to a variable with static storage, means that the variable must be emitted even if it appears that the variable is not referenced.</p>
<p>When applied to a static data member of a C++ class template, the attribute also means that the member is instantiated if the class itself is instantiated.</p>
</blockquote>
<p>在《<a href="https://kingcos.me/posts/2019/const_static_extern_in_cpp/">C/C++ 中的 const、static &amp; extern</a>》一文中，我们曾经说过静态变量只在其编译单元内可见，最终可执行文件中的外部符号里并不会存在静态变量的符号，而其实如果编译单元内根本没有使用到某一静态变量，编译器默认会提示警告并将该静态变量进行优化：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="cp"></span>
<span class="c1">// WARNING: Unused variable &#39;var1&#39;
</span><span class="c1"></span><span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">var1</span> <span class="o">=</span> <span class="s">&#34;kingcos.me&#34;</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="c1">// printf(&#34;%s\n&#34;, var1);
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>比如此时的 <code>var1</code> 仅声明并定义但并没有代码使用到，我们可以通过 <code>nm PATH/TO/MustOverrideDemo | grep var</code> 命令发现可执行文件不存在该静态变量的符号。而如果我们将 <code>main</code> 函数中的注释打开，此时可执行文件中才会含有该符号：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">➜  MustOverride nm PATH/TO/MustOverrideDemo <span class="p">|</span> grep var
00000001000036e8 d _var1
</code></pre></div><p>而 <code>__attribute__((used))</code> 变量属性正是可以将编译器对于未使用的静态变量的优化关闭：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">var1</span> <span class="o">=</span> <span class="s">&#34;kingcos.me&#34;</span><span class="p">;</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">used</span><span class="p">))</span> <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">var2</span> <span class="o">=</span> <span class="s">&#34;kingcos.me&#34;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">var3</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">used</span><span class="p">))</span> <span class="o">=</span> <span class="s">&#34;kingcos.me&#34;</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="c1">// printf(&#34;%s\n&#34;, var1);
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// SHELL OUTPUT:
</span><span class="c1">// ➜  MustOverride nm PATH/TO/MustOverrideDemo | grep var
</span><span class="c1">// 00000001000036d8 d _var2
</span><span class="c1">// 00000001000036e0 d _var3
</span></code></pre></div><p>因此 <code>__attribute__((used)) static const char *__must_override_entry__ = __func__</code> 即声明一个静态常量 <code>__must_override_entry__</code> 为 <code>__func__</code>（编译器的预定义符，即函数名），并保证其不会被编译器优化。</p>
<blockquote>
<p><code>section (&quot;section-name&quot;)</code></p>
<p>Normally, the compiler places the objects it generates in sections like <code>data</code> and <code>bss</code>. Sometimes, however, you need additional sections, or you need certain particular variables to appear in special sections, for example to map to special hardware. The section attribute specifies that a variable (or function) lives in a particular section. For example, this small program uses several specific section names:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">duart</span> <span class="n">a</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">section</span> <span class="p">(</span><span class="s">&#34;DUART_A&#34;</span><span class="p">)))</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">duart</span> <span class="n">b</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">section</span> <span class="p">(</span><span class="s">&#34;DUART_B&#34;</span><span class="p">)))</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="kt">char</span> <span class="n">stack</span><span class="p">[</span><span class="mi">10000</span><span class="p">]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">section</span> <span class="p">(</span><span class="s">&#34;STACK&#34;</span><span class="p">)))</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">init_data</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">section</span> <span class="p">(</span><span class="s">&#34;INITDATA&#34;</span><span class="p">)));</span>

<span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="cm">/* Initialize stack pointer */</span>
  <span class="n">init_sp</span> <span class="p">(</span><span class="n">stack</span> <span class="o">+</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">stack</span><span class="p">));</span>

  <span class="cm">/* Initialize initialized data */</span>
  <span class="n">memcpy</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">init_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edata</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>

  <span class="cm">/* Turn on the serial ports */</span>
  <span class="n">init_duart</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
  <span class="n">init_duart</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>Use the <code>section</code> attribute with <em>global</em> variables and not <em>local</em> variables, as shown in the example.</p>
<p>You may use the <code>section</code> attribute with initialized or uninitialized global variables but the linker requires each object be defined once, with the exception that uninitialized variables tentatively go in the <code>common</code> (or <code>bss</code>) section and can be multiply “defined”. Using the <code>section</code> attribute changes what section the variable goes into and may cause the linker to issue an error if an uninitialized variable has multiple definitions. You can force a variable to be initialized with the <code>-fno-common</code> flag or the <code>nocommon</code> attribute.</p>
<p>Some file formats do not support arbitrary sections so the <code>section</code> attribute is not available on all platforms. If you need to map the entire contents of a module to a particular section, consider using the facilities of the linker instead.</p>
</blockquote>
<p>编译器通常会将不同类型（注：此处的类型指非狭义的数据结构类型）的变量放置在可执行文件内不同但特定的区域中。对于 iOS/macOS 项目的可执行文件 Mach-O 即放置在不同的段（Segment）和节（Section）中，比如全局变量通常是在数据段中。而 <code>__attribute__((section(&quot;name&quot;)))</code> 使得开发者可以将特定的变量存储在自定义的段和节内：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="n">__attribute__</span><span class="p">((</span><span class="n">section</span><span class="p">(</span><span class="s">&#34;__DATA,kingcos.me&#34;</span><span class="p">)))</span> <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">var4</span> <span class="o">=</span> <span class="s">&#34;kingcos.me&#34;</span><span class="p">;</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">section</span><span class="p">(</span><span class="s">&#34;__DATA,maimieng.com&#34;</span><span class="p">)))</span> <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">var5</span> <span class="o">=</span> <span class="s">&#34;maimieng.com&#34;</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="n">var4</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>我们可以使用 MachOView 来查看 Mach-O 文件中的信息：</p>
<p><img src="/img/2019/dive_into_mustoverride/1.png" alt="1"></p>
<p>其中确实存在了 <code>__DATA</code> 段的 <code>kingcos.me</code> 节，而这里 <code>var5</code> 的节并没有存在，这是因为编译器已经将该未使用的静态变量进行了优化。</p>
<p>因此 <code>MustOverride.h</code> 中定义了 <code>SUBCLASS_MUST_OVERRIDE</code> 宏，并结合了两个编译器的变量属性，将使用到该宏的方法名存储在 <code>__must_override_entry__</code> 静态常量中，并将该常量最终存储在可执行文件的数据段 <code>MustOverride</code> 节，即为 <code>#define SUBCLASS_MUST_OVERRIDE static const char *__must_override_entry__ __attribute__((used, section(&quot;__DATA,MustOverride&quot;))) = __func__;</code>。</p>
<p><img src="/img/2019/dive_into_mustoverride/2.png" alt="2"></p>
<h3 id="mustoverridem">MustOverride.m</h3>
<p>那么将方法名独立存储在可执行文件的数据段 <code>MustOverride</code> 节有什么意义呢？这就需要从 <code>MustOverride.m</code> 开始着手。</p>
<p><code>MustOverride.m</code> 中定义了 <code>MustOverride</code> 类，但其实目的只是为了使用到 <code>+load</code> 方法，使得程序启动时可以执行其它函数，是该库的入口；其中关于 <code>+load</code> 方法，可详见《<a href="../+load_in_ios/">iOS 中的 +load 方法</a>》一文。</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// MustOverride.m
</span><span class="c1"></span>
<span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">load</span>
<span class="p">{</span>
    <span class="n">CheckOverrides</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><p>在 <code>MustOverride</code> 的 <code>+load</code> 方法中调用了 <code>CheckOverrides()</code> C 语言静态函数。不过在具体说明该入口函数之前，我们先来看下另外两个在 <code>CheckOverrides()</code> 中使用到的辅助函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// MustOverride.m
</span><span class="c1"></span>
<span class="c1">// 该类是否重写某个方法（该类是否实现某个方法）
</span><span class="c1"></span><span class="k">static</span> <span class="kt">BOOL</span> <span class="nf">ClassOverridesMethod</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">selector</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 声明存储方法总数的变量
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">numberOfMethods</span><span class="p">;</span>
    <span class="c1">// 获取该类的方法列表，并设置方法总数
</span><span class="c1"></span>    <span class="n">Method</span> <span class="o">*</span><span class="n">methods</span> <span class="o">=</span> <span class="n">class_copyMethodList</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">numberOfMethods</span><span class="p">);</span>
    <span class="c1">// 遍历该类的所有方法
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numberOfMethods</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 若有方法与参数的某个方法一致，则代表该类实现了该方法
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">method_getName</span><span class="p">(</span><span class="n">methods</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">selector</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 释放
</span><span class="c1"></span>            <span class="n">free</span><span class="p">(</span><span class="n">methods</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 释放
</span><span class="c1"></span>    <span class="n">free</span><span class="p">(</span><span class="n">methods</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 获取某个类的所有子类
</span><span class="c1"></span><span class="k">static</span> <span class="n">NSArray</span> <span class="o">*</span><span class="nf">SubclassesOfClass</span><span class="p">(</span><span class="kt">Class</span> <span class="n">baseClass</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 声明存储第一个类的指针
</span><span class="c1"></span>    <span class="k">static</span> <span class="kt">Class</span> <span class="o">*</span><span class="n">classes</span><span class="p">;</span>
    <span class="c1">// 声明存储类总数的变量
</span><span class="c1"></span>    <span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">classCount</span><span class="p">;</span>
    <span class="c1">// 保证类列表的获取只需一次（在一个程序中该列表应当是不变的）
</span><span class="c1"></span>    <span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
      <span class="c1">// 拷贝类列表
</span><span class="c1"></span>      <span class="n">classes</span> <span class="o">=</span> <span class="n">objc_copyClassList</span><span class="p">(</span><span class="o">&amp;</span><span class="n">classCount</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="c1">// 声明存储子类的可变数组
</span><span class="c1"></span>    <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">subclasses</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
    <span class="c1">// 遍历所有类
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">classCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 存储当前遍历到的类
</span><span class="c1"></span>        <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">classes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="kt">Class</span> <span class="n">superclass</span> <span class="o">=</span> <span class="n">cls</span><span class="p">;</span>
        <span class="c1">// 当父类存在时
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">superclass</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 如果父类与参数一致，说明 cls 是 baseClass 子类链之一
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">superclass</span> <span class="o">==</span> <span class="n">baseClass</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// 存在子类数组中
</span><span class="c1"></span>                <span class="p">[</span><span class="n">subclasses</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">cls</span><span class="p">];</span>
                <span class="c1">// 去遍历下个类
</span><span class="c1"></span>                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// 找上一级父类（找到 NSObject 的父类 nil 为止）
</span><span class="c1"></span>            <span class="n">superclass</span> <span class="o">=</span> <span class="n">class_getSuperclass</span><span class="p">(</span><span class="n">superclass</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 扫描完所有类，返回结果
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">subclasses</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><code>ClassOverridesMethod()</code> 与 <code>SubclassesOfClass()</code> 两个独立封装的辅助函数使得 <code>CheckOverrides()</code> 函数可以设计得不会过长且功能独立：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// MustOverride.m
</span><span class="c1"></span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">CheckOverrides</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 声明 Dl_info 结构体
</span><span class="c1"></span>    <span class="n">Dl_info</span> <span class="n">info</span><span class="p">;</span>
    <span class="c1">// 获取当前函数地址处的镜像信息并保存在 info 中
</span><span class="c1"></span>    <span class="n">dladdr</span><span class="p">((</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">CheckOverrides</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

    <span class="c1">// 获取 Mach-O 头（基地址）
</span><span class="c1"></span>    <span class="k">const</span> <span class="n">MustOverrideValue</span> <span class="n">mach_header</span> <span class="o">=</span> <span class="p">(</span><span class="n">MustOverrideValue</span><span class="p">)</span><span class="n">info</span><span class="p">.</span><span class="n">dli_fbase</span><span class="p">;</span>
    <span class="c1">// 获取 Mach-O 中相应的节信息
</span><span class="c1"></span>    <span class="k">const</span> <span class="n">MustOverrideSection</span> <span class="o">*</span><span class="n">section</span> <span class="o">=</span> <span class="n">GetSectByNameFromHeader</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">mach_header</span><span class="p">,</span> <span class="s">&#34;__DATA&#34;</span><span class="p">,</span> <span class="s">&#34;MustOverride&#34;</span><span class="p">);</span>
    <span class="c1">// 如果未获取到则返回
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">section</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="c1">// 声明存储错误信息的可变数组
</span><span class="c1"></span>    <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">failures</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
    <span class="c1">// 从 section-&gt;offset 偏移开始，每次循环跨越指向字符数组指针大小的范围，最终不超过偏移地址与节大小之和，即可遍历节中存储的信息
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">MustOverrideValue</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">section</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">section</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">section</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// 取存储的 __func__ 信息并转换为 NSString，eg: @&#34;-[Foo(Ext) fooExt]&#34;
</span><span class="c1"></span>        <span class="n">NSString</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="l">@(</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="p">)(</span><span class="n">mach_header</span> <span class="o">+</span> <span class="n">addr</span><span class="p">)</span><span class="l">)</span><span class="p">;</span>
        <span class="c1">// 分割方法名，eg: [@&#34;Foo(Ext)&#34;, @&#34;fooExt&#34;]
</span><span class="c1"></span>        <span class="n">NSArray</span> <span class="o">*</span><span class="n">parts</span> <span class="o">=</span> <span class="p">[[</span><span class="n">entry</span> <span class="nl">substringWithRange</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">entry</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)]</span> <span class="nl">componentsSeparatedByString</span><span class="p">:</span><span class="s">@&#34; &#34;</span><span class="p">];</span>
        <span class="c1">// 取出类名
</span><span class="c1"></span>        <span class="n">NSString</span> <span class="o">*</span><span class="n">className</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="c1">// 针对分类特殊处理
</span><span class="c1"></span>        <span class="n">NSRange</span> <span class="n">categoryRange</span> <span class="o">=</span> <span class="p">[</span><span class="n">className</span> <span class="nl">rangeOfString</span><span class="p">:</span><span class="s">@&#34;(&#34;</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">categoryRange</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 取出类名，eg: @&#34;Foo&#34;
</span><span class="c1"></span>            <span class="n">className</span> <span class="o">=</span> <span class="p">[</span><span class="n">className</span> <span class="nl">substringToIndex</span><span class="p">:</span><span class="n">categoryRange</span><span class="p">.</span><span class="n">location</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="c1">// 判断是否为类方法（是否以 + 开头）
</span><span class="c1"></span>        <span class="kt">BOOL</span> <span class="n">isClassMethod</span> <span class="o">=</span> <span class="p">[</span><span class="n">entry</span> <span class="nl">characterAtIndex</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span><span class="p">;</span>
        <span class="c1">// 根据类名构造 Class
</span><span class="c1"></span>        <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">NSClassFromString</span><span class="p">(</span><span class="n">className</span><span class="p">);</span>
        <span class="c1">// 根据方法名构造 SEL
</span><span class="c1"></span>        <span class="kt">SEL</span> <span class="n">selector</span> <span class="o">=</span> <span class="n">NSSelectorFromString</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

        <span class="c1">// 遍历该类的所有子类
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">Class</span> <span class="n">subclass</span> <span class="k">in</span> <span class="n">SubclassesOfClass</span><span class="p">(</span><span class="n">cls</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="c1">// 判断类中是否有重写的方法（如果是类方法，其存储在元类的方法列表中，则传入元类对象；否则传入类对象）
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ClassOverridesMethod</span><span class="p">(</span><span class="n">isClassMethod</span> <span class="o">?</span> <span class="n">object_getClass</span><span class="p">(</span><span class="n">subclass</span><span class="p">)</span> <span class="o">:</span> <span class="n">subclass</span><span class="p">,</span> <span class="n">selector</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="c1">// 添加未重写的子类和方法信息
</span><span class="c1"></span>                <span class="p">[</span><span class="n">failures</span> <span class="nl">addObject</span><span class="p">:[</span><span class="n">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&#34;%@ does not implement method %c%@ required by %@&#34;</span><span class="p">,</span>
                                     <span class="n">subclass</span><span class="p">,</span> <span class="n">isClassMethod</span> <span class="o">?</span> <span class="sc">&#39;+&#39;</span> <span class="o">:</span> <span class="sc">&#39;-&#39;</span><span class="p">,</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">className</span><span class="p">]];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 若错误存在则触发断言，使程序终止
</span><span class="c1"></span>    <span class="n">NSCAssert</span><span class="p">(</span><span class="n">failures</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">@&#34;%@%@&#34;</span><span class="p">,</span>
              <span class="n">failures</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&#34;%zd method override errors:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">failures</span><span class="p">.</span><span class="n">count</span><span class="p">]</span> <span class="o">:</span> <span class="s">@&#34;&#34;</span><span class="p">,</span>
              <span class="p">[</span><span class="n">failures</span> <span class="nl">componentsJoinedByString</span><span class="p">:</span><span class="s">@&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">]);</span>
<span class="p">}</span>

</code></pre></div><p><code>DL_info</code> 是定义在 <code>dlfcn.h</code> 中的结构体类型，由 <code>dladdr()</code> 函数填充：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// dlfcn.h
</span><span class="c1"></span>
<span class="cm">/*
</span><span class="cm"> * Structure filled in by dladdr().
</span><span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">dl_info</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span>      <span class="o">*</span><span class="n">dli_fname</span><span class="p">;</span>     <span class="cm">/* Pathname of shared object */</span>
        <span class="kt">void</span>            <span class="o">*</span><span class="n">dli_fbase</span><span class="p">;</span>     <span class="cm">/* Base address of shared object */</span>
        <span class="k">const</span> <span class="kt">char</span>      <span class="o">*</span><span class="n">dli_sname</span><span class="p">;</span>     <span class="cm">/* Name of nearest symbol */</span>
        <span class="kt">void</span>            <span class="o">*</span><span class="n">dli_saddr</span><span class="p">;</span>     <span class="cm">/* Address of nearest symbol */</span>
<span class="p">}</span> <span class="n">Dl_info</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="nf">dladdr</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">Dl_info</span> <span class="o">*</span><span class="p">);</span>
</code></pre></div><p>而关于 <code>dladdr()</code> 函数我们可以在 Terminal 通过 <code>man dladdr</code> 查阅 Manual 手册（如下）。该函数将通过 <code>dyld</code>（动态链接器）查询传入地址所在的镜像信息，并将其填充至 <code>DL_info</code> 结构体，其中 <code>dli_fbase</code> 为镜像的基地址，即 Mach-O 头部（<code>mach_header</code>）。</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">DLADDR(3)                BSD Library Functions Manual                DLADDR(3)

NAME
     dladdr -- find the image containing a given address

SYNOPSIS
     #include &lt;dlfcn.h&gt;

     int
     dladdr(const void* addr, Dl_info* info);

DESCRIPTION
     The dladdr() function queries dyld (the dynamic linker) for information
     about the image containing the address addr.  The information is returned
     in the structure specified by info.  The structure contains at least the
     following members:

     const char* dli_fname     The pathname of the shared object containing
                               the address.

     void* dli_fbase           The base address (mach_header) at which the
                               image is mapped into the address space of the
                               calling process.

     const char* dli_sname     The name of the nearest run-time symbol with a
                               value less than or equal to addr.

     void* dli_saddr           The value of the symbol returned in dli_sname.

     The dladdr() function is available only in dynamically linked programs.

ERRORS
     If an image containing addr cannot be found, dladdr() returns 0.  On suc-cess, success,
     cess, a non-zero value is returned.

     If the image containing addr is found, but no nearest symbol was found,
     the dli_sname and dli_saddr fields are set to NULL.

SEE ALSO
     dyld(3), dlopen(3)

HISTORY
     The dladdr() function first appeared in the Solaris operating system.

AUTHORS
     Mac OS X 10.3 incorporated the dlcompat package written by Jorge Acereda
     &lt;jacereda@users.sourceforge.net&gt; and Peter O&#39;Gorman &lt;ogor-
     man@users.sourceforge.net&gt;.

     In Mac OS X 10.4, dlopen was rewritten to be a native part of dyld.

     This man page was borrowed from FreeBSD and modified.

BUGS
     This implementation is almost bug-compatible with the Solaris implementa-tion. implementation.
     tion.  The following bugs are present:

     oo   Returning 0 as an indication of failure goes against long-standing
         Unix tradition.

BSD                           September 24, 2004                           BSD
</code></pre></div><p>通过 <code>mach_header</code> 和具体的段和节信息，我们就可以读取到其中的内容，但这里需要注意的是，在不同架构的设备上，相应的函数和类型可能略有不同，我们这里以目前更为普及的 64 位系统为例：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// MustOverride.m
</span><span class="c1"></span>
<span class="cp">#ifdef __LP64__
</span><span class="cp"></span><span class="k">typedef</span> <span class="n">uint64_t</span> <span class="n">MustOverrideValue</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">section_64</span> <span class="n">MustOverrideSection</span><span class="p">;</span>
<span class="cp">#define GetSectByNameFromHeader getsectbynamefromheader_64
</span><span class="cp">#else
</span><span class="cp"></span><span class="k">typedef</span> <span class="n">uint32_t</span> <span class="n">MustOverrideValue</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">section</span> <span class="n">MustOverrideSection</span><span class="p">;</span>
<span class="cp">#define GetSectByNameFromHeader getsectbynamefromheader
</span><span class="cp">#endif
</span><span class="cp"></span>
<span class="c1">// mach-o/getsect.h
</span><span class="c1"></span>
<span class="c1">// 根据 Mach-O 头地址和段、节名获取节信息
</span><span class="c1">// getsectbyname,  getsectdata - get the section information for the named section
</span><span class="c1"></span><span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">section_64</span> <span class="o">*</span><span class="nf">getsectbynamefromheader_64</span><span class="p">(</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">mach_header_64</span> <span class="o">*</span><span class="n">mhp</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">segname</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sectname</span><span class="p">);</span>
</code></pre></div><p>节信息存储在 <code>section_64</code> 结构体中，通过 <code>offset</code> 偏移和 <code>mach_header</code> 可以取出其中第一个内容；由于我们在节中存储的实际上是指向字符数组的指针，指针在内存中占用的空间是固定的，即可顺位继续取出后续的内容；节中内容的总长度则可以由 <code>size</code> 得出：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// mach-o/loader.h
</span><span class="c1"></span>
<span class="k">struct</span> <span class="nc">section_64</span> <span class="p">{</span> <span class="cm">/* for 64-bit architectures */</span>
	<span class="kt">char</span>		<span class="n">sectname</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* name of this section */</span>
	<span class="kt">char</span>		<span class="n">segname</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* segment this section goes in */</span>
	<span class="kt">uint64_t</span>	<span class="n">addr</span><span class="p">;</span>		<span class="cm">/* memory address of this section */</span>
	<span class="kt">uint64_t</span>	<span class="n">size</span><span class="p">;</span>		<span class="cm">/* size in bytes of this section */</span>
	<span class="kt">uint32_t</span>	<span class="n">offset</span><span class="p">;</span>		<span class="cm">/* file offset of this section */</span>
	<span class="kt">uint32_t</span>	<span class="n">align</span><span class="p">;</span>		<span class="cm">/* section alignment (power of 2) */</span>
	<span class="kt">uint32_t</span>	<span class="n">reloff</span><span class="p">;</span>		<span class="cm">/* file offset of relocation entries */</span>
	<span class="kt">uint32_t</span>	<span class="n">nreloc</span><span class="p">;</span>		<span class="cm">/* number of relocation entries */</span>
	<span class="kt">uint32_t</span>	<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* flags (section type and attributes)*/</span>
	<span class="kt">uint32_t</span>	<span class="n">reserved1</span><span class="p">;</span>	<span class="cm">/* reserved (for offset or index) */</span>
	<span class="kt">uint32_t</span>	<span class="n">reserved2</span><span class="p">;</span>	<span class="cm">/* reserved (for count or sizeof) */</span>
	<span class="kt">uint32_t</span>	<span class="n">reserved3</span><span class="p">;</span>	<span class="cm">/* reserved */</span>
<span class="p">};</span>
</code></pre></div><p>这样综上，我们就可以在程序启动时读取到编译时已经存储在 Mach-O 中 <code>__DATA</code> 段 <code>MustOverride</code> 节的方法信息，并通过查询相应的方法是否被子类实现，在第一时间触发断言终止 app 运行。最后需要注意的是，<code>MustOverride.m</code> 其中的代码块几乎整体被 <code>#if DEBUG</code> 和 <code>#endif</code> 宏包裹，这意味着该库仅适用于 Debug 模式，可能会造成某些崩溃等影响，因此切忌 Release 模式下使用。</p>
<h2 id="extension">Extension</h2>
<p>经过以上的分析，我们可以发现「MustOverride」这个库其实并不复杂，但带给了我们一些思路。比如我们可以使用 <code>__attribute__</code> 在编译时刻写入 Mach-O 中一些内容，并在 app 启动或运行时读取，进而做一些操作。那么还有一些由此相关的扩展内容，我们一起来领略一下吧！</p>
<h3 id="宏的拼接">宏的拼接</h3>
<p>宏的拼接指我们可以将一个宏的多个部分进行拼接，进而达到整体使用它的效果。虽然我们可能很少用到宏的拼接，但这却带来不少的灵活性。比如如下我们将 <code>A</code>、<code>B</code> 和 <code>C</code> 通过 <code>##</code> 进行了拼接：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="cp">#define A &#34;aaa\n&#34;
</span><span class="cp">#define B &#34;bbb\n&#34;
</span><span class="cp">#define C &#34;ccc\n&#34;
</span><span class="cp"></span>
<span class="cp">#define AB &#34;ab\n&#34;
</span><span class="cp">#define AC &#34;ac\n&#34;
</span><span class="cp">#define ABC &#34;abc\n&#34;
</span><span class="cp"></span>
<span class="cp">#define CONCAT_MACRO_1(X, Y) X##Y
</span><span class="cp">#define CONCAT_MACRO_2(X, Y) X ## Y
</span><span class="cp">#define CONCAT_MACRO_3(X, Y, Z) X   ##   Y ##Z
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="n">B</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="n">C</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="n">CONCAT_MACRO_1</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="n">CONCAT_MACRO_2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="n">CONCAT_MACRO_3</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">));</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// aaa
</span><span class="c1">// bbb
</span><span class="c1">// ccc
</span><span class="c1">// ab
</span><span class="c1">// ac
</span><span class="c1">// abc
</span></code></pre></div><ul>
<li><a href="https://gcc.gnu.org/onlinedocs/cpp/Concatenation.html">3.5 Concatenation - GNU</a></li>
</ul>
<h3 id="计数宏">计数宏</h3>
<p><code>__COUNTER__</code> 即计数宏，该宏会从 <code>0</code> 开始，每预编译一次便会自增 <code>1</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="cp">#define COUNTER_MACRO printf(&#34;%d\n&#34;, __COUNTER__);
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">COUNTER_MACRO</span>
    <span class="n">COUNTER_MACRO</span>
    <span class="n">COUNTER_MACRO</span>
    <span class="n">COUNTER_MACRO</span>
    <span class="n">COUNTER_MACRO</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// 0
</span><span class="c1">// 1
</span><span class="c1">// 2
</span><span class="c1">// 3
</span><span class="c1">// 4
</span></code></pre></div><p>由于 <code>__COUNTER__</code> 宏的自增性，我们可以用其来定义一些避免重复的命名。</p>
<h3 id="汇编标签">汇编标签</h3>
<p>汇编标签即 Asm Labels，我们可以通过 <code>asm</code> 或 <code>__asm__</code> 指定该标签来自定义函数、变量等类型的汇编符号：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// main.m
</span><span class="c1"></span>
<span class="cp">#import &lt;Foundation/Foundation.h&gt;
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">demoVar1</span> <span class="nf">asm</span> <span class="p">(</span><span class="s">&#34;someVar&#34;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">demoVar2</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">demoFunc1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__asm__</span> <span class="p">(</span><span class="s">&#34;someFunc&#34;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">demoFunc1</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">demoVar1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">demoFunc2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">demoVar2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">demoFunc1</span><span class="p">();</span>
    <span class="n">demoFunc2</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><p>我们可以使用 <code>nm</code> 命令来验证最终的可执行文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">➜  ~ nm PATH/TO/BINARY <span class="p">|</span> grep demo
0000000100000db0 T _demoFunc2
000000010000144c D _demoVar2

➜  ~ nm PATH/TO/BINARY <span class="p">|</span> grep some
0000000100000d80 T someFunc
<span class="m">0000000100001448</span> D someVar
</code></pre></div><ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.7.2/gcc/Asm-Labels.html">6.43 Controlling Names Used in Assembler Code - GNU</a></li>
</ul>
<!-- c++filt _var1

### Name Mangling

➜  ios-mm git:(release/3.7.0) ✗
xcrun swift-demangle --compact sSDyq_SgxcigSS_10Experiment0A10ExpressionCTg5Tf4xn_n
function signature specialization <Arg[0] = Exploded> of generic specialization <Swift.String, Experiment.ExperimentExpression> of Swift.Dictionary.subscript.getter : (A) -> B?
-->
<!--
https://www.jianshu.com/p/1de663f64c05
https://satanwoo.github.io/2017/06/01/FBTweak/
https://github.com/facebook/Tweaks

链接器默认使用 -ObjC 指令进行链接，不会链接不包含 OC 类或分类的目标文件；为了与 Address Sanitizer 等检测工具共存，我们在充分阅读了 clang 源码之后，决定使用前缀 “__objc” 来进行 workaround。因此，我们将 Kylin 写入的段名称更改为了 “__objc_k_kylin”，这样就避免了 Address Sanitizer 等工具对数据段的破坏。

// 读写安全：
https://stackoverflow.com/questions/26515968/swift-access-to-dictionary-of-a-singleton-causes-exc-bad-access
https://github.com/Alamofire/AlamofireImage/pull/387/files
 -->
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://nshipster.com/__attribute__/"><code>__attribute__</code> - NSHipster</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html">Attribute Syntax - GNU</a></li>
<li><a href="http://releases.llvm.org/9.0.0/tools/clang/docs/AttributeReference.html">Attributes in Clang - LLVM</a></li>
<li><a href="../const_static_extern_in_cpp/">C/C++ 中的 const、static &amp; extern - kingcos</a></li>
<li><a href="https://blog.sunnyxx.com/2016/05/14/clang-attributes/">Clang Attributes 黑魔法小记 - sunnyxx</a></li>
<li><a href="../+load_in_ios/">iOS 中的 +load 方法 - kingcos</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dladdr.3.html">dladdr - iOS Manual Pages</a></li>
<li><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0491c/Caccache.html"><code>__attribute__((section(&quot;name&quot;))) variable attribute</code> - ARM</a></li>
<li><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0491c/BABCJJID.html"><code>__attribute__((used)) variable attribute</code> - ARM</a></li>
<li><a href="https://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html">美团外卖 iOS App 冷启动治理 - 美团技术团队</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dladdr.3.html">dladdr - iOS Manual Pages</a></li>
</ul>
</div>
                    <div class="post_footer">
                        
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    <a href="https://kingcos.me/tags/focus/">Focus</a>
                                    
                                    <a href="https://kingcos.me/tags/obj-c/">Obj-C</a>
                                    
                                    <a href="https://kingcos.me/tags/c/c&#43;&#43;/">C/C&#43;&#43;</a>
                                    
                                    <a href="https://kingcos.me/tags//">★</a>
                                    
                                </span>
                            </div>
                        </div>
                        
                    </div>
                </div>
                <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<table style="border: 0;">
  <tr>
  <td style="border: 0; width: 30%;">
    <img width='100%' src='/img/about/1.jpg'>
  </td>
  <td style="border: 0; width: 50%;">
    <ins class="adsbygoogle"
     style="display:block;width:100%;"
     data-ad-client="ca-pub-9925978992661955"
     data-ad-slot="3213735320"
     data-ad-format="rectangle"
     data-full-width-responsive="false"></ins>
  </td>
  </tr>
</table>

<hr>

<script>
    (adsbygoogle = window.adsbygoogle || []).push({});
</script>
                
                
                



<script id="dsq-count-scr" src="//kingcos.disqus.com/count.js" async></script>

<div id="disqus_thread"></div>
<script>
    

    

    (function() { 
    var d = document, s = d.createElement('script');
    s.src = 'https://kingcos.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



    
    
    <hr>
    <div>
        <div id="github-comment">
        </div>

        <script type="text/javascript">
        function getUtterances(isDark) {
            var utterances = document.createElement('script');
            utterances.type = 'text/javascript';
            utterances.async = true;
            utterances.setAttribute('issue-term', "pathname")
            utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
            utterances.setAttribute('label', "comments")
            isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
            utterances.crossorigin = 'anonymous';
            utterances.src = 'https://utteranc.es/client.js';

            return utterances
        }
        document.getElementById('github-comment').appendChild(getUtterances(false))
        </script>
    </div>
    




                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://kingcos.me">Powered by kingcos with love.</a>
    </div>

    <div class="footer_slogan">
        <span>❤️</span>
    </div>
</footer>
    <script src="https://kingcos.me/js/jquery-3.5.1.min.js"></script>
<link href="https://kingcos.me/css/fancybox.min.css" rel="stylesheet">
<script src="https://kingcos.me/js/fancybox.min.js"></script>
<script src="https://kingcos.me/js/zozo.js"></script>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</body>

</html>