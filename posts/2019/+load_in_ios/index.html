<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>iOS ä¸­çš„ &#43;load æ–¹æ³• :: iBlog â€” github.com/kingcos</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Source Code Demo     2019-04-20 é¦–æ¬¡æäº¤ objc4-750 Load_Obj-C_Demo    Preface åœ¨ iOS å¼€å‘ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸ä¼šä½¿ç”¨ &#43;load æ–¹æ³•æ¥åšä¸€äº›åœ¨ main å‡½æ•°ä¹‹å‰çš„æ“ä½œï¼Œæ¯”å¦‚æ–¹æ³•äº¤æ¢ï¼ˆMethod Swizzleï¼‰ç­‰ã€‚é‚£ä¹ˆ &#43;load åˆ°åº•æ˜¯å¦‚ä½•è¢«è°ƒç”¨çš„å‘¢ï¼Ÿ
What // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { &#43; (void)load; }  Obj-C ä¸­çš„ &#43;load æ–¹æ³•æŒ‡çš„æ˜¯ NSObject ä¸­çš„ &#43; (void)load ç±»æ–¹æ³•ã€‚å®˜æ–¹æ–‡æ¡£ä¸­çš„ &#43;load å¦‚ä¸‹ï¼š
 Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading."/>
<meta name="keywords" content="ios,swift,objective-c,obj-c,objc,oc,geek,python,ruby,golang,go,apple,mac"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/&#43;load_in_ios/" />





<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="iOS ä¸­çš„ &#43;load æ–¹æ³•"/>
<meta name="twitter:description" content="åœ¨ iOS å¼€å‘ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸ä¼šä½¿ç”¨ &#43;load æ–¹æ³•æ¥åšä¸€äº›åœ¨ `main` å‡½æ•°ä¹‹å‰çš„æ“ä½œï¼Œæ¯”å¦‚æ–¹æ³•äº¤æ¢ï¼ˆMethod Swizzleï¼‰ç­‰ã€‚é‚£ä¹ˆ &#43;load åˆ°åº•æ˜¯å¦‚ä½•è¢«è°ƒç”¨çš„å‘¢ï¼Ÿ"/>



<meta property="og:title" content="iOS ä¸­çš„ &#43;load æ–¹æ³•" />
<meta property="og:description" content="åœ¨ iOS å¼€å‘ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸ä¼šä½¿ç”¨ &#43;load æ–¹æ³•æ¥åšä¸€äº›åœ¨ `main` å‡½æ•°ä¹‹å‰çš„æ“ä½œï¼Œæ¯”å¦‚æ–¹æ³•äº¤æ¢ï¼ˆMethod Swizzleï¼‰ç­‰ã€‚é‚£ä¹ˆ &#43;load åˆ°åº•æ˜¯å¦‚ä½•è¢«è°ƒç”¨çš„å‘¢ï¼Ÿ" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2019/&#43;load_in_ios/" />
<meta property="article:published_time" content="2019-04-20T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-04-20T00:00:00+00:00" /><meta property="og:site_name" content="iBlog" />






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">iBlog</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="post">
    <h2 class="post-title"><a href="/posts/2019/&#43;load_in_ios/">iOS ä¸­çš„ +load æ–¹æ³•</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            2019-04-20
        </span>
      
      
      
        <span class="post-read-time">â€” 17 min read</span>
      
    </div>

    
      <span class="post-tags">
        
          #<a href="/tags/focus/">Focus</a>&nbsp;
        
          #<a href="/tags/ios/">iOS</a>&nbsp;
        
          #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Source Code</th>
<th align="center">Demo</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2019-04-20</td>
<td align="center">é¦–æ¬¡æäº¤</td>
<td align="center"><a href="https://opensource.apple.com/tarballs/objc4/">objc4-750</a></td>
<td align="center"><a href="https://github.com/kingcos/Perspective/tree/writing/Posts/Practice/%2Bload_in_iOS">Load_Obj-C_Demo</a></td>
</tr>
</tbody>
</table>

<h2 id="preface">Preface</h2>

<p>åœ¨ iOS å¼€å‘ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸ä¼šä½¿ç”¨ +load æ–¹æ³•æ¥åšä¸€äº›åœ¨ <code>main</code> å‡½æ•°ä¹‹å‰çš„æ“ä½œï¼Œæ¯”å¦‚æ–¹æ³•äº¤æ¢ï¼ˆMethod Swizzleï¼‰ç­‰ã€‚é‚£ä¹ˆ +load åˆ°åº•æ˜¯å¦‚ä½•è¢«è°ƒç”¨çš„å‘¢ï¼Ÿ</p>

<h2 id="what">What</h2>

<pre><code class="language-objectivec">// NSObject.h
@interface NSObject &lt;NSObject&gt; {
+ (void)load;
}
</code></pre>

<p>Obj-C ä¸­çš„ +load æ–¹æ³•æŒ‡çš„æ˜¯ NSObject ä¸­çš„ <code>+ (void)load</code> ç±»æ–¹æ³•ã€‚å®˜æ–¹æ–‡æ¡£ä¸­çš„ +load å¦‚ä¸‹ï¼š</p>

<blockquote>
<p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</p>

<p>The <code>load</code> message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.</p>

<p>The order of initialization is as follows:</p>

<ol>
<li>All initializers in any framework you link to.</li>
<li>All <code>+load</code> methods in your image.</li>
<li>All C++ static initializers and C/C++ <code>__attribute__(constructor)</code> functions in your image.</li>
<li>All initializers in frameworks that link to you.</li>
</ol>

<p>In addition:</p>

<ul>
<li>A classâ€™s <code>+load</code> method is called after all of its superclassesâ€™ <code>+load</code> methods.</li>
<li>A category <code>+load</code> method is called after the classâ€™s own <code>+load</code> method.</li>
</ul>

<p>In a custom implementation of <code>load</code> you can therefore safely message other unrelated classes from the same image, but any <code>load</code> methods implemented by those classes may not have run yet.</p>

<blockquote>
<p><strong>Important</strong></p>

<p>Custom implementations of the <code>load</code> method for Swift classes bridged to Objective-C are not called automatically.</p>
</blockquote>

<p>â€”â€” Documentation, Apple Developer</p>

<p>è¯‘ï¼š</p>

<p>å½“ç±»æˆ–åˆ†ç±»è¢«æ·»åŠ åˆ° Obj-C è¿è¡Œæ—¶çš„æ—¶å€™è¢«è°ƒç”¨ï¼›å¯ä»¥å®ç°è¯¥æ–¹æ³•ç”¨æ¥åœ¨åŠ è½½æ—¶åˆ»æ‰§è¡Œç‰¹å®šç±»çš„æ“ä½œã€‚</p>

<p>åŠ¨æ€åŠ è½½å’Œé™æ€é“¾æ¥éƒ½èƒ½å°† <code>load</code> æ¶ˆæ¯å‘é€åˆ°ç±»å’Œåˆ†ç±»ï¼Œä½†å‰ææ˜¯æ–°åŠ è½½ç±»æˆ–åˆ†ç±»å®ç°äº†è¦å“åº”çš„æ–¹æ³•ã€‚</p>

<p>åˆå§‹åŒ–çš„é¡ºåºå¦‚ä¸‹ï¼š</p>

<ol>
<li>é“¾æ¥çš„æ‰€æœ‰æ¡†æ¶ï¼ˆFrameworkï¼‰ä¸­å…¨éƒ¨çš„æ„é€ å™¨ã€‚</li>
<li>é•œåƒï¼ˆImageï¼‰ä¸­æ‰€æœ‰çš„ <code>+load</code> æ–¹æ³•ã€‚</li>
<li>é•œåƒä¸­æ‰€æœ‰çš„ C++ é™æ€æ„é€ å™¨ï¼Œä»¥åŠ C/C++ çš„ <code>__attribute__(constructor)</code> å‡½æ•°ã€‚</li>
<li>æ¡†æ¶ä¸­é“¾æ¥çš„æ‰€æœ‰æ„é€ å™¨ã€‚</li>
</ol>

<p>å¦å¤–ï¼š</p>

<ul>
<li>ç±»çš„ <code>+load</code> æ–¹æ³•åœ¨å…¶æ‰€æœ‰çˆ¶ç±»çš„ <code>+load</code> æ–¹æ³•è°ƒç”¨ä¹‹åè°ƒç”¨ã€‚</li>
<li>åˆ†ç±»çš„ <code>+load</code> æ–¹æ³•åœ¨å…¶ä¸»ç±»çš„ <code>+load</code> æ–¹æ³•è°ƒç”¨ä¹‹åè°ƒç”¨ã€‚</li>
</ul>

<p>åœ¨ <code>load</code> çš„è‡ªå®šä¹‰å®ç°ä¸­ï¼Œå¯ä»¥å®‰å…¨åœ°ä»åŒä¸€é•œåƒä¸­å‘é€å…¶ä»–ä¸ç›¸å…³çš„ç±»ï¼Œä½†è¿™äº›ç±»ä¸­å®ç°çš„ <code>load</code> æ–¹æ³•å¯èƒ½è¿˜æ²¡æœ‰è¿è¡Œã€‚</p>

<blockquote>
<p><strong>é‡ç‚¹</strong></p>

<p>Swift ç±»ä¸­æ¡¥æ¥åˆ° Obj-C çš„ <code>load</code> æ–¹æ³•è‡ªå®šä¹‰å®ç°å°†ä¸ä¼šè‡ªåŠ¨è°ƒç”¨ã€‚</p>
</blockquote>

<p>â€”â€” æ–‡æ¡£ï¼Œè‹¹æœå¼€å‘è€…</p>
</blockquote>

<h2 id="how">How</h2>

<p>æ ¹æ®å®˜æ–¹æ–‡æ¡£çš„æè¿°ï¼Œæˆ‘ä»¬å¯ä»¥å°è¯•å®šä¹‰ä¸€ä¸ªç»§æ‰¿è‡ª <code>NSObject</code> çš„ <code>Person</code> ç±»ï¼Œå¹¶å¯¹å…¶æ·»åŠ ä¸¤ä¸ªåˆ†ç±» <code>Life</code> å’Œ <code>Work</code>ï¼›å†å®šä¹‰ä¸€ä¸ª <code>Student</code> ç±»ç»§æ‰¿è‡ª <code>Person</code>ï¼Œå¹¶å¯¹å…¶æ·»åŠ  <code>School</code> åˆ†ç±»ã€‚åœ¨ä»¥ä¸Šæ‰€æœ‰ç±»å’Œåˆ†ç±»ä¸­ï¼Œå‡å®ç° +loadï¼š</p>

<pre><code class="language-objectivec">// Person.m
#import &quot;Person.h&quot;

@implementation Person
+ (void)load {
    NSLog(@&quot;Person %s&quot;, __func__);
}
@end

// Person+Life.m
#import &quot;Person+Life.h&quot;

@implementation Person (Life)
+ (void)load {
    NSLog(@&quot;Person+Life %s&quot;, __func__);
}
@end

// Person+Work.m
#import &quot;Person+Work.h&quot;

@implementation Person (Work)
+ (void)load {
    NSLog(@&quot;Person+Work %s&quot;, __func__);
}
@end

// Student.m
#import &quot;Student.h&quot;

@implementation Student
+ (void)load {
    NSLog(@&quot;Student %s&quot;, __func__);
}
@end

// Student+School.m
#import &quot;Student+School.h&quot;

@implementation Student (School)
+ (void)load {
    NSLog(@&quot;Student+School %s&quot;, __func__);
}
@end

// OUTPUT:
// Person +[Person load]
// Student +[Student load]
// Person+Life +[Person(Life) load]
// Student+School +[Student(School) load]
// Person+Work +[Person(Work) load]
// Hello, World!
</code></pre>

<p>ä¸éœ€è¦æ›´æ”¹ main.mï¼Œå°è¯•è¿è¡Œç¨‹åºï¼Œç»“æœæ­£å¦‚å®˜æ–¹æ‰€è¿°ï¼Œå³ <strong>+load æ–¹æ³•ä¼šåœ¨ <code>main</code> å‡½æ•°ä¹‹å‰è¢«è°ƒç”¨ï¼›ä¸”è°ƒç”¨é¡ºåºæ€»æ˜¯å…ˆçˆ¶ç±»å†å­ç±»å†åˆ†ç±»</strong>ã€‚</p>

<h2 id="why">Why</h2>

<h3 id="å®ç°åŸç†">å®ç°åŸç†</h3>

<blockquote>
<p><strong>Obj-C è¿è¡Œæ—¶çš„å…¥å£æ˜¯å“ªé‡Œå‘¢ï¼Ÿ</strong></p>

<p>åœ¨ objc4 æºç ä¸­æœ‰ä¸€ä¸ªã€Œlibobjc.orderã€çš„æ–‡ä»¶ï¼Œåˆ—ä¸¾äº†è¯¥åº“æ–¹æ³•ç¬¦å·çš„è°ƒç”¨é¡ºåºï¼Œæˆ‘ä»¬èƒ½çœ‹åˆ°ç¬¬ä¸€ä¸ªå°±æ˜¯ <code>__objc_init</code>ã€‚ç¼–è¯‘æ—¶ï¼ŒC/C++ æ–¹æ³•å‰ä¼šè¢«è‡ªåŠ¨åŠ ä¸Š <code>_</code> å‰ç¼€ä½œä¸ºæ–¹æ³•ç¬¦å·ï¼ˆè¿™ä¸€ç‚¹å¯ä»¥åœ¨åˆ†æ Link Map æˆ–è€… Mach-O æ—¶è¯æ˜ï¼‰ï¼Œå› æ­¤è¿™é‡Œç¬¬ä¸€ä¸ªæœ¬è´¨å°±æ˜¯ <code>_objc_init</code>ã€‚</p>

<p><img src="/img/2019/+load_in_ios/1.png" alt="1" /></p>
</blockquote>

<p>ä¸ºäº†è¯æ˜ä¸Šè¿°ç»“è®ºï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ objc4 çš„æºç ä¸­ï¼Œä» Obj-C è¿è¡Œæ—¶åˆå§‹åŒ–çš„å…¥å£ç€æ‰‹ï¼Œå³ <code>_objc_init</code>ï¼š</p>

<pre><code class="language-objectivec">// objc-os.mm
/***********************************************************************
* _objc_init
* Bootstrap initialization. Registers our image notifier with dyld.
* å¼•å¯¼åˆå§‹åŒ–ã€‚ä½¿ç”¨ dyld æ³¨å†Œé•œåƒé€šçŸ¥å™¨ã€‚
* Called by libSystem BEFORE library initialization time
* åœ¨åº“åˆå§‹åŒ–æ—¶é—´ä¹‹å‰ç”± libSystem è°ƒç”¨
**********************************************************************/

void _objc_init(void)
{
    static bool initialized = false;
    if (initialized) return;
    initialized = true;

    // fixme defer initialization until an objc-using image is found?
    environ_init();
    tls_init();
    static_init();
    lock_init();
    exception_init();

    // â¡ï¸ dyld æ³¨å†Œé€šçŸ¥ï¼›map_imagesï¼šæ˜ å°„é•œåƒï¼Œload_imagesï¼šåŠ è½½é•œåƒï¼Œunmap_imageï¼šåæ˜ å°„é•œåƒ
    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);
}

// objc-runtime-new.mm
/***********************************************************************
* load_images
* Process +load in the given images which are being mapped in by dyld.
* ç”± dyld å¤„ç†ç»™å®šå°†è¦æ˜ å°„çš„é•œåƒä¸­çš„ +loadã€‚
*
* Locking: write-locks runtimeLock and loadMethodLock
* é”ï¼šå†™é” runtimeLock å’Œ loadMethodLock
**********************************************************************/
extern bool hasLoadMethods(const headerType *mhdr);
extern void prepare_load_methods(const headerType *mhdr);

void
load_images(const char *path __unused, const struct mach_header *mh)
{
    // Return without taking locks if there are no +load methods here.
    // â¡ï¸ å¦‚æœæ²¡æœ‰ +load æ–¹æ³•åˆ™è¿”å›
    if (!hasLoadMethods((const headerType *)mh)) return;

    // é€’å½’é”
    recursive_mutex_locker_t lock(loadMethodLock);

    // Discover load methods
    // å‘ç° load æ–¹æ³•
    {
        // äº’æ–¥é”
        mutex_locker_t lock2(runtimeLock);
        // â¡ï¸ å‡†å¤‡åŠ è½½ load æ–¹æ³•
        prepare_load_methods((const headerType *)mh);
    }

    // Call +load methods (without runtimeLock - re-entrant)
    // â¡ï¸ è°ƒç”¨ +load æ–¹æ³•ï¼ˆä¸å¸¦ runtimeLock - å¯é‡å…¥çš„ï¼ˆçº¿ç¨‹å®‰å…¨çš„ï¼‰ï¼‰
    call_load_methods();
}

// objc-runtime-new.mm
// Quick scan for +load methods that doesn't take a lock.
// ä¸éœ€è¦åŠ é”åœ°å¿«é€Ÿæœç´¢ +load æ–¹æ³•
bool hasLoadMethods(const headerType *mhdr)
{
    size_t count;
    // éæ‡’åŠ è½½ç±»åˆ—è¡¨ï¼ˆå– Mach-O ä¸­ __objc_nlclslist èŠ‚ï¼‰
    // GETSECT(_getObjc2NonlazyClassList,    classref_t,      &quot;__objc_nlclslist&quot;);
    if (_getObjc2NonlazyClassList(mhdr, &amp;count)  &amp;&amp;  count &gt; 0) return true;
    // éæ‡’åŠ è½½åˆ†ç±»åˆ—è¡¨ï¼ˆå– Mach-O ä¸­ __objc_nlcatlist èŠ‚ï¼‰
    // GETSECT(_getObjc2NonlazyCategoryList, category_t *,    &quot;__objc_nlcatlist&quot;);
    if (_getObjc2NonlazyCategoryList(mhdr, &amp;count)  &amp;&amp;  count &gt; 0) return true;
    return false;
}

// objc-runtime-new.mm
void prepare_load_methods(const headerType *mhdr)
{
    size_t count, i;

    // æ–­è¨€ runtimeLock å·²é”
    runtimeLock.assertLocked();

    // 1. éæ‡’åŠ è½½ç±»åˆ—è¡¨
    classref_t *classlist =
        _getObjc2NonlazyClassList(mhdr, &amp;count);
    // éå†æ‰€æœ‰ç±»
    for (i = 0; i &lt; count; i++) {
        // â¡ï¸ è®¡åˆ’ +load æ–¹æ³•è°ƒç”¨
        schedule_class_load(remapClass(classlist[i]));
    }

    // 2. éæ‡’åŠ è½½åˆ†ç±»åˆ—è¡¨
    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);
    // éå†æ‰€æœ‰åˆ†ç±»
    for (i = 0; i &lt; count; i++) {
        category_t *cat = categorylist[i];
        // é‡æ˜ å°„åˆ†ç±»çš„ä¸»ç±»
        Class cls = remapClass(cat-&gt;cls);
        if (!cls) continue;  // category for ignored weak-linked class å¿½ç•¥å¼±é“¾æ¥ä¸»ç±»çš„åˆ†ç±»
        // å®åŒ–ç±»ï¼ˆä¸º cls æ‰§è¡Œä¸€æ¬¡æ€§åˆå§‹åŒ–ç­‰æ“ä½œï¼‰
        realizeClass(cls);
        // æ–­è¨€ç±»çš„ isaï¼ˆå…ƒç±»ï¼‰å·²å®åŒ–
        assert(cls-&gt;ISA()-&gt;isRealized());
        // â¡ï¸ æ·»åŠ åˆ†ç±»åˆ°å¯åŠ è½½åˆ—è¡¨
        add_category_to_loadable_list(cat);
    }
}

// objc-runtime-new.mm
static Class remapClass(classref_t cls)
{
    â¡ï¸ é‡æ˜ å°„ç±»
    return remapClass((Class)cls);
}

// objc-runtime-new.mm
/***********************************************************************
* remapClass
* Returns the live class pointer for cls, which may be pointing to
* a class struct that has been reallocated.
* ä¸ºå‚æ•° cls è¿”å›å¯èƒ½æŒ‡å‘å·²ç»é‡æ–°åˆ†é…ç±»ç»“æ„åˆ°æ´»ç±»æŒ‡é’ˆã€‚
* Returns nil if cls is ignored because of weak linking.
* å¦‚æœç±»æ˜¯å¼±é“¾æ¥ï¼Œå°†è¿”å› nilã€‚
* Locking: runtimeLock must be read- or write-locked by the caller
* é”ï¼šruntimeLock å¿…é¡»ç”±è°ƒç”¨è€…è¯»å–æˆ–å†™å…¥é”å®šã€‚
**********************************************************************/
static Class remapClass(Class cls)
{
    // æ–­è¨€ runtimeLock å·²é”
    runtimeLock.assertLocked();

    Class c2;

    if (!cls) return nil;

    NXMapTable *map = remappedClasses(NO);
    // ä» map ä¸­å– cls å¯¹åº”çš„å€¼
    // void *NXMapMember(NXMapTable *table, const void *key, void **value)
    if (!map  ||  NXMapMember(map, cls, (void**)&amp;c2) == NX_MAPNOTAKEY) {
        return cls;
    } else {
        return c2;
    }
}

// objc-runtime-new.mm
/***********************************************************************
* prepare_load_methods
* Schedule +load for classes in this image, any un-+load-ed
* superclasses in other images, and any categories in this image.
* ä¸ºå½“å‰é•œåƒä¸­çš„ç±»ã€å…¶å®ƒé•œåƒä¸­æ‰€æœ‰æœªè°ƒç”¨è¿‡ +load çš„çˆ¶ç±»ã€ä»¥åŠè¯¥é•œåƒä¸­çš„æ‰€æœ‰çš„åˆ†ç±»è®¡åˆ’è°ƒç”¨ +loadã€‚
**********************************************************************/
// Recursively schedule +load for cls and any un-+load-ed superclasses.
// ä¸º cls ä»¥åŠæ‰€æœ‰æœªè°ƒç”¨è¿‡ +load çš„çˆ¶ç±»é€’å½’è®¡åˆ’è°ƒç”¨ +loadã€‚
// cls must already be connected.
// cls å¿…é¡»å·²è¢«è¿æ¥ã€‚
static void schedule_class_load(Class cls)
{
    if (!cls) return;
    // æ–­è¨€ç±»æ˜¯å®åŒ–çš„
    assert(cls-&gt;isRealized());  // _read_images should realize

    // åˆ¤æ–­ç±»çš„ +load æ˜¯å¦å·²ç»è¢«è°ƒç”¨
    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;

    // Ensure superclass-first ordering
    // ï¼ˆé€’å½’ï¼‰ç¡®ä¿çˆ¶ç±»ä¼˜å…ˆè°ƒç”¨ +load
    schedule_class_load(cls-&gt;superclass);

    // â¡ï¸ æ·»åŠ ç±»åˆ°å¯åŠ è½½åˆ—è¡¨
    add_class_to_loadable_list(cls);
    // è®¾ç½®æœ¬ç±» +load å·²è°ƒç”¨è¿‡
    cls-&gt;setInfo(RW_LOADED);
}



// objc-loadmethod.mm
/***********************************************************************
* add_class_to_loadable_list
* Class cls has just become connected. Schedule it for +load if
* it implements a +load method.
* cls åˆšåˆšè¢«è¿æ¥ã€‚å¦‚æœå…¶å®ç°äº† +load æ–¹æ³•å°±å°†è®¡åˆ’è°ƒç”¨ã€‚
**********************************************************************/
void add_class_to_loadable_list(Class cls)
{
    IMP method;

    // æ–­è¨€ loadMethodLock å·²é”
    loadMethodLock.assertLocked();

    // â¡ï¸ è·å–ç±» load æ–¹æ³•
    method = cls-&gt;getLoadMethod();
    if (!method) return;  // Don't bother if cls has no +load method æ²¡æœ‰ +load å°±è¿”å›

    // Xcode ä¸­ OBJC_PRINT_LOAD_METHODS ç¯å¢ƒå˜é‡å€¼ä¸º YES æ—¶ï¼Œå°†å¯åœ¨æ§åˆ¶å°æ‰“å°è¯¥ä¿¡æ¯
    // OPTION(PrintLoading, OBJC_PRINT_LOAD_METHODS, &quot;log calls to class and category +load methods&quot;)
    if (PrintLoading) {
        _objc_inform(&quot;LOAD: class '%s' scheduled for +load&quot;,
                     cls-&gt;nameForLogging());
    }

    // å¦‚æœä½¿ç”¨çš„ == åˆ†é…çš„ï¼Œéœ€è¦æ‰©å®¹
    if (loadable_classes_used == loadable_classes_allocated) {
        loadable_classes_allocated = loadable_classes_allocated*2 + 16;
        loadable_classes = (struct loadable_class *)
            realloc(loadable_classes,
                              loadable_classes_allocated *
                              sizeof(struct loadable_class));
    }

    // æ·»åŠ åˆ° loadable_classesï¼ˆå°†åœ¨ call_class_loads ä¸­å®é™…è°ƒç”¨ï¼‰
    loadable_classes[loadable_classes_used].cls = cls;
    loadable_classes[loadable_classes_used].method = method;
    loadable_classes_used++;
}

// objc-runtime-new.mm
/***********************************************************************
* objc_class::getLoadMethod
* fixme
* Called only from add_class_to_loadable_list.
* åªåœ¨ add_class_to_loadable_list ä¸­è°ƒç”¨ã€‚
* Locking: runtimeLock must be read- or write-locked by the caller.
* é”ï¼šruntimeLock å¿…é¡»ç”±è°ƒç”¨è€…è¯»å–æˆ–å†™å…¥é”å®šã€‚
**********************************************************************/
IMP
objc_class::getLoadMethod()
{
    runtimeLock.assertLocked();

    const method_list_t *mlist;

    // æ–­è¨€
    assert(isRealized());
    assert(ISA()-&gt;isRealized());
    assert(!isMetaClass());
    assert(ISA()-&gt;isMetaClass());

    // ä»åªè¯»åˆ—è¡¨ä¸­è¯»å– baseMethodsï¼ˆå¯å‚è€ƒã€ŒiOS ä¸­çš„ NSObjectã€ï¼‰
    mlist = ISA()-&gt;data()-&gt;ro-&gt;baseMethods();
    if (mlist) {
        // éå†
        for (const auto&amp; meth : *mlist) {
            // è·å– selector åç§°
            const char *name = sel_cname(meth.name);
            if (0 == strcmp(name, &quot;load&quot;)) {
                // è‹¥ä¸º load æ–¹æ³•ï¼Œåˆ™è¿”å› IMP
                return meth.imp;
            }
        }
    }

    return nil;
}

// objc-loadmethod.mm
/***********************************************************************
* add_category_to_loadable_list
* Category cat's parent class exists and the category has been attached
* to its class. Schedule this category for +load after its parent class
* becomes connected and has its own +load method called.
* åˆ†ç±» cat çš„ä¸»ç±»å­˜åœ¨ï¼Œä¸”åˆ†ç±»å·²ç»è¿æ¥åˆ°ä¸»ç±»çš„ç±»ä¸Šäº†ã€‚åœ¨çˆ¶ç±»è¿æ¥ä¸”è°ƒç”¨äº† +load åè®¡åˆ’è°ƒç”¨è¯¥åˆ†ç±»çš„ +loadã€‚
**********************************************************************/
void add_category_to_loadable_list(Category cat)
{
    IMP method;

    // æ–­è¨€ loadMethodLock å·²é”
    loadMethodLock.assertLocked();

    // â¡ï¸ è·å–åˆ†ç±» load æ–¹æ³•
    method = _category_getLoadMethod(cat);

    // Don't bother if cat has no +load method
    // æ²¡æœ‰ +load å°±è¿”å›
    if (!method) return;

    // OPTION(PrintLoading, OBJC_PRINT_LOAD_METHODS, &quot;log calls to class and category +load methods&quot;)
    if (PrintLoading) {
        _objc_inform(&quot;LOAD: category '%s(%s)' scheduled for +load&quot;,
                     _category_getClassName(cat), _category_getName(cat));
    }

    // å¦‚æœä½¿ç”¨çš„ == åˆ†é…çš„ï¼Œéœ€è¦æ‰©å®¹
    if (loadable_categories_used == loadable_categories_allocated) {
        loadable_categories_allocated = loadable_categories_allocated*2 + 16;
        loadable_categories = (struct loadable_category *)
            realloc(loadable_categories,
                              loadable_categories_allocated *
                              sizeof(struct loadable_category));
    }

	 // å­˜å…¥ loadable_categoriesï¼ˆå°†åœ¨ call_category_loads ä¸­å®é™…è°ƒç”¨ï¼‰
    loadable_categories[loadable_categories_used].cat = cat;
    loadable_categories[loadable_categories_used].method = method;
    loadable_categories_used++;
}

// objc-runtime-new.mm
/***********************************************************************
* _category_getLoadMethod
* fixme
* Called only from add_category_to_loadable_list
* åªåœ¨ add_category_to_loadable_list ä¸­è°ƒç”¨
* Locking: runtimeLock must be read- or write-locked by the caller
* é”ï¼šruntimeLock å¿…é¡»ç”±è°ƒç”¨è€…è¯»å–æˆ–å†™å…¥é”å®šã€‚
**********************************************************************/
IMP
_category_getLoadMethod(Category cat)
{
    // æ–­è¨€ loadMethodLock å·²é”
    runtimeLock.assertLocked();

    const method_list_t *mlist;

    // åˆ†ç±»ä¸­ç±»æ–¹æ³•åˆ—è¡¨
    mlist = cat-&gt;classMethods;
    if (mlist) {
        // éå†
        for (const auto&amp; meth : *mlist) {
            // è·å– selector åç§°
            const char *name = sel_cname(meth.name);
            if (0 == strcmp(name, &quot;load&quot;)) {
                // è‹¥ä¸º load æ–¹æ³•ï¼Œåˆ™è¿”å› IMP
                return meth.imp;
            }
        }
    }

    return nil;
}

// objc-loadmethod.mm
/***********************************************************************
* call_load_methods
* Call all pending class and category +load methods.
* è°ƒç”¨æ‰€æœ‰ç±»å’Œåˆ†ç±»çš„ +load  æ–¹æ³•ã€‚
* Class +load methods are called superclass-first.
* ç±»çš„ +load æ–¹æ³•å°†å…ˆè°ƒç”¨çˆ¶ç±»çš„ã€‚
* Category +load methods are not called until after the parent class's +load.
* åˆ†ç±»çš„ +load æ‰éœ€è¦ç­‰åˆ°å…¶ä¸»ç±»çš„ +load è°ƒç”¨åæ‰è°ƒç”¨ã€‚
*
* This method must be RE-ENTRANT, because a +load could trigger
* more image mapping. In addition, the superclass-first ordering
* must be preserved in the face of re-entrant calls. Therefore,
* only the OUTERMOST call of this function will do anything, and
* that call will handle all loadable classes, even those generated
* while it was running.
* è¯¥æ–¹æ³•å¿…é¡»æ˜¯å¯é‡å…¥çš„ï¼ˆçº¿ç¨‹å®‰å…¨çš„ï¼‰ï¼Œå› ä¸º +load å¯èƒ½è§¦å‘æ›´å¤šé•œåƒæ˜ å°„ã€‚
* å¦å¤–ï¼Œé¢å¯¹å¯é‡å…¥è°ƒç”¨æ—¶ï¼Œå¿…é¡»ä¿ç•™çˆ¶ç±»ä¼˜å…ˆæ’åºã€‚
* å› æ­¤ï¼Œåªæœ‰å½“è¯¥å‡½æ•°åœ¨æœ€åè°ƒç”¨æ‰ä¼šæ‰§è¡Œå…¨éƒ¨æ“ä½œï¼Œä¸”è¯¥è°ƒç”¨å°†å¤„ç†æ‰€æœ‰å¯åŠ è½½çš„ç±»ï¼Œç”šè‡³æ˜¯åœ¨è¿è¡Œæ—¶ç”Ÿæˆçš„ç±»ã€‚
*
* The sequence below preserves +load ordering in the face of
* image loading during a +load, and make sure that no
* +load method is forgotten because it was added during
* a +load call.
* ä¸‹é¢çš„é¡ºåºä¿ç•™äº†åœ¨é¢å¯¹ +load ä¸­åŠ è½½é•œåƒçš„ +load æ’åºï¼Œå¹¶ä¸”å› ä¸ºå®ƒæ˜¯åœ¨ä¸€ä¸ª +load è°ƒç”¨ä¸­è¢«æ·»åŠ çš„ï¼Œå› æ­¤å¯ä»¥ä¿è¯æ²¡æœ‰ +load è¢«é—å¿˜ï¼Œã€‚
* Sequence:
* é¡ºåº
* 1. Repeatedly call class +loads until there aren't any more
* 1. é‡å¤è°ƒç”¨ç±» +load ç›´åˆ°ä¸å†æœ‰æœªè°ƒç”¨çš„ +load
* 2. Call category +loads ONCE.
* 2. è°ƒç”¨åˆ†ç±» +load ä¸€æ¬¡
* 3. Run more +loads if:
* 3. æ‰§è¡Œå¤šæ¬¡ +load çš„æƒ…å†µï¼š
*    (a) there are more classes to load, OR
*    (a) æœ‰å¤šä¸ªç±»è¦åŠ è½½ï¼Œæˆ–è€…
*    (b) there are some potential category +loads that have
*        still never been attempted.
*    (b) æœ‰ä¸€äº›æ½œåœ¨çš„åˆ†ç±» +load ä»æœªå°è¯•ã€‚
* Category +loads are only run once to ensure &quot;parent class first&quot;
* ordering, even if a category +load triggers a new loadable class
* and a new loadable category attached to that class.
* åˆ†ç±»ä¸­çš„ +load åªä¼šè¢«æ‰§è¡Œä¸€æ¬¡ï¼Œå¹¶ä¿è¯ã€Œçˆ¶ç±»ä¼˜å…ˆã€æ’åºï¼Œå°½ç®¡ä¸€ä¸ªåˆ†ç±»çš„ +load è§¦å‘äº†ä¸€ä¸ªæ–°çš„å¯åŠ è½½çš„ç±»ä»¥åŠé™„åŠ è¯¥ç±»çš„ä¸€ä¸ªæ–°çš„å¯åŠ è½½çš„åˆ†ç±»ã€‚
*
* Locking: loadMethodLock must be held by the caller
* é”ï¼šloadMethodLock å¿…é¡»ç”±è°ƒç”¨è€…æŒæœ‰
*   All other locks must not be held.
*   æ‰€æœ‰å…¶å®ƒé”å¿…é¡»ä¸æŒæœ‰ã€‚
**********************************************************************/
void call_load_methods(void)
{
    static bool loading = NO;
    bool more_categories;

    // æ–­è¨€ loadMethodLock å·²é”
    loadMethodLock.assertLocked();

    // Re-entrant calls do nothing; the outermost call will finish the job.
    // é‡å…¥çš„è°ƒç”¨ä¸åšäº‹æƒ…ï¼Œæœ€æ—©çš„è°ƒç”¨å°†å®Œæˆä»»åŠ¡
    if (loading) return;
    loading = YES;

    void *pool = objc_autoreleasePoolPush();

    do {
        // 1. Repeatedly call class +loads until there aren't any more
        // 1. é‡å¤è°ƒç”¨ç±» +loadï¼Œç›´åˆ°å…¨éƒ¨è°ƒç”¨åˆ°
        while (loadable_classes_used &gt; 0) {
            // â¡ï¸ è°ƒç”¨ç±»çš„ +load æ–¹æ³•
            call_class_loads();
        }

        // 2. Call category +loads ONCE
        // 2. â¡ï¸ è°ƒç”¨åˆ†ç±» +load ä¸€æ¬¡
        more_categories = call_category_loads();

        // 3. Run more +loads if there are classes OR more untried categories
        // 3.å¦‚æœæœ‰ç±»æˆ–è€…æ›´å¤šæœªå°è¯•çš„åˆ†ç±»åˆ™è¿è¡Œæ›´å¤šçš„ +load
    } while (loadable_classes_used &gt; 0  ||  more_categories);

    objc_autoreleasePoolPop(pool);

    loading = NO;
}

// objc-loadmethod.mm
/***********************************************************************
* call_class_loads
* Call all pending class +load methods.
* è°ƒç”¨æ‰€æœ‰ç±»çš„ +load æ–¹æ³•ã€‚
* If new classes become loadable, +load is NOT called for them.
* å¦‚æœæœ‰æ–°çš„ç±»å˜ä¸ºå¯åŠ è½½çš„ï¼Œå®ƒä»¬çš„ +load ä¸ä¼šè¢«è°ƒç”¨
*
* Called only by call_load_methods().
* åªèƒ½ç”± call_load_methods() è°ƒç”¨ã€‚
**********************************************************************/
static void call_class_loads(void)
{
    int i;

    // Detach current loadable list.
    // åˆ†ç¦»å½“å‰å¯åŠ è½½åˆ—è¡¨ã€‚
    struct loadable_class *classes = loadable_classes;
    int used = loadable_classes_used;
    loadable_classes = nil;
    loadable_classes_allocated = 0;
    loadable_classes_used = 0;

    // Call all +loads for the detached list.
    // åœ¨åˆ†ç¦»çš„è¡¨ä¸­è°ƒç”¨æ‰€æœ‰ +loadã€‚
    for (i = 0; i &lt; used; i++) {
        Class cls = classes[i].cls;
        load_method_t load_method = (load_method_t)classes[i].method;
        if (!cls) continue;

        // OPTION(PrintLoading, OBJC_PRINT_LOAD_METHODS, &quot;log calls to class and category +load methods&quot;)
        if (PrintLoading) {
            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());
        }
        // ğŸ’¡ è°ƒç”¨ +load
        (*load_method)(cls, SEL_load);
    }

    // Destroy the detached list.
    // é”€æ¯åˆ†ç¦»åˆ—è¡¨
    if (classes) free(classes);
}

// objc-loadmethod.mm
/***********************************************************************
* call_category_loads
* Call some pending category +load methods.
* è°ƒç”¨ä¸€äº›åˆ†ç±»ä¸­æœªè°ƒç”¨çš„ +load æ–¹æ³•ã€‚
* The parent class of the +load-implementing categories has all of
*   its categories attached, in case some are lazily waiting for +initalize.
* å®ç° +load åˆ†ç±»çš„çˆ¶ç±»æ‹¥æœ‰æ‰€æœ‰å…¶é™„åŠ çš„åˆ†ç±» ï¼Œæ¥é˜²æ­¢ç­‰å¾… +initialize æ‡’åŠ è½½ã€‚
*
* Don't call +load unless the parent class is connected.
* If new categories become loadable, +load is NOT called, and they
*   are added to the end of the loadable list, and we return TRUE.
* Return FALSE if no new categories became loadable.
* é™¤éçˆ¶ç±»å·²ç»è¿æ¥ï¼Œå¦åˆ™ä¸è¦è°ƒç”¨ +loadã€‚
* å¦‚æœæ–°çš„åˆ†ç±»å˜æˆå¯åŠ è½½çš„ï¼Œ+load æœªè¢«è°ƒç”¨ï¼Œå¹¶ä¸”å®ƒä»¬è¢«æ·»åŠ åˆ°å¯åŠ è½½åˆ—è¡¨çš„æœ«å°¾ï¼Œè¿”å› TRUEã€‚
* å¦‚æœæ²¡æœ‰æ–°çš„åˆ†ç±»å˜ä¸ºå¯åŠ è½½çš„ï¼Œè¿”å› FALSEã€‚
*
* Called only by call_load_methods().
* åªèƒ½ç”± call_load_methods() è°ƒç”¨ã€‚
**********************************************************************/
static bool call_category_loads(void)
{
    int i, shift;
    bool new_categories_added = NO;

    // Detach current loadable list.
    // åˆ†ç¦»å½“å‰å¯åŠ è½½åˆ—è¡¨ã€‚
    struct loadable_category *cats = loadable_categories;
    int used = loadable_categories_used;
    int allocated = loadable_categories_allocated;
    loadable_categories = nil;
    loadable_categories_allocated = 0;
    loadable_categories_used = 0;

    // Call all +loads for the detached list.
    // ä¸ºåˆ†ç¦»çš„åˆ—è¡¨è°ƒç”¨æ‰€æœ‰çš„ +loadã€‚
    for (i = 0; i &lt; used; i++) {
        Category cat = cats[i].cat;
        load_method_t load_method = (load_method_t)cats[i].method;
        Class cls;
        if (!cat) continue;

        // è·å–ä¸»ç±»
        cls = _category_getClass(cat);
        if (cls  &amp;&amp;  cls-&gt;isLoadable()) {
            // OPTION(PrintLoading, OBJC_PRINT_LOAD_METHODS, &quot;log calls to class and category +load methods&quot;)
            if (PrintLoading) {
                _objc_inform(&quot;LOAD: +[%s(%s) load]\n&quot;,
                             cls-&gt;nameForLogging(),
                             _category_getName(cat));
            }
            // ğŸ’¡ è°ƒç”¨ +load
            (*load_method)(cls, SEL_load);
            // ç½®ä¸ºç©º
            cats[i].cat = nil;
        }
    }

    // Compact detached list (order-preserving)
    // å‹ç¼©åˆ†ç¦»åˆ—è¡¨ï¼ˆä¿ç•™é¡ºåºï¼‰
    shift = 0;
    for (i = 0; i &lt; used; i++) {
        if (cats[i].cat) {
            cats[i-shift] = cats[i];
        } else {
            shift++;
        }
    }
    used -= shift;

    // Copy any new +load candidates from the new list to the detached list.
    // ä»æ–°çš„åˆ—è¡¨ä¸­æ‹·è´æ‰€æœ‰æ–°çš„ +load å€™é€‰åˆ°åˆ†ç¦»åˆ—è¡¨ã€‚
    new_categories_added = (loadable_categories_used &gt; 0);
    for (i = 0; i &lt; loadable_categories_used; i++) {
        if (used == allocated) {
            allocated = allocated*2 + 16;
            cats = (struct loadable_category *)
                realloc(cats, allocated *
                                  sizeof(struct loadable_category));
        }
        cats[used++] = loadable_categories[i];
    }

    // Destroy the new list.
    // é”€æ¯æ–°åˆ—è¡¨
    if (loadable_categories) free(loadable_categories);

    // Reattach the (now augmented) detached list.
    // é‡æ–°é™„åŠ ï¼ˆç°åœ¨å·²å¢åŠ çš„ï¼‰åˆ†ç¦»åˆ—è¡¨ã€‚
    // But if there's nothing left to load, destroy the list.
    // ä½†æ˜¯å¦‚æœæ²¡æœ‰ä»€ä¹ˆè¦åŠ è½½çš„ï¼Œåˆ™é”€æ¯è¯¥åˆ—è¡¨ã€‚
    if (used) {
        loadable_categories = cats;
        loadable_categories_used = used;
        loadable_categories_allocated = allocated;
    } else {
        if (cats) free(cats);
        loadable_categories = nil;
        loadable_categories_used = 0;
        loadable_categories_allocated = 0;
    }

    if (PrintLoading) {
        if (loadable_categories_used != 0) {
            _objc_inform(&quot;LOAD: %d categories still waiting for +load\n&quot;,
                         loadable_categories_used);
        }
    }

    return new_categories_added;
}
</code></pre>

<p>ä¸Šé¢çš„æºç è¿‡ç¨‹æ¯”è¾ƒå¤æ‚ï¼Œå…¶å®ä¸»è¦é¡ºåºå°±æ˜¯å…ˆåœ¨ <code>prepare_load_methods</code> ä¸­è°ƒç”¨ <code>schedule_class_load</code>ï¼Œå…ˆè®¡åˆ’ç±»çš„ +load æ–¹æ³•è°ƒç”¨é¡ºåºï¼Œåœ¨å…¶ä¸­ä¼šé€’å½’æ‰¾åˆ°åŸºç±»ï¼Œå¹¶ <code>add_class_to_loadable_list</code> å°†ç±»ä¸­ +load çš„ <code>IMP</code> å­˜å‚¨åœ¨ <code>loadable_classes</code>ï¼›ä¹‹ååœ¨ <code>prepare_load_methods</code> ä¸­è°ƒç”¨ <code>add_category_to_loadable_list</code>ï¼Œå†å°†åˆ†ç±»ä¸­ +load çš„ <code>IMP</code> å­˜å‚¨åœ¨ <code>loadable_categories</code>ï¼›å½“ç±»å’Œåˆ†ç±»çš„å¯åŠ è½½åˆ—è¡¨ç¡®å®šåï¼Œé¢„å¤‡ï¼ˆPrepareï¼‰å·¥ä½œå®Œæˆï¼›ä¹‹åå¼€å§‹ <code>call_load_methods</code>ï¼Œè°ƒç”¨ <code>call_class_loads</code> å°†ç±»ä¸­çš„ +load å…¨éƒ¨è°ƒç”¨å®Œæ¯•ï¼Œå†è°ƒç”¨ <code>call_category_loads</code> å°†åˆ†ç±»ä¸­çš„ +load å…¨éƒ¨è°ƒç”¨å®Œæ¯•ã€‚è¿™ä¹Ÿå°±å®Œå…¨ç¬¦åˆäº†æˆ‘ä»¬ä¸Šè¿°çš„ç»“è®ºï¼Œè‡³äºæ¯«æ— å…³ç³»çš„ç±»ä¹‹é—´ä»¥åŠåˆ†ç±»ç›¸äº’ä¹‹é—´çš„è°ƒç”¨é¡ºåºï¼Œç”±äº <code>loadable_classes</code> å’Œ <code>loadable_categories</code> çš„å¢åŠ éƒ½æ˜¯æŒ‰é¡ºåºè¿½åŠ ï¼Œå³æŒ‰ç…§ç¼–è¯‘é¡ºåºæ¥å†³å®šï¼Œå…ˆç¼–è¯‘å…ˆè°ƒç”¨ã€‚å…·ä½“çš„ç¼–è¯‘é¡ºåºå¯ä»¥åœ¨ Xcode -ã€ŒTARGETSã€ -ã€ŒBuild Phasesã€-ã€ŒCompile Sourcesã€ä¸­æ‰¾åˆ°ã€‚</p>

<p><img src="/img/2019/+load_in_ios/2.png" alt="2" /></p>

<h3 id="imp-ä¸-load">IMP ä¸ +load</h3>

<p>æŒ‰ç…§æˆ‘ä»¬ä¹‹å‰åœ¨ã€ŒiOS ä¸­çš„ Categoryã€ä¸€ç¯‡æ‰€æåˆ°çš„ï¼Œå½“åˆ†ç±»ä¸­å®šä¹‰äº†å’Œä¸»ç±»ä¸­ç›¸åŒçš„æ–¹æ³•ï¼Œé‚£ä¹ˆåœ¨è°ƒç”¨æ—¶å°†é€‰æ‹©æœ€åè¢«ç¼–è¯‘çš„åˆ†ç±»ä¸­çš„å®ç°ã€‚å› ä¸ºåœ¨è¿è¡Œæ—¶ï¼Œåˆ†ç±»ä¸­çš„æ–¹æ³•æœ€ç»ˆå°†é™„åŠ åˆ°ä¸»ç±»æˆ–ä¸»ç±»å…ƒç±»çš„æ–¹æ³•åˆ—è¡¨ä¸­ï¼Œæœ€ç»ˆå°†è¿”å›ç¬¬ä¸€ä¸ªæ‰¾åˆ°çš„æ–¹æ³•ã€‚é‚£ä¹ˆä¸ºä»€ä¹ˆ +load å¦‚æ­¤ç‰¹æ®Šå‘¢ï¼Ÿ</p>

<pre><code class="language-objectivec">// add_class_to_loadable_list
loadable_classes[loadable_classes_used].cls = cls;
loadable_classes[loadable_classes_used].method = method;

// objc-loadmethod.mm
typedef void(*load_method_t)(id, SEL);

load_method_t load_method = (load_method_t)classes[i].method;
(*load_method)(cls, SEL_load);
</code></pre>

<p>æˆ‘ä»¬çŸ¥é“ï¼ŒObj-C æ˜¯ä¸€é—¨æ¶ˆæ¯æœºåˆ¶è¯­è¨€ï¼Œæ‰€è°“æ–¹æ³•è°ƒç”¨æ˜¯ä¸ä¸¥è°¨çš„ï¼Œå…¶æœ¬è´¨æ˜¯æ¶ˆæ¯å‘é€ï¼ˆMessage Sendingï¼‰ï¼Œå³ <code>objc_msgSend</code>ã€‚å½“ã€Œè°ƒç”¨ã€å¯¹è±¡æ–¹æ³•æ—¶ï¼Œç±»å¯¹è±¡æ¥æ”¶åˆ°æ¶ˆæ¯ä½œå‡ºå“åº”ï¼›å½“ã€Œè°ƒç”¨ã€ç±»æ–¹æ³•æ—¶ï¼Œå…ƒç±»å¯¹è±¡æ¥æ”¶åˆ°æ¶ˆæ¯ä½œå‡ºå“åº”ã€‚è€Œåœ¨ +load æœ€ç»ˆçš„è°ƒç”¨å¤„åªæ˜¯ <code>(*load_method)(cls, SEL_load)</code>ï¼Œå¹¶ä¸å­˜åœ¨æ¶ˆæ¯çš„å‘é€ã€‚æˆ‘ä»¬åœ¨ <code>add_class_to_loadable_list</code> ä¸­ä¹Ÿå¯ä»¥çœ‹åˆ°ï¼Œ+load æ–¹æ³•æœ¬è´¨æ˜¯å­˜å‚¨äº†æ–¹æ³•æŒ‡é’ˆï¼ˆIMPï¼‰å¹¶ç›´æ¥è°ƒç”¨ï¼Œå› æ­¤ä¸ä¼šå‡ºç°ç±»ä¼¼ã€Œè¦†ç›–ã€çš„æƒ…å½¢ï¼Œè€Œä¸”æ•ˆç‡ä¼šæ›´é«˜ã€‚</p>

<pre><code class="language-objectivec">#import &quot;Student.h&quot;

@implementation Student
+ (void)load {
    [super load];
    NSLog(@&quot;Student %s&quot;, __func__);
}
@end

// OUTPUT:
// Person +[Person load]
// Person+Work +[Person(Work) load]
// Student +[Student load]
// Person+Life +[Person(Life) load]
// Student+School +[Student(School) load]
// Person+Work +[Person(Work) load]
// Hello, World!
</code></pre>

<p>é‚£ä¹ˆæœ‰äº†ä¸Šè¿°åŸºç¡€ï¼Œå½“æˆ‘ä»¬åœ¨ä¸€ä¸ªç±»çš„å­ç±»çš„ +load ä¸­ <code>[super load]</code> åˆä¼šè°ƒç”¨åˆ°åˆ°åº•å“ªä¸ªç±»ä¸­å‘¢ï¼ˆå½“ç„¶ï¼Œåœ¨å®é™…å¼€å‘ä¸­è¿™ç§æƒ…å‡ ä¹ä¸å¯èƒ½å­˜åœ¨ï¼‰ï¼Ÿç­”æ¡ˆå°±æ˜¯ <code>[super load]</code> å°†è°ƒç”¨åˆ° <code>Person</code> æœ€åä¸€ä¸ªè¢«ç¼–è¯‘çš„åˆ†ç±»ï¼ˆ<code>Person+Work</code>ï¼‰ä¸­çš„ <code>+load</code> æ–¹æ³•ï¼Œå› ä¸ºè¿™é‡Œæ˜¯æ¶ˆæ¯å‘é€ï¼Œè€Œä¸æ˜¯é€šè¿‡æ–¹æ³•æŒ‡é’ˆã€‚</p>

<h3 id="objc-print-load-methods"><code>OBJC_PRINT_LOAD_METHODS</code></h3>

<p>åœ¨ objc4 çš„æºç ä¸­æä¾›äº†å¾ˆå¤šç¯å¢ƒå˜é‡ï¼Œæ–¹ä¾¿æˆ‘ä»¬ Debug æ—¶è¾“å‡ºä¸€äº›å†…éƒ¨æºç çš„æ‰§è¡Œä¿¡æ¯ã€‚<code>OBJC_PRINT_LOAD_METHODS</code> å³æ˜¯ <code>+load</code> ç›¸å…³çš„ä¸€ä¸ªç¯å¢ƒå˜é‡ï¼Œå°† <code>OBJC_PRINT_LOAD_METHODS</code> åœ¨ Xcode ä¸­è®¾ç½®ä¸º <code>YES</code> åï¼Œå°†ä¼šæ‰“å°å‡ºå¾ˆå¤š +load æ–¹æ³•æ‰§è¡Œæ—¶çš„ä¿¡æ¯ã€‚ä»ä¸‹é¢çš„ä¿¡æ¯æˆ‘ä»¬ä¹Ÿå¯ä»¥å¾—çŸ¥ï¼ŒObj-C å†…ä¹Ÿå¹¿æ³›ä½¿ç”¨äº† +loadï¼Œè€Œå› ä¸ºæˆ‘ä»¬è‡ªå®šä¹‰çš„ç±»ä¼šåœ¨æœ€æ™šè¢«ç¼–è¯‘ï¼Œå› æ­¤ä¹Ÿä¼šåœ¨æœ€æ™šå»è°ƒç”¨ï¼š</p>

<pre><code class="language-objectivec">objc[63382]: LOAD: class 'NSObject' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_queue' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_source' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_mach' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_queue_serial' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_queue_runloop' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_semaphore' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_group' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_workloop' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_queue_concurrent' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_queue_main' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_queue_global' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_queue_pthread_root' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_queue_mgr' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_queue_attr' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_mach_msg' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_io' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_operation' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_disk' scheduled for +load
objc[63382]: LOAD: class 'OS_voucher' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_data_empty' scheduled for +load
objc[63382]: LOAD: +[NSObject load]

objc[63382]: LOAD: +[OS_dispatch_queue load]

objc[63382]: LOAD: +[OS_dispatch_source load]

objc[63382]: LOAD: +[OS_dispatch_mach load]

objc[63382]: LOAD: +[OS_dispatch_queue_serial load]

objc[63382]: LOAD: +[OS_dispatch_queue_runloop load]

objc[63382]: LOAD: +[OS_dispatch_semaphore load]

objc[63382]: LOAD: +[OS_dispatch_group load]

objc[63382]: LOAD: +[OS_dispatch_workloop load]

objc[63382]: LOAD: +[OS_dispatch_queue_concurrent load]

objc[63382]: LOAD: +[OS_dispatch_queue_main load]

objc[63382]: LOAD: +[OS_dispatch_queue_global load]

objc[63382]: LOAD: +[OS_dispatch_queue_pthread_root load]

objc[63382]: LOAD: +[OS_dispatch_queue_mgr load]

objc[63382]: LOAD: +[OS_dispatch_queue_attr load]

objc[63382]: LOAD: +[OS_dispatch_mach_msg load]

objc[63382]: LOAD: +[OS_dispatch_io load]

objc[63382]: LOAD: +[OS_dispatch_operation load]

objc[63382]: LOAD: +[OS_dispatch_disk load]

objc[63382]: LOAD: +[OS_voucher load]

objc[63382]: LOAD: +[OS_dispatch_data_empty load]

objc[63382]: LOAD: class 'OS_os_log' scheduled for +load
objc[63382]: LOAD: class 'OS_os_activity' scheduled for +load
objc[63382]: LOAD: +[OS_os_log load]

objc[63382]: LOAD: +[OS_os_activity load]

objc[63382]: LOAD: class 'OS_xpc_connection' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_service' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_null' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_bool' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_double' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_pointer' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_date' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_data' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_string' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_uuid' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_fd' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_shmem' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_mach_send' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_array' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_dictionary' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_error' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_endpoint' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_serializer' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_pipe' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_mach_recv' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_bundle' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_service_instance' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_activity' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_file_transfer' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_int64' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_uint64' scheduled for +load
objc[63382]: LOAD: +[OS_xpc_connection load]

objc[63382]: LOAD: +[OS_xpc_service load]

objc[63382]: LOAD: +[OS_xpc_null load]

objc[63382]: LOAD: +[OS_xpc_bool load]

objc[63382]: LOAD: +[OS_xpc_double load]

objc[63382]: LOAD: +[OS_xpc_pointer load]

objc[63382]: LOAD: +[OS_xpc_date load]

objc[63382]: LOAD: +[OS_xpc_data load]

objc[63382]: LOAD: +[OS_xpc_string load]

objc[63382]: LOAD: +[OS_xpc_uuid load]

objc[63382]: LOAD: +[OS_xpc_fd load]

objc[63382]: LOAD: +[OS_xpc_shmem load]

objc[63382]: LOAD: +[OS_xpc_mach_send load]

objc[63382]: LOAD: +[OS_xpc_array load]

objc[63382]: LOAD: +[OS_xpc_dictionary load]

objc[63382]: LOAD: +[OS_xpc_error load]

objc[63382]: LOAD: +[OS_xpc_endpoint load]

objc[63382]: LOAD: +[OS_xpc_serializer load]

objc[63382]: LOAD: +[OS_xpc_pipe load]

objc[63382]: LOAD: +[OS_xpc_mach_recv load]

objc[63382]: LOAD: +[OS_xpc_bundle load]

objc[63382]: LOAD: +[OS_xpc_service_instance load]

objc[63382]: LOAD: +[OS_xpc_activity load]

objc[63382]: LOAD: +[OS_xpc_file_transfer load]

objc[63382]: LOAD: +[OS_xpc_int64 load]

objc[63382]: LOAD: +[OS_xpc_uint64 load]

objc[63382]: LOAD: class '__IncompleteProtocol' scheduled for +load
objc[63382]: LOAD: class 'Protocol' scheduled for +load
objc[63382]: LOAD: class '__NSUnrecognizedTaggedPointer' scheduled for +load
objc[63382]: LOAD: +[__IncompleteProtocol load]

objc[63382]: LOAD: +[Protocol load]

objc[63382]: LOAD: +[__NSUnrecognizedTaggedPointer load]

objc[63382]: LOAD: category 'NSObject(NSObject)' scheduled for +load
objc[63382]: LOAD: +[NSObject(NSObject) load]

objc[63382]: LOAD: category 'NSObject(NSObject)' scheduled for +load
objc[63382]: LOAD: +[NSObject(NSObject) load]

objc[63382]: LOAD: category 'CIFilter(Interposer)' scheduled for +load
objc[63382]: LOAD: +[CIFilter(Interposer) load]

objc[63382]: LOAD: class 'NSApplication' scheduled for +load
objc[63382]: LOAD: class 'NSBinder' scheduled for +load
objc[63382]: LOAD: class 'NSColorSpaceColor' scheduled for +load
objc[63382]: LOAD: class 'NSNextStepFrame' scheduled for +load
objc[63382]: LOAD: category 'NSBundle(NSNibLoading)' scheduled for +load
objc[63382]: LOAD: +[NSApplication load]

objc[63382]: LOAD: +[NSBinder load]

objc[63382]: LOAD: +[NSColorSpaceColor load]

objc[63382]: LOAD: +[NSNextStepFrame load]

objc[63382]: LOAD: +[NSBundle(NSNibLoading) load]

objc[63382]: LOAD: class 'Person' scheduled for +load
objc[63382]: LOAD: class 'Student' scheduled for +load
objc[63382]: LOAD: category 'Person(Life)' scheduled for +load
objc[63382]: LOAD: category 'Student(School)' scheduled for +load
objc[63382]: LOAD: category 'Person(Work)' scheduled for +load
objc[63382]: LOAD: +[Person load]

2019-04-20 19:25:30.541922+0800 Load_Obj-C_Demo[63382:15374262] Person +[Person load]
objc[63382]: LOAD: +[Student load]

2019-04-20 19:25:30.542367+0800 Load_Obj-C_Demo[63382:15374262] Person+Work +[Person(Work) load]
2019-04-20 19:25:30.542379+0800 Load_Obj-C_Demo[63382:15374262] Student +[Student load]
objc[63382]: LOAD: +[Person(Life) load]

2019-04-20 19:25:30.542409+0800 Load_Obj-C_Demo[63382:15374262] Person+Life +[Person(Life) load]
objc[63382]: LOAD: +[Student(School) load]

2019-04-20 19:25:30.542443+0800 Load_Obj-C_Demo[63382:15374262] Student+School +[Student(School) load]
objc[63382]: LOAD: +[Person(Work) load]

2019-04-20 19:25:30.542473+0800 Load_Obj-C_Demo[63382:15374262] Person+Work +[Person(Work) load]
2019-04-20 19:25:30.542535+0800 Load_Obj-C_Demo[63382:15374262] Hello, World!
</code></pre>

<h2 id="å¼€é”€">å¼€é”€</h2>

<pre><code class="language-objectivec">@interface Fruit : NSObject

@end

@implementation Fruit
+ (void)load {
    NSLog(@&quot;------&quot;);
    sleep(3);
    NSLog(@&quot;------&quot;);
}
@end

// OUTPUT:
// 2019-04-20 19:23:38.433375+0800 Load_Obj-C_iOS_Demo[63358:15371945] ------
// 2019-04-20 19:23:41.434564+0800 Load_Obj-C_iOS_Demo[63358:15371945] ------
</code></pre>

<p>é€šè¿‡ä¸Šé¢çš„åˆ†æï¼Œæˆ‘ä»¬äº†è§£äº† +load åœ¨è¿è¡Œæ—¶åˆå§‹åŒ–åŠ è½½é•œåƒæ—¶å°±ä¼šè¢«è°ƒç”¨ï¼Œä½¿å¾—å¯ä»¥æœ‰æœºä¼šé¢„å…ˆåšå¾ˆå¤šäº‹æƒ…ã€‚ä½†æ­£æ˜¯å› ä¸ºå…¶åŠ è½½çš„æ—¶æœºéå¸¸é å‰ï¼Œå¦‚æœåœ¨ +load æ–¹æ³•ä¸­åšæ¯”è¾ƒå¤æ‚ä¸”åœ¨ä¸»çº¿ç¨‹çš„æ“ä½œï¼Œå°†ä¼šå½±å“ App å¯åŠ¨æ—¶é—´ï¼Œé™ä½ç”¨æˆ·ä½“éªŒã€‚æˆ‘ä»¬å¯ä»¥å°è¯•å»ºç«‹ä¸€ä¸ª iOS Appï¼Œåœ¨ +load ä¸­ <code>sleep(3)</code> æ¨¡æ‹Ÿåšæ¯”è¾ƒå¤æ‚çš„æ“ä½œï¼Œæ­¤æ—¶æ¯æ¬¡ App å†·å¯åŠ¨éƒ½å°†ä¼šæœ‰ 3 ç§’ä»¥ä¸Šçš„æ—¶é—´æ‰èƒ½è¿›å…¥ App ä¸»é¡µçš„æ§åˆ¶å™¨ï¼Œæå¤§çš„å½±å“äº†å¯åŠ¨æ—¶é—´ã€‚</p>

<p>æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ <code>DYLD_PRINT_STATISTICS_DETAILS</code> ç¯å¢ƒå˜é‡æ¥æ§åˆ¶è¾“å‡ºå¯åŠ¨ç»Ÿè®¡çš„ç›¸å…³ä¿¡æ¯ï¼Œå°±å¯ä»¥åœ¨ <code>total time in initializers and ObjC +load</code> ä¸­å‘ç° <code>Load_Obj-C_iOS_Demo : 3.0 seconds (74.4%)</code> å ç”¨äº†å¤§éƒ¨åˆ†æ—¶é—´ã€‚</p>

<pre><code>  total time: 4.0 seconds (100.0%)
  total images loaded:  258 (0 from dyld shared cache)
  total segments mapped: 767, into 102430 pages with 7398 pages pre-fetched
  total images loading time: 397.50 milliseconds (9.8%)
  total load time in ObjC:  47.34 milliseconds (1.1%)
  total debugger pause time: 189.60 milliseconds (4.6%)
  total dtrace DOF registration time:   0.14 milliseconds (0.0%)
  total rebase fixups:  2,716,086
  total rebase fixups time: 552.17 milliseconds (13.6%)
  total binding fixups: 286,035
  total binding fixups time:  19.12 milliseconds (0.4%)
  total weak binding fixups time:   0.45 milliseconds (0.0%)
  total redo shared cached bindings time:  26.04 milliseconds (0.6%)
  total bindings lazily fixed up: 0 of 0
  total time in initializers and ObjC +load: 3.0 seconds (74.9%)
                         libSystem.B.dylib :   2.99 milliseconds (0.0%)
                libMainThreadChecker.dylib :  10.24 milliseconds (0.2%)
                       Load_Obj-C_iOS_Demo : 3.0 seconds (74.4%)
</code></pre>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1418815-load?language=objc">load - Apple Developer</a></li>
<li><a href="../category_in_ios/">iOS ä¸­çš„ Category - kingcos</a></li>
<li><a href="../objc_msgsend/">æµ…å° objc_msgSend - kingcos</a></li>
</ul>

    </div>
    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>
        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="/posts/2019/&#43;initialize_in_ios/">
                <span class="button__icon">â†</span>
                <span class="button__text">iOS ä¸­çš„ &#43;initialize æ–¹æ³•</span>
              </a>
            </span>
          
          
            <span class="button next">
              <a href="/posts/2019/category_in_ios/">
                <span class="button__text">iOS ä¸­çš„ Category</span>
                <span class="button__icon">â†’</span>
              </a>
            </span>
          
        </div>
      </div>
    

    

    
    
    <div>
      <div id="github-comment">
      </div>

      <script type="text/javascript">
        function getUtterances(isDark) {
          var utterances = document.createElement('script');
          utterances.type = 'text/javascript';
          utterances.async = true;
          utterances.setAttribute('issue-term', "pathname")
          utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
          utterances.setAttribute('label', "comments")
          isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
          utterances.crossorigin = 'anonymous';
          utterances.src = 'https://utteranc.es/client.js';

          return utterances
        }

        var themeToggle = document.querySelector(".theme-toggle")
        themeToggle.addEventListener("click", function () {
          var getTheme = window.localStorage && window.localStorage.getItem("theme")
          var divNode = document.getElementById('github-comment')
          while(divNode.hasChildNodes()) {
            divNode.removeChild(divNode.firstChild);
          }
          
          
          

          
          
          
          
          
          
          document.getElementById('github-comment').appendChild(getUtterances(getTheme !== "dark"))
        })

        var getTheme = window.localStorage && window.localStorage.getItem("theme")
        document.getElementById('github-comment').appendChild(getUtterances(getTheme === "dark"))
      </script>
    </div>
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">Powered by github.com/kingcos</div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </body>
</html>
