<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>iOS 中的 &#43;load 方法 :: iBlog — github.com/kingcos</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Source Code Demo     2019-04-20 首次提交 objc4-750 Load_Obj-C_Demo    Preface 在 iOS 开发中，我们经常会使用 &#43;load 方法来做一些在 main 函数之前的操作，比如方法交换（Method Swizzle）等。那么 &#43;load 到底是如何被调用的呢？
What // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { &#43; (void)load; }  Obj-C 中的 &#43;load 方法指的是 NSObject 中的 &#43; (void)load 类方法。官方文档中的 &#43;load 如下：
 Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading."/>
<meta name="keywords" content="ios,swift,objective-c,obj-c,objc,oc,geek,python,ruby,golang,go,apple,mac"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/&#43;load_in_ios/" />





<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="iOS 中的 &#43;load 方法"/>
<meta name="twitter:description" content="在 iOS 开发中，我们经常会使用 &#43;load 方法来做一些在 `main` 函数之前的操作，比如方法交换（Method Swizzle）等。那么 &#43;load 到底是如何被调用的呢？"/>



<meta property="og:title" content="iOS 中的 &#43;load 方法" />
<meta property="og:description" content="在 iOS 开发中，我们经常会使用 &#43;load 方法来做一些在 `main` 函数之前的操作，比如方法交换（Method Swizzle）等。那么 &#43;load 到底是如何被调用的呢？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2019/&#43;load_in_ios/" />
<meta property="article:published_time" content="2019-04-20T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-04-20T00:00:00+00:00" /><meta property="og:site_name" content="iBlog" />






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">iBlog</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="post">
    <h2 class="post-title"><a href="/posts/2019/&#43;load_in_ios/">iOS 中的 +load 方法</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            2019-04-20
        </span>
      
      
      
        <span class="post-read-time">— 17 min read</span>
      
    </div>

    
      <span class="post-tags">
        
          #<a href="/tags/focus/">Focus</a>&nbsp;
        
          #<a href="/tags/ios/">iOS</a>&nbsp;
        
          #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Source Code</th>
<th align="center">Demo</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2019-04-20</td>
<td align="center">首次提交</td>
<td align="center"><a href="https://opensource.apple.com/tarballs/objc4/">objc4-750</a></td>
<td align="center"><a href="https://github.com/kingcos/Perspective/tree/writing/Posts/Practice/%2Bload_in_iOS">Load_Obj-C_Demo</a></td>
</tr>
</tbody>
</table>

<h2 id="preface">Preface</h2>

<p>在 iOS 开发中，我们经常会使用 +load 方法来做一些在 <code>main</code> 函数之前的操作，比如方法交换（Method Swizzle）等。那么 +load 到底是如何被调用的呢？</p>

<h2 id="what">What</h2>

<pre><code class="language-objectivec">// NSObject.h
@interface NSObject &lt;NSObject&gt; {
+ (void)load;
}
</code></pre>

<p>Obj-C 中的 +load 方法指的是 NSObject 中的 <code>+ (void)load</code> 类方法。官方文档中的 +load 如下：</p>

<blockquote>
<p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</p>

<p>The <code>load</code> message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.</p>

<p>The order of initialization is as follows:</p>

<ol>
<li>All initializers in any framework you link to.</li>
<li>All <code>+load</code> methods in your image.</li>
<li>All C++ static initializers and C/C++ <code>__attribute__(constructor)</code> functions in your image.</li>
<li>All initializers in frameworks that link to you.</li>
</ol>

<p>In addition:</p>

<ul>
<li>A class’s <code>+load</code> method is called after all of its superclasses’ <code>+load</code> methods.</li>
<li>A category <code>+load</code> method is called after the class’s own <code>+load</code> method.</li>
</ul>

<p>In a custom implementation of <code>load</code> you can therefore safely message other unrelated classes from the same image, but any <code>load</code> methods implemented by those classes may not have run yet.</p>

<blockquote>
<p><strong>Important</strong></p>

<p>Custom implementations of the <code>load</code> method for Swift classes bridged to Objective-C are not called automatically.</p>
</blockquote>

<p>—— Documentation, Apple Developer</p>

<p>译：</p>

<p>当类或分类被添加到 Obj-C 运行时的时候被调用；可以实现该方法用来在加载时刻执行特定类的操作。</p>

<p>动态加载和静态链接都能将 <code>load</code> 消息发送到类和分类，但前提是新加载类或分类实现了要响应的方法。</p>

<p>初始化的顺序如下：</p>

<ol>
<li>链接的所有框架（Framework）中全部的构造器。</li>
<li>镜像（Image）中所有的 <code>+load</code> 方法。</li>
<li>镜像中所有的 C++ 静态构造器，以及 C/C++ 的 <code>__attribute__(constructor)</code> 函数。</li>
<li>框架中链接的所有构造器。</li>
</ol>

<p>另外：</p>

<ul>
<li>类的 <code>+load</code> 方法在其所有父类的 <code>+load</code> 方法调用之后调用。</li>
<li>分类的 <code>+load</code> 方法在其主类的 <code>+load</code> 方法调用之后调用。</li>
</ul>

<p>在 <code>load</code> 的自定义实现中，可以安全地从同一镜像中发送其他不相关的类，但这些类中实现的 <code>load</code> 方法可能还没有运行。</p>

<blockquote>
<p><strong>重点</strong></p>

<p>Swift 类中桥接到 Obj-C 的 <code>load</code> 方法自定义实现将不会自动调用。</p>
</blockquote>

<p>—— 文档，苹果开发者</p>
</blockquote>

<h2 id="how">How</h2>

<p>根据官方文档的描述，我们可以尝试定义一个继承自 <code>NSObject</code> 的 <code>Person</code> 类，并对其添加两个分类 <code>Life</code> 和 <code>Work</code>；再定义一个 <code>Student</code> 类继承自 <code>Person</code>，并对其添加 <code>School</code> 分类。在以上所有类和分类中，均实现 +load：</p>

<pre><code class="language-objectivec">// Person.m
#import &quot;Person.h&quot;

@implementation Person
+ (void)load {
    NSLog(@&quot;Person %s&quot;, __func__);
}
@end

// Person+Life.m
#import &quot;Person+Life.h&quot;

@implementation Person (Life)
+ (void)load {
    NSLog(@&quot;Person+Life %s&quot;, __func__);
}
@end

// Person+Work.m
#import &quot;Person+Work.h&quot;

@implementation Person (Work)
+ (void)load {
    NSLog(@&quot;Person+Work %s&quot;, __func__);
}
@end

// Student.m
#import &quot;Student.h&quot;

@implementation Student
+ (void)load {
    NSLog(@&quot;Student %s&quot;, __func__);
}
@end

// Student+School.m
#import &quot;Student+School.h&quot;

@implementation Student (School)
+ (void)load {
    NSLog(@&quot;Student+School %s&quot;, __func__);
}
@end

// OUTPUT:
// Person +[Person load]
// Student +[Student load]
// Person+Life +[Person(Life) load]
// Student+School +[Student(School) load]
// Person+Work +[Person(Work) load]
// Hello, World!
</code></pre>

<p>不需要更改 main.m，尝试运行程序，结果正如官方所述，即 <strong>+load 方法会在 <code>main</code> 函数之前被调用；且调用顺序总是先父类再子类再分类</strong>。</p>

<h2 id="why">Why</h2>

<h3 id="实现原理">实现原理</h3>

<blockquote>
<p><strong>Obj-C 运行时的入口是哪里呢？</strong></p>

<p>在 objc4 源码中有一个「libobjc.order」的文件，列举了该库方法符号的调用顺序，我们能看到第一个就是 <code>__objc_init</code>。编译时，C/C++ 方法前会被自动加上 <code>_</code> 前缀作为方法符号（这一点可以在分析 Link Map 或者 Mach-O 时证明），因此这里第一个本质就是 <code>_objc_init</code>。</p>

<p><img src="/img/2019/+load_in_ios/1.png" alt="1" /></p>
</blockquote>

<p>为了证明上述结论，我们可以在 objc4 的源码中，从 Obj-C 运行时初始化的入口着手，即 <code>_objc_init</code>：</p>

<pre><code class="language-objectivec">// objc-os.mm
/***********************************************************************
* _objc_init
* Bootstrap initialization. Registers our image notifier with dyld.
* 引导初始化。使用 dyld 注册镜像通知器。
* Called by libSystem BEFORE library initialization time
* 在库初始化时间之前由 libSystem 调用
**********************************************************************/

void _objc_init(void)
{
    static bool initialized = false;
    if (initialized) return;
    initialized = true;

    // fixme defer initialization until an objc-using image is found?
    environ_init();
    tls_init();
    static_init();
    lock_init();
    exception_init();

    // ➡️ dyld 注册通知；map_images：映射镜像，load_images：加载镜像，unmap_image：反映射镜像
    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);
}

// objc-runtime-new.mm
/***********************************************************************
* load_images
* Process +load in the given images which are being mapped in by dyld.
* 由 dyld 处理给定将要映射的镜像中的 +load。
*
* Locking: write-locks runtimeLock and loadMethodLock
* 锁：写锁 runtimeLock 和 loadMethodLock
**********************************************************************/
extern bool hasLoadMethods(const headerType *mhdr);
extern void prepare_load_methods(const headerType *mhdr);

void
load_images(const char *path __unused, const struct mach_header *mh)
{
    // Return without taking locks if there are no +load methods here.
    // ➡️ 如果没有 +load 方法则返回
    if (!hasLoadMethods((const headerType *)mh)) return;

    // 递归锁
    recursive_mutex_locker_t lock(loadMethodLock);

    // Discover load methods
    // 发现 load 方法
    {
        // 互斥锁
        mutex_locker_t lock2(runtimeLock);
        // ➡️ 准备加载 load 方法
        prepare_load_methods((const headerType *)mh);
    }

    // Call +load methods (without runtimeLock - re-entrant)
    // ➡️ 调用 +load 方法（不带 runtimeLock - 可重入的（线程安全的））
    call_load_methods();
}

// objc-runtime-new.mm
// Quick scan for +load methods that doesn't take a lock.
// 不需要加锁地快速搜索 +load 方法
bool hasLoadMethods(const headerType *mhdr)
{
    size_t count;
    // 非懒加载类列表（取 Mach-O 中 __objc_nlclslist 节）
    // GETSECT(_getObjc2NonlazyClassList,    classref_t,      &quot;__objc_nlclslist&quot;);
    if (_getObjc2NonlazyClassList(mhdr, &amp;count)  &amp;&amp;  count &gt; 0) return true;
    // 非懒加载分类列表（取 Mach-O 中 __objc_nlcatlist 节）
    // GETSECT(_getObjc2NonlazyCategoryList, category_t *,    &quot;__objc_nlcatlist&quot;);
    if (_getObjc2NonlazyCategoryList(mhdr, &amp;count)  &amp;&amp;  count &gt; 0) return true;
    return false;
}

// objc-runtime-new.mm
void prepare_load_methods(const headerType *mhdr)
{
    size_t count, i;

    // 断言 runtimeLock 已锁
    runtimeLock.assertLocked();

    // 1. 非懒加载类列表
    classref_t *classlist =
        _getObjc2NonlazyClassList(mhdr, &amp;count);
    // 遍历所有类
    for (i = 0; i &lt; count; i++) {
        // ➡️ 计划 +load 方法调用
        schedule_class_load(remapClass(classlist[i]));
    }

    // 2. 非懒加载分类列表
    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);
    // 遍历所有分类
    for (i = 0; i &lt; count; i++) {
        category_t *cat = categorylist[i];
        // 重映射分类的主类
        Class cls = remapClass(cat-&gt;cls);
        if (!cls) continue;  // category for ignored weak-linked class 忽略弱链接主类的分类
        // 实化类（为 cls 执行一次性初始化等操作）
        realizeClass(cls);
        // 断言类的 isa（元类）已实化
        assert(cls-&gt;ISA()-&gt;isRealized());
        // ➡️ 添加分类到可加载列表
        add_category_to_loadable_list(cat);
    }
}

// objc-runtime-new.mm
static Class remapClass(classref_t cls)
{
    ➡️ 重映射类
    return remapClass((Class)cls);
}

// objc-runtime-new.mm
/***********************************************************************
* remapClass
* Returns the live class pointer for cls, which may be pointing to
* a class struct that has been reallocated.
* 为参数 cls 返回可能指向已经重新分配类结构到活类指针。
* Returns nil if cls is ignored because of weak linking.
* 如果类是弱链接，将返回 nil。
* Locking: runtimeLock must be read- or write-locked by the caller
* 锁：runtimeLock 必须由调用者读取或写入锁定。
**********************************************************************/
static Class remapClass(Class cls)
{
    // 断言 runtimeLock 已锁
    runtimeLock.assertLocked();

    Class c2;

    if (!cls) return nil;

    NXMapTable *map = remappedClasses(NO);
    // 从 map 中取 cls 对应的值
    // void *NXMapMember(NXMapTable *table, const void *key, void **value)
    if (!map  ||  NXMapMember(map, cls, (void**)&amp;c2) == NX_MAPNOTAKEY) {
        return cls;
    } else {
        return c2;
    }
}

// objc-runtime-new.mm
/***********************************************************************
* prepare_load_methods
* Schedule +load for classes in this image, any un-+load-ed
* superclasses in other images, and any categories in this image.
* 为当前镜像中的类、其它镜像中所有未调用过 +load 的父类、以及该镜像中的所有的分类计划调用 +load。
**********************************************************************/
// Recursively schedule +load for cls and any un-+load-ed superclasses.
// 为 cls 以及所有未调用过 +load 的父类递归计划调用 +load。
// cls must already be connected.
// cls 必须已被连接。
static void schedule_class_load(Class cls)
{
    if (!cls) return;
    // 断言类是实化的
    assert(cls-&gt;isRealized());  // _read_images should realize

    // 判断类的 +load 是否已经被调用
    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;

    // Ensure superclass-first ordering
    // （递归）确保父类优先调用 +load
    schedule_class_load(cls-&gt;superclass);

    // ➡️ 添加类到可加载列表
    add_class_to_loadable_list(cls);
    // 设置本类 +load 已调用过
    cls-&gt;setInfo(RW_LOADED);
}



// objc-loadmethod.mm
/***********************************************************************
* add_class_to_loadable_list
* Class cls has just become connected. Schedule it for +load if
* it implements a +load method.
* cls 刚刚被连接。如果其实现了 +load 方法就将计划调用。
**********************************************************************/
void add_class_to_loadable_list(Class cls)
{
    IMP method;

    // 断言 loadMethodLock 已锁
    loadMethodLock.assertLocked();

    // ➡️ 获取类 load 方法
    method = cls-&gt;getLoadMethod();
    if (!method) return;  // Don't bother if cls has no +load method 没有 +load 就返回

    // Xcode 中 OBJC_PRINT_LOAD_METHODS 环境变量值为 YES 时，将可在控制台打印该信息
    // OPTION(PrintLoading, OBJC_PRINT_LOAD_METHODS, &quot;log calls to class and category +load methods&quot;)
    if (PrintLoading) {
        _objc_inform(&quot;LOAD: class '%s' scheduled for +load&quot;,
                     cls-&gt;nameForLogging());
    }

    // 如果使用的 == 分配的，需要扩容
    if (loadable_classes_used == loadable_classes_allocated) {
        loadable_classes_allocated = loadable_classes_allocated*2 + 16;
        loadable_classes = (struct loadable_class *)
            realloc(loadable_classes,
                              loadable_classes_allocated *
                              sizeof(struct loadable_class));
    }

    // 添加到 loadable_classes（将在 call_class_loads 中实际调用）
    loadable_classes[loadable_classes_used].cls = cls;
    loadable_classes[loadable_classes_used].method = method;
    loadable_classes_used++;
}

// objc-runtime-new.mm
/***********************************************************************
* objc_class::getLoadMethod
* fixme
* Called only from add_class_to_loadable_list.
* 只在 add_class_to_loadable_list 中调用。
* Locking: runtimeLock must be read- or write-locked by the caller.
* 锁：runtimeLock 必须由调用者读取或写入锁定。
**********************************************************************/
IMP
objc_class::getLoadMethod()
{
    runtimeLock.assertLocked();

    const method_list_t *mlist;

    // 断言
    assert(isRealized());
    assert(ISA()-&gt;isRealized());
    assert(!isMetaClass());
    assert(ISA()-&gt;isMetaClass());

    // 从只读列表中读取 baseMethods（可参考「iOS 中的 NSObject」）
    mlist = ISA()-&gt;data()-&gt;ro-&gt;baseMethods();
    if (mlist) {
        // 遍历
        for (const auto&amp; meth : *mlist) {
            // 获取 selector 名称
            const char *name = sel_cname(meth.name);
            if (0 == strcmp(name, &quot;load&quot;)) {
                // 若为 load 方法，则返回 IMP
                return meth.imp;
            }
        }
    }

    return nil;
}

// objc-loadmethod.mm
/***********************************************************************
* add_category_to_loadable_list
* Category cat's parent class exists and the category has been attached
* to its class. Schedule this category for +load after its parent class
* becomes connected and has its own +load method called.
* 分类 cat 的主类存在，且分类已经连接到主类的类上了。在父类连接且调用了 +load 后计划调用该分类的 +load。
**********************************************************************/
void add_category_to_loadable_list(Category cat)
{
    IMP method;

    // 断言 loadMethodLock 已锁
    loadMethodLock.assertLocked();

    // ➡️ 获取分类 load 方法
    method = _category_getLoadMethod(cat);

    // Don't bother if cat has no +load method
    // 没有 +load 就返回
    if (!method) return;

    // OPTION(PrintLoading, OBJC_PRINT_LOAD_METHODS, &quot;log calls to class and category +load methods&quot;)
    if (PrintLoading) {
        _objc_inform(&quot;LOAD: category '%s(%s)' scheduled for +load&quot;,
                     _category_getClassName(cat), _category_getName(cat));
    }

    // 如果使用的 == 分配的，需要扩容
    if (loadable_categories_used == loadable_categories_allocated) {
        loadable_categories_allocated = loadable_categories_allocated*2 + 16;
        loadable_categories = (struct loadable_category *)
            realloc(loadable_categories,
                              loadable_categories_allocated *
                              sizeof(struct loadable_category));
    }

	 // 存入 loadable_categories（将在 call_category_loads 中实际调用）
    loadable_categories[loadable_categories_used].cat = cat;
    loadable_categories[loadable_categories_used].method = method;
    loadable_categories_used++;
}

// objc-runtime-new.mm
/***********************************************************************
* _category_getLoadMethod
* fixme
* Called only from add_category_to_loadable_list
* 只在 add_category_to_loadable_list 中调用
* Locking: runtimeLock must be read- or write-locked by the caller
* 锁：runtimeLock 必须由调用者读取或写入锁定。
**********************************************************************/
IMP
_category_getLoadMethod(Category cat)
{
    // 断言 loadMethodLock 已锁
    runtimeLock.assertLocked();

    const method_list_t *mlist;

    // 分类中类方法列表
    mlist = cat-&gt;classMethods;
    if (mlist) {
        // 遍历
        for (const auto&amp; meth : *mlist) {
            // 获取 selector 名称
            const char *name = sel_cname(meth.name);
            if (0 == strcmp(name, &quot;load&quot;)) {
                // 若为 load 方法，则返回 IMP
                return meth.imp;
            }
        }
    }

    return nil;
}

// objc-loadmethod.mm
/***********************************************************************
* call_load_methods
* Call all pending class and category +load methods.
* 调用所有类和分类的 +load  方法。
* Class +load methods are called superclass-first.
* 类的 +load 方法将先调用父类的。
* Category +load methods are not called until after the parent class's +load.
* 分类的 +load 才需要等到其主类的 +load 调用后才调用。
*
* This method must be RE-ENTRANT, because a +load could trigger
* more image mapping. In addition, the superclass-first ordering
* must be preserved in the face of re-entrant calls. Therefore,
* only the OUTERMOST call of this function will do anything, and
* that call will handle all loadable classes, even those generated
* while it was running.
* 该方法必须是可重入的（线程安全的），因为 +load 可能触发更多镜像映射。
* 另外，面对可重入调用时，必须保留父类优先排序。
* 因此，只有当该函数在最后调用才会执行全部操作，且该调用将处理所有可加载的类，甚至是在运行时生成的类。
*
* The sequence below preserves +load ordering in the face of
* image loading during a +load, and make sure that no
* +load method is forgotten because it was added during
* a +load call.
* 下面的顺序保留了在面对 +load 中加载镜像的 +load 排序，并且因为它是在一个 +load 调用中被添加的，因此可以保证没有 +load 被遗忘，。
* Sequence:
* 顺序
* 1. Repeatedly call class +loads until there aren't any more
* 1. 重复调用类 +load 直到不再有未调用的 +load
* 2. Call category +loads ONCE.
* 2. 调用分类 +load 一次
* 3. Run more +loads if:
* 3. 执行多次 +load 的情况：
*    (a) there are more classes to load, OR
*    (a) 有多个类要加载，或者
*    (b) there are some potential category +loads that have
*        still never been attempted.
*    (b) 有一些潜在的分类 +load 仍未尝试。
* Category +loads are only run once to ensure &quot;parent class first&quot;
* ordering, even if a category +load triggers a new loadable class
* and a new loadable category attached to that class.
* 分类中的 +load 只会被执行一次，并保证「父类优先」排序，尽管一个分类的 +load 触发了一个新的可加载的类以及附加该类的一个新的可加载的分类。
*
* Locking: loadMethodLock must be held by the caller
* 锁：loadMethodLock 必须由调用者持有
*   All other locks must not be held.
*   所有其它锁必须不持有。
**********************************************************************/
void call_load_methods(void)
{
    static bool loading = NO;
    bool more_categories;

    // 断言 loadMethodLock 已锁
    loadMethodLock.assertLocked();

    // Re-entrant calls do nothing; the outermost call will finish the job.
    // 重入的调用不做事情，最早的调用将完成任务
    if (loading) return;
    loading = YES;

    void *pool = objc_autoreleasePoolPush();

    do {
        // 1. Repeatedly call class +loads until there aren't any more
        // 1. 重复调用类 +load，直到全部调用到
        while (loadable_classes_used &gt; 0) {
            // ➡️ 调用类的 +load 方法
            call_class_loads();
        }

        // 2. Call category +loads ONCE
        // 2. ➡️ 调用分类 +load 一次
        more_categories = call_category_loads();

        // 3. Run more +loads if there are classes OR more untried categories
        // 3.如果有类或者更多未尝试的分类则运行更多的 +load
    } while (loadable_classes_used &gt; 0  ||  more_categories);

    objc_autoreleasePoolPop(pool);

    loading = NO;
}

// objc-loadmethod.mm
/***********************************************************************
* call_class_loads
* Call all pending class +load methods.
* 调用所有类的 +load 方法。
* If new classes become loadable, +load is NOT called for them.
* 如果有新的类变为可加载的，它们的 +load 不会被调用
*
* Called only by call_load_methods().
* 只能由 call_load_methods() 调用。
**********************************************************************/
static void call_class_loads(void)
{
    int i;

    // Detach current loadable list.
    // 分离当前可加载列表。
    struct loadable_class *classes = loadable_classes;
    int used = loadable_classes_used;
    loadable_classes = nil;
    loadable_classes_allocated = 0;
    loadable_classes_used = 0;

    // Call all +loads for the detached list.
    // 在分离的表中调用所有 +load。
    for (i = 0; i &lt; used; i++) {
        Class cls = classes[i].cls;
        load_method_t load_method = (load_method_t)classes[i].method;
        if (!cls) continue;

        // OPTION(PrintLoading, OBJC_PRINT_LOAD_METHODS, &quot;log calls to class and category +load methods&quot;)
        if (PrintLoading) {
            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());
        }
        // 💡 调用 +load
        (*load_method)(cls, SEL_load);
    }

    // Destroy the detached list.
    // 销毁分离列表
    if (classes) free(classes);
}

// objc-loadmethod.mm
/***********************************************************************
* call_category_loads
* Call some pending category +load methods.
* 调用一些分类中未调用的 +load 方法。
* The parent class of the +load-implementing categories has all of
*   its categories attached, in case some are lazily waiting for +initalize.
* 实现 +load 分类的父类拥有所有其附加的分类 ，来防止等待 +initialize 懒加载。
*
* Don't call +load unless the parent class is connected.
* If new categories become loadable, +load is NOT called, and they
*   are added to the end of the loadable list, and we return TRUE.
* Return FALSE if no new categories became loadable.
* 除非父类已经连接，否则不要调用 +load。
* 如果新的分类变成可加载的，+load 未被调用，并且它们被添加到可加载列表的末尾，返回 TRUE。
* 如果没有新的分类变为可加载的，返回 FALSE。
*
* Called only by call_load_methods().
* 只能由 call_load_methods() 调用。
**********************************************************************/
static bool call_category_loads(void)
{
    int i, shift;
    bool new_categories_added = NO;

    // Detach current loadable list.
    // 分离当前可加载列表。
    struct loadable_category *cats = loadable_categories;
    int used = loadable_categories_used;
    int allocated = loadable_categories_allocated;
    loadable_categories = nil;
    loadable_categories_allocated = 0;
    loadable_categories_used = 0;

    // Call all +loads for the detached list.
    // 为分离的列表调用所有的 +load。
    for (i = 0; i &lt; used; i++) {
        Category cat = cats[i].cat;
        load_method_t load_method = (load_method_t)cats[i].method;
        Class cls;
        if (!cat) continue;

        // 获取主类
        cls = _category_getClass(cat);
        if (cls  &amp;&amp;  cls-&gt;isLoadable()) {
            // OPTION(PrintLoading, OBJC_PRINT_LOAD_METHODS, &quot;log calls to class and category +load methods&quot;)
            if (PrintLoading) {
                _objc_inform(&quot;LOAD: +[%s(%s) load]\n&quot;,
                             cls-&gt;nameForLogging(),
                             _category_getName(cat));
            }
            // 💡 调用 +load
            (*load_method)(cls, SEL_load);
            // 置为空
            cats[i].cat = nil;
        }
    }

    // Compact detached list (order-preserving)
    // 压缩分离列表（保留顺序）
    shift = 0;
    for (i = 0; i &lt; used; i++) {
        if (cats[i].cat) {
            cats[i-shift] = cats[i];
        } else {
            shift++;
        }
    }
    used -= shift;

    // Copy any new +load candidates from the new list to the detached list.
    // 从新的列表中拷贝所有新的 +load 候选到分离列表。
    new_categories_added = (loadable_categories_used &gt; 0);
    for (i = 0; i &lt; loadable_categories_used; i++) {
        if (used == allocated) {
            allocated = allocated*2 + 16;
            cats = (struct loadable_category *)
                realloc(cats, allocated *
                                  sizeof(struct loadable_category));
        }
        cats[used++] = loadable_categories[i];
    }

    // Destroy the new list.
    // 销毁新列表
    if (loadable_categories) free(loadable_categories);

    // Reattach the (now augmented) detached list.
    // 重新附加（现在已增加的）分离列表。
    // But if there's nothing left to load, destroy the list.
    // 但是如果没有什么要加载的，则销毁该列表。
    if (used) {
        loadable_categories = cats;
        loadable_categories_used = used;
        loadable_categories_allocated = allocated;
    } else {
        if (cats) free(cats);
        loadable_categories = nil;
        loadable_categories_used = 0;
        loadable_categories_allocated = 0;
    }

    if (PrintLoading) {
        if (loadable_categories_used != 0) {
            _objc_inform(&quot;LOAD: %d categories still waiting for +load\n&quot;,
                         loadable_categories_used);
        }
    }

    return new_categories_added;
}
</code></pre>

<p>上面的源码过程比较复杂，其实主要顺序就是先在 <code>prepare_load_methods</code> 中调用 <code>schedule_class_load</code>，先计划类的 +load 方法调用顺序，在其中会递归找到基类，并 <code>add_class_to_loadable_list</code> 将类中 +load 的 <code>IMP</code> 存储在 <code>loadable_classes</code>；之后在 <code>prepare_load_methods</code> 中调用 <code>add_category_to_loadable_list</code>，再将分类中 +load 的 <code>IMP</code> 存储在 <code>loadable_categories</code>；当类和分类的可加载列表确定后，预备（Prepare）工作完成；之后开始 <code>call_load_methods</code>，调用 <code>call_class_loads</code> 将类中的 +load 全部调用完毕，再调用 <code>call_category_loads</code> 将分类中的 +load 全部调用完毕。这也就完全符合了我们上述的结论，至于毫无关系的类之间以及分类相互之间的调用顺序，由于 <code>loadable_classes</code> 和 <code>loadable_categories</code> 的增加都是按顺序追加，即按照编译顺序来决定，先编译先调用。具体的编译顺序可以在 Xcode -「TARGETS」 -「Build Phases」-「Compile Sources」中找到。</p>

<p><img src="/img/2019/+load_in_ios/2.png" alt="2" /></p>

<h3 id="imp-与-load">IMP 与 +load</h3>

<p>按照我们之前在「iOS 中的 Category」一篇所提到的，当分类中定义了和主类中相同的方法，那么在调用时将选择最后被编译的分类中的实现。因为在运行时，分类中的方法最终将附加到主类或主类元类的方法列表中，最终将返回第一个找到的方法。那么为什么 +load 如此特殊呢？</p>

<pre><code class="language-objectivec">// add_class_to_loadable_list
loadable_classes[loadable_classes_used].cls = cls;
loadable_classes[loadable_classes_used].method = method;

// objc-loadmethod.mm
typedef void(*load_method_t)(id, SEL);

load_method_t load_method = (load_method_t)classes[i].method;
(*load_method)(cls, SEL_load);
</code></pre>

<p>我们知道，Obj-C 是一门消息机制语言，所谓方法调用是不严谨的，其本质是消息发送（Message Sending），即 <code>objc_msgSend</code>。当「调用」对象方法时，类对象接收到消息作出响应；当「调用」类方法时，元类对象接收到消息作出响应。而在 +load 最终的调用处只是 <code>(*load_method)(cls, SEL_load)</code>，并不存在消息的发送。我们在 <code>add_class_to_loadable_list</code> 中也可以看到，+load 方法本质是存储了方法指针（IMP）并直接调用，因此不会出现类似「覆盖」的情形，而且效率会更高。</p>

<pre><code class="language-objectivec">#import &quot;Student.h&quot;

@implementation Student
+ (void)load {
    [super load];
    NSLog(@&quot;Student %s&quot;, __func__);
}
@end

// OUTPUT:
// Person +[Person load]
// Person+Work +[Person(Work) load]
// Student +[Student load]
// Person+Life +[Person(Life) load]
// Student+School +[Student(School) load]
// Person+Work +[Person(Work) load]
// Hello, World!
</code></pre>

<p>那么有了上述基础，当我们在一个类的子类的 +load 中 <code>[super load]</code> 又会调用到到底哪个类中呢（当然，在实际开发中这种情几乎不可能存在）？答案就是 <code>[super load]</code> 将调用到 <code>Person</code> 最后一个被编译的分类（<code>Person+Work</code>）中的 <code>+load</code> 方法，因为这里是消息发送，而不是通过方法指针。</p>

<h3 id="objc-print-load-methods"><code>OBJC_PRINT_LOAD_METHODS</code></h3>

<p>在 objc4 的源码中提供了很多环境变量，方便我们 Debug 时输出一些内部源码的执行信息。<code>OBJC_PRINT_LOAD_METHODS</code> 即是 <code>+load</code> 相关的一个环境变量，将 <code>OBJC_PRINT_LOAD_METHODS</code> 在 Xcode 中设置为 <code>YES</code> 后，将会打印出很多 +load 方法执行时的信息。从下面的信息我们也可以得知，Obj-C 内也广泛使用了 +load，而因为我们自定义的类会在最晚被编译，因此也会在最晚去调用：</p>

<pre><code class="language-objectivec">objc[63382]: LOAD: class 'NSObject' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_queue' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_source' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_mach' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_queue_serial' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_queue_runloop' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_semaphore' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_group' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_workloop' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_queue_concurrent' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_queue_main' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_queue_global' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_queue_pthread_root' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_queue_mgr' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_queue_attr' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_mach_msg' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_io' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_operation' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_disk' scheduled for +load
objc[63382]: LOAD: class 'OS_voucher' scheduled for +load
objc[63382]: LOAD: class 'OS_dispatch_data_empty' scheduled for +load
objc[63382]: LOAD: +[NSObject load]

objc[63382]: LOAD: +[OS_dispatch_queue load]

objc[63382]: LOAD: +[OS_dispatch_source load]

objc[63382]: LOAD: +[OS_dispatch_mach load]

objc[63382]: LOAD: +[OS_dispatch_queue_serial load]

objc[63382]: LOAD: +[OS_dispatch_queue_runloop load]

objc[63382]: LOAD: +[OS_dispatch_semaphore load]

objc[63382]: LOAD: +[OS_dispatch_group load]

objc[63382]: LOAD: +[OS_dispatch_workloop load]

objc[63382]: LOAD: +[OS_dispatch_queue_concurrent load]

objc[63382]: LOAD: +[OS_dispatch_queue_main load]

objc[63382]: LOAD: +[OS_dispatch_queue_global load]

objc[63382]: LOAD: +[OS_dispatch_queue_pthread_root load]

objc[63382]: LOAD: +[OS_dispatch_queue_mgr load]

objc[63382]: LOAD: +[OS_dispatch_queue_attr load]

objc[63382]: LOAD: +[OS_dispatch_mach_msg load]

objc[63382]: LOAD: +[OS_dispatch_io load]

objc[63382]: LOAD: +[OS_dispatch_operation load]

objc[63382]: LOAD: +[OS_dispatch_disk load]

objc[63382]: LOAD: +[OS_voucher load]

objc[63382]: LOAD: +[OS_dispatch_data_empty load]

objc[63382]: LOAD: class 'OS_os_log' scheduled for +load
objc[63382]: LOAD: class 'OS_os_activity' scheduled for +load
objc[63382]: LOAD: +[OS_os_log load]

objc[63382]: LOAD: +[OS_os_activity load]

objc[63382]: LOAD: class 'OS_xpc_connection' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_service' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_null' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_bool' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_double' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_pointer' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_date' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_data' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_string' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_uuid' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_fd' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_shmem' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_mach_send' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_array' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_dictionary' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_error' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_endpoint' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_serializer' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_pipe' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_mach_recv' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_bundle' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_service_instance' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_activity' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_file_transfer' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_int64' scheduled for +load
objc[63382]: LOAD: class 'OS_xpc_uint64' scheduled for +load
objc[63382]: LOAD: +[OS_xpc_connection load]

objc[63382]: LOAD: +[OS_xpc_service load]

objc[63382]: LOAD: +[OS_xpc_null load]

objc[63382]: LOAD: +[OS_xpc_bool load]

objc[63382]: LOAD: +[OS_xpc_double load]

objc[63382]: LOAD: +[OS_xpc_pointer load]

objc[63382]: LOAD: +[OS_xpc_date load]

objc[63382]: LOAD: +[OS_xpc_data load]

objc[63382]: LOAD: +[OS_xpc_string load]

objc[63382]: LOAD: +[OS_xpc_uuid load]

objc[63382]: LOAD: +[OS_xpc_fd load]

objc[63382]: LOAD: +[OS_xpc_shmem load]

objc[63382]: LOAD: +[OS_xpc_mach_send load]

objc[63382]: LOAD: +[OS_xpc_array load]

objc[63382]: LOAD: +[OS_xpc_dictionary load]

objc[63382]: LOAD: +[OS_xpc_error load]

objc[63382]: LOAD: +[OS_xpc_endpoint load]

objc[63382]: LOAD: +[OS_xpc_serializer load]

objc[63382]: LOAD: +[OS_xpc_pipe load]

objc[63382]: LOAD: +[OS_xpc_mach_recv load]

objc[63382]: LOAD: +[OS_xpc_bundle load]

objc[63382]: LOAD: +[OS_xpc_service_instance load]

objc[63382]: LOAD: +[OS_xpc_activity load]

objc[63382]: LOAD: +[OS_xpc_file_transfer load]

objc[63382]: LOAD: +[OS_xpc_int64 load]

objc[63382]: LOAD: +[OS_xpc_uint64 load]

objc[63382]: LOAD: class '__IncompleteProtocol' scheduled for +load
objc[63382]: LOAD: class 'Protocol' scheduled for +load
objc[63382]: LOAD: class '__NSUnrecognizedTaggedPointer' scheduled for +load
objc[63382]: LOAD: +[__IncompleteProtocol load]

objc[63382]: LOAD: +[Protocol load]

objc[63382]: LOAD: +[__NSUnrecognizedTaggedPointer load]

objc[63382]: LOAD: category 'NSObject(NSObject)' scheduled for +load
objc[63382]: LOAD: +[NSObject(NSObject) load]

objc[63382]: LOAD: category 'NSObject(NSObject)' scheduled for +load
objc[63382]: LOAD: +[NSObject(NSObject) load]

objc[63382]: LOAD: category 'CIFilter(Interposer)' scheduled for +load
objc[63382]: LOAD: +[CIFilter(Interposer) load]

objc[63382]: LOAD: class 'NSApplication' scheduled for +load
objc[63382]: LOAD: class 'NSBinder' scheduled for +load
objc[63382]: LOAD: class 'NSColorSpaceColor' scheduled for +load
objc[63382]: LOAD: class 'NSNextStepFrame' scheduled for +load
objc[63382]: LOAD: category 'NSBundle(NSNibLoading)' scheduled for +load
objc[63382]: LOAD: +[NSApplication load]

objc[63382]: LOAD: +[NSBinder load]

objc[63382]: LOAD: +[NSColorSpaceColor load]

objc[63382]: LOAD: +[NSNextStepFrame load]

objc[63382]: LOAD: +[NSBundle(NSNibLoading) load]

objc[63382]: LOAD: class 'Person' scheduled for +load
objc[63382]: LOAD: class 'Student' scheduled for +load
objc[63382]: LOAD: category 'Person(Life)' scheduled for +load
objc[63382]: LOAD: category 'Student(School)' scheduled for +load
objc[63382]: LOAD: category 'Person(Work)' scheduled for +load
objc[63382]: LOAD: +[Person load]

2019-04-20 19:25:30.541922+0800 Load_Obj-C_Demo[63382:15374262] Person +[Person load]
objc[63382]: LOAD: +[Student load]

2019-04-20 19:25:30.542367+0800 Load_Obj-C_Demo[63382:15374262] Person+Work +[Person(Work) load]
2019-04-20 19:25:30.542379+0800 Load_Obj-C_Demo[63382:15374262] Student +[Student load]
objc[63382]: LOAD: +[Person(Life) load]

2019-04-20 19:25:30.542409+0800 Load_Obj-C_Demo[63382:15374262] Person+Life +[Person(Life) load]
objc[63382]: LOAD: +[Student(School) load]

2019-04-20 19:25:30.542443+0800 Load_Obj-C_Demo[63382:15374262] Student+School +[Student(School) load]
objc[63382]: LOAD: +[Person(Work) load]

2019-04-20 19:25:30.542473+0800 Load_Obj-C_Demo[63382:15374262] Person+Work +[Person(Work) load]
2019-04-20 19:25:30.542535+0800 Load_Obj-C_Demo[63382:15374262] Hello, World!
</code></pre>

<h2 id="开销">开销</h2>

<pre><code class="language-objectivec">@interface Fruit : NSObject

@end

@implementation Fruit
+ (void)load {
    NSLog(@&quot;------&quot;);
    sleep(3);
    NSLog(@&quot;------&quot;);
}
@end

// OUTPUT:
// 2019-04-20 19:23:38.433375+0800 Load_Obj-C_iOS_Demo[63358:15371945] ------
// 2019-04-20 19:23:41.434564+0800 Load_Obj-C_iOS_Demo[63358:15371945] ------
</code></pre>

<p>通过上面的分析，我们了解了 +load 在运行时初始化加载镜像时就会被调用，使得可以有机会预先做很多事情。但正是因为其加载的时机非常靠前，如果在 +load 方法中做比较复杂且在主线程的操作，将会影响 App 启动时间，降低用户体验。我们可以尝试建立一个 iOS App，在 +load 中 <code>sleep(3)</code> 模拟做比较复杂的操作，此时每次 App 冷启动都将会有 3 秒以上的时间才能进入 App 主页的控制器，极大的影响了启动时间。</p>

<p>我们可以使用 <code>DYLD_PRINT_STATISTICS_DETAILS</code> 环境变量来控制输出启动统计的相关信息，就可以在 <code>total time in initializers and ObjC +load</code> 中发现 <code>Load_Obj-C_iOS_Demo : 3.0 seconds (74.4%)</code> 占用了大部分时间。</p>

<pre><code>  total time: 4.0 seconds (100.0%)
  total images loaded:  258 (0 from dyld shared cache)
  total segments mapped: 767, into 102430 pages with 7398 pages pre-fetched
  total images loading time: 397.50 milliseconds (9.8%)
  total load time in ObjC:  47.34 milliseconds (1.1%)
  total debugger pause time: 189.60 milliseconds (4.6%)
  total dtrace DOF registration time:   0.14 milliseconds (0.0%)
  total rebase fixups:  2,716,086
  total rebase fixups time: 552.17 milliseconds (13.6%)
  total binding fixups: 286,035
  total binding fixups time:  19.12 milliseconds (0.4%)
  total weak binding fixups time:   0.45 milliseconds (0.0%)
  total redo shared cached bindings time:  26.04 milliseconds (0.6%)
  total bindings lazily fixed up: 0 of 0
  total time in initializers and ObjC +load: 3.0 seconds (74.9%)
                         libSystem.B.dylib :   2.99 milliseconds (0.0%)
                libMainThreadChecker.dylib :  10.24 milliseconds (0.2%)
                       Load_Obj-C_iOS_Demo : 3.0 seconds (74.4%)
</code></pre>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1418815-load?language=objc">load - Apple Developer</a></li>
<li><a href="../category_in_ios/">iOS 中的 Category - kingcos</a></li>
<li><a href="../objc_msgsend/">浅尝 objc_msgSend - kingcos</a></li>
</ul>

    </div>
    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>
        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="/posts/2019/&#43;initialize_in_ios/">
                <span class="button__icon">←</span>
                <span class="button__text">iOS 中的 &#43;initialize 方法</span>
              </a>
            </span>
          
          
            <span class="button next">
              <a href="/posts/2019/category_in_ios/">
                <span class="button__text">iOS 中的 Category</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    

    

    
    
    <div>
      <div id="github-comment">
      </div>

      <script type="text/javascript">
        function getUtterances(isDark) {
          var utterances = document.createElement('script');
          utterances.type = 'text/javascript';
          utterances.async = true;
          utterances.setAttribute('issue-term', "pathname")
          utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
          utterances.setAttribute('label', "comments")
          isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
          utterances.crossorigin = 'anonymous';
          utterances.src = 'https://utteranc.es/client.js';

          return utterances
        }

        var themeToggle = document.querySelector(".theme-toggle")
        themeToggle.addEventListener("click", function () {
          var getTheme = window.localStorage && window.localStorage.getItem("theme")
          var divNode = document.getElementById('github-comment')
          while(divNode.hasChildNodes()) {
            divNode.removeChild(divNode.firstChild);
          }
          
          
          

          
          
          
          
          
          
          document.getElementById('github-comment').appendChild(getUtterances(getTheme !== "dark"))
        })

        var getTheme = window.localStorage && window.localStorage.getItem("theme")
        document.getElementById('github-comment').appendChild(getUtterances(getTheme === "dark"))
      </script>
    </div>
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">Powered by github.com/kingcos</div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </body>
</html>
