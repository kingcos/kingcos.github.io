<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>iOS 项目持续集成实践（二） :: iBlog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Preface 自从「iOS 项目持续集成实践（一）」发布之后，发生了很多事情，原本计划持续更新的系列文章也因此没有更新。这次我将重拾该系列，本篇的围绕核心为「使用 GitLab Runner 搭建 CI」。
What 在开始之前，我们首先要明确使用 CI 要解决哪些具体问题，这次我们先来关注代码到主仓库的过程。
在工程师开发完新 Feature 或者修复好 Bug 时，需要将代码提交到相应的仓库的某个分支，大多数团队会在代码合并（Merge）之前，强制 Code Review（代码审查）并给出 Approve（确认）或者 Comment（评论）。然而在一个团队中，每天都可能会有数十个合并请求，这样的 Code Review 很难强制约束到每个审查代码的人都能够「人眼编译」、并保证代码是合理的实践。
那么我们将希望 CI 能够替工程师完成一些固定化的检查和操作，比如单元测试、资源压缩，并在这些检查和操作都成功的前提下，再进行关注业务的 Code Review 将会高效很多。当然，CI 并不能替代 Code Review，但利用 CI 可以减轻 Code Review 的工作量，并显著提升代码和工程质量。
我们目前使用的代码托管平台是公司内部搭建的 GitLab EE，因此为了更加便捷地集成，我们选择了 GitLab Runner 作为 CI 脚本执行者，下面我们将一步步搭建、配置。
How 环境搭建 由于 Xcode 目前只能运行在 macOS 上，所以我们选择的 CI 机器是一台 Mac Pro，并重装了目前最新版本的 macOS，从零开始。关于这台 Mac Pro 的信息，可以参考下表：
   Mac Pro Info     Version Late 2013   Processor 3."/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/ci_practice_in_ios-2/" />


<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/green.css">



<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="/img/favicon/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="iOS 项目持续集成实践（二） :: iBlog — " />
<meta name="twitter:description" content="Preface 自从「iOS 项目持续集成实践（一）」发布之后，发生了很多事情，原本计划持续更新的系列文章也因此没有更新。这次我将重拾该系列，本篇的围绕核心为「使用 GitLab Runner 搭建 CI」。
What 在开始之前，我们首先要明确使用 CI 要解决哪些具体问题，这次我们先来关注代码到主仓库的过程。
在工程师开发完新 Feature 或者修复好 Bug 时，需要将代码提交到相应的仓库的某个分支，大多数团队会在代码合并（Merge）之前，强制 Code Review（代码审查）并给出 Approve（确认）或者 Comment（评论）。然而在一个团队中，每天都可能会有数十个合并请求，这样的 Code Review 很难强制约束到每个审查代码的人都能够「人眼编译」、并保证代码是合理的实践。
那么我们将希望 CI 能够替工程师完成一些固定化的检查和操作，比如单元测试、资源压缩，并在这些检查和操作都成功的前提下，再进行关注业务的 Code Review 将会高效很多。当然，CI 并不能替代 Code Review，但利用 CI 可以减轻 Code Review 的工作量，并显著提升代码和工程质量。
我们目前使用的代码托管平台是公司内部搭建的 GitLab EE，因此为了更加便捷地集成，我们选择了 GitLab Runner 作为 CI 脚本执行者，下面我们将一步步搭建、配置。
How 环境搭建 由于 Xcode 目前只能运行在 macOS 上，所以我们选择的 CI 机器是一台 Mac Pro，并重装了目前最新版本的 macOS，从零开始。关于这台 Mac Pro 的信息，可以参考下表：
   Mac Pro Info     Version Late 2013   Processor 3." />
<meta name="twitter:site" content="/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="iOS 项目持续集成实践（二） :: iBlog — ">
<meta property="og:description" content="Preface 自从「iOS 项目持续集成实践（一）」发布之后，发生了很多事情，原本计划持续更新的系列文章也因此没有更新。这次我将重拾该系列，本篇的围绕核心为「使用 GitLab Runner 搭建 CI」。
What 在开始之前，我们首先要明确使用 CI 要解决哪些具体问题，这次我们先来关注代码到主仓库的过程。
在工程师开发完新 Feature 或者修复好 Bug 时，需要将代码提交到相应的仓库的某个分支，大多数团队会在代码合并（Merge）之前，强制 Code Review（代码审查）并给出 Approve（确认）或者 Comment（评论）。然而在一个团队中，每天都可能会有数十个合并请求，这样的 Code Review 很难强制约束到每个审查代码的人都能够「人眼编译」、并保证代码是合理的实践。
那么我们将希望 CI 能够替工程师完成一些固定化的检查和操作，比如单元测试、资源压缩，并在这些检查和操作都成功的前提下，再进行关注业务的 Code Review 将会高效很多。当然，CI 并不能替代 Code Review，但利用 CI 可以减轻 Code Review 的工作量，并显著提升代码和工程质量。
我们目前使用的代码托管平台是公司内部搭建的 GitLab EE，因此为了更加便捷地集成，我们选择了 GitLab Runner 作为 CI 脚本执行者，下面我们将一步步搭建、配置。
How 环境搭建 由于 Xcode 目前只能运行在 macOS 上，所以我们选择的 CI 机器是一台 Mac Pro，并重装了目前最新版本的 macOS，从零开始。关于这台 Mac Pro 的信息，可以参考下表：
   Mac Pro Info     Version Late 2013   Processor 3." />
<meta property="og:url" content="/posts/2019/ci_practice_in_ios-2/" />
<meta property="og:site_name" content="iOS 项目持续集成实践（二）" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-04-17 00:00:00 &#43;0000 UTC" />











</head>
<body class="">


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    iBlog
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/2019/ci_practice_in_ios-2/">iOS 项目持续集成实践（二）</a></h1>
  <div class="post-meta">
    <span class="post-date">
      2019-04-17
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/practice/">Practice</a>&nbsp;
    
    #<a href="/tags/ios/">iOS</a>&nbsp;
    
    #<a href="/tags/devops/">DevOps</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    

<p><img src="/img/2019/CI_Practice_in_iOS-2/0.png" alt="CI in Practice" /></p>

<h2 id="preface">Preface</h2>

<p>自从「iOS 项目持续集成实践（一）」发布之后，发生了很多事情，原本计划持续更新的系列文章也因此没有更新。这次我将重拾该系列，本篇的围绕核心为「使用 GitLab Runner 搭建 CI」。</p>

<h2 id="what">What</h2>

<p>在开始之前，我们首先要明确使用 CI 要解决哪些具体问题，这次我们先来关注代码到主仓库的过程。</p>

<p>在工程师开发完新 Feature 或者修复好 Bug 时，需要将代码提交到相应的仓库的某个分支，大多数团队会在代码合并（Merge）之前，强制 Code Review（代码审查）并给出 Approve（确认）或者 Comment（评论）。然而在一个团队中，每天都可能会有数十个合并请求，这样的 Code Review 很难强制约束到每个审查代码的人都能够「人眼编译」、并保证代码是合理的实践。</p>

<p>那么我们将希望 CI 能够替工程师完成一些固定化的检查和操作，比如单元测试、资源压缩，并在这些检查和操作都成功的前提下，再进行关注业务的 Code Review 将会高效很多。当然，CI 并不能替代 Code Review，但利用 CI 可以减轻 Code Review 的工作量，并显著提升代码和工程质量。</p>

<p>我们目前使用的代码托管平台是公司内部搭建的 GitLab EE，因此为了更加便捷地集成，我们选择了 GitLab Runner 作为 CI 脚本执行者，下面我们将一步步搭建、配置。</p>

<h2 id="how">How</h2>

<h3 id="环境搭建">环境搭建</h3>

<p>由于 Xcode 目前只能运行在 macOS 上，所以我们选择的 CI 机器是一台 Mac Pro，并重装了目前最新版本的 macOS，从零开始。关于这台 Mac Pro 的信息，可以参考下表：</p>

<table>
<thead>
<tr>
<th align="center">Mac Pro</th>
<th align="center">Info</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">Version</td>
<td align="center">Late 2013</td>
</tr>

<tr>
<td align="center">Processor</td>
<td align="center">3.5 GHz 6-Core Intel Xeon E5</td>
</tr>

<tr>
<td align="center">Memory</td>
<td align="center">16 GB 1866 MHz DDR3</td>
</tr>

<tr>
<td align="center">Storage</td>
<td align="center">256 GB Flash Storage</td>
</tr>

<tr>
<td align="center">System</td>
<td align="center">macOS 10.14.4</td>
</tr>
</tbody>
</table>

<h4 id="iterm-fish-optional">iTerm + fish (Optional)</h4>

<p><img src="/img/2019/CI_Practice_in_iOS-2/1.png" alt="" /></p>

<p>安装 iTerm 替代系统自带的 Terminal；以及 fish shell 替代系统自带的 bash shell，fish shell 是我最近开始替代 zsh 的新选择，关于其配置可以参考 <a href="https://github.com/kingcos/EZconfigs/tree/master/Mac/shell#fish">EZConfigs - shell - fish</a>。</p>

<p>⚠️：该步骤并不会影响后续设置及结果，仅为可选。</p>

<h4 id="安装-xcode">安装 Xcode</h4>

<p>由于我们目前的 iOS 项目是 Swift + Obj-C 混编，虽然 Swift 5.0 已经 Release，但目前还没有来得及更新，因此我们这里安装的仍然是 Xcode 10.1。为了同时兼容 Xcode 后续版本，我们可以将 Xcode 的名称改为「Xcode-10.1」，这样即可和其他 Xcode 版本共存，并使用 <code>xcode-select</code> 进行切换。</p>

<p><img src="/img/2019/CI_Practice_in_iOS-2/2.png" alt="" /></p>

<p>⚠️：Xcode 第一次安装成功后，需要手动打开，它将自动安装 Command Line Tools。待安装完毕后，在 iTerm/Terminal 执行 <code>xcode-select -p</code> 尝试打印当前的 Xcode Command Line Tools 路径。如果未正确输出，可以使用 <code>sudo xcode-select -s /Applications/Xcode-10.1.app</code> 手动更改为我们安装的路径。</p>

<h4 id="homebrew">Homebrew</h4>

<p>Homebrew 是 macOS 上必备的软件包管理工具。为了统一管理各种软件，我都会尽量使用 Homebrew。在 iTerm/Terminal 中执行以下命令来安装：</p>

<pre><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>

<p>⚠️：安装期间可能需要输入系统密码。</p>

<h4 id="安装-gitlab-runner">安装 GitLab Runner</h4>

<p>使用 Homebrew 安装 GitLab Runner：</p>

<pre><code>brew install gitlab-runner
</code></pre>

<p><img src="/img/2019/CI_Practice_in_iOS-2/3.png" alt="" /></p>

<h3 id="配置-runner">配置 Runner</h3>

<p>安装好 GitLab Runner 下面就可以来注册、配置了。</p>

<h4 id="注册-runner">注册 Runner</h4>

<p><img src="/img/2019/CI_Practice_in_iOS-2/5.png" alt="" /></p>

<pre><code>sudo gitlab-runner register
</code></pre>

<p>依次输入操作系统账户密码；GitLab URL 和 GitLab CI Token，这两个内容可以在 GitLab 网页中找到，打开 GitLab 项目，左侧「Settings」-「CI/CD」-「Runners settings」-「Expand」-「Specific Runners」下方找到（可参考下图）；描述信息，方便在 Runner 页面查看；Tag，即标签，多个标签使用 <code>,</code> 分隔，标签可以在后续指定某个或某些确定的 Runner，因此我这里截取了 Mac Pro 序列号的后四位作为唯一标志；执行器（Executor），代表了运行脚本的执行者，由于 iOS 项目比较特殊，无法使用 Docker 等 Linux 系统的容器，所以这里选择 shell，后续我们将使用 shell 命令（<code>xcodebuild</code>）来执行 Xcode。</p>

<p><img src="/img/2019/CI_Practice_in_iOS-2/4.png" alt="" /></p>

<p>当我们完成注册后，就可以在 GitLab 网页中查看到我们刚刚配置的 Runner：</p>

<p><img src="/img/2019/CI_Practice_in_iOS-2/6.png" alt="" /></p>

<p>我们可以注意到右侧（箭头）的「Shared Runners」，即共享 Runner。但由于 iOS 项目特殊，必须依赖 macOS，所以这些 Runner 基本上都无法满足我们的需要，可以将该选项关闭，否则在不指定 Tag 时可能会随机分配到错误环境的 Runner，从而引发错误。</p>

<h3 id="开发模式">开发模式</h3>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="https://maimieng.com/posts/2018/ci_practice_in_ios-1/">iOS 项目持续集成实践（一）- kingcos</a></li>
<li><a href="https://about.gitlab.com/gitlab-ci/#gitlab-runner">GitLab Runner</a></li>
<li><a href="https://github.com/kingcos/EZconfigs">EZconfigs - kingcos</a></li>
</ul>

  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span
        class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      <span class="button previous">
        <a href="/posts/2019/&#43;load_in_ios/">
          <span class="button__icon">←</span>
          <span class="button__text">iOS 中的 &#43;load 方法</span>
        </a>
      </span>
      
      
      <span class="button next">
        <a href="/posts/2019/category_in_ios/">
          <span class="button__text">iOS 中的 Category</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo="kingcos/kingcos.github.io"
            issue-term="pathname"
            label="comments"
            theme="github-dark"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2019 · <a href="http://github.com/kingcos">kingcos</a></span>
      </div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>





  
</div>

</body>
</html>
