<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>《》阅读笔记 :: iBlog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Book ISBN     编写高质量 iOS 与 OS X 代码的 52 个有效方法 9787111451297   Date Chapters   2019-05-01      Speed）决定了数据能传输得多快。
 on aChip（系统芯片）。
 vonNeumann）提出的冯·诺依曼体系结构（Von Neumannarchitecture），也叫存储程序计算机
 首先是一个包含算术逻辑单元（Arithmetic LogicUnit，ALU）和处理器寄存器（ProcessorRegister）的处理器单元（ProcessingUnit），用来完成各种算术和逻辑运算。因为它能够完成各种数据的处理或者计算工作，因此也有人把这个叫作数据通路（Datapath）或者运算器。然后是一个包含指令寄存器（InstructionReigster）和程序计数器（ProgramCounter）的控制器单元（ControlUnit/CU），用来控制程序的流程，通常就是不同条件下的分支和跳转。在现在的计算机里，上面的算术逻辑单元和这里的控制器单元，共同组成了我们说的CPU。接着是用来存储数据（Data）和指令（Instruction）的内存。以及更大容量的外部存储，在过去，可能是磁带、磁鼓这样的设备，现在通常就是硬盘。最后就是各种输入和输出设备，以及对应的输入和输出机制。我们现在无论是使用什么样的计算机，其实都是和输入输出设备在打交道。个人电脑的鼠标键盘是输入设备，显示器是输出设备。我们用的智能手机，触摸屏既是输入设备，又是输出设备。而跑在各种云上的服务器，则是通过网络来进行输入和输出。这个时候，网卡既是输入设备又是输出设备。
 任何一台计算机的任何一个部件都可以归到运算器、控制器、存储器、输入设备和输出设备中，而所有的现代计算机也都是基于这个基础架构来设计开发的。
 和控制器来执行存储在存储器里的程序，最终把结果输出到输出设备中。而我们所有撰写的无论高级还是低级语言的程序，也都是基于这样一个抽象框架来进行运作的。
 Draft of a Report on theEDVAC。对于工程师来说，直接读取英文论文的原文，既可以搞清楚、弄明白对应的设计及其背后的思路来源，还可以帮你破除对于论文或者核心技术的恐惧心理。
 计算机组成原理的英文叫ComputerOrganization。这里的Organization是“组织机构”的意思。计算机由很多个不同的部件放在一起，变成了一个“组织机构”。这个组织机构最终能够进行各种计算、控制、读取输入，进行输出，达成各种强大的功能。
 CPU时钟可以用来构造寄存器和内存的锁存器和触发器，因此，CPU时钟应该是我们学习CPU的前导知识。搞明白我们为什么需要CPU时钟（CPU
 我写的程序，是怎样从输入的代码，变成运行的程序，并得到最终结果的？整个过程中，计算器层面到底经历了哪些步骤，有哪些地方是可以优化的？
 第一个是响应时间（Responsetime）或者叫执行时间（Executiontime）。想要提升响应时间这个性能指标，你可以理解为让计算机“跑得更快”。
 第二个是吞吐率（Throughput）或者带宽（Bandwidth），想要提升这个指标，你可以理解为让计算机“搬得更多”。
 而吞吐率是指我们在一定的时间范围内，到底能处理多少事情。这里的“事情”，在计算机里就是处理的数据或者执行的程序指令。
 提升吞吐率的办法有很多。大部分时候，我们只要多加一些机器，多堆一些硬件就好了。但是响应时间的提升却没有那么容易，因为CPU的性能提升其实在10年前就处于“挤牙膏”的状态了，所以我们得慎重地来分析对待。下面我们具体来看。
 我们一般把性能，定义成响应时间的倒数，也就是：性能 =1/响应时间
 第一个就是时间不“准”。如果用你自己随便写的一个程序，来统计程序运行的时间，每一次统计结果不会完全一样。有可能这一次花了45ms，下一次变成了53ms。"/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/temp/" />


<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/green.css">



<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="/img/favicon/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="《》阅读笔记 :: iBlog — " />
<meta name="twitter:description" content="Book ISBN     编写高质量 iOS 与 OS X 代码的 52 个有效方法 9787111451297   Date Chapters   2019-05-01      Speed）决定了数据能传输得多快。
 on aChip（系统芯片）。
 vonNeumann）提出的冯·诺依曼体系结构（Von Neumannarchitecture），也叫存储程序计算机
 首先是一个包含算术逻辑单元（Arithmetic LogicUnit，ALU）和处理器寄存器（ProcessorRegister）的处理器单元（ProcessingUnit），用来完成各种算术和逻辑运算。因为它能够完成各种数据的处理或者计算工作，因此也有人把这个叫作数据通路（Datapath）或者运算器。然后是一个包含指令寄存器（InstructionReigster）和程序计数器（ProgramCounter）的控制器单元（ControlUnit/CU），用来控制程序的流程，通常就是不同条件下的分支和跳转。在现在的计算机里，上面的算术逻辑单元和这里的控制器单元，共同组成了我们说的CPU。接着是用来存储数据（Data）和指令（Instruction）的内存。以及更大容量的外部存储，在过去，可能是磁带、磁鼓这样的设备，现在通常就是硬盘。最后就是各种输入和输出设备，以及对应的输入和输出机制。我们现在无论是使用什么样的计算机，其实都是和输入输出设备在打交道。个人电脑的鼠标键盘是输入设备，显示器是输出设备。我们用的智能手机，触摸屏既是输入设备，又是输出设备。而跑在各种云上的服务器，则是通过网络来进行输入和输出。这个时候，网卡既是输入设备又是输出设备。
 任何一台计算机的任何一个部件都可以归到运算器、控制器、存储器、输入设备和输出设备中，而所有的现代计算机也都是基于这个基础架构来设计开发的。
 和控制器来执行存储在存储器里的程序，最终把结果输出到输出设备中。而我们所有撰写的无论高级还是低级语言的程序，也都是基于这样一个抽象框架来进行运作的。
 Draft of a Report on theEDVAC。对于工程师来说，直接读取英文论文的原文，既可以搞清楚、弄明白对应的设计及其背后的思路来源，还可以帮你破除对于论文或者核心技术的恐惧心理。
 计算机组成原理的英文叫ComputerOrganization。这里的Organization是“组织机构”的意思。计算机由很多个不同的部件放在一起，变成了一个“组织机构”。这个组织机构最终能够进行各种计算、控制、读取输入，进行输出，达成各种强大的功能。
 CPU时钟可以用来构造寄存器和内存的锁存器和触发器，因此，CPU时钟应该是我们学习CPU的前导知识。搞明白我们为什么需要CPU时钟（CPU
 我写的程序，是怎样从输入的代码，变成运行的程序，并得到最终结果的？整个过程中，计算器层面到底经历了哪些步骤，有哪些地方是可以优化的？
 第一个是响应时间（Responsetime）或者叫执行时间（Executiontime）。想要提升响应时间这个性能指标，你可以理解为让计算机“跑得更快”。
 第二个是吞吐率（Throughput）或者带宽（Bandwidth），想要提升这个指标，你可以理解为让计算机“搬得更多”。
 而吞吐率是指我们在一定的时间范围内，到底能处理多少事情。这里的“事情”，在计算机里就是处理的数据或者执行的程序指令。
 提升吞吐率的办法有很多。大部分时候，我们只要多加一些机器，多堆一些硬件就好了。但是响应时间的提升却没有那么容易，因为CPU的性能提升其实在10年前就处于“挤牙膏”的状态了，所以我们得慎重地来分析对待。下面我们具体来看。
 我们一般把性能，定义成响应时间的倒数，也就是：性能 =1/响应时间
 第一个就是时间不“准”。如果用你自己随便写的一个程序，来统计程序运行的时间，每一次统计结果不会完全一样。有可能这一次花了45ms，下一次变成了53ms。" />
<meta name="twitter:site" content="/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="《》阅读笔记 :: iBlog — ">
<meta property="og:description" content="Book ISBN     编写高质量 iOS 与 OS X 代码的 52 个有效方法 9787111451297   Date Chapters   2019-05-01      Speed）决定了数据能传输得多快。
 on aChip（系统芯片）。
 vonNeumann）提出的冯·诺依曼体系结构（Von Neumannarchitecture），也叫存储程序计算机
 首先是一个包含算术逻辑单元（Arithmetic LogicUnit，ALU）和处理器寄存器（ProcessorRegister）的处理器单元（ProcessingUnit），用来完成各种算术和逻辑运算。因为它能够完成各种数据的处理或者计算工作，因此也有人把这个叫作数据通路（Datapath）或者运算器。然后是一个包含指令寄存器（InstructionReigster）和程序计数器（ProgramCounter）的控制器单元（ControlUnit/CU），用来控制程序的流程，通常就是不同条件下的分支和跳转。在现在的计算机里，上面的算术逻辑单元和这里的控制器单元，共同组成了我们说的CPU。接着是用来存储数据（Data）和指令（Instruction）的内存。以及更大容量的外部存储，在过去，可能是磁带、磁鼓这样的设备，现在通常就是硬盘。最后就是各种输入和输出设备，以及对应的输入和输出机制。我们现在无论是使用什么样的计算机，其实都是和输入输出设备在打交道。个人电脑的鼠标键盘是输入设备，显示器是输出设备。我们用的智能手机，触摸屏既是输入设备，又是输出设备。而跑在各种云上的服务器，则是通过网络来进行输入和输出。这个时候，网卡既是输入设备又是输出设备。
 任何一台计算机的任何一个部件都可以归到运算器、控制器、存储器、输入设备和输出设备中，而所有的现代计算机也都是基于这个基础架构来设计开发的。
 和控制器来执行存储在存储器里的程序，最终把结果输出到输出设备中。而我们所有撰写的无论高级还是低级语言的程序，也都是基于这样一个抽象框架来进行运作的。
 Draft of a Report on theEDVAC。对于工程师来说，直接读取英文论文的原文，既可以搞清楚、弄明白对应的设计及其背后的思路来源，还可以帮你破除对于论文或者核心技术的恐惧心理。
 计算机组成原理的英文叫ComputerOrganization。这里的Organization是“组织机构”的意思。计算机由很多个不同的部件放在一起，变成了一个“组织机构”。这个组织机构最终能够进行各种计算、控制、读取输入，进行输出，达成各种强大的功能。
 CPU时钟可以用来构造寄存器和内存的锁存器和触发器，因此，CPU时钟应该是我们学习CPU的前导知识。搞明白我们为什么需要CPU时钟（CPU
 我写的程序，是怎样从输入的代码，变成运行的程序，并得到最终结果的？整个过程中，计算器层面到底经历了哪些步骤，有哪些地方是可以优化的？
 第一个是响应时间（Responsetime）或者叫执行时间（Executiontime）。想要提升响应时间这个性能指标，你可以理解为让计算机“跑得更快”。
 第二个是吞吐率（Throughput）或者带宽（Bandwidth），想要提升这个指标，你可以理解为让计算机“搬得更多”。
 而吞吐率是指我们在一定的时间范围内，到底能处理多少事情。这里的“事情”，在计算机里就是处理的数据或者执行的程序指令。
 提升吞吐率的办法有很多。大部分时候，我们只要多加一些机器，多堆一些硬件就好了。但是响应时间的提升却没有那么容易，因为CPU的性能提升其实在10年前就处于“挤牙膏”的状态了，所以我们得慎重地来分析对待。下面我们具体来看。
 我们一般把性能，定义成响应时间的倒数，也就是：性能 =1/响应时间
 第一个就是时间不“准”。如果用你自己随便写的一个程序，来统计程序运行的时间，每一次统计结果不会完全一样。有可能这一次花了45ms，下一次变成了53ms。" />
<meta property="og:url" content="/posts/2019/temp/" />
<meta property="og:site_name" content="《》阅读笔记" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-05-01 00:00:00 &#43;0000 UTC" />











</head>
<body class="">


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    iBlog
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/2019/temp/">《》阅读笔记</a></h1>
  <div class="post-meta">
    <span class="post-date">
      2019-05-01
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/read/">Read</a>&nbsp;
    
    #<a href="/tags/ios/">iOS</a>&nbsp;
    
    #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    <table>
<thead>
<tr>
<th align="center">Book</th>
<th align="center">ISBN</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">编写高质量 iOS 与 OS X 代码的 52 个有效方法</td>
<td align="center">9787111451297</td>
</tr>

<tr>
<td align="center"><strong>Date</strong></td>
<td align="center"><strong>Chapters</strong></td>
</tr>

<tr>
<td align="center">2019-05-01</td>
<td align="center"></td>
</tr>
</tbody>
</table>

<ul>
<li><p>Speed）决定了数据能传输得多快。</p></li>

<li><p>on aChip（系统芯片）。</p></li>

<li><p>vonNeumann）提出的冯·诺依曼体系结构（Von Neumannarchitecture），也叫存储程序计算机</p></li>

<li><p>首先是一个包含算术逻辑单元（Arithmetic LogicUnit，ALU）和处理器寄存器（ProcessorRegister）的处理器单元（ProcessingUnit），用来完成各种算术和逻辑运算。因为它能够完成各种数据的处理或者计算工作，因此也有人把这个叫作数据通路（Datapath）或者运算器。然后是一个包含指令寄存器（InstructionReigster）和程序计数器（ProgramCounter）的控制器单元（ControlUnit/CU），用来控制程序的流程，通常就是不同条件下的分支和跳转。在现在的计算机里，上面的算术逻辑单元和这里的控制器单元，共同组成了我们说的CPU。接着是用来存储数据（Data）和指令（Instruction）的内存。以及更大容量的外部存储，在过去，可能是磁带、磁鼓这样的设备，现在通常就是硬盘。最后就是各种输入和输出设备，以及对应的输入和输出机制。我们现在无论是使用什么样的计算机，其实都是和输入输出设备在打交道。个人电脑的鼠标键盘是输入设备，显示器是输出设备。我们用的智能手机，触摸屏既是输入设备，又是输出设备。而跑在各种云上的服务器，则是通过网络来进行输入和输出。这个时候，网卡既是输入设备又是输出设备。</p></li>

<li><p>任何一台计算机的任何一个部件都可以归到运算器、控制器、存储器、输入设备和输出设备中，而所有的现代计算机也都是基于这个基础架构来设计开发的。</p></li>

<li><p>和控制器来执行存储在存储器里的程序，最终把结果输出到输出设备中。而我们所有撰写的无论高级还是低级语言的程序，也都是基于这样一个抽象框架来进行运作的。</p></li>

<li><p>Draft of a Report on theEDVAC。对于工程师来说，直接读取英文论文的原文，既可以搞清楚、弄明白对应的设计及其背后的思路来源，还可以帮你破除对于论文或者核心技术的恐惧心理。</p></li>

<li><p>计算机组成原理的英文叫ComputerOrganization。这里的Organization是“组织机构”的意思。计算机由很多个不同的部件放在一起，变成了一个“组织机构”。这个组织机构最终能够进行各种计算、控制、读取输入，进行输出，达成各种强大的功能。</p></li>

<li><p>CPU时钟可以用来构造寄存器和内存的锁存器和触发器，因此，CPU时钟应该是我们学习CPU的前导知识。搞明白我们为什么需要CPU时钟（CPU</p></li>

<li><p>我写的程序，是怎样从输入的代码，变成运行的程序，并得到最终结果的？整个过程中，计算器层面到底经历了哪些步骤，有哪些地方是可以优化的？</p></li>

<li><p>第一个是响应时间（Responsetime）或者叫执行时间（Executiontime）。想要提升响应时间这个性能指标，你可以理解为让计算机“跑得更快”。</p></li>

<li><p>第二个是吞吐率（Throughput）或者带宽（Bandwidth），想要提升这个指标，你可以理解为让计算机“搬得更多”。</p></li>

<li><p>而吞吐率是指我们在一定的时间范围内，到底能处理多少事情。这里的“事情”，在计算机里就是处理的数据或者执行的程序指令。</p></li>

<li><p>提升吞吐率的办法有很多。大部分时候，我们只要多加一些机器，多堆一些硬件就好了。但是响应时间的提升却没有那么容易，因为CPU的性能提升其实在10年前就处于“挤牙膏”的状态了，所以我们得慎重地来分析对待。下面我们具体来看。</p></li>

<li><p>我们一般把性能，定义成响应时间的倒数，也就是：性能 =1/响应时间</p></li>

<li><p>第一个就是时间不“准”。如果用你自己随便写的一个程序，来统计程序运行的时间，每一次统计结果不会完全一样。有可能这一次花了45ms，下一次变成了53ms。</p></li>

<li><p>ClockTime或者ElapsedTime，就是在运行程序期间，挂在墙上的钟走掉的时间。</p></li>

<li><p>但是，计算机可能同时运行着好多个程序，CPU实际上不停地在各个程序之间进行切换。在这些走掉的时间里面，很可能CPU切换去运行别的程序了。而且，有些程序在运行的时候，可能要从网络、硬盘去读取数据，要等网络和硬盘把数据读出来，给到内存和CPU。所以说，要想准确统计某个程序运行时间，进而去比较两个程序的实际性能，我们得把这些时间给刨除掉。</p></li>

<li><p>我们简单运行一下time命令。它会返回三个值，第一个是realtime，也就是我们说的Wall ClockTime，也就是运行程序整个过程中流逝掉的时间；第二个是usertime，也就是CPU在运行你的程序，在用户态运行指令的时间；第三个是systime，是CPU在运行你的程序，在操作系统内核里运行指令的时间。而程序实际花费的CPU执行时间（CPUTime），就是usertime加上sys time。</p></li>

<li><p>其次，即使我们已经拿到了CPU时间，我们也不一定可以直接“比较”出两个程序的性能差异。即使在同一台计算机上，CPU可能满载运行也可能降频运行，降频运行的时候自然花的时间会多一些。</p></li>

<li><p>CPU时钟周期数（CPUCycles）和时钟周期时间（ClockCycle）的乘积。</p></li>

<li><p>程序的CPU执行时间=CPU时钟周期数×时钟周期时间</p></li>

<li><p>Crystal）的东西，简称为晶振。我们把晶振当成CPU内部的电子表来使用。晶振带来的每一次“滴答”，就是时钟周期时间。</p></li>

<li><p>对于CPU时钟周期数，我们可以再做一个分解，把它变成“指令数×每条指令的平均时钟周期数（Cycles PerInstruction，简称CPI）”。不同的指令需要的Cycles是不同的，加法和乘法都对应着一条CPU指令，但是乘法需要的Cycles就比加法要多，自然也就慢。在这样拆分了之后，我们的程序的CPU执行时间就可以变成这样三个部分的乘积。</p></li>

<li><p>程序的CPU执行时间=指令数×CPI×Clock Cycle Time</p></li>

<li><p>时钟周期时间，就是计算机主频，这个取决于计算机硬件。我们所熟知的摩尔定律就一直在不停地提高我们计算机的主频。比如说，我最早使用的80386主频只有33MHz，现在手头的笔记本电脑就有2.8GHz，在主频层面，就提升了将近100倍。</p></li>

<li><p>每条指令的平均时钟周期数CPI，就是一条指令到底需要多少CPUCycle。在后面讲解CPU结构的时候，我们会看到，现代的CPU通过流水线技术（Pipeline），让一条指令需要的CPU</p></li>

<li><p>Cycle尽可能地少。因此，对于CPI的优化，也是计算机组成和体系结构中的重要一环。</p></li>

<li><p>指令数，代表执行我们的程序到底需要多少条指令、用哪些指令。这个很多时候就把挑战交给了编译器。同样的代码，编译成计算机指令时候，就有各种不同的表示方式。</p></li>
</ul>

  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span
        class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      <span class="button previous">
        <a href="/posts/2019/swift_4_to_5/">
          <span class="button__icon">←</span>
          <span class="button__text">Swift/Obj-C 混编项目升级 Swift 5 踩坑</span>
        </a>
      </span>
      
      
      <span class="button next">
        <a href="/posts/2019/effective_objc_2.0_notes/">
          <span class="button__text">《编写高质量 iOS 与 OS X 代码的 52 个有效方法》阅读笔记</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo="kingcos/kingcos.github.io"
            issue-term="pathname"
            label="comments"
            theme="github-dark"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2019 · <a href="http://github.com/kingcos">kingcos</a></span>
      </div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>





  
</div>

</body>
</html>
