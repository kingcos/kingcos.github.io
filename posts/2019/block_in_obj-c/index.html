<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Obj-C 中的 Block :: iBlog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Preface Obj-C 中的 Block，即闭包，其相关知识点非常多，那么本文就来仔细谈谈其中的概念与原理。
需要注意的是，以下代码块中如未明确标示 // MRC 即表明该处代码块运行环境并不需要关闭 ARC（Automatic Reference Counting，自动引用计数）。ARC 的开关可以参照下图设置（No: MRC, Yes: ARC）：
Block 的本质 // main.m #import &amp;lt;Foundation/Foundation.h&amp;gt; int main(int argc, const char * argv[]) { @autoreleasepool { ^{ NSLog(@&amp;quot;Hello, World!&amp;quot;); }(); } return 0; } // OUTPUT: // Hello, World!  在 main 函数中声明一个最简单的 Block，其中只有一句打印 Hello, World! 的语句。为了看清 Block 的结构，我们尝试使用 xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp 命令将 main.m 翻译为 C/C&#43;&#43; 代码来分析。"/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/block_in_obj-c/" />


<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/green.css">



<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="/img/favicon/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Obj-C 中的 Block :: iBlog — " />
<meta name="twitter:description" content="Preface Obj-C 中的 Block，即闭包，其相关知识点非常多，那么本文就来仔细谈谈其中的概念与原理。
需要注意的是，以下代码块中如未明确标示 // MRC 即表明该处代码块运行环境并不需要关闭 ARC（Automatic Reference Counting，自动引用计数）。ARC 的开关可以参照下图设置（No: MRC, Yes: ARC）：
Block 的本质 // main.m #import &amp;lt;Foundation/Foundation.h&amp;gt; int main(int argc, const char * argv[]) { @autoreleasepool { ^{ NSLog(@&amp;quot;Hello, World!&amp;quot;); }(); } return 0; } // OUTPUT: // Hello, World!  在 main 函数中声明一个最简单的 Block，其中只有一句打印 Hello, World! 的语句。为了看清 Block 的结构，我们尝试使用 xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp 命令将 main.m 翻译为 C/C&#43;&#43; 代码来分析。" />
<meta name="twitter:site" content="/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Obj-C 中的 Block :: iBlog — ">
<meta property="og:description" content="Preface Obj-C 中的 Block，即闭包，其相关知识点非常多，那么本文就来仔细谈谈其中的概念与原理。
需要注意的是，以下代码块中如未明确标示 // MRC 即表明该处代码块运行环境并不需要关闭 ARC（Automatic Reference Counting，自动引用计数）。ARC 的开关可以参照下图设置（No: MRC, Yes: ARC）：
Block 的本质 // main.m #import &amp;lt;Foundation/Foundation.h&amp;gt; int main(int argc, const char * argv[]) { @autoreleasepool { ^{ NSLog(@&amp;quot;Hello, World!&amp;quot;); }(); } return 0; } // OUTPUT: // Hello, World!  在 main 函数中声明一个最简单的 Block，其中只有一句打印 Hello, World! 的语句。为了看清 Block 的结构，我们尝试使用 xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp 命令将 main.m 翻译为 C/C&#43;&#43; 代码来分析。" />
<meta property="og:url" content="/posts/2019/block_in_obj-c/" />
<meta property="og:site_name" content="Obj-C 中的 Block" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2009-05-19 00:00:00 &#43;0000 UTC" />











</head>
<body class="">


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    iBlog
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About &amp; AMA</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About &amp; AMA</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/2019/block_in_obj-c/">Obj-C 中的 Block</a></h1>
  <div class="post-meta">
    <span class="post-date">
      2009-05-19
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/focus/">Focus</a>&nbsp;
    
    #<a href="/tags/ios/">iOS</a>&nbsp;
    
    #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    

<h2 id="preface">Preface</h2>

<p>Obj-C 中的 Block，即闭包，其相关知识点非常多，那么本文就来仔细谈谈其中的概念与原理。</p>

<p>需要注意的是，以下代码块中如未明确标示 <code>// MRC</code> 即表明该处代码块运行环境并不需要关闭 ARC（Automatic Reference Counting，自动引用计数）。ARC 的开关可以参照下图设置（No: MRC, Yes: ARC）：</p>

<p><img src="/img/2019/Block_in_Obj-C/3.png" alt="" /></p>

<h2 id="block-的本质">Block 的本质</h2>

<pre><code class="language-objectivec">// main.m
#import &lt;Foundation/Foundation.h&gt;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        ^{
            NSLog(@&quot;Hello, World!&quot;);
        }();
    }
    return 0;
}

// OUTPUT:
// Hello, World!
</code></pre>

<p>在 <code>main</code> 函数中声明一个最简单的 Block，其中只有一句打印 <code>Hello, World!</code> 的语句。为了看清 Block 的结构，我们尝试使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</code> 命令将 main.m 翻译为 C/C++ 代码来分析。</p>

<pre><code class="language-cpp">struct __block_impl {
  void *isa;     // isa 指针
  int Flags;     // 标记，默认会被初始化为 0
  int Reserved;  // 保留域
  void *FuncPtr; // Block 代码块的函数指针
};

static struct __main_block_desc_0 {
  size_t reserved;   // 保留域，默认 0
  size_t Block_size; // Block 大小，sizeof 整个结构体
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

struct __main_block_impl_0 {
  struct __block_impl impl;         // 实现，注意非指针
  struct __main_block_desc_0* Desc; // 描述信息
  // 构造函数
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

// 静态函数封装 Block 内代码块
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {

            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_429af3_mi_0);
        }

// 定义 Block 变量
// void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));
void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));

// 执行 Block 内部代码
// 在 __main_block_impl_0 结构体中，impl 是第一个变量，因此其与结构体本身的首地址一致，因此可以强转
// block-&gt;FuncPtr(block);
((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
</code></pre>

<p>当我们声明 Block 后，其中的代码会被封装到 <code>__main_block_func_0</code> 静态函数中（后缀 <code>0</code> 代表序号），用来和 <code>__main_block_desc_0_DATA</code> 构造 <code>__main_block_impl_0</code>，并在该构造函数中将函数名（即函数指针）赋值给 <code>FuncPtr</code>；最终在 Block 真正调用时，通过 <code>block-&gt;FuncPtr(block)</code> 执行 Block 代码块。</p>

<p><img src="/img/2019/Block_in_Obj-C/1.png" alt="" /></p>

<p>将如上结构图形化，Obj-C 的 Block 的本质是 <code>__main_block_impl_0</code> 结构体。该结构体中又直接包含了 <code>__block_impl</code> 结构体，以及指向 <code>__main_block_desc_0</code> 结构体的指针。在 <code>__block_impl</code> 结构体中，<code>isa</code> 暗示了其本质是 Obj-C 对象的事实，而 <code>FuncPtr</code> 函数指针则指向 Block 中要执行的代码块。我们也可以尝试将 Block 转换为同样结构的 C 语言结构体，这样就能发现 <code>FuncPtr</code> 的首地址与 Block 中的代码块首地址其实是一致的：</p>

<p><img src="/img/2019/Block_in_Obj-C/2.png" alt="" /></p>

<p>所以总的来说 Block 本质即<strong>封装了函数调用以及函数调用环境的 Obj-C 对象</strong>。</p>

<h2 id="block-的变量捕获">Block 的变量捕获</h2>

<h3 id="局部变量">局部变量</h3>

<h4 id="自动变量">自动变量</h4>

<p>自动变量（Automatic Variable）即局部作用域变量，具体指在代码块中声明的变量，也可以使用 <code>auto</code> 关键字来显式声明。</p>

<pre><code class="language-objectivec">// main.m
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // auto int a = 1;
        int a = 1;
        
        void (^block)(void) = ^() {
            NSLog(@&quot;a == %d&quot;, a);
        };
        
        block();
    }
    return 0;
}
</code></pre>

<p>对于自动变量，由于其生命周期可能小于 Block 本身，因此 Block 会将自动变量捕获到结构体内部（即值传递），因此即使后续更改原有的变量值也不会影响已经被捕获的变量值：</p>

<pre><code class="language-cpp">struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  int a; // ⚠️ 捕获的变量
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  // a：取值
  int a = __cself-&gt;a; // bound by copy

    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_3c9d7c_mi_0, a);
}

int a = 1;
// 传入 a 本身作为参数
// 去掉类型转换：void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, a));
void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));
// 去掉类型转换：block-&gt;FuncPtr(block);
((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
</code></pre>

<h4 id="局部静态变量">局部静态变量</h4>

<p>局部静态变量指定义在函数体（代码块）内的静态变量，其作用域在函数体内，但并不会随函数返回而销毁。</p>

<pre><code class="language-objectivec">// main.m
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        static int a = 1;

        void (^block)(void) = ^() {
            NSLog(@&quot;a == %d&quot;, a);
        };
        a = 10;

        block();
    }
    return 0;
}

// OUTOUT:
// a == 10
</code></pre>

<p>由于静态局部变量的生命周期结束于程序退出，Block 只需要将局部静态变量的<strong>地址</strong>进行捕获（即引用传递），这样即使超过函数体的作用域 Block 中仍然可以访问到。而正因为捕获的是地址，因此当外界在 Block 执行前改变了局部静态变量的值，那么执行时也将获取到最新的值。</p>

<pre><code class="language-cpp">struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  int *a; // ⚠️ 捕获的变量地址
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  // *a：取地址中存储的值
  int *a = __cself-&gt;a; // bound by copy

    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_adf509_mi_0, (*a));
}

static int a = 1;
// 传入 &amp;a 即 a 的地址作为参数
// 去掉类型转换：void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;a);
void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;a));

// a 的值被改变
a = 10;

((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
</code></pre>

<h4 id="self"><code>self</code></h4>

<p>刚才我们分析了 Block 对于不同类型的局部变量捕获区别，那么 <code>self</code> 呢？</p>

<pre><code class="language-objectivec">#import &quot;A.h&quot;

@implementation A

- (void)objectFunc {
    void (^block)(void) = ^() {
        NSLog(@&quot;%@&quot;, self);
    };

    block();
}

@end
</code></pre>

<p>Obj-C 中的方法默认都会带有两个参数，即当前对象 <code>self</code> 和当前方法 <code>_cmd</code>。函数参数的作用域又在函数体内，属于自动变量，因此 Block 也会对其本身直接进行捕获：</p>

<pre><code class="language-cpp">// - (void)objectFunc
static void _I_A_objectFunc(A * self, SEL _cmd) {
    void (*block)(void) = ((void (*)())&amp;__A__objectFunc_block_impl_0((void *)__A__objectFunc_block_func_0, &amp;__A__objectFunc_block_desc_0_DATA, self, 570425344));

    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
}

struct __A__block_block_impl_0 {
  struct __block_impl impl;
  struct __A__block_block_desc_0* Desc;
  A *self; // ⚠️ 捕获的 self
  __A__block_block_impl_0(void *fp, struct __A__block_block_desc_0 *desc, A *_self, int flags=0) : self(_self) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __A__block_block_func_0(struct __A__block_block_impl_0 *__cself) {
  A *self = __cself-&gt;self; // bound by copy

        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_A_2e834a_mi_0, self);
    }
</code></pre>

<p>那么成员变量呢？</p>

<pre><code class="language-objectivec">#import &quot;A.h&quot;

@implementation A {
    NSString *_memVar;
}

- (void)objectFunc {
    void (^block)(void) = ^() {
        NSLog(@&quot;%@&quot;, _memVar);
    };

    block();
}

@end
</code></pre>

<p>同理如果 Block 中引入了成员变量，本质其实是通过 <code>self</code> 进行访问，也会对 <code>self</code> 本身进行捕获：</p>

<pre><code class="language-cpp">struct __A__objectFunc_block_impl_0 {
  struct __block_impl impl;
  struct __A__objectFunc_block_desc_0* Desc;
  A *self; // ⚠️ 捕获的 self
  __A__objectFunc_block_impl_0(void *fp, struct __A__objectFunc_block_desc_0 *desc, A *_self, int flags=0) : self(_self) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __A__objectFunc_block_func_0(struct __A__objectFunc_block_impl_0 *__cself) {
  A *self = __cself-&gt;self; // bound by copy

        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_A_f4faca_mi_0, (*(NSString **)((char *)self + OBJC_IVAR_$_A$_memVar)));
    }
</code></pre>

<h3 id="block-中的全局变量">Block 中的全局变量</h3>

<p>全局变量即定义在所有函数体外的变量，其生命周期结束语程序退出：</p>

<pre><code class="language-objectivec">// main.m
// 全局变量：
int a = 1;
static int b = 2;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        void (^block)(void) = ^() {
            NSLog(@&quot;a == %d, b == %d&quot;, a, b);
        };
        
        a = 10;
        b = 20;
        
        block();
    }
}

// OUTOUT:
// a == 10, b == 20
</code></pre>

<p>因此对于全局变量，Block 并不会去捕获，而是在用的时候直接进行读取即可：</p>

<pre><code class="language-cpp">int a = 1;
static int b = 2;

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {

            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_437bca_mi_0, a, b);
        }
</code></pre>

<h2 id="block-的类型">Block 的类型</h2>

<p>Obj-C 中的 Block 根据其存储在不同的内存区域被分为三种：<code>__NSGlobalBlock__</code>、<code>__NSStackBlock__</code>、<code>__NSMallocBlock__</code>，它们又各自继承自 <code>__NSGlobalBlock</code>、<code>__NSMallocBlock</code>、<code>__NSStackBlock</code>，这些父类又都继承自 <code>NSBlock</code>，<code>NSBlock</code> 又继承自 <code>NSObject</code>：</p>

<pre><code class="language-objectivec">int main(int argc, const char * argv[]) {
    @autoreleasepool {
        void (^block1)(void) = ^() {
            NSLog(@&quot;Hello, world!&quot;);
        };
        
        int a = 1;
        void (^block2)(void) = ^() {
            NSLog(@&quot;%d&quot;, a);
        };
        
        NSLog(@&quot;%@ %@ %@&quot;, [block1 class], [block2 class], [^{
            NSLog(@&quot;%d&quot;, a);
        } class]);

        NSLog(@&quot;%@ %@ %@&quot;, [block1 superclass], [block2 superclass],[^{
            NSLog(@&quot;%d&quot;, a);
        } superclass]);

        NSLog(@&quot;%@ %@ %@&quot;, [[block1 superclass] superclass], [[block2 superclass] superclass],[[^{
            NSLog(@&quot;%d&quot;, a);
        } superclass] superclass]);

        NSLog(@&quot;%@ %@ %@&quot;, [[[block1 superclass] superclass] superclass], [[[block2 superclass] superclass] superclass],[[[^{
            NSLog(@&quot;%d&quot;, a);
        } superclass] superclass] superclass]);
    }
    return 0;
}

// OUTPUT:
// __NSGlobalBlock__ __NSMallocBlock__ __NSStackBlock__
// __NSGlobalBlock __NSMallocBlock __NSStackBlock
// NSBlock NSBlock NSBlock
// NSObject NSObject NSObject
</code></pre>

<blockquote>
<p>⚠️</p>

<p>在上一节中，我们可以从翻译的 C++ 代码中看到 Block 内部的 <code>isa</code> 指针指向了 <code>&amp;_NSConcreteStackBlock</code>，但其实在 Xcode 真正的编译运行时并不存在「翻译」的步骤，因此这里我们最好使用运行时的方法来确定 Block 的类型。</p>
</blockquote>

<h3 id="nsglobalblock"><code>__NSGlobalBlock__</code></h3>

<p><code>__NSGlobalBlock__</code> 类型的 Block 存储在内存的数据区（Data 段），该区域通常也会存放全局变量。</p>

<pre><code class="language-objectivec">// main.m
int a = 1;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // 没有访问任何外界变量
        void (^gloablBlock)(void) = ^{
            NSLog(@&quot;This is a __NSGlobalBlock__.&quot;);
        };
        gloablBlock();
        
        NSLog(@&quot;%@&quot;, [gloablBlock class]);

        static int b = 1;

        // 访问了全局变量、或局部静态变量
        gloablBlock = ^{
            NSLog(@&quot;a == %d, b == %d.&quot;, a, b);
        };
        gloablBlock();
        
        NSLog(@&quot;%@&quot;, [gloablBlock class]);
    }
}

// OUTPUT:
//  This is a __NSGlobalBlock__.
// __NSGlobalBlock__
// a == 1, b == 1.
// __NSGlobalBlock__
</code></pre>

<p>在 Block 内没有访问外界<strong>自动</strong>变量的 Block 均属于 <code>__NSGlobalBlock__</code>。</p>

<h3 id="nsstackblock"><code>__NSStackBlock__</code></h3>

<p><code>__NSStackBlock__</code> 类型的 Block 存储在内存的栈区，而栈区内存是不需要开发者来管理的，超过作用域的栈区内存将会被自动回收。</p>

<pre><code class="language-objectivec">// MRC

// main.m
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        int c = 1;

        void (^stackBlock)(void) = ^{
            NSLog(@&quot;c == %d.&quot;, c);
        };
        stackBlock();
        
        NSLog(@&quot;%@&quot;, [stackBlock class]);
    }
}

// OUTPUT:
// c == 1.
//  __NSStackBlock__
</code></pre>

<p>在 Block 内访问了外界<strong>自动</strong>变量（自动变量被分配在了栈区）的 Block 在 MRC 下均属于 <code>__NSStackBlock__</code>。</p>

<p>正是由于 <code>__NSStackBlock__</code> 类型的 Block 存储在内存的栈区，所以即使 Block 内部捕获了自动变量，但这个变量也仍然在栈区，会随着作用域而释放。我们尝试让 Block 捕获自动变量，并在其作用域外调用：</p>

<pre><code class="language-objectivec">// MRC

// main.m
void (^stackBlock)(void);

void initBlock() {
    int c = 10;
    stackBlock = ^{
        NSLog(@&quot;c == %d.&quot;, c);
    };
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // 首先在 initBlock 中初始化 stackBlock
        initBlock();
        // 执行 stackBlock Block
        stackBlock();

        // EXC_BAD_ACCESS
        // NSLog(@&quot;stackBlock is a %@.&quot;, [stackBlock class]);
    }
}

// OUTPUT:
// c == -272632648.
</code></pre>

<p>此时 <code>c</code> 变成了一个脏数据，这就是因为捕获的 Block 中的 <code>c</code> 在栈上由于超出作用域而被释放，此时再去访问 <code>c</code> 内存地址，其中的值已经发生了改变；同理访问 Block 中的 <code>class</code> 也出现了 <code>EXC_BAD_ACCESS</code>。为了避免这种问题，我们需要将 Block 分配在堆上（即 <code>__NSMallocBlock__</code>），与栈区不同，堆区的内存是需要开发者自己来管理的，也就可以避免被自动回收。</p>

<h3 id="nsmallocblock"><code>__NSMallocBlock__</code></h3>

<p><code>__NSMallocBlock__</code> 类型的 Block 存储在内存的堆区，堆区通常用作动态分配（Malloc）的内存。在 MRC 下，对于 <code>__NSStackBlock__</code> 类型的 Block 只要再对其发送 <code>copy</code> 消息即可将栈上的内存拷贝到堆上：</p>

<pre><code class="language-objectivec">// MRC

// main.m
void (^mallocBlock)(void);

void initBlock() {
    int c = 10;
    mallocBlock = [^{
        NSLog(@&quot;c == %d.&quot;, c);
    } copy];
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // 首先在 initBlock 中初始化 mallocBlock
        initBlock();
        // 执行 mallocBlock Block
        mallocBlock();

        NSLog(@&quot;mallocBlock is a %@.&quot;, [mallocBlock class]);
    }
}

// OUTPUT:
// c == 10.
// mallocBlock is a __NSMallocBlock__.
</code></pre>

<blockquote>
<p>⚠️</p>

<ul>
<li>对于 <code>[__NSGlobalBlock__ copy]</code>，仍将返回 <code>__NSGlobalBlock__</code>；</li>
<li>对于 <code>[__NSStackBlock__ copy]</code>，将从栈拷贝到堆区，返回 <code>__NSMallocBlock__</code>；</li>
<li>对于 <code>[__NSMallocBlock__ copy]</code>，引用计数会增加（相当于 <code>ratain</code>）？？如何证明？？</li>
</ul>
</blockquote>

<ul>
<li>在 ARC 下，编译器会根据情况将栈上的 Block（<code>__NSStackBlock__</code>）拷贝（<code>copy</code>）到堆上：

<ul>
<li>Block 作为函数返回值时</li>
<li>将 Block 赋值给 <code>__strong</code> 指针时</li>
<li>Block 作为 Cocoa API 中方法名含有 <code>usingBlock</code> 的参数时（eg. <code>- (void)enumerateObjectsUsingBlock:(void (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))block</code>）</li>
<li>Block 作为 GCD API 时</li>
</ul></li>
</ul>

<pre><code class="language-objectivec">// ARC

typedef void(^StackBlock)(void);

StackBlock returnStackBlock() {
    auto int autoVar = 10;
    
    NSLog(@&quot;%@&quot;, [^{
        NSLog(@&quot;%d&quot;, autoVar);
    } class]);
    
    // Block 作为函数返回值 -&gt; copy（ARC）
    // 此处代码若在 MRC 下会编译报错「Returning block that lives on the local stack」
    // 即编译器已经发现返回的 Block 是在栈上，一旦函数体走完，Block 就会被销毁，因此在 MRC 下需要手动 copy
    // return [^{ NSLog(@&quot;%d&quot;, autoVar); } copy]; // MRC
    return ^{
        NSLog(@&quot;%d&quot;, autoVar);
    };
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        StackBlock mallocBlock = returnStackBlock();
        mallocBlock();
    
        NSLog(@&quot;mallocBlock is a %@.&quot;, [mallocBlock class]);

        auto int autoVar = 10;
        
        // block 强指针指向了 StackBlock，因此 ARC 下编译器自动为其 copy 为 __NSMallocBlock__
        StackBlock block = ^{
            NSLog(@&quot;%d&quot;, autoVar);
        };
        
        NSLog(@&quot;block is a %@.&quot;, [block class]);

        // 弱引用则不会 copy，即仍然是 __NSStackBlock__
        __weak StackBlock block2 = ^{
            NSLog(@&quot;%d&quot;, autoVar);
        };
        
        NSLog(@&quot;block2 is a %@.&quot;, [block2 class]);
    }
}

// OUTPUT:
//  __NSStackBlock__
// 10
// mallocBlock is a __NSMallocBlock__.
// block is a __NSMallocBlock__.
// block2 is a __NSStackBlock__.
</code></pre>

<p>因此，在 Block 作为属性时应当使用 <code>copy</code> 或 <code>strong</code> 修饰：</p>

<pre><code class="language-objectivec">// MRC
@property (nonatomic, copy) void (^block1)(void);

// ARC
@property (nonatomic, copy) void (^block2)(void);
@property (nonatomic, strong) void (^block3)(void);
</code></pre>

<h3 id="nsstackblock-捕获对象类型的自动变量"><code>__NSStackBlock__</code> 捕获对象类型的自动变量</h3>

<p>上面，我们了解了 Block 的三种类型，重点说了 <code>__NSStackBlock__</code> 与 <code>__NSMallocBlock__</code> 的不同以及 ARC 下强弱引用 Block 对其内存管理的影响。</p>

<p>接下来我们将深入了解一下 <code>__NSStackBlock__</code> 对对象类型的自动变量的捕获后的影响。对于 ARC，<code>__NSStackBlock__</code> 内部访问了对象类型的自动变量，无论对自动变量强还是弱引用，都不会对捕获的变量本身产生强引用：</p>

<pre><code class="language-objectivec">// ARC

// main.m
@interface Foo : NSObject
@property (nonatomic, assign) int bar;
@end

@implementation Foo

- (void)dealloc
{
    // 销毁时打印
    NSLog(@&quot;dealloc&quot;);
}

@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // 下面是一个代码块（作用域）
        {
            // 默认是强引用，即 __strong
            Foo *foo = [[Foo alloc] init];
            // 也可使用 __weak 指定为弱引用
            __weak Foo *foo2 = foo;
            foo.bar = 20;
            
            // 为了避免在 ARC 下 __NSStackBlock__ 变成堆上的 BlockARC，此处不能使用强指针指向 Block
            ^{
                // Block 将对 foo &amp; foo2 捕获
                NSLog(@&quot;foo.bar = %d&quot;, foo.bar);
                NSLog(@&quot;foo2.bar = %d&quot;, foo2.bar);
            }();
        } 
        NSLog(@&quot;---&quot;);
    }
}

// OUTPUT:
// foo.bar = 20
// foo2.bar = 20
// dealloc // 代码块作用域结束，捕获的变量即销毁
// ---
</code></pre>

<p>对于 MRC，<code>__NSStackBlock__</code> 内部访问了对象类型的自动变量，其也不会对捕获的变量本身持有（Retain）：</p>

<pre><code class="language-objectivec">// MRC

typedef void(^SomeBlock)(void);

@interface Foo : NSObject
@property (nonatomic, assign) int bar;
@end

@implementation Foo

- (void)dealloc
{
    // MRC 下需手动调用
    [super dealloc];
    NSLog(@&quot;dealloc&quot;);
}

@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        SomeBlock block;
        {
            Foo *foo = [[Foo alloc] init];
            foo.bar = 20;
            
            // MRC 下的 __NSStackBlock__
            block = ^{
                NSLog(@&quot;foo.bar = %d&quot;, foo.bar);
            };
            // 如果希望 block 能够在代码块外正常执行，需要将 block copy 到堆上
            // block = [^{ NSLog(@&quot;foo.bar = %d&quot;, foo.bar); } copy];
            
            // 即将超出作用域，手动 release
            [foo release];
        }
        NSLog(@&quot;---&quot;);

        // 拷贝到堆上的 block 要手动 release
        // [block release];
    }
}

// OUTPUT:
// dealloc // 代码块作用域结束，捕获的变量即销毁
// ---
</code></pre>

<h3 id="拷贝时发生了什么">拷贝时发生了什么</h3>

<p>如果 Block 被拷贝到了堆上，Block 内部会发生什么呢？</p>

<pre><code class="language-objectivec">typedef void(^SomeBlock)(void);

@interface Foo : NSObject
@property (nonatomic, assign) int bar;
@end

@implementation Foo

- (void)dealloc
{
    NSLog(@&quot;dealloc&quot;);
}

@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        SomeBlock block;
        {
            Foo *foo = [[Foo alloc] init];
            foo.bar = 20;

            __weak Foo *weakFoo = foo;
            
            // 强指针引用，相当于 copy
            block = ^{
                NSLog(@&quot;foo.bar = %d&quot;, foo.bar);
                NSLog(@&quot;weakFoo.bar = %d&quot;, weakFoo.bar);
            };
        }
        block();
        NSLog(@&quot;---&quot;);
    }
}

// OUTPUT:
// foo.bar = 20
// weakFoo.bar = 20
// ---
// dealloc
</code></pre>

<p>将以上 Obj-C 代码使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -fobjc-arc -fobjc-runtime=ios-8.0.0 -o main.cpp</code> 命令翻译为 C++ 代码：</p>

<pre><code class="language-cpp">struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  // 默认强引用
  Foo *__strong foo;
  // 或者弱引用
  Foo *__weak weakFoo;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, Foo *__strong _foo, int flags=0) : foo(_foo) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

// 栈上的 Block 拷贝到堆时，会调用 __main_block_copy_0 方法
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {
    // _Block_object_assign 函数会根据自动变量的修饰符（如上 Foo *__strong foo;）作出相应的操作，形成强引用或弱引用（类似 Retain）：
    // 对外界 foo 强引用
    _Block_object_assign((void*)&amp;dst-&gt;foo, (void*)src-&gt;foo, 3/*BLOCK_FIELD_IS_OBJECT*/);
    // 对外界 weakFoo 弱引用
    _Block_object_assign((void*)&amp;dst-&gt;weakFoo, (void*)src-&gt;weakFoo, 3/*BLOCK_FIELD_IS_OBJECT*/);
}

// 栈上的 Block 被废弃时
static void __main_block_dispose_0(struct __main_block_impl_0*src) {
    // _Block_object_dispose 函数使得自动变量的引用计数减一（类似 Release）
    _Block_object_dispose((void*)src-&gt;foo, 3/*BLOCK_FIELD_IS_OBJECT*/);
    _Block_object_dispose((void*)src-&gt;weakFoo, 3/*BLOCK_FIELD_IS_OBJECT*/);
}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
</code></pre>

<h2 id="block"><code>__block</code></h2>

<p>上面的 Demo 中，Block 只是访问了外界的变量，但没有进行过修改，接下来我们尝试下：</p>

<pre><code class="language-objectivec">static int staticGlobalVar = 0;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        int autoVar = 0;
        static int staticVar = 0;
        
        ^{
            // Error: Variable is not assignable (missing __block type specifier)
            // autoVar = 10;
            
            staticVar = 10;
            staticGlobalVar = 10;
        }();
    }
}
</code></pre>

<p>Block 中按引用捕获静态局部变量，以及不捕获全局静态变量，可以直接修改这些变量的值。而对于自动变量，由于其是值传递，内部的 <code>autoVar</code> 与外界已无关系，所以此时不能在内部修改，编译器将提示「Variable is not assignable (missing __block type specifier)」，那么这里的 <code>__block</code> 是什么呢？</p>

<pre><code class="language-obejctivec">int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __block int autoVar = 0;
        
        ^{
            autoVar = 10;
        }();
    }
}
</code></pre>

  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span
        class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      <span class="button previous">
        <a href="/posts/2019/shopping_618/">
          <span class="button__icon">←</span>
          <span class="button__text">618 买买买</span>
        </a>
      </span>
      
      
    </div>
  </div>
  

  

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo="kingcos/kingcos.github.io"
            issue-term="pathname"
            label="comments"
            theme="github-dark"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2019 · <a href="http://github.com/kingcos">kingcos</a></span>
      </div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>





  
</div>

</body>
</html>
