<!DOCTYPE html>
<html lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="kingcos" />
	
	
	
	<title>Obj-C 中的 Block ｜ kingcos</title>
	
    
    
    <meta name="description" content="从 OS X Snow Leopard 和 iOS 4 开始，Apple 引入了 Block 的概念。Obj-C 中的 Block 即通常意义上的匿名函数，而之所以引入是因为 C 语言中并不支持匿名函数。这使得 Block 在 Obj-C 中可以称为是一类公民，既可以作为类的属性，也可以作为函数参数或返回值来传递。那么本文就将着眼于此，谈谈 Obj-C 中的 Block。" />
    

    
    
    <meta name="keywords" content="Hugo, theme, zozo" />
    

	
    
    <link rel="shortcut icon" href="https://kingcos.me/images/favicon.png" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/highlight.css" />

    
    
</head>

<script data-ad-client="ca-pub-9925978992661955" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<body>
    <div class="main animate__animated animate__fadeInDown">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/posts/">Archive</a>
            </li>
            
            <li>
                <a href="/tags/">Tags</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>

<style>
.nav_container {
  height: 1rem;
}
table {
    width: 100%;
    table-layout: fixed;
}
.markdown code {
    white-space: normal;
    word-wrap: break-word;
     
}

.menu_icon a {
    font-size: 20px;
}

 

body {
    font-family: 'Hiragino Sans GB', 'SFMono', 'Lato', '-apple-system';
    -webkit-font-smoothing: 'antialiased';
}

.markdown strong, .markdown b, .markdown em {
    font-weight: bold;
}

.markdown .book-hint.info {
    border-left-color:#6bf;
    background-color:rgba(102,187,255,.1);
    font-weight: bold;
}

.markdown .book-hint.warning{
    border-left-color:#fd6;
    background-color:rgba(255,221,102,.1);
    font-weight: bold;
}

.markdown .book-hint.danger{
    border-left-color:#f66;
    background-color:rgba(255,102,102,.1);
    font-weight: bold;
}

.markdown img {
     
    margin: 0 auto;
    display: block;
}

</style>

        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://kingcos.me/">
                    <span>kingcos</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">专注、坚持</p>
            <div class="my_socials">
                
                
                <a href="https://github.com/kingcos" title="github" target="_blank"><i class="ri-github-fill"></i></a>
                
                
                
                <a href="https://www.instagram.com/kingcos_v/" title="instagram" target="_blank"><i class="ri-instagram-fill"></i></a>
                
                
                
                <a href="https://twitter.com/kingcos_v" title="twitter" target="_blank"><i class="ri-twitter-fill"></i></a>
                
                
                
                <a href="https://weibo.com/u/1798410923" title="weibo" target="_blank"><i class="ri-weibo-fill"></i></a>
                
                
                
            </div>
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/posts/2019/block_in_obj-c/'>Obj-C 中的 Block</a></h2>
                        <span class="date">2019.11.24</span>
                        <span>by kingcos</span>
                    </div>
                    <div class="post_content markdown"><table>
<thead>
<tr>
<th style="text-align:center">Date</th>
<th style="text-align:center">Notes</th>
<th style="text-align:center">Demo</th>
<th style="text-align:center">Source Code</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2019-07-27</td>
<td style="text-align:center">首次提交</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">2019-11-24</td>
<td style="text-align:center">重新整理部分内容；补充《Effective Objective-C 2.0》&amp;《Objective-C 高级编程》相关内容</td>
<td style="text-align:center"><a href="https://github.com/kingcos/Perspective/tree/writing/Posts/Focus/block_in_obj-c/Block_in_Obj-C">Block_in_Obj-C</a></td>
<td style="text-align:center"><a href="https://opensource.apple.com/tarballs/objc4/">objc4-756.2</a>、<a href="https://opensource.apple.com/tarballs/libclosure/">libclosure-73</a></td>
</tr>
</tbody>
</table>
<p><img src="/img/2019/block_in_obj-c/0.png" alt="0"></p>
<h2 id="preface">Preface</h2>
<p>从 OS X Snow Leopard 和 iOS 4 开始，Apple 引入了 Block 的概念。Obj-C 中的 Block 即通常意义上的匿名函数，而之所以引入是因为 C 语言中并不支持匿名函数。这使得 Block 在 Obj-C 中可以称为是一类公民（First-Class Citizen），既可以作为类的属性，也可以作为函数参数或返回值来传递。那么本文就将着眼于此，谈谈 Obj-C 中的 Block。</p>
<!-- 当我们需要做一些异步行为时，总是希望能够在异步动作完成时可以在回调中执行额外的动作，那么此时我们就可以选择使用 Block 来作为 handler，其相较于 Delegate 更加简洁。

对于设计 handler API，可参考《编写高质量 iOS 与 OS X 代码的 52 个有效方法》一书中所提到的，通常我们可以将成功与失败情况放在同一个 handler 中处理；另外我们可以仿照 `NSNotificationCenter` API，通过增加一个参数来让外界决定 handler 执行的队列。 -->
<h2 id="prerequisites">Prerequisites</h2>
<h3 id="匿名函数与-block">匿名函数与 Block</h3>
<p>匿名函数顾名思义，即不带名称的函数，而 C 语言中即使是函数指针也仍然需要通过函数名来获得其地址：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// C 语言函数
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">cFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">arg</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main_1</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">cFunc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="c1">// C 语言中的函数指针需要通过函数名来获得其地址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cFuncPtr</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cFunc</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result2</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">cFuncPtr</span><span class="p">)(</span><span class="mi">10</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;result1 = %d, result2 = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">result1</span><span class="p">,</span> <span class="n">result2</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// result1 = 10, result2 = 10
</span></code></pre></div><p>Obj-C 中的匿名函数被称为 Block，中文有译作块、闭包（Closure），其实很多语言都有类似的机制，比如 Swift 中的 Closure，Java / Python / C++ 11 中的 Lambda（λ）表达式，JavaScript 中的匿名函数等。</p>
<h3 id="arc--mrc">ARC &amp; MRC</h3>
<p>Obj-C 作为使用引用计数来进行内存管理语言，虽然 ARC（Automatic Reference Counting，自动引用计数）已经引入多年，但有时仍然需要通过 MRC（Mannul Reference Counting，手动引用计数）了解更加底层的细节与区别。在 Obj-C 中我们可以使用 <code>__has_feature(objc_arc)</code> 宏来区分 ARC 和 MRC 下可以编译的代码。</p>
<p>目前 Xcode 中默认为 ARC，如需切换为 MRC 可以通过 Xcode - Build Settings - Automatic Reference Counting - No 来设置：</p>
<p><img src="/img/2019/block_in_obj-c/3.png" alt="3"></p>
<blockquote>
<p>⚠️ 注意：本文中若未指明 MRC 或未使用 <code>__has_feature(objc_arc)</code> 明确编译条件，则默认为 ARC。</p>
</blockquote>
<h2 id="what">What</h2>
<h3 id="语法">语法</h3>
<p>Obj-C 中的 Block 令人十分诟病的一个问题是其语法的繁杂。笔者也时常在 <a href="http://fuckingblocksyntax.com">fuckingblocksyntax.com</a> 查询相应的语法。</p>
<p>声明一个参数为 <code>int</code> 没有返回值的 Block：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// main_2
</span><span class="c1"></span>
<span class="c1">// 省略返回值的 void
</span><span class="c1"></span><span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// 完整写法
</span><span class="c1"></span><span class="o">^</span><span class="kt">void</span> <span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div><p>在语法上，与 C 语言函数不同的是：Block 没有函数名以及 <code>^</code> 记号，后者作为特殊记号将便于查找。BNF（Backus Normal Form，又 Backus-Naur Form，译作巴科斯范式，又巴科斯-诺尔范式）是一种用来描述计算机编程语言语法符号集的规范，通过这个规范在识别每一条编程语言语句时即可构建抽象语法树，进而帮助编译，未来笔者将在编译原理相关内容中深入探究。Block 声明语法的 BNF 如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">Block_literal_expression ::= ^ block_decl compound_statement_body
block_decl ::=
block_decl ::= parameter_list
block_decl ::= type_expression
</code></pre></div><p>因此通过上述 BNF 就能清晰的知道 Block 的几种声明语法：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// main_2
</span><span class="c1"></span>
<span class="c1">// 省略返回值 &amp; 参数
</span><span class="c1"></span><span class="o">^</span><span class="p">{</span> <span class="cm">/* compound_statement_body */</span> <span class="p">};</span>
<span class="c1">// 省略返回值
</span><span class="c1"></span><span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">){</span> <span class="cm">/* compound_statement_body */</span> <span class="p">};</span>
<span class="c1">// 省略参数
</span><span class="c1"></span><span class="o">^</span><span class="kt">int</span><span class="p">{</span> <span class="cm">/* compound_statement_body */</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div><p>Obj-C 中的 Block 与其它类型类似，可以作为属性或者变量，也可以在函数中作为参数或者返回值。但由于 Block 的语法繁杂，我们可以用 <code>typedef</code> 定义 Block 的类型，使得 API 更加简洁明了：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// BlockType_1 是一个参数和返回值均为 int 的 Block 类型
</span><span class="c1"></span><span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">^</span><span class="n">BlockType_1</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>

<span class="k">@interface</span> <span class="nc">Foo_1</span> : <span class="nc">NSObject</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="n">BlockType_1</span> <span class="n">block</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo_1</span>
<span class="c1">// 作为对象方法参数
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">blockAsArg_1:</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span><span class="nv">block</span> <span class="p">{</span>
    <span class="n">block</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 使用 typedef 作为对象方法参数
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">blockAsArg_2:</span><span class="p">(</span><span class="n">BlockType_1</span><span class="p">)</span><span class="nv">block</span> <span class="p">{</span>
    <span class="n">block</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 作为对象方法返回值
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span><span class="nf">blockAsReturnValue_1</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">arg</span><span class="p">;</span> <span class="p">};</span>
<span class="p">}</span>
<span class="c1">// 使用 typedef 作为对象方法返回值
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="n">BlockType_1</span><span class="p">)</span><span class="nf">blockAsReturnValue_2</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">arg</span><span class="p">;</span> <span class="p">};</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="c1">// Block 作为 C 语言函数参数
</span><span class="c1"></span><span class="kt">void</span> <span class="n">blockAsArg_1</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">block</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 使用 typedef 作为 C 语言函数参数
</span><span class="c1"></span><span class="kt">void</span> <span class="n">blockAsArg_2</span><span class="p">(</span><span class="n">BlockType_1</span> <span class="n">block</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">block</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 《Objective-C 高级编程》中提到的，将 Block 以非 typedef 形式作为 C 语言函数的返回值类型；但目前会报错，且尚未找到相应的解决方法：
</span><span class="c1">// ERROR: Block pointer to non-function type is invalid
</span><span class="c1">// ERROR: Returning &#39;int (^)(int)&#39; from a function with incompatible result type &#39;int (int)&#39;
</span><span class="c1">// int (^blockAsReturnValue()(int)) {
</span><span class="c1">//     return ^(int arg) { return arg; };
</span><span class="c1">// }
</span><span class="c1"></span>
<span class="n">BlockType_1</span> <span class="n">blockAsReturnValue</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">arg</span><span class="p">;</span> <span class="p">};</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main_2</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// 声明 Block 类型的变量
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">^</span><span class="n">block1</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
    <span class="c1">// 声明并赋值 Block（省略返回值类型）
</span><span class="c1"></span>    <span class="kt">int</span><span class="p">(</span><span class="o">^</span><span class="n">block2</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">arg</span><span class="p">;</span> <span class="p">};</span>
    <span class="n">block2</span> <span class="o">=</span> <span class="o">^</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">arg</span><span class="p">;</span> <span class="p">};</span>
    <span class="c1">// Block 类型的变量之间赋值
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">^</span><span class="n">block3</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">block2</span><span class="p">;</span>

    <span class="n">block1</span> <span class="o">=</span> <span class="n">block2</span><span class="p">;</span>

    <span class="c1">// 使用 typedef
</span><span class="c1"></span>    <span class="n">BlockType_1</span> <span class="n">block4</span><span class="p">;</span>
    <span class="n">BlockType_1</span> <span class="n">block5</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">arg</span><span class="p">;</span> <span class="p">};</span>
    <span class="n">block5</span> <span class="o">=</span> <span class="o">^</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">arg</span><span class="p">;</span> <span class="p">};</span>
    <span class="n">BlockType_1</span> <span class="n">block6</span> <span class="o">=</span> <span class="n">block5</span><span class="p">;</span>
    <span class="n">block4</span> <span class="o">=</span> <span class="n">block5</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="结构">结构</h3>
<p>在 <code>main</code> 函数中声明并执行一个简单的 Block：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">int</span> <span class="nf">main_3</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;Hello, World!&#34;</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="n">block</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// Hello, World!
</span></code></pre></div><p>为了窥探 Block 的结构，可以尝试使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</code> 命令将以上代码翻译为 C/C++ 代码来分析：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Block 实现的结构体
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">__block_impl</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">isa</span><span class="p">;</span>     <span class="c1">// isa 指针，即 Block 也是 id 类型，即 Obj-C 对象
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">Flags</span><span class="p">;</span>     <span class="c1">// 标记，默认会被初始化为 0
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">Reserved</span><span class="p">;</span>  <span class="c1">// 保留域（ABI 兼容），默认 0
</span><span class="c1"></span>  <span class="kt">void</span> <span class="o">*</span><span class="n">FuncPtr</span><span class="p">;</span> <span class="c1">// Block 代码块的函数指针
</span><span class="c1"></span><span class="p">};</span>

<span class="c1">// ➡️ Block 结构体
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">__main_3_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">__block_impl</span> <span class="n">impl</span><span class="p">;</span>           <span class="c1">// 实现（非指针）
</span><span class="c1"></span>  <span class="k">struct</span> <span class="nc">__main_3_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span> <span class="c1">// 描述信息（指针）
</span><span class="c1"></span>  <span class="c1">// 构造函数
</span><span class="c1"></span>  <span class="n">__main_3_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__main_3_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span> <span class="c1">// Block 作为 Obj-C 对象，那么 isa 将指向其类对象，即 _NSConcreteStackBlock
</span><span class="c1"></span>    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Block 内代码块封装在该 C 语言静态函数中，函数命名规则：__CALLER_METHOD_NAME_block_func_NUMBER
</span><span class="c1">// 类似 Obj-C 实例方法参数 self 或 C++ 实例方法参数 this，__cself 为指向 Block 结构体的变量
</span><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_3_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_3_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_b9596e_mi_0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Block 描述信息的结构体静态变量
</span><span class="c1"></span><span class="k">static</span> <span class="k">struct</span> <span class="nc">__main_3_block_desc_0</span> <span class="p">{</span>
  <span class="n">size_t</span> <span class="n">reserved</span><span class="p">;</span>   <span class="c1">// 保留域，默认 0
</span><span class="c1"></span>  <span class="n">size_t</span> <span class="n">Block_size</span><span class="p">;</span> <span class="c1">// Block 大小，sizeof 整个 Block 结构体 ⬇️
</span><span class="c1"></span><span class="p">}</span> <span class="n">__main_3_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_3_block_impl_0</span><span class="p">)};</span>

<span class="c1">// 主函数
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">main_3</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// 通过 __main_3_block_impl_0 结构体的构造函数初始化，参数为静态函数和描述信息静态变量的地址，将地址存储在 block 变量中
</span><span class="c1"></span>    <span class="c1">// 忽略类型转换：block = &amp;__main_3_block_impl_0(__main_3_block_func_0, &amp;__main_3_block_desc_0_DATA));
</span><span class="c1"></span>    <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">block</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_3_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_3_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_3_block_desc_0_DATA</span><span class="p">));</span>

    <span class="c1">// 执行 Block（参数 block 即静态函数中的参数 __cself）
</span><span class="c1"></span>    <span class="c1">// 忽略类型转换：block-&gt;FuncPtr(block);
</span><span class="c1"></span>    <span class="c1">// 在 __main_block_impl_0 结构体中，impl 是第一个变量，因此其与结构体本身的首地址一致，因此可以强转
</span><span class="c1"></span>    <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">block</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">block</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>当声明一个 Block 变量，其中的代码块会被封装到 <code>__main_3_block_func_0</code> 静态函数中（后缀 <code>0</code> 代表序号，后同），描述信息则被初始化并封装到 <code>__main_3_block_desc_0_DATA</code> 静态变量中；这两者在 <code>main</code> 函数中一起构造了 Block 结构体 <code>__main_3_block_impl_0</code>，并将其地址保存在声明的 <code>block</code> 变量中；由于 Block 的结构体直接包含了 <code>__block_impl</code> 结构体，因此在构造函数中，<code>__block_impl</code> 的 <code>isa</code> 指向了 <code>_NSConcreteStackBlock</code> 类对象的地址，也印证了 Block 的本质是特殊的 Obj-C 对象；<code>__block_impl</code> 的 <code>FuncPtr</code> 函数指针则指向包含代码块的静态函数，在 Block 真正执行时，将通过 <code>block-&gt;FuncPtr(block)</code> 找到静态函数并调用。上述代码中的 <code>block</code> 结构正如下图：</p>
<p><img src="/img/2019/block_in_obj-c/1.png" alt="1"></p>
<h2 id="变量捕获">变量捕获</h2>
<h3 id="自动变量">自动变量</h3>
<p>自动变量（Automatic Variable）即局部作用域变量，指在代码块中声明的变量，也可以显式使用 <code>auto</code> 关键字声明。自动变量存储在内存的栈区，离开作用域时会被自动回收：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">int</span> <span class="nf">main_4</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

    <span class="p">{</span>
        <span class="k">auto</span> <span class="kt">int</span> <span class="n">autoVar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">autoConstVar</span> <span class="o">=</span> <span class="s">&#34;kingcos.me&#34;</span><span class="p">;</span>

        <span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;autoVar == %d, autoConstVar == %s&#34;</span><span class="p">,</span> <span class="n">autoVar</span><span class="p">,</span> <span class="n">autoConstVar</span><span class="p">);</span>
        <span class="p">};</span>

        <span class="n">autoVar</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="c1">// const char * 为常量，不可改变存储的类型
</span><span class="c1"></span>        <span class="c1">// autoConstVar = 1.5;
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="c1">// ERROR: Use of undeclared identifier &#39;autoVar&#39;
</span><span class="c1"></span>    <span class="c1">// autoVar = 10;
</span><span class="c1"></span>
    <span class="n">block</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// autoVar == 1, autoConstVar == kingcos.me
</span></code></pre></div><p>如上，我们在代码块外声明了一个 Block，而在代码块内声明了自动变量，并将 <code>block</code> 赋值。超出代码块作用于后，我们已经无法再次访问代码块内部的变量，而 <code>block</code> 执行的结果却是正常的。这是为什么呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">__main_4_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="nc">__main_4_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">autoVar</span><span class="p">;</span>              <span class="c1">// 捕获的自动变量 autoVar
</span><span class="c1"></span>  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">autoConstVar</span><span class="p">;</span> <span class="c1">// 捕获的变量类型与外界声明完全相同
</span><span class="c1"></span>
  <span class="n">__main_4_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__main_4_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_autoVar</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">_autoConstVar</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">autoVar</span><span class="p">(</span><span class="n">_autoVar</span><span class="p">),</span> <span class="n">autoConstVar</span><span class="p">(</span><span class="n">_autoConstVar</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 构造函数初始化内结构体内部的自动变量
</span><span class="c1"></span>    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_4_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_4_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 从 __celf 取初始化时获得的值
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">autoVar</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">autoVar</span><span class="p">;</span> <span class="c1">// bound by copy
</span><span class="c1"></span>  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">autoConstVar</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">autoConstVar</span><span class="p">;</span> <span class="c1">// bound by copy
</span><span class="c1"></span>
  <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_27d308_mi_3</span><span class="p">,</span> <span class="n">autoVar</span><span class="p">,</span> <span class="n">autoConstVar</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="nc">__main_4_block_desc_0</span> <span class="p">{</span>
  <span class="n">size_t</span> <span class="n">reserved</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__main_4_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_4_block_impl_0</span><span class="p">)};</span>

<span class="kt">int</span> <span class="nf">main_4</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// 在代码块外声明的 Block 变量
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">block</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

    <span class="p">{</span>
        <span class="k">auto</span> <span class="kt">int</span> <span class="n">autoVar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">autoConstV</span><span class="c1">// 构造时将外部自动变量的值直接传入
</span><span class="c1"></span>        <span class="c1">// 忽略类型转换：block = &amp;__main_4_block_impl_0(__main_4_block_func_0, &amp;__main_4_block_desc_0_DATA, autoVar, autoConstVar));
</span><span class="c1"></span>        <span class="n">block</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_4_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_4_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_4_block_desc_0_DATA</span><span class="p">,</span> <span class="n">autoVar</span><span class="p">,</span> <span class="n">autoConstVar</span><span class="p">));</span>

        <span class="n">autoVar</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 执行 Block
</span><span class="c1"></span>    <span class="c1">// 忽略类型转换：block-&gt;FuncPtr(block);
</span><span class="c1"></span>    <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">block</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">block</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>为了避免自动变量的提前释放，Block 会将其内部使用到的自动变量捕获到结构体内部（按值传递），这样即使超出自动变量的作用域或者在 Block 外更改了原有的变量值，也不会影响 Block 中已经被捕获的那个变量。</p>
<p>那么在 Obj-C 对象方法中如果有 Block 使用到了 <code>self</code> 或者成员变量呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@interface</span> <span class="nc">Foo_2</span> : <span class="nc">NSObject</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">bar_1</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">bar_2</span><span class="p">;</span>

<span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">bar</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo_2</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;dealloc&#34;</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">bar_1</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">block_1</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;self == %@&#34;</span><span class="p">,</span> <span class="nb">self</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="n">block_1</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">bar_2</span> <span class="p">{</span>
    <span class="nb">self</span><span class="p">.</span><span class="n">prop</span> <span class="o">=</span> <span class="s">@&#34;kingcos.me&#34;</span><span class="p">;</span>

    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">block_2</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// WARNING: Block implicitly retains &#39;self&#39;; explicitly mention &#39;self&#39; to indicate this is intended behavior
</span><span class="c1"></span>        <span class="c1">// NSLog(@&#34;_prop == %@.&#34;, _prop);
</span><span class="c1"></span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;_prop == %@&#34;</span><span class="p">,</span> <span class="nb">self</span><span class="o">-&gt;</span><span class="n">_prop</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="n">block_2</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">bar</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;self == %@&#34;</span><span class="p">,</span> <span class="nb">self</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="n">block</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="kt">int</span> <span class="n">main_4</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">Foo_2</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo_2</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
    <span class="p">[</span><span class="n">foo</span> <span class="n">bar_1</span><span class="p">];</span>
    <span class="p">[</span><span class="n">foo</span> <span class="n">bar_2</span><span class="p">];</span>

    <span class="p">[</span><span class="n">Foo_2</span> <span class="n">bar</span><span class="p">];</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// self == &lt;Foo_2: 0x100532d80&gt;
</span><span class="c1">// _prop == kingcos.me
</span><span class="c1">// self == Foo_2
</span><span class="c1">// dealloc
</span></code></pre></div><p>Obj-C 方法里使用到的 <code>self</code> 来自于其默认参数（另一个默认参数是 <code>_cmd</code>），而函数参数的作用域也仅在当前函数体内。因此 Block 内如果使用到 <code>self</code> 或者成员变量（本质也是通过 <code>self</code> 进行访问的）则也会对其进行捕获：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">__Foo_2__bar_1_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="nc">__Foo_2__bar_1_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="n">Foo_2</span> <span class="o">*</span><span class="k">const</span> <span class="n">__strong</span> <span class="n">self</span><span class="p">;</span> <span class="c1">// 捕获的 self
</span><span class="c1"></span>
  <span class="n">__Foo_2__bar_1_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__Foo_2__bar_1_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">Foo_2</span> <span class="o">*</span><span class="k">const</span> <span class="n">__strong</span> <span class="n">_self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">self</span><span class="p">(</span><span class="n">_self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__Foo_2__bar_1_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__Foo_2__bar_1_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 执行时取出 self
</span><span class="c1"></span>  <span class="n">Foo_2</span> <span class="o">*</span><span class="k">const</span> <span class="n">__strong</span> <span class="n">self</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span> <span class="c1">// bound by copy
</span><span class="c1"></span>
  <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_169b69_mi_1</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">__Foo_2__bar_2_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="nc">__Foo_2__bar_2_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="n">Foo_2</span> <span class="o">*</span><span class="k">const</span> <span class="n">__strong</span> <span class="n">self</span><span class="p">;</span> <span class="c1">// 捕获的 self
</span><span class="c1"></span>
  <span class="n">__Foo_2__bar_2_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__Foo_2__bar_2_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">Foo_2</span> <span class="o">*</span><span class="k">const</span> <span class="n">__strong</span> <span class="n">_self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">self</span><span class="p">(</span><span class="n">_self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__Foo_2__bar_2_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__Foo_2__bar_2_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Foo_2</span> <span class="o">*</span><span class="k">const</span> <span class="n">__strong</span> <span class="n">self</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span> <span class="c1">// bound by copy
</span><span class="c1"></span>
  <span class="c1">// self + OBJC_IVAR_$_Foo_2$_prop：成员变量是根据 self 做的偏移
</span><span class="c1"></span>  <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_169b69_mi_3</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">__strong</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span> <span class="o">+</span> <span class="n">OBJC_IVAR_</span><span class="err">$</span><span class="n">_Foo_2</span><span class="err">$</span><span class="n">_prop</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">__Foo_2__bar_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="nc">__Foo_2__bar_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">Class</span> <span class="n">self</span><span class="p">;</span> <span class="c1">// 对于类方法，则捕获的是类对象
</span><span class="c1"></span>  <span class="n">__Foo_2__bar_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__Foo_2__bar_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">const</span> <span class="n">Class</span> <span class="n">_self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">self</span><span class="p">(</span><span class="n">_self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__Foo_2__bar_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__Foo_2__bar_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">Class</span> <span class="n">self</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span> <span class="c1">// bound by copy
</span><span class="c1"></span>
  <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_169b69_mi_4</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h3 id="局部静态变量">局部静态变量</h3>
<p>局部静态变量指定义在代码块内的静态变量，其作用域是在代码块内，但其生命周期并不会随代码块结束：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">int</span> <span class="nf">main_5</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

    <span class="p">{</span>
        <span class="k">static</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;a == %d&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
        <span class="p">};</span>

        <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">block</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// a == 10
</span></code></pre></div><p>不同于自动变量，对于局部静态变量，由于其生命周期随程序退出才结束，因此在 Block 内部只需要将局部静态变量的地址进行捕获即可（按引用传递）。这样即使超过局部静态变量的作用域但 Block 中仍然可以通过地址访问到，且当 Block 执行前如果改变了局部静态变量的值，那么执行时也将根据地址获取到最新值：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">__main_5_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="nc">__main_5_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span> <span class="c1">// 捕获的变量，类型为指向 int 类型的指针
</span><span class="c1"></span>  <span class="n">__main_5_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__main_5_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">_a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="n">_a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_5_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_5_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// int *a = &amp;a;（外界 a 的地址）
</span><span class="c1"></span>  <span class="kt">int</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span> <span class="c1">// bound by copy
</span><span class="c1"></span>
  <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_0fafd0_mi_4</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="nc">__main_5_block_desc_0</span> <span class="p">{</span>
  <span class="n">size_t</span> <span class="n">reserved</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__main_5_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_5_block_impl_0</span><span class="p">)};</span>

<span class="kt">int</span> <span class="nf">main_5</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">block</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

    <span class="p">{</span>
        <span class="k">static</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="c1">// 忽略类型转换：block = &amp;__main_5_block_impl_0(__main_5_block_func_0, &amp;__main_5_block_desc_0_DATA, &amp;a);（&amp;a 即 a 的地址作为参数传入）
</span><span class="c1"></span>        <span class="n">block</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_5_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_5_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_5_block_desc_0_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">));</span>

        <span class="c1">// a 的值发生改变
</span><span class="c1"></span>        <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">block</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">block</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="全局变量">全局变量</h3>
<p>全局变量即定义在所有函数体外的变量，只有当程序退出时其生命周期和作用域才结束：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// 全局变量
</span><span class="c1"></span><span class="kt">int</span> <span class="n">globalVar_1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// 全局静态变量
</span><span class="c1"></span><span class="k">static</span> <span class="kt">int</span> <span class="n">staticGlobalVar_1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main_6</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;globalVar_1 == %d, staticGlobalVar_1 == %d&#34;</span><span class="p">,</span> <span class="n">globalVar_1</span><span class="p">,</span> <span class="n">staticGlobalVar_1</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="n">globalVar_1</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">staticGlobalVar_1</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

    <span class="n">block</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTOUT:
</span><span class="c1">// globalVar_1 == 10, staticGlobalVar_1 == 20
</span></code></pre></div><p>因此对于全局变量，Block 并不会去捕获，而是在使用时直接进行读取即可：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">globalVar_1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">staticGlobalVar_1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">__main_6_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="nc">__main_6_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="c1">// 没有捕获
</span><span class="c1"></span>
  <span class="n">__main_6_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__main_6_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_6_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_6_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 直接访问
</span><span class="c1"></span>  <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_d50b04_mi_8</span><span class="p">,</span> <span class="n">globalVar_1</span><span class="p">,</span> <span class="n">staticGlobalVar_1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h3 id="c-语言数组">C 语言数组</h3>
<p>需要注意的是，当 Block 并不能捕获 C 语言中的数组。实际上这在 C 语言的函数中也是不支持的，猜测这是因为 Block 遵循了类似 C 语言的规范（参考《Objective-C 高级编程》），这里可以使用指针代替：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">void</span> <span class="nf">cFunc_2</span><span class="p">(</span><span class="kt">char</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cFunc_3</span><span class="p">(</span><span class="kt">char</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="p">{</span>
    <span class="c1">// C 语言不允许数组类型变量赋值给另外的数组类型变量
</span><span class="c1"></span>    <span class="c1">// ERROR: Array initializer must be an initializer list or string literal
</span><span class="c1"></span>    <span class="c1">// char b[10] = a;
</span><span class="c1"></span>    <span class="c1">// printf(&#34;%d\n&#34;, b[0]);
</span><span class="c1"></span><span class="p">}</span>

<span class="kt">int</span> <span class="nf">main_7</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="n">cLocalArr</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;kingcos.me&#34;</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cLocalString</span> <span class="o">=</span> <span class="s">&#34;kingcos.me&#34;</span><span class="p">;</span>

    <span class="o">^</span><span class="p">{</span>
        <span class="c1">// Block 不会对 C 语言数组进行捕获
</span><span class="c1"></span>        <span class="c1">// ERROR: Cannot refer to declaration with an array type inside block
</span><span class="c1"></span>        <span class="c1">// printf(&#34;%c\n&#34;, cLocalArr[7]);
</span><span class="c1"></span>
        <span class="c1">// 使用指针代替
</span><span class="c1"></span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%c</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">cLocalString</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
    <span class="p">}();</span>

    <span class="c1">// 猜测 Block 遵循了类似 C 语言的规范
</span><span class="c1"></span>    <span class="kt">char</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">};</span>

    <span class="n">cFunc_2</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">cFunc_3</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// .
</span><span class="c1">// 2
</span></code></pre></div><h2 id="类型">类型</h2>
<p>Obj-C 中的 Block 根据其存储在不同的内存区域被分为三种：<code>__NSGlobalBlock__</code>、<code>__NSStackBlock__</code>、<code>__NSMallocBlock__</code>，它们又各自继承自 <code>__NSGlobalBlock</code>、<code>__NSMallocBlock</code>、<code>__NSStackBlock</code>，这些父类又都继承自 <code>NSBlock</code>，<code>NSBlock</code> 又继承自 <code>NSObject</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">int</span> <span class="nf">main_8</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">block1</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;Hello, world!&#34;</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">block2</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%d&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@ %@ %@&#34;</span><span class="p">,</span> <span class="p">[</span><span class="n">block1</span> <span class="k">class</span><span class="p">],</span> <span class="p">[</span><span class="n">block2</span> <span class="k">class</span><span class="p">],</span> <span class="p">[</span><span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%d&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">class</span><span class="p">]);</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@ %@ %@&#34;</span><span class="p">,</span> <span class="p">[</span><span class="n">block1</span> <span class="n">superclass</span><span class="p">],</span> <span class="p">[</span><span class="n">block2</span> <span class="n">superclass</span><span class="p">],[</span><span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%d&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="p">}</span> <span class="n">superclass</span><span class="p">]);</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@ %@ %@&#34;</span><span class="p">,</span> <span class="p">[[</span><span class="n">block1</span> <span class="n">superclass</span><span class="p">]</span> <span class="n">superclass</span><span class="p">],</span> <span class="p">[[</span><span class="n">block2</span> <span class="n">superclass</span><span class="p">]</span> <span class="n">superclass</span><span class="p">],[[</span><span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%d&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="p">}</span> <span class="n">superclass</span><span class="p">]</span> <span class="n">superclass</span><span class="p">]);</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@ %@ %@&#34;</span><span class="p">,</span> <span class="p">[[[</span><span class="n">block1</span> <span class="n">superclass</span><span class="p">]</span> <span class="n">superclass</span><span class="p">]</span> <span class="n">superclass</span><span class="p">],</span> <span class="p">[[[</span><span class="n">block2</span> <span class="n">superclass</span><span class="p">]</span> <span class="n">superclass</span><span class="p">]</span> <span class="n">superclass</span><span class="p">],[[[</span><span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%d&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="p">}</span> <span class="n">superclass</span><span class="p">]</span> <span class="n">superclass</span><span class="p">]</span> <span class="n">superclass</span><span class="p">]);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// __NSGlobalBlock__ __NSMallocBlock__ __NSStackBlock__
</span><span class="c1">// __NSGlobalBlock __NSMallocBlock __NSStackBlock
</span><span class="c1">// NSBlock NSBlock NSBlock
</span><span class="c1">// NSObject NSObject NSObject
</span></code></pre></div><blockquote>
<p>⚠️ 注意：</p>
<p>在上一节中，我们可以从「翻译」后的 C++ 代码中看到 Block 内部的 <code>isa</code> 指针均默认指向了 <code>_NSConcreteStackBlock</code>，但其实在 macOS 的 Xcode 中运行时并不存在「翻译」这一步骤，因此我们最好使用运行时的方法来真正确定 Block 的具体类型。</p>
</blockquote>
<h3 id="__nsglobalblock__">__NSGlobalBlock__</h3>
<p>内部没有访问外界<strong>自动变量</strong>的 Block 将在执行时不依赖上下文，该类型的 Block 属于 <code>__NSGlobalBlock__</code>，存储在内存的数据段（Data Section），该区域通常也会存放全局变量：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">int</span> <span class="n">globalVar_2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main_9</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">gloablBlock</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="c1">// 没有访问任何外界变量
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;This is a __NSGlobalBlock__.&#34;</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="p">[</span><span class="n">gloablBlock</span> <span class="k">class</span><span class="p">]);</span>

    <span class="k">static</span> <span class="kt">int</span> <span class="n">staticVar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">gloablBlock</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="c1">// 访问了全局变量或局部静态变量
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;globalVar2 == %d, staticVar == %d.&#34;</span><span class="p">,</span> <span class="n">globalVar_2</span><span class="p">,</span> <span class="n">staticVar</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="p">[</span><span class="n">gloablBlock</span> <span class="k">class</span><span class="p">]);</span>

    <span class="c1">// 该 Block 实际初始化时将：
</span><span class="c1"></span>    <span class="c1">// impl.isa = &amp;_NSConcreteGlobalBlock;
</span><span class="c1"></span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// __NSGlobalBlock__
</span><span class="c1">// __NSGlobalBlock__
</span></code></pre></div><p>对 <code>__NSGlobalBlock__</code> 类型的 Block 执行 <code>copy</code> 操作并不会将其拷贝至堆中，而是仍将返回 <code>__NSGlobalBlock__</code>。</p>
<h3 id="__nsstackblock__">__NSStackBlock__</h3>
<h4 id="what-1">What</h4>
<p>自动变量存储在内存的栈区，当 Block 内访问了外界的自动变量时会对其进行捕获，此时 Block 本身也被分配在栈区，属于 <code>__NSStackBlock__</code> 类型：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">int</span> <span class="nf">main_10</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="cp">#if !__has_feature(objc_arc)
</span><span class="cp"></span>    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">stackBlock</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;c == %d.&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="p">[</span><span class="n">stackBlock</span> <span class="k">class</span><span class="p">]);</span>
<span class="cp">#endif
</span><span class="cp"></span>
    <span class="c1">// stackBlock 初始化时将：
</span><span class="c1"></span>    <span class="c1">// impl.isa = &amp;_NSConcreteStackBlock;
</span><span class="c1"></span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">//  __NSStackBlock__
</span></code></pre></div><p>栈区的内存不需要开发者手动管理，当作用域结束时栈区内存将会被自动回收。所以即使 <code>__NSStackBlock__</code> 类型的 Block 内部捕获了自动变量，但 Block 本身和捕获的变量也仍然存储在栈区，会随着其作用域结束而释放：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@interface</span> <span class="nc">Foo_3</span> : <span class="nc">NSObject</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo_3</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span>
<span class="p">{</span>
<span class="cp">#if !__has_feature(objc_arc)
</span><span class="cp"></span>    <span class="p">[</span><span class="nb">super</span> <span class="n">dealloc</span><span class="p">];</span> <span class="c1">// MRC 下需手动调用下父类的 dealloc
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;dealloc&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">stackBlock_1</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">stackBlock_2</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">initBlockInARC</span><span class="p">()</span> <span class="p">{</span>
<span class="cp">#if __has_feature(objc_arc)
</span><span class="cp"></span>    <span class="c1">// 初始化，引用计数 +1
</span><span class="c1"></span>    <span class="n">Foo_3</span> <span class="o">*</span><span class="n">strongF</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo_3</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%ld&#34;</span><span class="p">,</span> <span class="n">CFGetRetainCount</span><span class="p">((</span><span class="k">__bridge</span> <span class="n">CFTypeRef</span><span class="p">)(</span><span class="n">strongF</span><span class="p">)));</span>

    <span class="c1">// 弱引用，引用计数不变 +0
</span><span class="c1"></span>    <span class="k">__weak</span> <span class="n">Foo_3</span> <span class="o">*</span><span class="n">weakF</span> <span class="o">=</span> <span class="n">strongF</span><span class="p">;</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%ld&#34;</span><span class="p">,</span> <span class="n">CFGetRetainCount</span><span class="p">((</span><span class="k">__bridge</span> <span class="n">CFTypeRef</span><span class="p">)(</span><span class="n">strongF</span><span class="p">)));</span>

    <span class="c1">// Block 捕获，引用计数 +1
</span><span class="c1"></span>    <span class="c1">// __NSStackBlock__
</span><span class="c1"></span>    <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">strongF</span><span class="p">);</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">weakF</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%ld&#34;</span><span class="p">,</span> <span class="n">CFGetRetainCount</span><span class="p">((</span><span class="k">__bridge</span> <span class="n">CFTypeRef</span><span class="p">)(</span><span class="n">strongF</span><span class="p">)));</span>
<span class="cp">#endif
</span><span class="cp"></span><span class="p">}</span>

<span class="kt">void</span> <span class="nf">initBlockInMRC</span><span class="p">()</span> <span class="p">{</span>
<span class="cp">#if !__has_feature(objc_arc)
</span><span class="cp"></span>    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="n">stackBlock_1</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;c == %d&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="c1">// 初始化，引用计数 +1
</span><span class="c1"></span>    <span class="n">Foo_3</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo_3</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%ld&#34;</span><span class="p">,</span> <span class="p">[</span><span class="n">f</span> <span class="n">retainCount</span><span class="p">]);</span>

    <span class="c1">// MRC 下 stackBlock_2 捕获 f 但不持有，引用计数 +0
</span><span class="c1"></span>    <span class="n">stackBlock_2</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
       <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;f == %@&#34;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%ld&#34;</span><span class="p">,</span> <span class="p">[</span><span class="n">f</span> <span class="n">retainCount</span><span class="p">]);</span>

    <span class="p">[</span><span class="n">f</span> <span class="k">release</span><span class="p">];</span>
<span class="cp">#endif
</span><span class="cp"></span><span class="p">}</span>

<span class="kt">int</span> <span class="nf">main_11</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="cp">#if __has_feature(objc_arc)
</span><span class="cp"></span>    <span class="c1">// 初始化 stackBlock
</span><span class="c1"></span>    <span class="n">initBlockInARC</span><span class="p">();</span>
<span class="cp">#else
</span><span class="cp"></span>    <span class="c1">// 初始化 stackBlock
</span><span class="c1"></span>    <span class="n">initBlockInMRC</span><span class="p">();</span>

    <span class="c1">// 执行 stackBlock_1
</span><span class="c1"></span>    <span class="n">stackBlock_1</span><span class="p">();</span> <span class="c1">// c == -272632744
</span><span class="c1"></span>    <span class="c1">// 执行 stackBlock_2
</span><span class="c1"></span>    <span class="n">stackBlock_2</span><span class="p">();</span> <span class="c1">// CRASH: objc[59614]: Attempt to use unknown class 0x7ffeefbff428.
</span><span class="c1"></span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;stackBlock_1 is a %@.&#34;</span><span class="p">,</span> <span class="p">[</span><span class="n">stackBlock_1</span> <span class="k">class</span><span class="p">]);</span> <span class="c1">// CRASH: EXC_BAD_ACCESS
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// MRC OUTPUT:
</span><span class="c1">// 1
</span><span class="c1">// 1
</span><span class="c1">// dealloc
</span><span class="c1"></span>
<span class="c1">// ARC OUTPUT:
</span><span class="c1">// 1
</span><span class="c1">// 1
</span><span class="c1">// 2
</span><span class="c1">// dealloc
</span></code></pre></div><p>MRC 下，<code>__NSStackBlock__</code> 类型的 Block 中虽然捕获了对象类型的自动变量，但没有改变其引用计数，即不会进行 <code>retain</code> 持有操作。而 <code>main</code> 函数中执行到 Block 时其本身已经被系统回收，捕获的自动变量 <code>c</code> 和 <code>f</code> 也已经从栈上释放，因此访问时出现了脏数据，访问 Block 本身也出现了 <code>EXC_BAD_ACCESS</code> 崩溃。为了避免这种问题，我们需要将 Block 分配在堆上（即 <code>__NSMallocBlock__</code>），这是因为堆区的内存由开发者自己管理，可以避免被自动回收。</p>
<p>ARC 下，<code>__NSStackBlock__</code> 类型的 Block 中捕获了 <code>strongP</code> 和 <code>weakP</code>（可以通过为翻译 Obj-C 代码的命令额外添加 <code>-fobjc-arc -fobjc-runtime=ios-13.0.0</code> 参数强制使用 ARC 并指定运行时平台和版本，这样即可输出带有部分运行时关键字的 C/C++ 代码，如下），虽然强引用会导致其引用计数增加，但由于 Block 本身在栈上并仍会随作用域超出而销毁，捕获的自动变量同理也会被销毁。</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">__initBlockInARC_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="nc">__initBlockInARC_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="n">Foo_3</span> <span class="o">*</span><span class="n">__strong</span> <span class="n">strongF</span><span class="p">;</span> <span class="c1">// ⚠️ 强引用
</span><span class="c1"></span>  <span class="n">Foo_3</span> <span class="o">*</span><span class="n">__weak</span> <span class="n">weakF</span><span class="p">;</span>     <span class="c1">// ⚠️ 弱引用
</span><span class="c1"></span>
  <span class="n">__initBlockInARC_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__initBlockInARC_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">Foo_3</span> <span class="o">*</span><span class="n">__strong</span> <span class="n">_strongF</span><span class="p">,</span> <span class="n">Foo_3</span> <span class="o">*</span><span class="n">__weak</span> <span class="n">_weakF</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">strongF</span><span class="p">(</span><span class="n">_strongF</span><span class="p">),</span> <span class="n">weakF</span><span class="p">(</span><span class="n">_weakF</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><h3 id="__nsmallocblock__">__NSMallocBlock__</h3>
<h4 id="what-2">What</h4>
<p><code>__NSMallocBlock__</code> 类型的 Block 存储在内存的堆区，堆区是通常用作动态分配（Malloc）的内存：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@interface</span> <span class="nc">Foo_4</span> : <span class="nc">NSObject</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo_4</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span>
<span class="p">{</span>
<span class="cp">#if !__has_feature(objc_arc)
</span><span class="cp"></span>    <span class="p">[</span><span class="nb">super</span> <span class="n">dealloc</span><span class="p">];</span>
<span class="cp">#endif
</span><span class="cp"></span>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;dealloc&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="k">typedef</span> <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">BlockType_2</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">mallocBlock_1</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">mallocBlock_2</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">initBlock</span><span class="p">()</span> <span class="p">{</span>
<span class="cp">#if !__has_feature(objc_arc)
</span><span class="cp"></span>    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="n">mallocBlock_1</span> <span class="o">=</span> <span class="p">[</span><span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;c == %d&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">copy</span><span class="p">];</span>

    <span class="n">Foo_4</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo_4</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

    <span class="n">mallocBlock_2</span> <span class="o">=</span> <span class="p">[</span><span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">copy</span><span class="p">];</span>

    <span class="p">[</span><span class="n">f</span> <span class="k">release</span><span class="p">];</span>
<span class="cp">#else
</span><span class="cp"></span>    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="n">mallocBlock_1</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;c == %d&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="n">Foo_4</span> <span class="o">*</span><span class="n">strongF</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo_4</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
    <span class="k">__weak</span> <span class="n">Foo_4</span> <span class="o">*</span><span class="n">weakF</span> <span class="o">=</span> <span class="n">strongF</span><span class="p">;</span>

    <span class="c1">// 1⃣️ ARC 下强指针 mallocBlock_2 指向的 Block 会被自动拷贝为 __NSMallocBlock__
</span><span class="c1"></span>    <span class="n">mallocBlock_2</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">strongF</span><span class="p">);</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">weakF</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="c1">// 使用弱引用指针指向的 Block，将仍然是 __NSStackBlock__，编译将提示以下警告
</span><span class="c1"></span>    <span class="c1">// WARNING: Assigning block literal to a weak variable; object will be released after assignment
</span><span class="c1"></span>    <span class="k">__weak</span> <span class="n">BlockType_2</span> <span class="n">weakStackBlock</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">strongF</span><span class="p">);</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">weakF</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;weakStackBlock is %@&#34;</span><span class="p">,</span> <span class="n">weakStackBlock</span><span class="p">);</span>

    <span class="c1">// 3⃣️ Block 作为 Cocoa API 中方法名含有 `usingBlock` 的参数时会被自动拷贝为 __NSMallocBlock__
</span><span class="c1"></span>    <span class="c1">// 4⃣️ Block 作为 GCD API 参数时会被自动拷贝为 __NSMallocBlock__
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span><span class="p">}</span>

<span class="n">BlockType_2</span> <span class="nf">returnMallocBlock</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="kt">int</span> <span class="n">autoVar</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="cp">#if !__has_feature(objc_arc)
</span><span class="cp"></span>    <span class="c1">// MRC 下如果直接返回 Block，将报错「Returning block that lives on the local stack」
</span><span class="c1"></span>    <span class="c1">// 即编译器已经发现返回的 Block 是在栈上，一旦函数体走完，Block 就会被销毁，因此在 MRC 下需要手动 copy：
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">[</span><span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%d&#34;</span><span class="p">,</span> <span class="n">autoVar</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">copy</span><span class="p">];</span>
<span class="cp">#else
</span><span class="cp"></span>    <span class="c1">// 2⃣️ ARC 下 Block 作为函数返回值会被自动拷贝为 __NSMallocBlock__
</span><span class="c1"></span>    <span class="k">return</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%d&#34;</span><span class="p">,</span> <span class="n">autoVar</span><span class="p">);</span>
    <span class="p">};</span>
<span class="cp">#endif
</span><span class="cp"></span><span class="p">}</span>

<span class="kt">int</span> <span class="nf">main_12</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">initBlock</span><span class="p">();</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;mallocBlock_1 is %@&#34;</span><span class="p">,</span> <span class="p">[</span><span class="n">mallocBlock_1</span> <span class="k">class</span><span class="p">]);</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;mallocBlock_2 is %@&#34;</span><span class="p">,</span> <span class="p">[</span><span class="n">mallocBlock_2</span> <span class="k">class</span><span class="p">]);</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;returnMallocBlock() is %@&#34;</span><span class="p">,</span> <span class="p">[</span><span class="n">returnMallocBlock</span><span class="p">()</span> <span class="k">class</span><span class="p">]);</span>

    <span class="n">mallocBlock_1</span><span class="p">();</span>
    <span class="n">mallocBlock_2</span><span class="p">();</span>

<span class="cp">#if !__has_feature(objc_arc)
</span><span class="cp"></span>    <span class="p">[</span><span class="n">mallocBlock_1</span> <span class="k">release</span><span class="p">];</span>
    <span class="p">[</span><span class="n">mallocBlock_2</span> <span class="k">release</span><span class="p">];</span>
<span class="cp">#endif
</span><span class="cp"></span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// MRC OUTPUT:
</span><span class="c1">// mallocBlock_1 is __NSMallocBlock__
</span><span class="c1">// mallocBlock_2 is __NSMallocBlock__
</span><span class="c1">// returnMallocBlock() is __NSMallocBlock__
</span><span class="c1">// c == 10
</span><span class="c1">// &lt;Foo_4: 0x100559170&gt;
</span><span class="c1">// dealloc
</span><span class="c1"></span>
<span class="c1">// ARC OUTPUT:
</span><span class="c1">// weakStackBlock is &lt;__NSStackBlock__: 0x7ffeefbff3d0&gt;
</span><span class="c1">// mallocBlock_1 is __NSMallocBlock__
</span><span class="c1">// mallocBlock_2 is __NSMallocBlock__
</span><span class="c1">// returnMallocBlock() is __NSMallocBlock__
</span><span class="c1">// c == 10
</span><span class="c1">// &lt;Foo_4: 0x1022a7e40&gt;
</span><span class="c1">// &lt;Foo_4: 0x1022a7e40&gt;
</span><span class="c1">// ⚠️：此处 mallocBlock_1 &amp; mallocBlock_2 全局变量还没有释放，因而持有的 strongF 也没有被释放
</span></code></pre></div><ul>
<li>MRC 下，对于 <code>__NSStackBlock__</code> 类型的 Block，只要再对其执行 <code>copy</code> 操作（在 C 语言中对应为 <code>Block_Copy</code>）即可从栈区拷贝到堆区。Block 和其中捕获的自动变量将均在堆区，在主动释放前，就都可以访问到；</li>
<li>ARC 下，需要我们手动 <code>copy</code> 或者编译器会根据情况将 <code>__NSStackBlock__</code> 类型的 Block 自动 <code>copy</code> 到堆上：
<ol>
<li>强指针指向的 Block 会被自动拷贝；</li>
<li>Block 作为函数返回值会被自动拷贝；</li>
<li>Block 作为 Cocoa API 中方法名含有 <code>usingBlock</code> 的参数时会被自动拷贝；</li>
<li>Block 作为 GCD API 参数时会被自动拷贝。</li>
</ol>
</li>
<li>当拷贝到堆上后，Block 将把 <code>_NSConcreteMallocBlock</code> 类对象写入到 <code>isa</code> 中，即 <code>isa = &amp;_NSConcreteMallocBlock</code>。</li>
</ul>
<p>因此，Block 作为属性时应当使用 <code>copy</code> 或 <code>strong</code> 修饰（推荐 <code>copy</code>）：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@interface</span> <span class="nc">Foo_5</span> : <span class="nc">NSObject</span>
<span class="cp">#if !__has_feature(objc_arc)
</span><span class="cp"></span><span class="c1">// MRC
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">block_1</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else
</span><span class="cp"></span><span class="c1">// ARC
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">block_2</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">block_3</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="cp"></span><span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo_5</span>
<span class="k">@end</span>
</code></pre></div><h4 id="__nsstackblock__-拷贝到堆上的细节">__NSStackBlock__ 拷贝到堆上的细节</h4>
<p>上一节提到，ARC 下，编译器会根据情况将 <code>__NSStackBlock__</code> 类型的 Block 自动 <code>copy</code> 到堆上，那么在「拷贝」时到底会发生什么呢？</p>
<p>这里以返回一个 <code>__NSStackBlock__</code> 的函数为例：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="cp">#if __has_feature(objc_arc)
</span><span class="cp"></span><span class="k">typedef</span> <span class="nf">int</span><span class="p">(</span><span class="o">^</span><span class="n">BlockType_3</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>

<span class="n">BlockType_3</span> <span class="nf">returnSomeBlock</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">param</span><span class="p">){</span> <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="n">param</span><span class="p">;</span> <span class="p">};</span>
<span class="p">}</span>
<span class="cp">#endif
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main_13</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="cp">#if __has_feature(objc_arc)
</span><span class="cp"></span>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">returnSomeBlock</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="cp">#endif
</span><span class="cp"></span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// &lt;__NSMallocBlock__: 0x1006baa60&gt;
</span></code></pre></div><p>虽然 <code>returnSomeBlock</code> 函数返回了一个栈上的 Block，但其实 ARC 已经为我们默默将其拷贝到堆。尝试将上述代码翻译为 C/C++ 代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">BlockType_3</span> <span class="nf">returnSomeBlock</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">((</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span><span class="o">&amp;</span><span class="n">__returnSomeBlock_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__returnSomeBlock_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__returnSomeBlock_block_desc_0_DATA</span><span class="p">,</span> <span class="n">arg</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div><p>但从这里似乎并不能看到 ARC 的所作所为。通过一番查阅，ARC 是在代码生成阶段插入了 <code>retain</code> / <code>release</code> LLVM 位代码（Bitcode），所以只能选择在汇编层面一探究竟了：</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">Block_in_Obj-C</span><span class="err">`</span><span class="no">returnSomeBlock</span><span class="p">:</span>
    <span class="err">0</span><span class="nf">x100003390</span> <span class="err">&lt;+</span><span class="mi">0</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">pushq</span>  <span class="nv">%rbp</span>
    <span class="err">0</span><span class="nf">x100003391</span> <span class="err">&lt;+</span><span class="mi">1</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movq</span>   <span class="nv">%rsp</span><span class="p">,</span> <span class="nv">%rbp</span>
    <span class="err">0</span><span class="nf">x100003394</span> <span class="err">&lt;+</span><span class="mi">4</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">subq</span>   <span class="no">$0x30</span><span class="p">,</span> <span class="nv">%rsp</span>
    <span class="err">0</span><span class="nf">x100003398</span> <span class="err">&lt;+</span><span class="mi">8</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">movl</span>   <span class="nv">%edi</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x4</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
<span class="err">-&gt;</span>  <span class="err">0</span><span class="nf">x10000339b</span> <span class="err">&lt;+</span><span class="mi">11</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="mi">0xc5e</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rax</span>         <span class="c">; (void *)0x00007fff8dfbbe40: _NSConcreteStackBlock
</span><span class="c"></span>    <span class="mi">0x1000033a2</span> <span class="err">&lt;+</span><span class="mi">18</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x28</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x1000033a6</span> <span class="err">&lt;+</span><span class="mi">22</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movl</span>   <span class="no">$0xc0000000</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x20</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>  <span class="c">; imm = 0xC0000000
</span><span class="c"></span>    <span class="mi">0x1000033ad</span> <span class="err">&lt;+</span><span class="mi">29</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movl</span>   <span class="no">$0x0</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x1c</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x1000033b4</span> <span class="err">&lt;+</span><span class="mi">36</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">leaq</span>   <span class="mi">0x35</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rax</span>          <span class="c">; __returnSomeBlock_block_invoke at main.m:551
</span><span class="c"></span>    <span class="mi">0x1000033bb</span> <span class="err">&lt;+</span><span class="mi">43</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x18</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x1000033bf</span> <span class="err">&lt;+</span><span class="mi">47</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">leaq</span>   <span class="mi">0x1022</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rax</span>        <span class="c">; __block_descriptor_36_e8_i12?0i8l
</span><span class="c"></span>    <span class="mi">0x1000033c6</span> <span class="err">&lt;+</span><span class="mi">54</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x10</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x1000033ca</span> <span class="err">&lt;+</span><span class="mi">58</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movl</span>   <span class="p">-</span><span class="mi">0x4</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%edi</span>
    <span class="err">0</span><span class="nf">x1000033cd</span> <span class="err">&lt;+</span><span class="mi">61</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movl</span>   <span class="nv">%edi</span><span class="p">,</span> <span class="p">-</span><span class="mi">0x8</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">)</span>
    <span class="err">0</span><span class="nf">x1000033d0</span> <span class="err">&lt;+</span><span class="mi">64</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">leaq</span>   <span class="p">-</span><span class="mi">0x28</span><span class="p">(</span><span class="nv">%rbp</span><span class="p">),</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x1000033d4</span> <span class="err">&lt;+</span><span class="mi">68</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">callq</span>  <span class="mi">0x100003ac0</span>               <span class="c">; symbol stub for: objc_retainBlock
</span><span class="c"></span>    <span class="mi">0x1000033d9</span> <span class="err">&lt;+</span><span class="mi">73</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">movq</span>   <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rdi</span>
    <span class="err">0</span><span class="nf">x1000033dc</span> <span class="err">&lt;+</span><span class="mi">76</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">addq</span>   <span class="no">$0x30</span><span class="p">,</span> <span class="nv">%rsp</span>
    <span class="err">0</span><span class="nf">x1000033e0</span> <span class="err">&lt;+</span><span class="mi">80</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">popq</span>   <span class="nv">%rbp</span>
    <span class="err">0</span><span class="nf">x1000033e1</span> <span class="err">&lt;+</span><span class="mi">81</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">jmp</span>    <span class="mi">0x100003a8a</span>               <span class="c">; symbol stub for: objc_autoreleaseReturnValue
</span></code></pre></div><blockquote>
<p>如何查看 Xcode 项目的汇编代码呢？</p>
<ol>
<li>在 Block 内部打个断点，当运行至断点时，Xcode Menu - Debug - Debug Workflow - Always Show Disassembly，即可自动跳转至汇编视图；</li>
<li>使用 Mac 自带的 <code>otool -tvV PRODUCT_PATH</code> 命令即可将 Xcode 编译后的二进制产物（Products 目录下）的汇编指令打印出来。</li>
</ol>
</blockquote>
<p>这里我们暂时没必要搞清楚每一条汇编指令，而是着重看一下右侧的注释 <code>objc_retainBlock</code> 和 <code>objc_autoreleaseReturnValue</code> 与 ARC 有关的指令，因此就基本可以得出 <code>returnSomeBlock</code> 在 ARC 下的伪代码（同时参考了《Objective-C 高级编程》）：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">BlockType_3</span> <span class="nf">returnSomeBlock</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 构造 Block，赋值给 tmp 变量（默认是强指针引用）
</span><span class="c1"></span>    <span class="n">BlockType_3</span> <span class="n">__strong</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__returnSomeBlock_block_impl_0</span><span class="p">(</span>
        <span class="n">__returnSomeBlock_block_func_0</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">__returnSomeBlock_block_desc_0_DATA</span><span class="p">,</span>
        <span class="n">arg</span>
    <span class="p">);</span>
    <span class="c1">// 根据 objc4 - NSObject.mm，等同 tmp = _Block_copy(tmp);，_Block_copy 的源码 Apple 开源在 libclosure
</span><span class="c1"></span>    <span class="c1">// 将栈上的 Block 拷贝到堆上，并将堆上 Block 地址返回给 tmp 保存
</span><span class="c1"></span>    <span class="n">tmp</span> <span class="o">=</span> <span class="n">objc_retainBlock</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="c1">// 注册到自动释放池并返回
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">objc_autoreleaseReturnValue</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>除了上述四个条件，ARC 对于 Block 并不是完全「可靠」的：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">^</span><span class="n">BlockType_4</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="n">NSArray</span> <span class="o">*</span><span class="nf">returnBlocksArray_1</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">autoVar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">[[</span><span class="n">NSArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithObjects</span><span class="p">:</span>
            <span class="o">^</span><span class="p">{</span> <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%d&#34;</span><span class="p">,</span> <span class="n">autoVar</span><span class="p">);</span> <span class="p">},</span>
            <span class="o">^</span><span class="p">{</span> <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%d&#34;</span><span class="p">,</span> <span class="n">autoVar</span><span class="p">);</span> <span class="p">},</span>
            <span class="nb">nil</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main_14</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">NSArray</span> <span class="o">*</span><span class="n">arr_1</span> <span class="o">=</span> <span class="n">returnBlocksArray_1</span><span class="p">();</span>
    <span class="n">BlockType_4</span> <span class="n">block_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">BlockType_4</span><span class="p">)[</span><span class="n">arr_1</span> <span class="nl">objectAtIndex</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">block_1</span><span class="p">();</span>
    <span class="c1">// CRASH: EXC_BAD_ACCESS
</span><span class="c1"></span>    <span class="c1">// block_1 = (BlockType_4)[arr_1 objectAtIndex:1];
</span><span class="c1"></span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// 1
</span></code></pre></div><p>在使用 <code>initWithObjects:</code> API 构建 <code>NSArray</code> 数组时，编译器并没有把作为参数且放置在栈上的 Block 自动拷贝到堆上，当栈区内存空间回收后去执行 Block 从而导致了崩溃：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="n">NSArray</span> <span class="o">*</span><span class="nf">returnBlocksArray_2</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">autoVar</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="c1">// 拷贝到堆上
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">[[</span><span class="n">NSArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithObjects</span><span class="p">:</span>
            <span class="p">[</span><span class="o">^</span><span class="p">{</span> <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%d&#34;</span><span class="p">,</span> <span class="n">autoVar</span><span class="p">);</span> <span class="p">}</span> <span class="k">copy</span><span class="p">],</span>
            <span class="p">[</span><span class="o">^</span><span class="p">{</span> <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%d&#34;</span><span class="p">,</span> <span class="n">autoVar</span><span class="p">);</span> <span class="p">}</span> <span class="k">copy</span><span class="p">],</span>
            <span class="nb">nil</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">NSArray</span> <span class="o">*</span><span class="nf">returnBlocksArray_3</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">autoVar</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

    <span class="c1">// 使用强指针指向
</span><span class="c1"></span>    <span class="n">BlockType_4</span> <span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span> <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%d&#34;</span><span class="p">,</span> <span class="n">autoVar</span><span class="p">);</span> <span class="p">};</span>

    <span class="k">return</span> <span class="p">[[</span><span class="n">NSArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithObjects</span><span class="p">:</span>
            <span class="n">block</span><span class="p">,</span>
            <span class="n">block</span><span class="p">,</span>
            <span class="nb">nil</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main_14</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">NSArray</span> <span class="o">*</span><span class="n">arr_2</span> <span class="o">=</span> <span class="n">returnBlocksArray_2</span><span class="p">();</span>
    <span class="n">BlockType_4</span> <span class="n">block_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">BlockType_4</span><span class="p">)[</span><span class="n">arr_2</span> <span class="nl">objectAtIndex</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">block_2</span><span class="p">();</span>
    <span class="n">block_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">BlockType_4</span><span class="p">)[</span><span class="n">arr_2</span> <span class="nl">objectAtIndex</span><span class="p">:</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">block_2</span><span class="p">();</span>

    <span class="n">NSArray</span> <span class="o">*</span><span class="n">arr_3</span> <span class="o">=</span> <span class="n">returnBlocksArray_3</span><span class="p">();</span>
    <span class="n">BlockType_4</span> <span class="n">block_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">BlockType_4</span><span class="p">)[</span><span class="n">arr_3</span> <span class="nl">objectAtIndex</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">block_3</span><span class="p">();</span>
    <span class="n">block_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">BlockType_4</span><span class="p">)[</span><span class="n">arr_3</span> <span class="nl">objectAtIndex</span><span class="p">:</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">block_3</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// 10
</span><span class="c1">// 10
</span><span class="c1">// 100
</span><span class="c1">// 100
</span></code></pre></div><p>即使在 ARC 下，我们有时也需要手动调用 <code>copy</code> 将 Block 拷贝至堆上或使用强指针指向，而对同一个 Block 多次 <code>copy</code> 会有什么问题么？</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">int</span> <span class="nf">main_14</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">autoVar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">BlockType_4</span> <span class="n">block_4</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span> <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%d&#34;</span><span class="p">,</span> <span class="n">autoVar</span><span class="p">);</span> <span class="p">};</span>
    <span class="n">block_4</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">block_4</span> <span class="k">copy</span><span class="p">]</span> <span class="k">copy</span><span class="p">]</span> <span class="k">copy</span><span class="p">];</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%ld&#34;</span><span class="p">,</span> <span class="n">CFGetRetainCount</span><span class="p">((</span><span class="k">__bridge</span> <span class="n">CFTypeRef</span><span class="p">)(</span><span class="n">block_4</span><span class="p">)));</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// 1
</span></code></pre></div><p>其实只有第一次 <code>copy</code> 时，栈上的 Block 将被拷贝至堆上一份，后续的 <code>copy</code> 则是对堆上的拷贝进行拷贝，即仅仅递增引用计数。如 <code>block_4 = [[[block_4 copy] copy] copy];</code> 则最终仍只有 <code>block_4</code> 指向堆上的 Block，因此其引用计数仍为 <code>1</code>。</p>
<p>不同于基础类型，对于对象类型的自动变量总是更多地涉及到内存管理方面：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@interface</span> <span class="nc">Foo_6</span> : <span class="nc">NSObject</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo_6</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span>
<span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;dealloc&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="kt">int</span> <span class="n">main_15</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">Foo_6</span> <span class="o">*</span><span class="n">strongF</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo_6</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

    <span class="k">__weak</span> <span class="n">Foo_6</span> <span class="o">*</span><span class="n">weakF</span> <span class="o">=</span> <span class="n">strongF</span><span class="p">;</span>

    <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">someBlcok</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">strongF</span><span class="p">);</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">weakF</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="n">someBlcok</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// &lt;Foo_6: 0x1007ab750&gt;
</span><span class="c1">// &lt;Foo_6: 0x1007ab750&gt;
</span><span class="c1">// dealloc
</span></code></pre></div><p>将上述翻译为 C/C++ 代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">__main_15_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="nc">__main_15_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="n">Foo_6</span> <span class="o">*</span><span class="n">__strong</span> <span class="n">strongF</span><span class="p">;</span> <span class="c1">// 默认强引用
</span><span class="c1"></span>  <span class="n">Foo_6</span> <span class="o">*</span><span class="n">__weak</span> <span class="n">weakF</span><span class="p">;</span>     <span class="c1">// 显式弱引用
</span><span class="c1"></span>  <span class="n">__main_15_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__main_15_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">Foo_6</span> <span class="o">*</span><span class="n">__strong</span> <span class="n">_strongF</span><span class="p">,</span> <span class="n">Foo_6</span> <span class="o">*</span><span class="n">__weak</span> <span class="n">_weakF</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">strongF</span><span class="p">(</span><span class="n">_strongF</span><span class="p">),</span> <span class="n">weakF</span><span class="p">(</span><span class="n">_weakF</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_15_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_15_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Foo_6</span> <span class="o">*</span><span class="n">__strong</span> <span class="n">strongF</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">strongF</span><span class="p">;</span> <span class="c1">// bound by copy
</span><span class="c1"></span>  <span class="n">Foo_6</span> <span class="o">*</span><span class="n">__weak</span> <span class="n">weakF</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">weakF</span><span class="p">;</span> <span class="c1">// bound by copy
</span><span class="c1"></span>
  <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_e96639_mi_49</span><span class="p">,</span> <span class="n">strongF</span><span class="p">);</span>
  <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_e96639_mi_50</span><span class="p">,</span> <span class="n">weakF</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 栈上的 Block 拷贝到堆时，会调用 __main_block_copy_0 方法
</span><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_15_block_copy_0</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_15_block_impl_0</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__main_15_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// _Block_object_assign 函数会根据自动变量的修饰符（__strong / __weak）作出相应的操作，形成强引用或弱引用（类似 Retain，将对象赋值在对象类型的结构体成员变量中）
</span><span class="c1"></span>    <span class="c1">// BLOCK_FIELD_IS_OBJECT 为 flags，函数内部根据此参数决定相应的处理逻辑；该 flag 对应为 _Block_retain_object
</span><span class="c1"></span>    <span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">strongF</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">strongF</span><span class="p">,</span> <span class="mi">3</span><span class="cm">/*BLOCK_FIELD_IS_OBJECT*/</span><span class="p">);</span> <span class="c1">// 对外界 strongF 强引用
</span><span class="c1"></span>    <span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">weakF</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">weakF</span><span class="p">,</span> <span class="mi">3</span><span class="cm">/*BLOCK_FIELD_IS_OBJECT*/</span><span class="p">);</span>     <span class="c1">// 对外界 weakF 弱引用
</span><span class="c1"></span>    <span class="c1">// _Block_object_assign 的源码 Apple 开源在 libclosure，此处暂略
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 堆上的 Block 销毁时，会调用 __main_15_block_dispose_0 方法，类似对象的 dealloc 方法
</span><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_15_block_dispose_0</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_15_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// _Block_object_dispose 函数使得自动变量的引用计数减一（类似 Release，释放赋值在对象类型的结构体成员变量中的对象）
</span><span class="c1"></span>    <span class="c1">// BLOCK_FIELD_IS_OBJECT 对应为 _Block_release_object(object);
</span><span class="c1"></span>    <span class="n">_Block_object_dispose</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">strongF</span><span class="p">,</span> <span class="mi">3</span><span class="cm">/*BLOCK_FIELD_IS_OBJECT*/</span><span class="p">);</span>
    <span class="n">_Block_object_dispose</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">weakF</span><span class="p">,</span> <span class="mi">3</span><span class="cm">/*BLOCK_FIELD_IS_OBJECT*/</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="nc">__main_15_block_desc_0</span> <span class="p">{</span>
  <span class="n">size_t</span> <span class="n">reserved</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
  <span class="c1">// 当在 Block 中访问对象类型的自动变量时会增加额外的域来协助管理内存
</span><span class="c1"></span>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">copy</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">__main_15_block_impl_0</span><span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__main_15_block_impl_0</span><span class="o">*</span><span class="p">);</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dispose</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">__main_15_block_impl_0</span><span class="o">*</span><span class="p">);</span>
<span class="p">}</span> <span class="n">__main_15_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_15_block_impl_0</span><span class="p">),</span> <span class="n">__main_15_block_copy_0</span><span class="p">,</span> <span class="n">__main_15_block_dispose_0</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">main_15</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">Foo_6</span> <span class="o">*</span><span class="n">strongF</span> <span class="o">=</span> <span class="p">((</span><span class="n">Foo_6</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="n">id</span><span class="p">)((</span><span class="n">Foo_6</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="n">id</span><span class="p">)</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&#34;Foo_6&#34;</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&#34;alloc&#34;</span><span class="p">)),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&#34;init&#34;</span><span class="p">));</span>

    <span class="n">__attribute__</span><span class="p">((</span><span class="n">objc_ownership</span><span class="p">(</span><span class="n">weak</span><span class="p">)))</span> <span class="n">Foo_6</span> <span class="o">*</span><span class="n">weakF</span> <span class="o">=</span> <span class="n">strongF</span><span class="p">;</span>

    <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">someBlcok</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_15_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_15_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_15_block_desc_0_DATA</span><span class="p">,</span> <span class="n">strongF</span><span class="p">,</span> <span class="n">weakF</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">));</span>

    <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">someBlcok</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">someBlcok</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="__block">__block</h2>
<h3 id="本质">本质</h3>
<p>上面的例子中 Block 内部只是访问了外界的变量，接下来我们尝试下在 Block 内修改变量值：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// 静态全局变量
</span><span class="c1"></span><span class="k">static</span> <span class="kt">int</span> <span class="n">staticGlobalVar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// 全局变量
</span><span class="c1"></span><span class="kt">int</span> <span class="n">globalVar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main_16</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// 自动变量
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">autoVar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 静态变量
</span><span class="c1"></span>    <span class="k">static</span> <span class="kt">int</span> <span class="n">staticVar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">autoArray</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

    <span class="o">^</span><span class="p">{</span>
        <span class="c1">// ERROR: Variable is not assignable (missing __block type specifier)
</span><span class="c1"></span>        <span class="c1">// autoVar = 10;
</span><span class="c1"></span>
        <span class="n">staticVar</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">staticGlobalVar</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">globalVar</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

        <span class="p">[</span><span class="n">autoArray</span> <span class="nl">addObject</span><span class="p">:</span><span class="s">@&#34;kingcos.me&#34;</span><span class="p">];</span>

        <span class="c1">// ERROR: Variable is not assignable (missing __block type specifier)
</span><span class="c1"></span>        <span class="c1">// autoArray = [[NSMutableArray alloc] init];
</span><span class="c1"></span>    <span class="p">}();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>对于局部静态变量和全局静态变量，Block 内可以直接修改这些变量的值。而对于自动变量编译器则会报错 <code>Variable is not assignable (missing __block type specifier)</code>（变量未分配（丢失 <code>__block</code> 类型限定符）），那么这里的 <code>__block</code> 是什么呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">int</span> <span class="nf">main_17</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block1</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
    <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block2</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

    <span class="p">{</span>
        <span class="k">__block</span> <span class="kt">int</span> <span class="n">autoVar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">__block</span> <span class="k">auto</span> <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">autoArray</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;autoVar = %d&#34;</span><span class="p">,</span> <span class="n">autoVar</span><span class="p">);</span>

        <span class="n">block1</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
            <span class="n">autoVar</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
            <span class="n">autoArray</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;autoVar = %d&#34;</span><span class="p">,</span> <span class="n">autoVar</span><span class="p">);</span>
        <span class="p">};</span>

        <span class="n">block2</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
            <span class="n">autoVar</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;autoVar = %d&#34;</span><span class="p">,</span> <span class="n">autoVar</span><span class="p">);</span>
        <span class="p">};</span>

        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;autoVar = %d&#34;</span><span class="p">,</span> <span class="n">autoVar</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">block1</span><span class="p">();</span>
    <span class="n">block2</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// autoVar = 1
</span><span class="c1">// autoVar = 1
</span><span class="c1">// autoVar = 10
</span><span class="c1">// autoVar = 20
</span></code></pre></div><p>如上，使用 <code>__block</code> 修饰的自动变量，在 Block 内部确实可以修改，尝试将以上代码翻译为 C++：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 将自动变量包装的结构体
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">__Block_byref_autoVar_0</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span> <span class="c1">// 标志着这是个 Obj-C 对象
</span><span class="c1"></span><span class="n">__Block_byref_autoVar_0</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span> <span class="c1">// 结构体本身的地址
</span><span class="c1"></span> <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span> <span class="c1">// 标志位
</span><span class="c1"></span> <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>  <span class="c1">// sizeof 结构体的大小
</span><span class="c1"></span> <span class="kt">int</span> <span class="n">autoVar</span><span class="p">;</span> <span class="c1">// 自动变量，初始化时赋值
</span><span class="c1"></span><span class="p">};</span>

<span class="k">struct</span> <span class="nc">__Block_byref_autoArray_1</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span>
<span class="n">__Block_byref_autoArray_1</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>
 <span class="c1">// 内存管理方法
</span><span class="c1"></span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__Block_byref_id_object_copy</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">);</span>
 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__Block_byref_id_object_dispose</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
  <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">__strong</span> <span class="n">autoArray</span><span class="p">;</span> <span class="c1">// 对象类型的自动变量
</span><span class="c1"></span><span class="p">};</span>

<span class="c1">// Block 结构体
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">__main_17_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="nc">__main_5_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="c1">// 不使用 __block 时为 int autoVar;，此时为指向 __Block_byref_autoVar_0 的指针
</span><span class="c1"></span>  <span class="n">__Block_byref_autoVar_0</span> <span class="o">*</span><span class="n">autoVar</span><span class="p">;</span> <span class="c1">// by ref
</span><span class="c1"></span>  <span class="c1">// 不使用 __block 时为 NSMutableArray *autoArray;，此时为指向 __Block_byref_autoArray_1 的指针
</span><span class="c1"></span>  <span class="n">__Block_byref_autoArray_1</span> <span class="o">*</span><span class="n">autoArray</span><span class="p">;</span> <span class="c1">// by ref
</span><span class="c1"></span>  <span class="n">__main_17_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__main_5_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">__Block_byref_autoVar_0</span> <span class="o">*</span><span class="n">_autoVar</span><span class="p">,</span> <span class="n">__Block_byref_autoArray_1</span> <span class="o">*</span><span class="n">_autoArray</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">autoVar</span><span class="p">(</span><span class="n">_autoVar</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="p">),</span> <span class="n">autoArray</span><span class="p">(</span><span class="n">_autoArray</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_17_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_17_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 指向结构体的指针
</span><span class="c1"></span>  <span class="n">__Block_byref_autoVar_0</span> <span class="o">*</span><span class="n">autoVar</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">autoVar</span><span class="p">;</span> <span class="c1">// bound by ref
</span><span class="c1"></span>  <span class="n">__Block_byref_autoArray_1</span> <span class="o">*</span><span class="n">autoArray</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">autoArray</span><span class="p">;</span> <span class="c1">// bound by ref
</span><span class="c1"></span>
  <span class="c1">// 通过指向自身的指针改变了值
</span><span class="c1"></span>  <span class="p">(</span><span class="n">autoVar</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">autoVar</span><span class="p">)</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="p">(</span><span class="n">autoArray</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">autoArray</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="n">NSMutableArray</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="n">id</span><span class="p">)((</span><span class="n">NSMutableArray</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="n">id</span><span class="p">)</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&#34;NSMutableArray&#34;</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&#34;alloc&#34;</span><span class="p">)),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&#34;init&#34;</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_17_block_copy_0</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_17_block_impl_0</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__main_17_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">autoVar</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">autoVar</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);</span>
    <span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">autoArray</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">autoArray</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_17_block_dispose_0</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_17_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_Block_object_dispose</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">autoVar</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);</span>
    <span class="n">_Block_object_dispose</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">autoArray</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="nc">__main_17_block_desc_0</span> <span class="p">{</span>
  <span class="n">size_t</span> <span class="n">reserved</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">copy</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">__main_17_block_impl_0</span><span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__main_17_block_impl_0</span><span class="o">*</span><span class="p">);</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dispose</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">__main_17_block_impl_0</span><span class="o">*</span><span class="p">);</span>
<span class="p">}</span> <span class="n">__main_17_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_17_block_impl_0</span><span class="p">),</span> <span class="n">__main_17_block_copy_0</span><span class="p">,</span> <span class="n">__main_17_block_dispose_0</span><span class="p">};</span>

<span class="c1">// 第二个 Block
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">__main_17_block_impl_1</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="nc">__main_17_block_desc_1</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="n">__Block_byref_autoVar_0</span> <span class="o">*</span><span class="n">autoVar</span><span class="p">;</span> <span class="c1">// by ref
</span><span class="c1"></span>  <span class="n">__main_17_block_impl_1</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__main_17_block_desc_1</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">__Block_byref_autoVar_0</span> <span class="o">*</span><span class="n">_autoVar</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">autoVar</span><span class="p">(</span><span class="n">_autoVar</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_17_block_func_1</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_17_block_impl_1</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">__Block_byref_autoVar_0</span> <span class="o">*</span><span class="n">autoVar</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">autoVar</span><span class="p">;</span> <span class="c1">// bound by ref
</span><span class="c1"></span>
  <span class="p">(</span><span class="n">autoVar</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">autoVar</span><span class="p">)</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_17_block_copy_1</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_17_block_impl_1</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__main_17_block_impl_1</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">autoVar</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">autoVar</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_17_block_dispose_1</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_17_block_impl_1</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_Block_object_dispose</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">autoVar</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="nc">__main_17_block_desc_1</span> <span class="p">{</span>
  <span class="n">size_t</span> <span class="n">reserved</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">copy</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">__main_17_block_impl_1</span><span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__main_17_block_impl_1</span><span class="o">*</span><span class="p">);</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dispose</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">__main_17_block_impl_1</span><span class="o">*</span><span class="p">);</span>
<span class="p">}</span> <span class="n">__main_17_block_desc_1_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_17_block_impl_1</span><span class="p">),</span> <span class="n">__main_17_block_copy_1</span><span class="p">,</span> <span class="n">__main_17_block_dispose_1</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">main_17</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">block1</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
    <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">block2</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

    <span class="p">{</span>
        <span class="c1">// 初始化 __Block_byref_autoVar_0 结构体，将 autoVar 的地址赋值给结构体中的 __forwarding 指针
</span><span class="c1"></span>        <span class="c1">// __Block_byref_autoVar_0 autoVar = {0, &amp;autoVar, 0, sizeof(__Block_byref_autoVar_0), 0（初始值）}
</span><span class="c1"></span>        <span class="n">__attribute__</span><span class="p">((</span><span class="n">__blocks__</span><span class="p">(</span><span class="n">byref</span><span class="p">)))</span> <span class="n">__Block_byref_autoVar_0</span> <span class="n">autoVar</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,(</span><span class="n">__Block_byref_autoVar_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">autoVar</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_autoVar_0</span><span class="p">),</span> <span class="mi">0</span><span class="p">};</span>

        <span class="c1">// 初始化 __Block_byref_autoArray_1 结构体，将 autoArray 的地址赋值给结构体中的 __forwarding 指针
</span><span class="c1"></span>        <span class="c1">// __Block_byref_autoArray_1 autoArray = {0, &amp;autoArray, 33554432, sizeof(__Block_byref_autoArray_1), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, NSMutableArray（初始值）}
</span><span class="c1"></span>        <span class="n">__attribute__</span><span class="p">((</span><span class="n">__blocks__</span><span class="p">(</span><span class="n">byref</span><span class="p">)))</span> <span class="k">auto</span> <span class="n">__Block_byref_autoArray_1</span> <span class="n">autoArray</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,(</span><span class="n">__Block_byref_autoArray_1</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">autoArray</span><span class="p">,</span> <span class="mi">33554432</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_autoArray_1</span><span class="p">),</span> <span class="n">__Block_byref_id_object_copy_131</span><span class="p">,</span> <span class="n">__Block_byref_id_object_dispose_131</span><span class="p">,</span> <span class="p">((</span><span class="n">NSMutableArray</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="n">id</span><span class="p">)((</span><span class="n">NSMutableArray</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="n">id</span><span class="p">)</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&#34;NSMutableArray&#34;</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&#34;alloc&#34;</span><span class="p">)),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&#34;init&#34;</span><span class="p">))};</span>

        <span class="c1">// 外界通过 __forwarding 访问 __block 变量
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_8f352d_mi_52</span><span class="p">,</span> <span class="p">(</span><span class="n">autoVar</span><span class="p">.</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">autoVar</span><span class="p">));</span>

        <span class="c1">// 忽略类型转换：block1 = &amp;__main_17_block_impl_0(__main_17_block_func_0, &amp;__main_17_block_desc_0_DATA, &amp;autoVar, &amp;autoArray, 570425344);
</span><span class="c1"></span>        <span class="n">block1</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_17_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_17_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_17_block_desc_0_DATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_autoVar_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">autoVar</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_autoArray_1</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">autoArray</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">));</span>

        <span class="c1">// 忽略类型转换：block2 = &amp;__main_17_block_impl_1(__main_17_block_func_1, &amp;___main_17_block_desc_1_DATA, &amp;autoVar, 570425344);
</span><span class="c1"></span>        <span class="n">block2</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_17_block_impl_1</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_17_block_func_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_17_block_desc_1_DATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_autoVar_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">autoVar</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">));</span>

        <span class="c1">// 外界通过 __forwarding 访问 __block 变量
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_8f352d_mi_55</span><span class="p">,</span> <span class="p">(</span><span class="n">autoVar</span><span class="p">.</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">autoVar</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">block1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">block1</span><span class="p">);</span>
    <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">block2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">block2</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><code>__block</code> 将 <code>autoVar</code> 封装到 <code>__Block_byref_autoVar_0</code> 结构体中，将 <code>autoArray</code> 封装到 <code>__Block_byref_autoArray_1</code> 结构体中，其中的 <code>isa</code> 指针标志着该结构体本质也属于 Obj-C 对象；<code>__forwarding</code> 指针指向了该结构体本身，在初始化时被赋值为声明的结构体的地址；<code>__size</code> 为该结构体的大小信息；<code>autoVar</code> 和 <code>autoArray</code> 为捕获的变量本身。因此捕获了 <code>__block</code> 变量的 Block 结构如下图所示：</p>
<p><img src="/img/2019/block_in_obj-c/4.png" alt="4"></p>
<h3 id="__forwarding">__forwarding</h3>
<p>当 Block 被分配在栈上时，其内部使用到的 <code>__block</code> 变量也会被分配在栈上；当 Block 超出作用域被销毁时，<code>__block</code> 变量则也会被销毁。当 Block 从栈拷贝到堆上时，其内部使用到的 <code>__block</code> 变量也会同时被拷贝到堆上，并被堆上的 Block 持有。当多个 Block 使用同一个 <code>__block</code> 变量时，第一个被拷贝到堆上的 Block 会将其同时拷贝到堆上并被该 Block 持有；当其它 Block 被拷贝到堆上后，将持有该变量，引用计数递增。</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">int</span> <span class="nf">main_18</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block1</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
    <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block2</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

    <span class="p">{</span>
        <span class="c1">// 声明 __block 变量 blockVar
</span><span class="c1"></span>        <span class="k">__block</span> <span class="kt">int</span> <span class="n">blockVar</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

        <span class="c1">// blockVar 默认在栈上
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;1 - %p&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blockVar</span><span class="p">);</span> <span class="c1">// 1 - 0x7ffeefbff3d8
</span><span class="c1"></span>
        <span class="c1">// 栈上的 Block 捕获，Block 本身在栈上
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;2 - %p&#34;</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%p&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blockVar</span><span class="p">);</span>
        <span class="p">});</span> <span class="c1">// 2 - 0x7ffeefbff388
</span><span class="c1"></span>
        <span class="c1">// 栈上的 Block 捕获对 blockVar 无影响
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;3 - %p&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blockVar</span><span class="p">);</span> <span class="c1">// 3 - 0x7ffeefbff3d8
</span><span class="c1"></span>
        <span class="c1">// 栈上的 Block 捕获并执行
</span><span class="c1"></span>        <span class="o">^</span><span class="p">{</span>
            <span class="c1">// 捕获的 blockVar 仍在栈上
</span><span class="c1"></span>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;4 - %p&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blockVar</span><span class="p">);</span> <span class="c1">// 4 - 0x7ffeefbff3d8
</span><span class="c1"></span>        <span class="p">}();</span>

        <span class="c1">// 栈上的 Block 执行对 blockVar 无影响
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;5 - %p&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blockVar</span><span class="p">);</span>

        <span class="c1">// 栈上的 Block 被强指针引用，将拷贝至堆上
</span><span class="c1"></span>        <span class="n">block1</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
            <span class="c1">// 捕获的 blockVar 也在堆上
</span><span class="c1"></span>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;6 - %p&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blockVar</span><span class="p">);</span> <span class="c1">// 6 - 0x100500eb8
</span><span class="c1"></span>        <span class="p">};</span>

        <span class="c1">// 此时 blockVar 已被拷贝至堆上
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;7 - %p&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blockVar</span><span class="p">);</span> <span class="c1">// 7 - 0x100500eb8
</span><span class="c1"></span>
        <span class="c1">// block1 在堆上
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;8 - %p&#34;</span><span class="p">,</span> <span class="n">block1</span><span class="p">);</span> <span class="c1">// 8 - 0x100500bb0
</span><span class="c1"></span>
        <span class="c1">// 另一个栈上的 Block 捕获并执行
</span><span class="c1"></span>        <span class="o">^</span><span class="p">{</span>
            <span class="c1">// 捕获的 blockVar 也在堆上
</span><span class="c1"></span>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;9 - %p&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blockVar</span><span class="p">);</span> <span class="c1">// 9 - 0x100500eb8
</span><span class="c1"></span>        <span class="p">}();</span>

        <span class="c1">// blockVar 再次被栈上 Block 捕获，此时仍在堆上
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;10 - %p&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blockVar</span><span class="p">);</span> <span class="c1">// 10 - 0x100500eb8
</span><span class="c1"></span>
        <span class="n">block1</span><span class="p">();</span>

        <span class="c1">// blockVar 此时仍在堆上
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;11 - %p&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blockVar</span><span class="p">);</span> <span class="c1">// 11 - 0x100701f18
</span><span class="c1"></span>
        <span class="c1">// 第二个栈上的 Block 被强指针引用，拷贝至堆上
</span><span class="c1"></span>        <span class="n">block2</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
            <span class="c1">// 捕获的 blockVar 也在堆上
</span><span class="c1"></span>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;12 - %p&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blockVar</span><span class="p">);</span> <span class="c1">// 12 - 0x100701f18
</span><span class="c1"></span>        <span class="p">};</span>

        <span class="c1">// blockVar 再次被堆上 Block 捕获，此时仍在堆上
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;13 - %p&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blockVar</span><span class="p">);</span> <span class="c1">// 13 - 0x100701f18
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;14 - %p&#34;</span><span class="p">,</span> <span class="n">block1</span><span class="p">);</span> <span class="c1">// 14 - 0x100500bb0
</span><span class="c1"></span>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;15 - %p&#34;</span><span class="p">,</span> <span class="n">block2</span><span class="p">);</span> <span class="c1">// 15 - 0x100500940
</span><span class="c1"></span>
    <span class="n">block1</span><span class="p">();</span>
    <span class="n">block2</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>将上述翻译为 C/C++ 代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_18_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_18_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">__Block_byref_blockVar_2</span> <span class="o">*</span><span class="n">blockVar</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">blockVar</span><span class="p">;</span> <span class="c1">// bound by ref
</span><span class="c1"></span>
  <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_58</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">blockVar</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">blockVar</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_18_block_func_1</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_18_block_impl_1</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">__Block_byref_blockVar_2</span> <span class="o">*</span><span class="n">blockVar</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">blockVar</span><span class="p">;</span> <span class="c1">// bound by ref
</span><span class="c1"></span>
  <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_60</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">blockVar</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">blockVar</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_18_block_func_2</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_18_block_impl_2</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">__Block_byref_blockVar_2</span> <span class="o">*</span><span class="n">blockVar</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">blockVar</span><span class="p">;</span> <span class="c1">// bound by ref
</span><span class="c1"></span>
  <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_62</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">blockVar</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">blockVar</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main_18</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">block1</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
    <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">block2</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

    <span class="p">{</span>
        <span class="n">__attribute__</span><span class="p">((</span><span class="n">__blocks__</span><span class="p">(</span><span class="n">byref</span><span class="p">)))</span> <span class="n">__Block_byref_blockVar_2</span> <span class="n">blockVar</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,(</span><span class="n">__Block_byref_blockVar_2</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">blockVar</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_blockVar_2</span><span class="p">),</span> <span class="mi">10</span><span class="p">};</span>

        <span class="c1">// blockVar.__forwarding-&gt;blockVar
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_56</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">blockVar</span><span class="p">.</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">blockVar</span><span class="p">));</span>


        <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_57</span><span class="p">,</span> <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_18_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_18_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_18_block_desc_0_DATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_blockVar_2</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">blockVar</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">)));</span>

        <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_59</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">blockVar</span><span class="p">.</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">blockVar</span><span class="p">));</span>


        <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_18_block_impl_1</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_18_block_func_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_18_block_desc_1_DATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_blockVar_2</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">blockVar</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">))();</span>


        <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_61</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">blockVar</span><span class="p">.</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">blockVar</span><span class="p">));</span>


        <span class="n">block1</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_18_block_impl_2</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_18_block_func_2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_18_block_desc_2_DATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_blockVar_2</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">blockVar</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">));</span>


        <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_63</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">blockVar</span><span class="p">.</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">blockVar</span><span class="p">));</span>


        <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_64</span><span class="p">,</span> <span class="n">block1</span><span class="p">);</span>


        <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_18_block_impl_3</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_18_block_func_3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_18_block_desc_3_DATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_blockVar_2</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">blockVar</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">))();</span>


        <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_66</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">blockVar</span><span class="p">.</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">blockVar</span><span class="p">));</span>

        <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">block1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">block1</span><span class="p">);</span>


        <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_67</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">blockVar</span><span class="p">.</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">blockVar</span><span class="p">));</span>


        <span class="n">block2</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_18_block_impl_4</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_18_block_func_4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_18_block_desc_4_DATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_blockVar_2</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">blockVar</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">));</span>


        <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_69</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">blockVar</span><span class="p">.</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">blockVar</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_70</span><span class="p">,</span> <span class="n">block1</span><span class="p">);</span>
    <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_71</span><span class="p">,</span> <span class="n">block2</span><span class="p">);</span>

    <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">block1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">block1</span><span class="p">);</span>
    <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">block2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">block2</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>由上我们可以看出，<code>__block</code> 变量从声明后，无论在 Block 内外去访问均是通过结构体的 <code>__forwarding</code> 指针即 <code>blockVar.__forwarding-&gt;blockVar</code>。当 <code>__block</code> 变量在栈上时，<code>blockVar.__forwarding-&gt;blockVar</code> 就等同于直接通过 <code>blockVar-&gt;blockVar</code> 来访问的，因为此时 <code>__forwarding</code> 就指向栈上的结构体本身；而当 Block 拷贝到堆上时，<code>__block</code> 变量也会被拷贝到堆上，此时栈上的 <code>__forwarding</code> 将替换为指向堆上的结构体，而堆上的结构体里的 <code>__forwarding</code> 将指向堆上的结构体本身，从而保证后续的数据变动均是在堆上。</p>
<p>因此 <code>__forwarding</code> 存在的意义是无论 <code>__block</code> 配置在栈上还是堆上都能正确地访问 <code>__block</code> 变量。</p>
<h3 id="内存管理">内存管理</h3>
<p>对于对象类型的 <code>__block</code> 变量自然也会更多涉及到内存管理方面：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@interface</span> <span class="nc">Foo_7</span> : <span class="nc">NSObject</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="kt">int</span> <span class="n">bar</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo_7</span>
<span class="k">@end</span>

<span class="kt">int</span> <span class="n">main_19</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">__block</span> <span class="n">Foo_7</span> <span class="o">*</span><span class="n">strongF</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo_7</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
    <span class="n">strongF</span><span class="p">.</span><span class="n">bar</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="k">__block</span> <span class="k">__weak</span> <span class="n">Foo_7</span> <span class="o">*</span><span class="n">weakF</span> <span class="o">=</span> <span class="n">strongF</span><span class="p">;</span>

    <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%lu&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">weakF</span><span class="p">.</span><span class="n">bar</span><span class="p">);</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%lu&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">strongF</span><span class="p">.</span><span class="n">bar</span><span class="p">);</span>

        <span class="n">strongF</span> <span class="o">=</span> <span class="p">[</span><span class="n">Foo_7</span> <span class="n">new</span><span class="p">];</span>
        <span class="n">strongF</span><span class="p">.</span><span class="n">bar</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%lu&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">strongF</span><span class="p">.</span><span class="n">bar</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="n">block</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// 10
</span><span class="c1">// 10
</span><span class="c1">// 100
</span></code></pre></div><p>将上述翻译为 C/C++ 代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">__Block_byref_strongF_3</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span>
<span class="n">__Block_byref_strongF_3</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>
 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__Block_byref_id_object_copy</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">);</span> <span class="c1">// 内存管理域
</span><span class="c1"></span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__Block_byref_id_object_dispose</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>     <span class="c1">// 内存管理域
</span><span class="c1"></span> <span class="n">Foo_7</span> <span class="o">*</span><span class="n">__strong</span> <span class="n">strongF</span><span class="p">;</span> <span class="c1">// 根据外界强引用而强引用
</span><span class="c1"></span><span class="p">};</span>

<span class="k">struct</span> <span class="nc">__Block_byref_weakF_4</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span>
<span class="n">__Block_byref_weakF_4</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>
 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__Block_byref_id_object_copy</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">);</span> <span class="c1">// 内存管理域
</span><span class="c1"></span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__Block_byref_id_object_dispose</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>     <span class="c1">// 内存管理域
</span><span class="c1"></span> <span class="n">Foo_7</span> <span class="o">*</span><span class="n">__weak</span> <span class="n">weakF</span><span class="p">;</span> <span class="c1">// 根据外界弱引用而弱引用
</span><span class="c1"></span><span class="p">};</span>

<span class="k">struct</span> <span class="nc">__main_19_block_impl_0</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="nc">__main_19_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
  <span class="c1">// 引用 __block 变量的结构体，但这里均为强指针，不受外界改变
</span><span class="c1"></span>  <span class="n">__Block_byref_weakF_4</span> <span class="o">*</span><span class="n">weakF</span><span class="p">;</span> <span class="c1">// by ref
</span><span class="c1"></span>  <span class="n">__Block_byref_strongF_3</span> <span class="o">*</span><span class="n">strongF</span><span class="p">;</span> <span class="c1">// by ref
</span><span class="c1"></span>  <span class="n">__main_19_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__main_19_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">__Block_byref_weakF_4</span> <span class="o">*</span><span class="n">_weakF</span><span class="p">,</span> <span class="n">__Block_byref_strongF_3</span> <span class="o">*</span><span class="n">_strongF</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">weakF</span><span class="p">(</span><span class="n">_weakF</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="p">),</span> <span class="n">strongF</span><span class="p">(</span><span class="n">_strongF</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_19_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_19_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">__Block_byref_weakF_4</span> <span class="o">*</span><span class="n">weakF</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">weakF</span><span class="p">;</span> <span class="c1">// bound by ref
</span><span class="c1"></span>  <span class="n">__Block_byref_strongF_3</span> <span class="o">*</span><span class="n">strongF</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">strongF</span><span class="p">;</span> <span class="c1">// bound by ref
</span><span class="c1"></span>
  <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ee0da7_mi_72</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)((</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="n">id</span><span class="p">)(</span><span class="n">weakF</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">weakF</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&#34;bar&#34;</span><span class="p">)));</span>
  <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ee0da7_mi_73</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)((</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="n">id</span><span class="p">)(</span><span class="n">strongF</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">strongF</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&#34;bar&#34;</span><span class="p">)));</span>

  <span class="p">(</span><span class="n">strongF</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">strongF</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="n">Foo_7</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="n">id</span><span class="p">)</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&#34;Foo_7&#34;</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&#34;new&#34;</span><span class="p">));</span>
  <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">,</span> <span class="kt">int</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="n">id</span><span class="p">)(</span><span class="n">strongF</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">strongF</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&#34;setBar:&#34;</span><span class="p">),</span> <span class="mi">100</span><span class="p">);</span>
  <span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ee0da7_mi_74</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)((</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="n">id</span><span class="p">)(</span><span class="n">strongF</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">strongF</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&#34;bar&#34;</span><span class="p">)));</span>
<span class="p">}</span>

<span class="c1">// 栈上的 Block 拷贝到堆时，会调用 __main_19_block_copy_0 方法
</span><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_19_block_copy_0</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_19_block_impl_0</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__main_19_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// _Block_object_assign 将对 strongF &amp; weakF 形成强引用（Retain）
</span><span class="c1"></span>    <span class="c1">// BLOCK_FIELD_IS_BYREF flag 对应为 _Block_byref_copy
</span><span class="c1"></span>    <span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">weakF</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">weakF</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);</span>
    <span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">strongF</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">strongF</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 堆上的 Block 销毁时，会调用 __main_19_block_dispose_0 方法
</span><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_19_block_dispose_0</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_19_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// _Block_object_dispose 将释放 strongF &amp; weakF （Release）
</span><span class="c1"></span>    <span class="c1">// BLOCK_FIELD_IS_BYREF flag 对应为 _Block_byref_release
</span><span class="c1"></span>    <span class="n">_Block_object_dispose</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">weakF</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);</span>
    <span class="n">_Block_object_dispose</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">strongF</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="nc">__main_19_block_desc_0</span> <span class="p">{</span>
  <span class="n">size_t</span> <span class="n">reserved</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">copy</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">__main_19_block_impl_0</span><span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">__main_19_block_impl_0</span><span class="o">*</span><span class="p">);</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dispose</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">__main_19_block_impl_0</span><span class="o">*</span><span class="p">);</span>
<span class="p">}</span> <span class="n">__main_19_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">__main_19_block_impl_0</span><span class="p">),</span> <span class="n">__main_19_block_copy_0</span><span class="p">,</span> <span class="n">__main_19_block_dispose_0</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">main_19</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">__attribute__</span><span class="p">((</span><span class="n">__blocks__</span><span class="p">(</span><span class="n">byref</span><span class="p">)))</span> <span class="n">__Block_byref_strongF_3</span> <span class="n">strongF</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,(</span><span class="n">__Block_byref_strongF_3</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">strongF</span><span class="p">,</span> <span class="mi">33554432</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_strongF_3</span><span class="p">),</span> <span class="n">__Block_byref_id_object_copy_131</span><span class="p">,</span> <span class="n">__Block_byref_id_object_dispose_131</span><span class="p">,</span> <span class="p">((</span><span class="n">Foo_7</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="n">id</span><span class="p">)((</span><span class="n">Foo_7</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="n">id</span><span class="p">)</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&#34;Foo_7&#34;</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&#34;alloc&#34;</span><span class="p">)),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&#34;init&#34;</span><span class="p">))};</span>
    <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">,</span> <span class="kt">int</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="n">id</span><span class="p">)(</span><span class="n">strongF</span><span class="p">.</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">strongF</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&#34;setBar:&#34;</span><span class="p">),</span> <span class="mi">10</span><span class="p">);</span>

    <span class="n">__attribute__</span><span class="p">((</span><span class="n">__blocks__</span><span class="p">(</span><span class="n">byref</span><span class="p">)))</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">objc_ownership</span><span class="p">(</span><span class="n">weak</span><span class="p">)))</span> <span class="n">__Block_byref_weakF_4</span> <span class="n">weakF</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,(</span><span class="n">__Block_byref_weakF_4</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">weakF</span><span class="p">,</span> <span class="mi">33554432</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_weakF_4</span><span class="p">),</span> <span class="n">__Block_byref_id_object_copy_131</span><span class="p">,</span> <span class="n">__Block_byref_id_object_dispose_131</span><span class="p">,</span> <span class="p">(</span><span class="n">strongF</span><span class="p">.</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">strongF</span><span class="p">)};</span>

    <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">block</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_19_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_19_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_19_block_desc_0_DATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_weakF_4</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">weakF</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_strongF_3</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">strongF</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">));</span>

    <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">))((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">block</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FuncPtr</span><span class="p">)((</span><span class="n">__block_impl</span> <span class="o">*</span><span class="p">)</span><span class="n">block</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>由此可以发现这与 Block 中捕获对象类型的自动变量时的内存管理类似，不同的是 <code>__block</code> 结构体指针在 Block 内部默认是强引用，因此 <code>_Block_object_assign</code> 中会进行强引用（Retain）的操作；而且 <code>_Block_object_assign</code> &amp; <code>_Block_object_dispose</code> 方法的最后一位参数的不同（对象：<code>BLOCK_FIELD_IS_OBJECT</code>，<code>__block</code>：<code>BLOCK_FIELD_IS_BYREF</code>），用来函数内部区分两者。</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">int</span> <span class="nf">main_20</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block_1</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
    <span class="p">{</span>
        <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
        <span class="c1">// 弱引用
</span><span class="c1"></span>        <span class="k">__weak</span> <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">weakArr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>

        <span class="n">block_1</span> <span class="o">=</span> <span class="o">^</span><span class="p">(){</span>
            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">weakArr</span><span class="p">);</span>
        <span class="p">};</span>

        <span class="n">block_1</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">block_1</span><span class="p">();</span>

    <span class="p">{</span>
        <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
        <span class="c1">// __block 下弱引用
</span><span class="c1"></span>        <span class="k">__block</span> <span class="k">__weak</span> <span class="n">NSMutableArray</span> <span class="o">*</span> <span class="n">weakArr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>

        <span class="n">block_1</span> <span class="o">=</span> <span class="o">^</span><span class="p">(){</span>
            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">weakArr</span><span class="p">);</span>
        <span class="p">};</span>

        <span class="n">block_1</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">block_1</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// ()
</span><span class="c1">// (null)
</span><span class="c1">// ()
</span><span class="c1">// (null)
</span></code></pre></div><p>这一例中，默认强指针引用的 <code>arr</code> 会在作用域（代码块）结束时被释放，因此 <code>__weak</code> 的弱引用指针将指向 <code>nil</code>（<code>__unsafe_unretained</code> 则不会自动清空）。代码可以正常执行，但弱引用处的对象便无法输出，即使带有 <code>__block</code>，其结构体中弱指针指向的对象也会被清空而无法输出。</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@interface</span> <span class="nc">Foo_8</span> : <span class="nc">NSObject</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo_8</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span>
<span class="p">{</span>
<span class="cp">#if !__has_feature(objc_arc)
</span><span class="cp"></span>    <span class="p">[</span><span class="nb">super</span> <span class="n">dealloc</span><span class="p">];</span>
<span class="cp">#endif
</span><span class="cp"></span>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;dealloc&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="kt">int</span> <span class="n">main_21</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="cp">#if !__has_feature(objc_arc)
</span><span class="cp"></span>    <span class="k">__block</span> <span class="n">Foo_8</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo_8</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

    <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="o">^</span><span class="p">{</span>
        <span class="c1">// 若不注释 [f release]; 一行则会崩溃
</span><span class="c1"></span>        <span class="c1">// CRASH: EXC_BAD_INSTRUCTION
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

        <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">Foo_8</span> <span class="n">new</span><span class="p">];</span>

        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">copy</span><span class="p">];</span>

    <span class="c1">// [f release]; // dealloc
</span><span class="c1"></span>
    <span class="n">block</span><span class="p">();</span>

    <span class="p">[</span><span class="n">block</span> <span class="k">release</span><span class="p">];</span>
<span class="cp">#endif
</span><span class="cp"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>MRC 下需要注意的一点是，如上代码我们可能会以为 <code>block</code> 会对外界 <code>f</code> 进行持有，进而引用计数增加，所以在 <code>block</code> 声明后对 <code>f</code> 进行 <code>release</code>，最终在 <code>block</code> 执行后对其本身 <code>release</code>，<code>f</code> 在此时释放，调用 <code>dealloc</code>。然而此时却在 <code>block</code> 执行时发生了崩溃，这是因为 MRC 下的 <code>__Block_byref_xxx</code> 对于变量并不会进行持有操作，这也可被用来破解循环引用。</p>
<!-- 这样，在 Block 内部改变变量值时，其实是更改了引用的结构体指向自身的变量值，而非直接修改值原本传递捕获的变量值。

通过 `__Block_byref` 结构体，使得多个 Block 中可以使用同一个 `__block` 变量；一个 Block 也可传入多个 `__Block_byref` 结构体的地址来使用多个 `__block` 变量。
-->
<!-- ### 细节

虽然 `__block` 将原本的自动变量封装到结构体中，但其实在使用时开发者几乎对此没有感知：

```objectivec
typedef void(^SomeBlock)(void);

struct __block_impl {
    void *isa;
    int Flags;
    int Reserved;
    void *FuncPtr;
};

static struct __main_block_desc_0 {
    size_t reserved;
    size_t Block_size;
//    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
//    void (*dispose)(struct __main_block_impl_0*);
};

// 0x000000010050ab10
struct __Block_byref_autoVar_0 {
    void *__isa; // 8
    struct __Block_byref_autoVar_0 *__forwarding; // 8
    int __flags; // 4
    int __size;  // 4
    int autoVar; // 4 // 0x000000010050ab28 => 0x000000010050ab10 + 24
};

struct __main_block_impl_0 {
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    struct __Block_byref_autoVar_0 *autoVar; // by ref
};

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // 0x00007ffeefbff4d8
        __block int autoVar = 0;
        // 0x00007ffeefbff4bc
        int autoVar2 = 0;

        SomeBlock block = ^{
            // block 中 __main_block_impl_0 结构体内部的 autoVar
            // 0x000000010050ab28
            autoVar = 10;
        };
        block();

        // 将 block 转换为 __main_block_impl_0 结构体
        struct __main_block_impl_0 *blockStruct = (__bridge struct __main_block_impl_0 *)block;

        // block 中 __main_block_impl_0 结构体内部的 autoVar
        // 0x000000010050ab28
        NSLog(@"%p", &autoVar); // 0x10050ab28
    }
}

// LLDB:
// (lldb) p &autoVar
// (int *) $0 = 0x00007ffeefbff4d8
// (lldb) p &autoVar
// (int *) $1 = 0x00000001007162b8
// (lldb) p &autoVar
// (int *) $2 = 0x000000010050ab28
// (lldb) p &(blockStruct->autoVar)
// (__Block_byref_autoVar_0 **) $3 = 0x000000010280f1d0
// (lldb) p &(blockStruct->autoVar->autoVar)
// (int *) $4 = 0x000000010050ab28
// (lldb) p 0x000000010050ab28 - 0x000000010050ab10
// (long) $5 = 24
```

```-->
<h2 id="循环引用">循环引用</h2>
<p>我们知道，Obj-C 通过引用计数来管理对象的内存，但其中的一个问题便是循环引用，即两个对象均以强引用互相指向对方，此时两个对象都将无法释放，导致内存泄漏：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">^</span><span class="n">BlockType_5</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">@interface</span> <span class="nc">Foo_9</span> : <span class="nc">NSObject</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="n">NSUInteger</span> <span class="n">bar</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="n">BlockType_5</span> <span class="n">block</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo_9</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span>
<span class="p">{</span>
<span class="cp">#if !__has_feature(objc_arc)
</span><span class="cp"></span>    <span class="p">[</span><span class="nb">super</span> <span class="n">dealloc</span><span class="p">];</span>
<span class="cp">#endif
</span><span class="cp"></span>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;dealloc&#34;</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">foo_1</span> <span class="p">{</span>
    <span class="c1">// Block 捕获了 self，其强引用了 Block，导致双方都无法释放
</span><span class="c1"></span>    <span class="nb">self</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="c1">// WARNING: Capturing &#39;self&#39; strongly in this block is likely to lead to a retain cycle
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%lu&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="nb">self</span><span class="p">.</span><span class="n">bar</span><span class="p">);</span>
        <span class="c1">// WARNING: Block implicitly retains &#39;self&#39;; explicitly mention &#39;self&#39; to indicate this is intended behavior
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%lu&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">_bar</span><span class="p">);</span> <span class="c1">// self-&gt;_bar
</span><span class="c1"></span>    <span class="p">};</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="kt">int</span> <span class="n">main_22</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="cp">#if __has_feature(objc_arc)
</span><span class="cp"></span>    <span class="n">Foo_9</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo_9</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
    <span class="n">f</span><span class="p">.</span><span class="n">bar</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

    <span class="n">f</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="c1">// Block 捕获了 f，其强引用了 Block，导致双方都无法释放
</span><span class="c1"></span>        <span class="c1">// WARNING: Capturing &#39;f&#39; strongly in this block is likely to lead to a retain cycle
</span><span class="c1"></span>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%lu&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">f</span><span class="p">.</span><span class="n">bar</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="n">f</span><span class="p">.</span><span class="n">block</span><span class="p">();</span>
    <span class="p">[</span><span class="n">f</span> <span class="n">foo_1</span><span class="p">];</span>

    <span class="c1">// Never call dealloc
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// 20
</span></code></pre></div><p><img src="/img/2019/block_in_obj-c/5.png" alt="5"></p>
<h3 id="arc">ARC</h3>
<h4 id="__weak--__unsafe_unretained">__weak &amp; __unsafe_unretained</h4>
<p>想要打破循环引用，我们需要一个不增加引用计数的指向。那么到底更改哪个引用呢？我们仍以上图为例：</p>
<ul>
<li>1⃣️ 处的强引用是我们在初始化时 <code>Foo_9 *f = [[Foo_9 alloc] init];</code> 所赋予的，栈上的 <code>f</code> 指针存储了堆上的对象的内存地址；</li>
<li>2⃣️ 处的强引用是 Block 结构体（<code>__main_22_block_impl_0</code>）对自身捕获到内部的对象的强引用，其引用是根据外界即 1⃣️ 处声明时的强弱来决定的；</li>
<li>3⃣️ 处的强引用是根据我们在 <code>Foo_9</code> 类中声明的属性修饰 <code>@property (nonatomic, copy) BlockType_5 block;</code> 所决定的。</li>
</ul>
<p>而我们需要 Block 应当随 <code>Foo_9</code> 对象销毁而销毁，如果将 3⃣️ 处改为弱引用或 <code>__unsafe_unretained</code>，则可能出现 Block 的提前释放。因此综上，我们可以将 1⃣️ 的引用改为弱引用或 <code>__unsafe_unretained</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// Foo_9
</span><span class="c1"></span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">foo_2</span> <span class="p">{</span>
    <span class="k">__weak</span> <span class="k">typeof</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="n">weakSelf</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
    <span class="nb">self</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%lu&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">weakSelf</span><span class="p">.</span><span class="n">bar</span><span class="p">);</span>

        <span class="c1">// 需要 __strong 避免编译器报错（也保证在下面使用时 self 没有被释放）
</span><span class="c1"></span>        <span class="k">__strong</span> <span class="k">typeof</span><span class="p">(</span><span class="n">weakSelf</span><span class="p">)</span> <span class="n">strongSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%lu&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">strongSelf</span><span class="o">-&gt;</span><span class="n">_bar</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main_23</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="cp">#if __has_feature(objc_arc)
</span><span class="cp"></span>    <span class="n">Foo_9</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo_9</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
    <span class="n">f</span><span class="p">.</span><span class="n">bar</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

    <span class="c1">// 也可使用 typeof() 简化类型声明
</span><span class="c1"></span>    <span class="c1">// __weak typeof(f) weakF = f;
</span><span class="c1"></span>    <span class="k">__weak</span> <span class="n">Foo_9</span> <span class="o">*</span><span class="n">weakF</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>

    <span class="c1">// __unsafe_unretained Foo_9 *unsafeUnretainedF = f;
</span><span class="c1"></span>    <span class="n">__unsafe_unretained</span> <span class="k">typeof</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="n">unsafeUnretainedF</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>

    <span class="n">f</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%lu&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">weakF</span><span class="p">.</span><span class="n">bar</span><span class="p">);</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%lu&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">unsafeUnretainedF</span><span class="p">.</span><span class="n">bar</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="n">f</span><span class="p">.</span><span class="n">block</span><span class="p">();</span>
    <span class="p">[</span><span class="n">f</span> <span class="n">foo_2</span><span class="p">];</span>
<span class="cp">#endif
</span><span class="cp"></span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// 30
</span><span class="c1">// 30
</span><span class="c1">// dealloc
</span></code></pre></div><p>而 <code>__weak</code> &amp; <code>__unsafe_unretained</code> 的区别在于前者在指向的对象销毁时，指针将自动置为 <code>nil</code>（Autoniling），而后者将保留指向的内存地址。</p>
<h4 id="__block-1">__block</h4>
<p><code>__block</code> 变量由于可以在 Block 内直接更改，因此其也可以用来解除循环引用：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">int</span> <span class="nf">main_24</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="cp">#if __has_feature(objc_arc)
</span><span class="cp"></span>    <span class="k">__block</span> <span class="n">Foo_9</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo_9</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
    <span class="n">f</span><span class="p">.</span><span class="n">bar</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

    <span class="n">f</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

        <span class="n">f</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span> <span class="c1">// 将 __Block_byref 中的 f 置为 nil，打破循环
</span><span class="c1"></span>    <span class="p">};</span>

    <span class="n">f</span><span class="p">.</span><span class="n">block</span><span class="p">();</span>

    <span class="c1">// CRASH: EXC_BAD_ACCESS
</span><span class="c1"></span>    <span class="c1">// f.block();
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// &lt;Foo_9: 0x1035005a0&gt;
</span><span class="c1">// dealloc
</span></code></pre></div><p><img src="/img/2019/block_in_obj-c/6.png" alt="6"></p>
<p>但需要注意：</p>
<ol>
<li>Block 必须执行，才可以将强引用的自动变量置为 <code>nil</code>，从而破解循环引用；</li>
<li>循环引用破解后，Block 和 <code>f</code> 均释放，因此如果后续再次执行 Block 将发生 <code>EXC_BAD_ACCESS</code> 崩溃。</li>
</ol>
<h3 id="mrc">MRC</h3>
<p>MRC 下，我们需要手动将栈上的 Block 拷贝到堆上，并在结束使用时 <code>release</code>，但循环引用出现时即使手动释放对象也无法销毁：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">int</span> <span class="nf">main_25</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="cp">#if !__has_feature(objc_arc)
</span><span class="cp"></span>    <span class="n">Foo_9</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo_9</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

    <span class="n">f</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="p">[</span><span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">copy</span><span class="p">];</span>

    <span class="n">f</span><span class="p">.</span><span class="n">block</span><span class="p">();</span>

    <span class="p">[</span><span class="n">f</span> <span class="k">release</span><span class="p">];</span> <span class="c1">// Never call dealloc
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// &lt;Foo_9: 0x1006bab90&gt;
</span></code></pre></div><p>由于 MRC 没有强弱引用的概念，因从破解循环引用只能使用 <code>__unsafe_unretained</code>，其使得 Block 内部不再会对捕获的对象持有：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">int</span> <span class="nf">main_26</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="cp">#if !__has_feature(objc_arc)
</span><span class="cp"></span>    <span class="n">__unsafe_unretained</span> <span class="n">Foo_9</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo_9</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

    <span class="n">f</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="p">[</span><span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">copy</span><span class="p">];</span>

    <span class="n">f</span><span class="p">.</span><span class="n">block</span><span class="p">();</span>

    <span class="p">[</span><span class="n">f</span> <span class="k">release</span><span class="p">];</span> <span class="c1">// Never call dealloc
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// &lt;Foo_9: 0x100507320&gt;
</span><span class="c1">// dealloc
</span></code></pre></div><p><code>__block</code> 其实也可以用来破解 MRC 下的循环引用，因为 <code>__block</code> 修饰的变量在 MRC 下，<code>__Block_byref_xxx</code> 将不会对捕获的变量持有：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="kt">int</span> <span class="nf">main_27</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="cp">#if !__has_feature(objc_arc)
</span><span class="cp"></span>    <span class="k">__block</span> <span class="n">Foo_9</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo_9</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

    <span class="n">f</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="p">[</span><span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;%@&#34;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">copy</span><span class="p">];</span>

    <span class="n">f</span><span class="p">.</span><span class="n">block</span><span class="p">();</span>

    <span class="p">[</span><span class="n">f</span> <span class="k">release</span><span class="p">];</span>
<span class="cp">#endif
</span><span class="cp"></span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// &lt;Foo_9: 0x100532c60&gt;
</span><span class="c1">// dealloc
</span></code></pre></div><h3 id="weakify--strongify">@weakify &amp; @strongify</h3>
<!-- Hook Block：http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/
Block 题（Objective-C Blocks Quiz）：https://www.cnblogs.com/xiaochaozi/p/4075581.html（http://blog.sina.com.cn/s/blog_605409770102v0dc.html）
总结：http://web.archive.org/web/20160712142025/http://rypress.com/tutorials/objective-c/blocks
https://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-1/
http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-2/
http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-3/
https://www.cnblogs.com/biosli/archive/2013/05/29/iOS_Objective-C_Block.html

LLVM block private

http://www.friday.com/bbum/2009/08/29/blocks-tips-tricks/
http://www.friday.com/bbum/2009/08/29/basic-blocks/

refer 里 so 的链接
https://yebz.fun/2018/11/01/2018-10-31/

https://www.zybuluo.com/MicroCai/note/57603

https://gist.github.com/Skifary/497ad1ee4bf7f57d8093463cfabd1c1f

https://www.jianshu.com/p/51b8a81db723 -->
<h2 id="reference">Reference</h2>
<ul>
<li>
<p><a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F">巴科斯范式 - 维基百科</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/10429857/is-it-possible-to-see-the-code-generated-by-arc-at-compile-time">Is it possible to see the code generated by ARC at compile time? - StackOverflow</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/7997666/storing-blocks-in-an-array">Storing Blocks in an Array - StackOverflow</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/23334863/should-i-still-copy-block-copy-the-blocks-under-arc/23352604">Should I still copy/Block_copy the blocks under ARC? - StackOverflow</a></p>
<!-- https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12
http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/ -->
</li>
</ul>
</div>
                    <div class="post_footer">
                        
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    <a href="https://kingcos.me/tags/focus/">Focus</a>
                                    
                                    <a href="https://kingcos.me/tags/ios/">iOS</a>
                                    
                                    <a href="https://kingcos.me/tags/obj-c/">Obj-C</a>
                                    
                                </span>
                            </div>
                        </div>
                        
                    </div>
                </div>
                <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<table style="border: 0;">
  <tr>
  <td style="border: 0; width: 30%;">
    <img width='100%' src='/img/about/1.jpg'>
  </td>
  <td style="border: 0;">
    <ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-9925978992661955"
     data-ad-slot="3213735320"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
  </td>
  </tr>
</table>

<script>
    (adsbygoogle = window.adsbygoogle || []).push({});
</script>
                
                
                <div class="doc_comments"><div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "kingcos" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div>
                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://kingcos.me">Powered by kingcos with love.</a>
    </div>

    <div class="footer_slogan">
        <span>❤️</span>
    </div>
</footer>
    <script src="https://kingcos.me/js/jquery-3.5.1.min.js"></script>
<link href="https://kingcos.me/css/fancybox.min.css" rel="stylesheet">
<script src="https://kingcos.me/js/fancybox.min.js"></script>
<script src="https://kingcos.me/js/zozo.js"></script>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</body>

</html>