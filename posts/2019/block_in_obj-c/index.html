<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>Obj-C 中的 Block :: iBlog</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Notes     2019-07-27 首次提交 -   2019-11-24 重新整理部分内容；补充《Effective Objective-C 2.0》&amp;amp;《Objective-C 高级编程》相关内容 Demo - Block_in_Obj-C    Preface 从 OS X Snow Leopard 和 iOS 4 开始，Apple 引入了 Block 的概念。Obj-C 中的 Block 即通常意义上的匿名函数，而之所以引入是因为 C 语言中并不支持匿名函数。这使得 Block 在 Obj-C 中可以称为是一类公民（First-Class Citizen），既可以作为类的属性，也可以作为函数参数或返回值来传递。那么本文就将着眼于此谈谈 Obj-C 中的 Block。
Prerequisites 匿名函数与 Block 匿名函数顾名思义，即不带名称的函数，C 语言中即使是函数指针也仍然需要通过函数名来获得其地址：
// C 语言函数 int cFunc(int arg) { return arg; } int main_1(int argc, const char * argv[]) { int result1 = cFunc(10); // C 语言中的函数指针需要通过函数名来获得其地址  int (*cFuncPtr)(int) = &amp;amp;cFunc; int result2 = (*cFuncPtr)(10); printf(&amp;#34;result1 = %d, result2 = %d\n&amp;#34;, result1, result2); return 0; } // OUTPUT: // result1 = 10, result2 = 10 Obj-C 中的匿名函数被称为 Block，中文有译作块、闭包（Closure），其实很多语言都有类似的机制，比如 Swift 中的 Closure，Java / Python / C&#43;&#43; 11 中的 Lambda（λ）表达式，JavaScript 中的匿名函数等。"/>
<meta name="keywords" content="kingcos.me,maimieng.comios,swift,objective-c,obj-c,objc,oc,geek,python,ruby,golang,go,apple,mac"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/block_in_obj-c/" />





<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Obj-C 中的 Block"/>
<meta name="twitter:description" content="从 OS X Snow Leopard 和 iOS 4 开始，Apple 引入了 Block 的概念。Obj-C 中的 Block 即通常意义上的匿名函数，而之所以引入是因为 C 语言中并不支持匿名函数。这使得 Block 在 Obj-C 中可以称为是一类公民，既可以作为类的属性，也可以作为函数参数或返回值来传递。那么本文就将着眼于此谈谈 Obj-C 中的 Block。"/>



<meta property="og:title" content="Obj-C 中的 Block" />
<meta property="og:description" content="从 OS X Snow Leopard 和 iOS 4 开始，Apple 引入了 Block 的概念。Obj-C 中的 Block 即通常意义上的匿名函数，而之所以引入是因为 C 语言中并不支持匿名函数。这使得 Block 在 Obj-C 中可以称为是一类公民，既可以作为类的属性，也可以作为函数参数或返回值来传递。那么本文就将着眼于此谈谈 Obj-C 中的 Block。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2019/block_in_obj-c/" />
<meta property="article:published_time" content="2019-11-24T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-11-24T00:00:00+00:00" /><meta property="og:site_name" content="iBlog" />






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">kingcos.me</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="post">
    <h2 class="post-title"><a href="/posts/2019/block_in_obj-c/">Obj-C 中的 Block</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            2019-11-24
        </span>
      
      
      
        <span class="post-read-time">— 21 min read</span>
      
    </div>

    
      <span class="post-tags">
        
          #<a href="/tags/focus/">Focus</a>&nbsp;
        
          #<a href="/tags/ios/">iOS</a>&nbsp;
        
          #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      <table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">2019-07-27</td>
<td align="center">首次提交</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">2019-11-24</td>
<td align="center">重新整理部分内容；补充《Effective Objective-C 2.0》&amp;《Objective-C 高级编程》相关内容</td>
<td align="center">Demo - <a href="https://github.com/kingcos/Perspective/tree/writing/Posts/Focus/block_in_obj-c/Block_in_Obj-C">Block_in_Obj-C</a></td>
</tr>
</tbody>
</table>
<p><img src="/img/2019/block_in_obj-c/0.png" alt="0"></p>
<h2 id="preface">Preface</h2>
<p>从 OS X Snow Leopard 和 iOS 4 开始，Apple 引入了 Block 的概念。Obj-C 中的 Block 即通常意义上的匿名函数，而之所以引入是因为 C 语言中并不支持匿名函数。这使得 Block 在 Obj-C 中可以称为是一类公民（First-Class Citizen），既可以作为类的属性，也可以作为函数参数或返回值来传递。那么本文就将着眼于此谈谈 Obj-C 中的 Block。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="prerequisites">Prerequisites</h2>
<h3 id="-block">匿名函数与 Block</h3>
<p>匿名函数顾名思义，即不带名称的函数，C 语言中即使是函数指针也仍然需要通过函数名来获得其地址：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// C 语言函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cFunc</span>(<span style="color:#66d9ef">int</span> arg) {
    <span style="color:#66d9ef">return</span> arg;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_1</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">int</span> result1 <span style="color:#f92672">=</span> cFunc(<span style="color:#ae81ff">10</span>);

    <span style="color:#75715e">// C 语言中的函数指针需要通过函数名来获得其地址
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>cFuncPtr)(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>cFunc;
    <span style="color:#66d9ef">int</span> result2 <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>cFuncPtr)(<span style="color:#ae81ff">10</span>);

    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">result1 = %d, result2 = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, result1, result2);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// result1 = 10, result2 = 10
</span></code></pre></div><p>Obj-C 中的匿名函数被称为 Block，中文有译作块、闭包（Closure），其实很多语言都有类似的机制，比如 Swift 中的 Closure，Java / Python / C++ 11 中的 Lambda（λ）表达式，JavaScript 中的匿名函数等。</p>
<h3 id="arc--mrc">ARC &amp; MRC</h3>
<p>Obj-C 作为使用引用计数来进行内存管理语言，虽然 ARC（Automatic Reference Counting，自动引用计数）已经引入多年，但有时仍然需要通过 MRC（Mannul Reference Counting，手动引用计数）了解更加底层的细节与区别。在 Obj-C 中我们可以使用 <code>__has_feature(objc_arc)</code> 宏来区分 ARC 和 MRC 下可以编译的代码。</p>
<p>目前 Xcode 中默认为 ARC，切换为 MRC 可以通过 Xcode - Build Settings - Automatic Reference Counting - No 来设置：</p>
<p><img src="/img/2019/block_in_obj-c/3.png" alt="3"></p>
<h2 id="what">What</h2>
<h3 id="heading">语法</h3>
<p>Obj-C 中的 Block 令人十分诟病的一个问题是其语法的繁杂。笔者也时常在 <a href="http://fuckingblocksyntax.com">fuckingblocksyntax.com</a> 查询相应的语法。</p>
<p>声明一个参数为 <code>int</code> 没有返回值的 Block：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// 省略返回值的 void
</span><span style="color:#75715e"></span><span style="color:#f92672">^</span>(<span style="color:#66d9ef">int</span> arg) {
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, arg);
};

<span style="color:#75715e">// 完整写法
</span><span style="color:#75715e"></span><span style="color:#f92672">^</span><span style="color:#66d9ef">void</span> (<span style="color:#66d9ef">int</span> arg) {
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, arg);
};
</code></pre></div><p>在语法上，与 C 语言函数不同的是：Block 没有函数名以及 <code>^</code> 记号，后者作为特殊记号将便于查找。BNF（Backus Normal Form，又 Backus-Naur Form，译作巴科斯范式，又巴科斯-诺尔范式）是一种用来描述计算机编程语言语法符号集的规范，通过这个规范在识别每一条编程语言语句时即可构建抽象语法树，进而帮助编译，未来笔者将在编译原理相关内容中深入探究。Block 声明语法的 BNF 如下：</p>
<pre><code>Block_literal_expression ::= ^ block_decl compound_statement_body
block_decl ::=
block_decl ::= parameter_list
block_decl ::= type_expression
</code></pre><p>因此通过上述 BNF 就能清晰的知道 Block 的几种声明语法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// 省略返回值 &amp; 参数
</span><span style="color:#75715e"></span><span style="color:#f92672">^</span>{ <span style="color:#75715e">/* compound_statement_body */</span> };
<span style="color:#75715e">// 省略返回值
</span><span style="color:#75715e"></span><span style="color:#f92672">^</span>(<span style="color:#66d9ef">int</span> arg){ <span style="color:#75715e">/* compound_statement_body */</span> };
<span style="color:#75715e">// 省略参数
</span><span style="color:#75715e"></span><span style="color:#f92672">^</span><span style="color:#66d9ef">int</span>{ <span style="color:#75715e">/* compound_statement_body */</span> <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; };
</code></pre></div><p>Obj-C 中的 Block 与其它类型类似，可以作为属性或者变量，也可以在函数中作为参数或者返回值。但由于 Block 的语法繁杂，我们可以用 <code>typedef</code> 定义 Block 的类型，使得 API 更加简洁明了：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">^</span>BlockType)(<span style="color:#66d9ef">int</span>);

<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo_1</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>) BlockType block;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo_1</span>
<span style="color:#75715e">// 作为对象方法参数
</span><span style="color:#75715e"></span>- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">blockAsArg_1:</span>(<span style="color:#66d9ef">int</span>(<span style="color:#f92672">^</span>)(<span style="color:#66d9ef">int</span>))block {
    block(<span style="color:#ae81ff">10</span>);
}
<span style="color:#75715e">// 使用 typedef 作为对象方法参数
</span><span style="color:#75715e"></span>- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">blockAsArg_2:</span>(BlockType)block {
    block(<span style="color:#ae81ff">10</span>);
}
<span style="color:#75715e">// 作为对象方法返回值
</span><span style="color:#75715e"></span>- (<span style="color:#66d9ef">int</span>(<span style="color:#f92672">^</span>)(<span style="color:#66d9ef">int</span>))<span style="color:#a6e22e">blockAsReturnValue_1</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">^</span>(<span style="color:#66d9ef">int</span> arg) { <span style="color:#66d9ef">return</span> arg; };
}
<span style="color:#75715e">// 使用 typedef 作为对象方法返回值
</span><span style="color:#75715e"></span>- (BlockType)<span style="color:#a6e22e">blockAsReturnValue_2</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">^</span>(<span style="color:#66d9ef">int</span> arg) { <span style="color:#66d9ef">return</span> arg; };
}
<span style="color:#66d9ef">@end</span>

<span style="color:#75715e">// Block 作为 C 语言函数参数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> blockAsArg_1(<span style="color:#66d9ef">int</span> (<span style="color:#f92672">^</span>block)(<span style="color:#66d9ef">int</span>)) {
    block(<span style="color:#ae81ff">10</span>);
}
<span style="color:#75715e">// 使用 typedef 作为 C 语言函数参数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> blockAsArg_2(BlockType block) {
    block(<span style="color:#ae81ff">10</span>);
}

<span style="color:#75715e">// 《Objective-C 高级编程》中教授的如下方法，目前会报错，且尚未找到相应的解决方法：
</span><span style="color:#75715e"></span><span style="color:#75715e">// Block pointer to non-function type is invalid
</span><span style="color:#75715e"></span><span style="color:#75715e">// Returning &#39;int (^)(int)&#39; from a function with incompatible result type &#39;int (int)&#39;
</span><span style="color:#75715e"></span><span style="color:#75715e">// int (^blockAsReturnValue()(int)) {
</span><span style="color:#75715e"></span><span style="color:#75715e">//     return ^(int arg) { return arg; };
</span><span style="color:#75715e"></span><span style="color:#75715e">// }
</span><span style="color:#75715e"></span>
BlockType blockAsReturnValue() {
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">^</span>(<span style="color:#66d9ef">int</span> arg) { <span style="color:#66d9ef">return</span> arg; };
}

<span style="color:#66d9ef">int</span> main_2(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#75715e">// 声明 Block 类型的变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">^</span>block1)(<span style="color:#66d9ef">int</span>);
    <span style="color:#75715e">// 声明并赋值 Block（省略返回值类型）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span>(<span style="color:#f92672">^</span>block2)(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>(<span style="color:#66d9ef">int</span> arg) { <span style="color:#66d9ef">return</span> arg; };
    block2 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span><span style="color:#66d9ef">int</span>(<span style="color:#66d9ef">int</span> arg) { <span style="color:#66d9ef">return</span> arg; };
    <span style="color:#75715e">// Block 类型的变量之间赋值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">^</span>block3)(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">=</span> block2;

    block1 <span style="color:#f92672">=</span> block2;

    <span style="color:#75715e">// 使用 typedef
</span><span style="color:#75715e"></span>    BlockType block4;
    BlockType block5 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>(<span style="color:#66d9ef">int</span> arg) { <span style="color:#66d9ef">return</span> arg; };
    block5 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span><span style="color:#66d9ef">int</span>(<span style="color:#66d9ef">int</span> arg) { <span style="color:#66d9ef">return</span> arg; };
    BlockType block6 <span style="color:#f92672">=</span> block5;
    block4 <span style="color:#f92672">=</span> block5;

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="heading1">结构</h3>
<p>在 <code>main</code> 函数中声明并执行一个简单的 Block：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_3</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">^</span>block)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">Hello, World!</span><span style="color:#e6db74">&#34;</span>);
    };

    block();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// Hello, World!
</span></code></pre></div><p>为了窥探 Block 的结构，可以尝试使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</code> 命令将以上代码翻译为 C/C++ 代码来分析：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// Block 实现的结构体
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> {
  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>isa;     <span style="color:#75715e">// isa 指针，即 Block 也是 id 类型，即 Obj-C 对象
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> Flags;     <span style="color:#75715e">// 标记，默认会被初始化为 0
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> Reserved;  <span style="color:#75715e">// 保留域（ABI 兼容），默认 0
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>FuncPtr; <span style="color:#75715e">// Block 代码块的函数指针
</span><span style="color:#75715e"></span>};
<span style="color:#75715e">// ➡️ Block 结构体
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_3_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;           <span style="color:#75715e">// 实现（非指针）
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_3_block_desc_0</span><span style="color:#f92672">*</span> Desc; <span style="color:#75715e">// 描述信息（指针）
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 构造函数
</span><span style="color:#75715e"></span>  __main_3_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_3_block_desc_0</span> <span style="color:#f92672">*</span>desc, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock; <span style="color:#75715e">// Block 作为 Obj-C 对象，那么 isa 将指向其类对象，即 _NSConcreteStackBlock
</span><span style="color:#75715e"></span>    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};

<span style="color:#75715e">// Block 内代码块封装在该 C 语言静态函数中，函数命名规则：__CALLER_METHOD_NAME_block_func_NUMBER
</span><span style="color:#75715e"></span><span style="color:#75715e">// 类似 Obj-C 实例方法参数 self 或 C++ 实例方法参数 this，__cself 为指向 Block 结构体的变量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_3_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_3_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {

        NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_b9596e_mi_0);
    }

<span style="color:#75715e">// Block 描述信息的结构体
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_3_block_desc_0</span> {
  size_t reserved;   <span style="color:#75715e">// 保留域，默认 0
</span><span style="color:#75715e"></span>  size_t Block_size; <span style="color:#75715e">// Block 大小，sizeof 整个 Block 结构体 ⬇️
</span><span style="color:#75715e"></span>} __main_3_block_desc_0_DATA <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_3_block_impl_0</span>)};

<span style="color:#75715e">// 主函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_3</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#75715e">// 通过 __main_3_block_impl_0 结构体的构造函数初始化，参数为静态函数和描述信息结构体的地址，将地址存储在 block 变量中
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 忽略类型转换：block = &amp;__main_3_block_impl_0(__main_3_block_func_0, &amp;__main_3_block_desc_0_DATA));
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>block)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__main_3_block_impl_0((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__main_3_block_func_0, <span style="color:#f92672">&amp;</span>__main_3_block_desc_0_DATA));

    <span style="color:#75715e">// 执行 Block（参数 block 即静态函数中的参数 __cself）
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 忽略类型转换：block-&gt;FuncPtr(block);
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 在 __main_block_impl_0 结构体中，impl 是第一个变量，因此其与结构体本身的首地址一致，因此可以强转
</span><span style="color:#75715e"></span>    ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(__block_impl <span style="color:#f92672">*</span>))((__block_impl <span style="color:#f92672">*</span>)block)<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>FuncPtr)((__block_impl <span style="color:#f92672">*</span>)block);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>当声明一个 Block，其中的代码块会被封装到 <code>__main_3_block_func_0</code> 静态函数中（后缀 <code>0</code> 代表序号，后同），用来和 Block 描述信息 <code>__main_3_block_desc_0_DATA</code> 的地址一起构造 Block 结构体 <code>__main_3_block_impl_0</code>；并在其构造函数中将代码块封装的函数指针赋值给 <code>FuncPtr</code>，描述信息以引用方式保存在 <code>desc</code> 指针中；最终在 Block 真正执行时，通过 <code>block-&gt;FuncPtr(block)</code> 找静态函数去调用。</p>
<p>所以 Obj-C 的 Block 即是 <code>__main_3_block_impl_0</code> 结构体。该结构体中又直接包含了含有实现相关 <code>__block_impl</code> 结构体，以及含有描述信息指向 <code>__main_3_block_desc_0</code> 结构体的指针。在 <code>__block_impl</code> 结构体中，<code>isa</code> 的存在印证了 Block 的本质其实也是属于 Obj-C 中的对象，而 <code>FuncPtr</code> 函数指针则指向封装好的静态函数：</p>
<p><img src="/img/2019/block_in_obj-c/1.png" alt="1"></p>
<blockquote>
<p>注：由于上图原始文件丢失，为保证和上文源码对照，特此说明：上图中 <code>__main_block_impl_0</code> 为上文中的 <code>__main_3_block_impl_0</code>，<code>__main_block_desc_0</code> 为上文中的 <code>__main_3_block_desc_0</code>，<code>__main_block_func_0</code> 为上文中的 <code>__main_3_block_func_0</code>。</p>
</blockquote>
<h2 id="heading2">变量捕获</h2>
<h3 id="heading3">自动变量</h3>
<p>自动变量（Automatic Variable）即局部作用域变量，指在代码块中声明的变量，存储在内存的栈区，离开作用域时栈区内存会被自动回收，也可以显式使用 <code>auto</code> 关键字声明：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_7</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">kingcos.me</span><span style="color:#e6db74">&#34;</span>;

    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>() {
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">a == %d, b == %s</span><span style="color:#e6db74">&#34;</span>, a, b);
    };

    block();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// a == 1, b == kingcos.me
</span></code></pre></div><p>由于 Block 可以被代码块外声明的变量持有，因此自动变量的生命周期可能早于 Block 本身结束。所以 Block 会将其内部使用到的自动变量捕获到结构体内部（按值传递），这样即使在 Block 声明后更改了原有的变量值或者自动变量的生命周期提前结束，也不会影响 Block 中已经被捕获的那个变量：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_7_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_7_block_desc_0</span><span style="color:#f92672">*</span> Desc;
  <span style="color:#66d9ef">int</span> a;         <span style="color:#75715e">// 捕获的自动变量 a
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>b; <span style="color:#75715e">// 注意捕获的变量类型与外界声明完全相同
</span><span style="color:#75715e"></span>  __main_7_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_7_block_desc_0</span> <span style="color:#f92672">*</span>desc, <span style="color:#66d9ef">int</span> _a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>_b, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> a(_a), b(_b) { <span style="color:#75715e">// 构造函数保存外部自动变量
</span><span style="color:#75715e"></span>    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_7_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_7_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {
  <span style="color:#75715e">// 从 __celf 取初始化时获得的值
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>a; <span style="color:#75715e">// bound by copy
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>b; <span style="color:#75715e">// bound by copy
</span><span style="color:#75715e"></span>
        NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_605531_mi_3, a, b);
    }

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_7_block_desc_0</span> {
  size_t reserved;
  size_t Block_size;
} __main_7_block_desc_0_DATA <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_7_block_impl_0</span>)};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_7</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">kingcos.me</span><span style="color:#e6db74">&#34;</span>;

    <span style="color:#75715e">// 忽略类型转换：block = &amp;__main_7_block_impl_0(__main_7_block_func_0, &amp;__main_7_block_desc_0_DATA, a, b));
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>block)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__main_7_block_impl_0((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__main_7_block_func_0, <span style="color:#f92672">&amp;</span>__main_7_block_desc_0_DATA, a, b));

    <span style="color:#75715e">// 忽略类型转换：block-&gt;FuncPtr(block);
</span><span style="color:#75715e"></span>    ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(__block_impl <span style="color:#f92672">*</span>))((__block_impl <span style="color:#f92672">*</span>)block)<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>FuncPtr)((__block_impl <span style="color:#f92672">*</span>)block);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Obj-C 中方法的两个默认参数 <code>self</code> 和 <code>_cmd</code> 的作用域仅在函数体内，因此 Block 内如果使用到 <code>self</code> 则也会对其进行捕获：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// - (void)objectFunc
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_I_A_objectFunc</span>(A <span style="color:#f92672">*</span> self, SEL _cmd) {
    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>block)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__A__objectFunc_block_impl_0((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__A__objectFunc_block_func_0, <span style="color:#f92672">&amp;</span>__A__objectFunc_block_desc_0_DATA, self, <span style="color:#ae81ff">570425344</span>));

    ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(__block_impl <span style="color:#f92672">*</span>))((__block_impl <span style="color:#f92672">*</span>)block)<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>FuncPtr)((__block_impl <span style="color:#f92672">*</span>)block);
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__A__block_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__A__block_block_desc_0</span><span style="color:#f92672">*</span> Desc;
  A <span style="color:#f92672">*</span>self; <span style="color:#75715e">// ⚠️ 捕获的 self
</span><span style="color:#75715e"></span>  __A__block_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__A__block_block_desc_0</span> <span style="color:#f92672">*</span>desc, A <span style="color:#f92672">*</span>_self, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> self(_self) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__A__block_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__A__block_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {
  A <span style="color:#f92672">*</span>self <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>self; <span style="color:#75715e">// bound by copy
</span><span style="color:#75715e"></span>
        NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_A_2e834a_mi_0, self);
    }
</code></pre></div><p>而如果 Block 中引入了成员变量，本质其实是通过 <code>self</code> 进行访问的，因此同理也会对 <code>self</code> 本身进行捕获：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__A__objectFunc_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__A__objectFunc_block_desc_0</span><span style="color:#f92672">*</span> Desc;
  A <span style="color:#f92672">*</span>self; <span style="color:#75715e">// ⚠️ 捕获的 self
</span><span style="color:#75715e"></span>  __A__objectFunc_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__A__objectFunc_block_desc_0</span> <span style="color:#f92672">*</span>desc, A <span style="color:#f92672">*</span>_self, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> self(_self) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__A__objectFunc_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__A__objectFunc_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {
  A <span style="color:#f92672">*</span>self <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>self; <span style="color:#75715e">// bound by copy
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">// self + OBJC_IVAR_$_A$_memVar：成员变量是根据 self 做的偏移
</span><span style="color:#75715e"></span>        NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_A_f4faca_mi_0, (<span style="color:#f92672">*</span>(NSString <span style="color:#f92672">*</span><span style="color:#f92672">*</span>)((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)self <span style="color:#f92672">+</span> OBJC_IVAR_<span style="color:#960050;background-color:#1e0010">$</span>_A<span style="color:#960050;background-color:#1e0010">$</span>_memVar)));
    }
</code></pre></div><h3 id="heading4">局部静态变量</h3>
<p>局部静态变量指定义在代码块内的静态变量，其作用域是在代码块内，但其生命周期并不会随代码块结束：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_8</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>() {
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">a == %d</span><span style="color:#e6db74">&#34;</span>, a);
    };

    a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

    block();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// a == 10
</span></code></pre></div><p>由于静态局部变量的生命周期随程序退出才结束，Block 只需要将局部静态变量的<strong>地址</strong>进行捕获即可（按引用传递）。这样即使超过静态局部变量的作用域但 Block 中仍然可以通过地址访问到，且当 Block 执行前如果改变了局部静态变量的值，那么执行时也将根据地址获取到最新值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_8_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_8_block_desc_0</span><span style="color:#f92672">*</span> Desc;
  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a; <span style="color:#75715e">// 捕获的变量，类型为指向 int 类型的指针
</span><span style="color:#75715e"></span>  __main_8_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_8_block_desc_0</span> <span style="color:#f92672">*</span>desc, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>_a, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> a(_a) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_8_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_8_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {
  <span style="color:#75715e">// int *a = &amp;a;（外界 a 的地址）
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>a; <span style="color:#75715e">// bound by copy
</span><span style="color:#75715e"></span>
        NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_0fafd0_mi_4, (<span style="color:#f92672">*</span>a));
    }

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_8_block_desc_0</span> {
  size_t reserved;
  size_t Block_size;
} __main_8_block_desc_0_DATA <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_8_block_impl_0</span>)};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_8</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#75715e">// 忽略类型转换：block = &amp;__main_8_block_impl_0(__main_8_block_func_0, &amp;__main_8_block_desc_0_DATA, &amp;a);（&amp;a 即 a 的地址作为参数传入）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>block)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__main_8_block_impl_0((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__main_8_block_func_0, <span style="color:#f92672">&amp;</span>__main_8_block_desc_0_DATA, <span style="color:#f92672">&amp;</span>a));

    <span style="color:#75715e">// a 的值发生改变
</span><span style="color:#75715e"></span>    a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

    ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(__block_impl <span style="color:#f92672">*</span>))((__block_impl <span style="color:#f92672">*</span>)block)<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>FuncPtr)((__block_impl <span style="color:#f92672">*</span>)block);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="heading5">全局变量</h3>
<p>全局变量即定义在所有函数体外的变量，只有当程序退出时其生命周期才结束：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// main.m
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 全局变量：
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">@autoreleasepool</span> {
        <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>() {
            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">a == %d, b == %d</span><span style="color:#e6db74">&#34;</span>, a, b);
        };

        a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
        b <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;

        block();
    }
}

<span style="color:#75715e">// OUTOUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// a == 10, b == 20
</span></code></pre></div><p>因此对于全局变量，Block 并不会去捕获，而是在使用时直接进行读取即可：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_desc_0</span><span style="color:#f92672">*</span> Desc;
  __main_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_desc_0</span> <span style="color:#f92672">*</span>desc, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {

            NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_437bca_mi_0, a, b);
        }
</code></pre></div><h3 id="c-">C 语言数组</h3>
<p>当 Block 遇到 C 语言中的数组时，其并不会去捕获，而可以使用指针取代。实际上这在 C 语言的函数中也是不支持的，猜测这是因为 Block 遵循了类似 C 语言的规范：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cFunc_2</span>(<span style="color:#66d9ef">char</span> a[<span style="color:#ae81ff">10</span>]) {
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, a[<span style="color:#ae81ff">0</span>]);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cFunc_3</span>(<span style="color:#66d9ef">char</span> a[<span style="color:#ae81ff">10</span>]) {
    <span style="color:#75715e">// C 语言不允许数组类型变量赋值给另外的数组类型变量
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// ERROR: Array initializer must be an initializer list or string literal
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// char b[10] = a;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// printf(&#34;%d\n&#34;, b[0]);
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_6</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> cLocalArr[] <span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">kingcos.me</span><span style="color:#e6db74">&#34;</span>;
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cLocalString <span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">kingcos.me</span><span style="color:#e6db74">&#34;</span>;

    <span style="color:#f92672">^</span>{
        <span style="color:#75715e">// Block 不会对 C 语言数组进行捕获，而可以使用指针
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// ERROR: Cannot refer to declaration with an array type inside block
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// printf(&#34;%c\n&#34;, cLocalArr[7]);
</span><span style="color:#75715e"></span>
        printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%c</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, cLocalString[<span style="color:#ae81ff">7</span>]);
    }();

    <span style="color:#75715e">// Block 遵循了类似 C 语言的规范
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> a[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">2</span>};

    cFunc_2(a);
    cFunc_3(a);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// .
</span><span style="color:#75715e"></span><span style="color:#75715e">// 2
</span></code></pre></div><h2 id="heading6">类型</h2>
<p>Obj-C 中的 Block 根据其存储在不同的内存区域被分为三种：<code>__NSGlobalBlock__</code>、<code>__NSStackBlock__</code>、<code>__NSMallocBlock__</code>，它们又各自继承自 <code>__NSGlobalBlock</code>、<code>__NSMallocBlock</code>、<code>__NSStackBlock</code>，这些父类又都继承自 <code>NSBlock</code>，<code>NSBlock</code> 又继承自 <code>NSObject</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block1)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>() {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">Hello, world!</span><span style="color:#e6db74">&#34;</span>);
};

<span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block2)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>() {
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, a);
};

NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@ %@ %@</span><span style="color:#e6db74">&#34;</span>, [block1 <span style="color:#66d9ef">class</span>], [block2 <span style="color:#66d9ef">class</span>], [<span style="color:#f92672">^</span>{
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, a);
} <span style="color:#66d9ef">class</span>]);

NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@ %@ %@</span><span style="color:#e6db74">&#34;</span>, [block1 superclass], [block2 superclass],[<span style="color:#f92672">^</span>{
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, a);
} superclass]);

NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@ %@ %@</span><span style="color:#e6db74">&#34;</span>, [[block1 superclass] superclass], [[block2 superclass] superclass],[[<span style="color:#f92672">^</span>{
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, a);
} superclass] superclass]);

NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@ %@ %@</span><span style="color:#e6db74">&#34;</span>, [[[block1 superclass] superclass] superclass], [[[block2 superclass] superclass] superclass],[[[<span style="color:#f92672">^</span>{
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, a);
} superclass] superclass] superclass]);

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// __NSGlobalBlock__ __NSMallocBlock__ __NSStackBlock__
</span><span style="color:#75715e"></span><span style="color:#75715e">// __NSGlobalBlock __NSMallocBlock __NSStackBlock
</span><span style="color:#75715e"></span><span style="color:#75715e">// NSBlock NSBlock NSBlock
</span><span style="color:#75715e"></span><span style="color:#75715e">// NSObject NSObject NSObject
</span></code></pre></div><blockquote>
<p>⚠️</p>
<p>在上一节中，我们可以从翻译的 C++ 代码中看到 Block 内部的 <code>isa</code> 指针指向了 <code>&amp;_NSConcreteStackBlock</code>，但其实在 Xcode 中运行时并不存在「翻译」这一步骤，因此我们最好使用运行时的方法来真正确定 Block 的具体类型。</p>
</blockquote>
<h3 id="nsglobalblock"><code>__NSGlobalBlock__</code></h3>
<p>内部没有访问外界<strong>自动变量</strong>的 Block 均属于 <code>__NSGlobalBlock__</code>，其存储在内存的数据区（Data 段），该区域通常也会存放全局变量：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// main.m
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">@autoreleasepool</span> {
        <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>gloablBlock)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
            <span style="color:#75715e">// 没有访问任何外界变量
</span><span style="color:#75715e"></span>            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">This is a __NSGlobalBlock__.</span><span style="color:#e6db74">&#34;</span>);
        };

        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, [gloablBlock <span style="color:#66d9ef">class</span>]);

        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

        gloablBlock <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
            <span style="color:#75715e">// 访问了全局变量或局部静态变量
</span><span style="color:#75715e"></span>            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">a == %d, b == %d.</span><span style="color:#e6db74">&#34;</span>, a, b);
        };

        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, [gloablBlock <span style="color:#66d9ef">class</span>]);
    }
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// __NSGlobalBlock__
</span><span style="color:#75715e"></span><span style="color:#75715e">// __NSGlobalBlock__
</span></code></pre></div><p>对 <code>__NSGlobalBlock__</code> 类型的 Block 执行 <code>copy</code> 操作仍将返回 <code>__NSGlobalBlock__</code>。</p>
<h3 id="nsstackblock"><code>__NSStackBlock__</code></h3>
<h4 id="what1">What</h4>
<p>自动变量存储在内存的栈区，当 Block 内访问了外界的自动变量时会对其进行捕获，此时 Block 本身也被分配在栈区，即为 <code>__NSStackBlock__</code> 类型：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

<span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>stackBlock)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">c == %d.</span><span style="color:#e6db74">&#34;</span>, c);
};

NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, [stackBlock <span style="color:#66d9ef">class</span>]);
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">//  __NSStackBlock__
</span></code></pre></div><p>栈区的内存不需要开发者手动管理，当作用域结束时栈区内存将会被自动回收。所以即使 <code>__NSStackBlock__</code> 类型的 Block 内部捕获了自动变量，但 Block 本身和捕获的变量也仍然存储在栈区，会随着其作用域结束而释放：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// main.m
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Person</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Person</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">dealloc</span>
{
<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    [super dealloc];
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">dealloc</span><span style="color:#e6db74">&#34;</span>);
}
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>stackBlock1)(<span style="color:#66d9ef">void</span>);
<span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>stackBlock2)(<span style="color:#66d9ef">void</span>);

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">initBlock</span>() {
<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

    stackBlock1 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">c == %d</span><span style="color:#e6db74">&#34;</span>, c);
    };

    <span style="color:#75715e">// -----
</span><span style="color:#75715e"></span>
    Person <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> [[Person alloc] init];

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%ld</span><span style="color:#e6db74">&#34;</span>, [p retainCount]);

    stackBlock2 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
       NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">p == %@</span><span style="color:#e6db74">&#34;</span>, p);
    };

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%ld</span><span style="color:#e6db74">&#34;</span>, [p retainCount]);

    [p <span style="color:#66d9ef">release</span>];
<span style="color:#75715e">#</span><span style="color:#75715e">else</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    Person <span style="color:#f92672">*</span>strongP <span style="color:#f92672">=</span> [[Person alloc] init];

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%ld</span><span style="color:#e6db74">&#34;</span>, CFGetRetainCount((<span style="color:#66d9ef">__bridge</span> CFTypeRef)(strongP)));

    <span style="color:#66d9ef">__weak</span> Person <span style="color:#f92672">*</span>weakP <span style="color:#f92672">=</span> strongP;

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%ld</span><span style="color:#e6db74">&#34;</span>, CFGetRetainCount((<span style="color:#66d9ef">__bridge</span> CFTypeRef)(strongP)));

    <span style="color:#75715e">// __NSStackBlock__
</span><span style="color:#75715e"></span>    <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, strongP);
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, weakP);
    };

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%ld</span><span style="color:#e6db74">&#34;</span>, CFGetRetainCount((<span style="color:#66d9ef">__bridge</span> CFTypeRef)(strongP)));
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">@autoreleasepool</span> {
        <span style="color:#75715e">// 初始化 stackBlock
</span><span style="color:#75715e"></span>        initBlock();
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">---</span><span style="color:#e6db74">&#34;</span>);
<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 执行 stackBlock1
</span><span style="color:#75715e"></span>        stackBlock1(); <span style="color:#75715e">// c == -272632744
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 执行 stackBlock2
</span><span style="color:#75715e"></span>        stackBlock2(); <span style="color:#75715e">// CRASH: objc[59614]: Attempt to use unknown class 0x7ffeefbff428.
</span><span style="color:#75715e"></span>
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">stackBlock is a %@.</span><span style="color:#e6db74">&#34;</span>, [stackBlock1 <span style="color:#66d9ef">class</span>]); <span style="color:#75715e">// CRASH: EXC_BAD_ACCESS
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    }
}

<span style="color:#75715e">// MRC OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// 1
</span><span style="color:#75715e"></span><span style="color:#75715e">// 1
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span><span style="color:#75715e"></span><span style="color:#75715e">// ---
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// ARC OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// 1
</span><span style="color:#75715e"></span><span style="color:#75715e">// 1
</span><span style="color:#75715e"></span><span style="color:#75715e">// 2
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span><span style="color:#75715e"></span><span style="color:#75715e">// ---
</span></code></pre></div><p>MRC 下，<code>__NSStackBlock__</code> 类型的 Block 捕获对象类型的自动变量但并不会改变其引用计数，即不会进行 <code>retain</code> 持有操作。而 <code>main</code> 函数中的执行到 Block 时自动变量 <code>c</code> 和 <code>p</code> 其实已经被释放，因此访问时出现了脏数据，访问 Block 本身也出现了 <code>EXC_BAD_ACCESS</code> 崩溃。为了避免这种问题，我们需要将其分配在堆上（即 <code>__NSMallocBlock__</code>），这是因为堆区的内存由开发者自己管理，可以避免被自动回收。</p>
<p>ARC 下，<code>__NSStackBlock__</code> 类型的 Block 中捕获了 <code>strongP</code> 和 <code>weakP</code>（可以通过为翻译 Obj-C 代码的命令额外添加 <code>-fobjc-arc -fobjc-runtime=ios-13.0.0</code> 参数强制使用 ARC 并指定运行时平台和版本，这样即可输出带有部分运行时关键字的 C/C++ 代码，如下），虽然强引用会导致其引用计数增加，但 Block 本身仍会随作用域超出而销毁，而自动变量也会被销毁。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__initBlock_block_impl_0</span> {
  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>  Person <span style="color:#f92672">*</span>__strong strongP; <span style="color:#75715e">// ⚠️ 强引用
</span><span style="color:#75715e"></span>  Person <span style="color:#f92672">*</span>__weak weakP;     <span style="color:#75715e">// ⚠️ 弱引用
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>};
</code></pre></div><h3 id="nsmallocblock"><code>__NSMallocBlock__</code></h3>
<h4 id="what2">What</h4>
<p><code>__NSMallocBlock__</code> 类型的 Block 存储在内存的堆区，堆区是通常用作动态分配（Malloc）的内存。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// main.m
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Person</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Person</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">dealloc</span>
{
<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    [super dealloc];
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">dealloc</span><span style="color:#e6db74">&#34;</span>);
}
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">void</span>(<span style="color:#f92672">^</span>SomeBlock)(<span style="color:#66d9ef">void</span>);

<span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>mallocBlock1)(<span style="color:#66d9ef">void</span>);
<span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>mallocBlock2)(<span style="color:#66d9ef">void</span>);

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">initBlock</span>() {
<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

    mallocBlock1 <span style="color:#f92672">=</span> [<span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">c == %d</span><span style="color:#e6db74">&#34;</span>, c);
    } <span style="color:#66d9ef">copy</span>];

    <span style="color:#75715e">// ---
</span><span style="color:#75715e"></span>
    Person <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> [[Person alloc] init];

    mallocBlock2 <span style="color:#f92672">=</span> [<span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, p);
    } <span style="color:#66d9ef">copy</span>];

    [p <span style="color:#66d9ef">release</span>];
<span style="color:#75715e">#</span><span style="color:#75715e">else</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

    mallocBlock1 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">c == %d</span><span style="color:#e6db74">&#34;</span>, c);
    };

    <span style="color:#75715e">// ---
</span><span style="color:#75715e"></span>
    Person <span style="color:#f92672">*</span>strongP <span style="color:#f92672">=</span> [[Person alloc] init];
    <span style="color:#66d9ef">__weak</span> Person <span style="color:#f92672">*</span>weakP <span style="color:#f92672">=</span> strongP;

    <span style="color:#75715e">// 1⃣️ ARC 下强指针 mallocBlock2 指向的 Block 会被自动拷贝为 __NSMallocBlock__
</span><span style="color:#75715e"></span>    mallocBlock2 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, strongP);
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, weakP);
    };

    <span style="color:#75715e">// 使用弱引用指针指向的 Block，将仍然是 __NSStackBlock__，编译将提示以下警告
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// WARNING: Assigning block literal to a weak variable; object will be released after assignment
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">__weak</span> SomeBlock weakStackBlock <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, strongP);
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, weakP);
    };

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">weakStackBlock is %@</span><span style="color:#e6db74">&#34;</span>, weakStackBlock);

    <span style="color:#75715e">// 3⃣️ Block 作为 Cocoa API 中方法名含有 `usingBlock` 的参数时会被自动拷贝为 __NSMallocBlock__（较难证明）
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 4⃣️ Block 作为 GCD API 参数时会被自动拷贝为 __NSMallocBlock__（较难证明）
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>}

SomeBlock <span style="color:#a6e22e">returnMallocBlock</span>() {
    <span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">int</span> autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// MRC 下如果直接返回 Block，将报错「Returning block that lives on the local stack」
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 即编译器已经发现返回的 Block 是在栈上，一旦函数体走完，Block 就会被销毁，因此在 MRC 下需要手动 copy：
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> [<span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, autoVar);
    } <span style="color:#66d9ef">copy</span>];
<span style="color:#75715e">#</span><span style="color:#75715e">else</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 2⃣️ ARC 下 Block 作为函数返回值会被自动拷贝为 __NSMallocBlock__
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, autoVar);
    };
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">@autoreleasepool</span> {
        initBlock();

        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">mallocBlock1 is %@</span><span style="color:#e6db74">&#34;</span>, [mallocBlock1 <span style="color:#66d9ef">class</span>]);
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">mallocBlock2 is %@</span><span style="color:#e6db74">&#34;</span>, [mallocBlock2 <span style="color:#66d9ef">class</span>]);
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">returnMallocBlock() is %@</span><span style="color:#e6db74">&#34;</span>, [returnMallocBlock() <span style="color:#66d9ef">class</span>]);

        mallocBlock1();
        mallocBlock2();

<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>        [mallocBlock1 <span style="color:#66d9ef">release</span>];
        [mallocBlock2 <span style="color:#66d9ef">release</span>];
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    }
}

<span style="color:#75715e">// MRC OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// mallocBlock1 is __NSMallocBlock__
</span><span style="color:#75715e"></span><span style="color:#75715e">// mallocBlock2 is __NSMallocBlock__
</span><span style="color:#75715e"></span><span style="color:#75715e">// returnMallocBlock() is __NSMallocBlock__
</span><span style="color:#75715e"></span><span style="color:#75715e">// c == 10
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;Person: 0x102a08970&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// ARC OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// weakStackBlock is &lt;__NSStackBlock__: 0x7ffeefbff3d0&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// mallocBlock1 is __NSMallocBlock__
</span><span style="color:#75715e"></span><span style="color:#75715e">// mallocBlock2 is __NSMallocBlock__
</span><span style="color:#75715e"></span><span style="color:#75715e">// returnMallocBlock() is __NSMallocBlock__
</span><span style="color:#75715e"></span><span style="color:#75715e">// c == 10
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;Person: 0x1007712c0&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;Person: 0x1007712c0&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// ⚠️：此处 mallocBlock1 &amp; mallocBlock2 全局变量还没有释放，因而持有的 strongP 也没有被释放
</span></code></pre></div><ul>
<li>MRC 下，对于 <code>__NSStackBlock__</code> 类型的 Block，我们只要再对执行 <code>copy</code> 操作即可从栈区拷贝到堆区。堆区内存由我们来负责管理，Block 和其中捕获的自动变量均在堆区，在我们主动释放前，均可以访问到；</li>
<li>ARC 下，编译器会根据情况将 <code>__NSStackBlock__</code> 类型的 Block 自动 <code>copy</code> 到堆上：
<ol>
<li>强指针指向的 Block 会被自动拷贝；</li>
<li>Block 作为函数返回值会被自动拷贝；</li>
<li>Block 作为 Cocoa API 中方法名含有 <code>usingBlock</code> 的参数时会被自动拷贝（较难证明）；</li>
<li>Block 作为 GCD API 参数时会被自动拷贝（较难证明）。</li>
</ol>
</li>
</ul>
<!-- raw HTML omitted -->
<p>因此，Block 作为属性时应当使用 <code>copy</code> 或 <code>strong</code> 修饰：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">// MRC
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">copy</span>) <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block1)(<span style="color:#66d9ef">void</span>);
<span style="color:#75715e">#</span><span style="color:#75715e">else</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">// ARC
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">copy</span>) <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block2)(<span style="color:#66d9ef">void</span>);
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>) <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block3)(<span style="color:#66d9ef">void</span>);
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span></code></pre></div><h4 id="nsstackblock-"><code>__NSStackBlock__</code> 拷贝到堆上的细节</h4>
<p>ARC 下，当 <code>__NSStackBlock__</code> 被强指针指向时会被拷贝到堆上，那么在「拷贝」时会发生什么呢？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">SomeBlock block;
{
    Person <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> [[Person alloc] init];
    p.age <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;

    <span style="color:#66d9ef">__weak</span> Person <span style="color:#f92672">*</span>weakP <span style="color:#f92672">=</span> p;

    <span style="color:#75715e">// __NSMallocBlock__
</span><span style="color:#75715e"></span>    block <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)p.age);
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)weakP.age);
    };
};
NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">---</span><span style="color:#e6db74">&#34;</span>);

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// ---
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span></code></pre></div><p>我们将以上代码使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -fobjc-arc -fobjc-runtime=ios-8.0.0 -o main.cpp</code> 翻译为 C/C++ 代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_desc_0</span><span style="color:#f92672">*</span> Desc;
  <span style="color:#75715e">// 默认强引用
</span><span style="color:#75715e"></span>  Person <span style="color:#f92672">*</span>__strong p;
  <span style="color:#75715e">// 显式弱引用
</span><span style="color:#75715e"></span>  Person <span style="color:#f92672">*</span>__weak weakP;
  __main_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_desc_0</span> <span style="color:#f92672">*</span>desc, Person <span style="color:#f92672">*</span>__strong _p, Person <span style="color:#f92672">*</span>__weak _weakP, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> p(_p), weakP(_weakP) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {
  Person <span style="color:#f92672">*</span>__strong p <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>p; <span style="color:#75715e">// bound by copy
</span><span style="color:#75715e"></span>  Person <span style="color:#f92672">*</span>__weak weakP <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>weakP; <span style="color:#75715e">// bound by copy
</span><span style="color:#75715e"></span>
        NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_38be7e_mi_1, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)((NSUInteger (<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)p, sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">age</span><span style="color:#e6db74">&#34;</span>)));
        NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_38be7e_mi_2, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)((NSUInteger (<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)weakP, sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">age</span><span style="color:#e6db74">&#34;</span>)));
    }

<span style="color:#75715e">// 栈上的 Block 拷贝到堆时，会调用 __main_block_copy_0 方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_block_copy_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span><span style="color:#f92672">*</span>dst, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span><span style="color:#f92672">*</span>src) {
    <span style="color:#75715e">// _Block_object_assign 函数会根据自动变量的修饰符（如上 Person *__strong p;）作出相应的操作，形成强引用或弱引用（类似 Retain）：
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 对外界 p 强引用，对外界 weakP 弱引用
</span><span style="color:#75715e"></span>    _Block_object_assign((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>dst<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>p, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>p, <span style="color:#ae81ff">3</span><span style="color:#75715e">/*BLOCK_FIELD_IS_OBJECT*/</span>);
    _Block_object_assign((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>dst<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>weakP, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>weakP, <span style="color:#ae81ff">3</span><span style="color:#75715e">/*BLOCK_FIELD_IS_OBJECT*/</span>);
    }

<span style="color:#75715e">// 栈上的 Block 销毁时
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_block_dispose_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span><span style="color:#f92672">*</span>src) {
    <span style="color:#75715e">// _Block_object_dispose 函数使得自动变量的引用计数减一（类似 Release）
</span><span style="color:#75715e"></span>    _Block_object_dispose((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>p, <span style="color:#ae81ff">3</span><span style="color:#75715e">/*BLOCK_FIELD_IS_OBJECT*/</span>);
    _Block_object_dispose((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>weakP, <span style="color:#ae81ff">3</span><span style="color:#75715e">/*BLOCK_FIELD_IS_OBJECT*/</span>);
    }

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_desc_0</span> {
  size_t reserved;
  size_t Block_size;
  <span style="color:#75715e">// 当在 Block 中访问对象类型时会增加额外的域来管理内存
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>copy)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span><span style="color:#f92672">*</span>);
  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>dispose)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span><span style="color:#f92672">*</span>);
} __main_block_desc_0_DATA <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span>), __main_block_copy_0, __main_block_dispose_0};
</code></pre></div><h2 id="block"><code>__block</code></h2>
<h3 id="heading7">本质</h3>
<p>上面的 Demo 中 Block 内部只是访问了外界的变量，接下来我们尝试下在 Block 内修改变量值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// 静态全局变量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> staticGlobalVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#75715e">// 全局变量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> globalVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_4</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#75715e">// 自动变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#75715e">// 静态变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> staticVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">auto</span> NSMutableArray <span style="color:#f92672">*</span>autoArray <span style="color:#f92672">=</span> [[NSMutableArray alloc] init];

    <span style="color:#f92672">^</span>{
        <span style="color:#75715e">// ERROR: Variable is not assignable (missing __block type specifier)
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// autoVar = 10;
</span><span style="color:#75715e"></span>
        staticVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
        staticGlobalVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
        globalVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

        [autoArray addObject:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">kingcos.me</span><span style="color:#e6db74">&#34;</span>];

        <span style="color:#75715e">// ERROR: Variable is not assignable (missing __block type specifier)
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// autoArray = [[NSMutableArray alloc] init];
</span><span style="color:#75715e"></span>    }();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>对于静态局部变量和全局静态变量，Block 内可以直接修改这些变量的值。而对于自动变量编译器则会报错 <code>Variable is not assignable (missing __block type specifier)</code>（变量未分配（丢失 <code>__block</code> 类型限定符）），那么这里的 <code>__block</code> 是什么呢？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_5</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">__block</span> <span style="color:#66d9ef">int</span> autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">__block</span> <span style="color:#66d9ef">auto</span> NSMutableArray <span style="color:#f92672">*</span>autoArray <span style="color:#f92672">=</span> [[NSMutableArray alloc] init];

    <span style="color:#75715e">// 使用 __block 修饰的自动变量，在 Block 内部确实可以修改
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">^</span>block1)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
        autoArray <span style="color:#f92672">=</span> [[NSMutableArray alloc] init];
    };

    block1();

    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">^</span>block2)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
    };

    block2();

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">autoVar = %d</span><span style="color:#e6db74">&#34;</span>, autoVar);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// autoVar = 20
</span></code></pre></div><p>我们尝试将以上代码翻译为 C++：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 将自动变量包装的结构体
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Block_byref_autoVar_0</span> {
  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>__isa; <span style="color:#75715e">// 标志着这是个 Obj-C 对象
</span><span style="color:#75715e"></span>__Block_byref_autoVar_0 <span style="color:#f92672">*</span>__forwarding; <span style="color:#75715e">// 结构体本身的地址
</span><span style="color:#75715e"></span> <span style="color:#66d9ef">int</span> __flags; <span style="color:#75715e">// 标志位
</span><span style="color:#75715e"></span> <span style="color:#66d9ef">int</span> __size; <span style="color:#75715e">// sizeof 结构体的大小
</span><span style="color:#75715e"></span> <span style="color:#66d9ef">int</span> autoVar; <span style="color:#75715e">// 自动变量，由初始化赋值
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Block_byref_autoArray_1</span> {
  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>__isa;
__Block_byref_autoArray_1 <span style="color:#f92672">*</span>__forwarding;
 <span style="color:#66d9ef">int</span> __flags;
 <span style="color:#66d9ef">int</span> __size;
 <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>__Block_byref_id_object_copy)(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>); <span style="color:#75715e">// 内存管理方法
</span><span style="color:#75715e"></span> <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>__Block_byref_id_object_dispose)(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>);     <span style="color:#75715e">// 内存管理方法
</span><span style="color:#75715e"></span>  NSMutableArray <span style="color:#f92672">*</span>__strong autoArray; <span style="color:#75715e">// 自动变量
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_desc_0</span><span style="color:#f92672">*</span> Desc;
  <span style="color:#75715e">// 不使用 __block 时为 int autoVar;
</span><span style="color:#75715e"></span>  __Block_byref_autoVar_0 <span style="color:#f92672">*</span>autoVar; <span style="color:#75715e">// by ref
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 不使用 __block 时为 NSMutableArray *autoArray;
</span><span style="color:#75715e"></span>  __Block_byref_autoArray_1 <span style="color:#f92672">*</span>autoArray; <span style="color:#75715e">// by ref
</span><span style="color:#75715e"></span>  __main_5_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_desc_0</span> <span style="color:#f92672">*</span>desc, __Block_byref_autoVar_0 <span style="color:#f92672">*</span>_autoVar, __Block_byref_autoArray_1 <span style="color:#f92672">*</span>_autoArray, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> autoVar(_autoVar<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding), autoArray(_autoArray<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_5_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {
  <span style="color:#75715e">// 指向结构体的指针
</span><span style="color:#75715e"></span>  __Block_byref_autoVar_0 <span style="color:#f92672">*</span>autoVar <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar; <span style="color:#75715e">// bound by ref
</span><span style="color:#75715e"></span>  __Block_byref_autoArray_1 <span style="color:#f92672">*</span>autoArray <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoArray; <span style="color:#75715e">// bound by ref
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">// 通过指向自身的指针改变了值
</span><span style="color:#75715e"></span>        (autoVar<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar) <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
        (autoArray<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoArray) <span style="color:#f92672">=</span> ((NSMutableArray <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)((NSMutableArray <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)objc_getClass(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">NSMutableArray</span><span style="color:#e6db74">&#34;</span>), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">alloc</span><span style="color:#e6db74">&#34;</span>)), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">init</span><span style="color:#e6db74">&#34;</span>));
    }
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_5_block_copy_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_0</span><span style="color:#f92672">*</span>dst, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_0</span><span style="color:#f92672">*</span>src) {_Block_object_assign((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>dst<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);_Block_object_assign((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>dst<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoArray, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoArray, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_5_block_dispose_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_0</span><span style="color:#f92672">*</span>src) {_Block_object_dispose((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);_Block_object_dispose((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoArray, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_desc_0</span> {
  size_t reserved;
  size_t Block_size;
  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>copy)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_0</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_0</span><span style="color:#f92672">*</span>);
  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>dispose)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_0</span><span style="color:#f92672">*</span>);
} __main_5_block_desc_0_DATA <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_0</span>), __main_5_block_copy_0, __main_5_block_dispose_0};

<span style="color:#75715e">// 第二个 Block
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_1</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_desc_1</span><span style="color:#f92672">*</span> Desc;
  __Block_byref_autoVar_0 <span style="color:#f92672">*</span>autoVar; <span style="color:#75715e">// by ref
</span><span style="color:#75715e"></span>  __main_5_block_impl_1(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_desc_1</span> <span style="color:#f92672">*</span>desc, __Block_byref_autoVar_0 <span style="color:#f92672">*</span>_autoVar, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> autoVar(_autoVar<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_5_block_func_1</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_1</span> <span style="color:#f92672">*</span>__cself) {
  __Block_byref_autoVar_0 <span style="color:#f92672">*</span>autoVar <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar; <span style="color:#75715e">// bound by ref
</span><span style="color:#75715e"></span>
        (autoVar<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar) <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
    }
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_5_block_copy_1</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_1</span><span style="color:#f92672">*</span>dst, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_1</span><span style="color:#f92672">*</span>src) {_Block_object_assign((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>dst<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_5_block_dispose_1</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_1</span><span style="color:#f92672">*</span>src) {_Block_object_dispose((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_desc_1</span> {
  size_t reserved;
  size_t Block_size;
  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>copy)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_1</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_1</span><span style="color:#f92672">*</span>);
  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>dispose)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_1</span><span style="color:#f92672">*</span>);
} __main_5_block_desc_1_DATA <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_1</span>), __main_5_block_copy_1, __main_5_block_dispose_1};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_5</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#75715e">// 初始化 __Block_byref_autoVar_0 结构体，将 autoVar 的地址赋值给结构体中的 __forwarding 指针
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// __Block_byref_autoVar_0 autoVar = {0, &amp;autoVar, 0, sizeof(__Block_byref_autoVar_0), 0（初始值）}
</span><span style="color:#75715e"></span>    __attribute__((__blocks__(byref))) __Block_byref_autoVar_0 autoVar <span style="color:#f92672">=</span> {(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#ae81ff">0</span>,(__Block_byref_autoVar_0 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>autoVar, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(__Block_byref_autoVar_0), <span style="color:#ae81ff">0</span>};

    <span style="color:#75715e">// 初始化 __Block_byref_autoArray_1 结构体，将 autoArray 的地址赋值给结构体中的 __forwarding 指针
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// __Block_byref_autoArray_1 autoArray = {0, &amp;autoArray, 33554432, sizeof(__Block_byref_autoArray_1), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, NSMutableArray（初始值）}
</span><span style="color:#75715e"></span>    __attribute__((__blocks__(byref))) <span style="color:#66d9ef">auto</span> __Block_byref_autoArray_1 autoArray <span style="color:#f92672">=</span> {(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#ae81ff">0</span>,(__Block_byref_autoArray_1 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>autoArray, <span style="color:#ae81ff">33554432</span>, <span style="color:#66d9ef">sizeof</span>(__Block_byref_autoArray_1), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSMutableArray <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)((NSMutableArray <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)objc_getClass(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">NSMutableArray</span><span style="color:#e6db74">&#34;</span>), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">alloc</span><span style="color:#e6db74">&#34;</span>)), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">init</span><span style="color:#e6db74">&#34;</span>))};

    <span style="color:#75715e">// 忽略类型转换：block1 = &amp;__main_5_block_impl_0(__main_5_block_func_0, &amp;__main_5_block_desc_0_DATA, &amp;autoVar, &amp;autoArray, 570425344);
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>block1)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__main_5_block_impl_0((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__main_5_block_func_0, <span style="color:#f92672">&amp;</span>__main_5_block_desc_0_DATA, (__Block_byref_autoVar_0 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>autoVar, (__Block_byref_autoArray_1 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>autoArray, <span style="color:#ae81ff">570425344</span>));

    ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(__block_impl <span style="color:#f92672">*</span>))((__block_impl <span style="color:#f92672">*</span>)block1)<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>FuncPtr)((__block_impl <span style="color:#f92672">*</span>)block1);

    <span style="color:#75715e">// 忽略类型转换：block2 = &amp;__main_5_block_impl_1(__main_5_block_func_1, &amp;__main_5_block_desc_1_DATA, &amp;autoVar, 570425344);
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>block2)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__main_5_block_impl_1((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__main_5_block_func_1, <span style="color:#f92672">&amp;</span>__main_5_block_desc_1_DATA, (__Block_byref_autoVar_0 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>autoVar, <span style="color:#ae81ff">570425344</span>));

    ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(__block_impl <span style="color:#f92672">*</span>))((__block_impl <span style="color:#f92672">*</span>)block2)<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>FuncPtr)((__block_impl <span style="color:#f92672">*</span>)block2);

    <span style="color:#75715e">// 外界通过 __forwarding 访问
</span><span style="color:#75715e"></span>    NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_77b1f8_mi_2, (autoVar.__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar));

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><code>__block</code> 将原本要捕获的变量 <code>autoVar</code> 封装为 <code>__Block_byref_autoVar_0</code> 结构体，其中 <code>isa</code> 指针标志其本质是个 Obj-C 对象；<code>__forwarding</code> 指向了该结构体本身，在初始化时被赋值为声明的结构体的地址；<code>__size</code> 为该结构体的大小；<code>autoVar</code> 为捕获的变量本身。这样，在 Block 内部改变变量值时，其实是更改了引用的结构体指向自身的变量值，而非直接修改值原本传递捕获的变量值。因此捕获了 <code>__block</code> 变量的 Block 结构如下图所示：</p>
<p><img src="/img/2019/block_in_obj-c/4.png" alt="4"></p>
<p>通过 <code>__Block_byref</code> 结构体，使得多个 Block 中可以使用同一个 <code>__block</code> 变量；一个 Block 也可传入多个 <code>__Block_byref</code> 结构体的地址来使用多个 <code>__block</code> 变量。</p>
<h3 id="heading8">细节</h3>
<p>虽然 <code>__block</code> 将原本的自动变量封装到结构体中，但其实在使用时开发者几乎对此没有感知：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">void</span>(<span style="color:#f92672">^</span>SomeBlock)(<span style="color:#66d9ef">void</span>);

<span style="color:#66d9ef">struct</span> __block_impl {
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>isa;
    <span style="color:#66d9ef">int</span> Flags;
    <span style="color:#66d9ef">int</span> Reserved;
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>FuncPtr;
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> __main_block_desc_0 {
    size_t reserved;
    size_t Block_size;
<span style="color:#75715e">//    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
</span><span style="color:#75715e"></span><span style="color:#75715e">//    void (*dispose)(struct __main_block_impl_0*);
</span><span style="color:#75715e"></span>};

<span style="color:#75715e">// 0x000000010050ab10
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> __Block_byref_autoVar_0 {
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>__isa; <span style="color:#75715e">// 8
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> __Block_byref_autoVar_0 <span style="color:#f92672">*</span>__forwarding; <span style="color:#75715e">// 8
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> __flags; <span style="color:#75715e">// 4
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> __size;  <span style="color:#75715e">// 4
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> autoVar; <span style="color:#75715e">// 4 // 0x000000010050ab28 =&gt; 0x000000010050ab10 + 24
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">struct</span> __main_block_impl_0 {
    <span style="color:#66d9ef">struct</span> __block_impl impl;
    <span style="color:#66d9ef">struct</span> __main_block_desc_0<span style="color:#f92672">*</span> Desc;
    <span style="color:#66d9ef">struct</span> __Block_byref_autoVar_0 <span style="color:#f92672">*</span>autoVar; <span style="color:#75715e">// by ref
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">@autoreleasepool</span> {
        <span style="color:#75715e">// 0x00007ffeefbff4d8
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">__block</span> <span style="color:#66d9ef">int</span> autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#75715e">// 0x00007ffeefbff4bc
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> autoVar2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

        SomeBlock block <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
            <span style="color:#75715e">// block 中 __main_block_impl_0 结构体内部的 autoVar
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 0x000000010050ab28
</span><span style="color:#75715e"></span>            autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
        };
        block();

        <span style="color:#75715e">// 将 block 转换为 __main_block_impl_0 结构体
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">struct</span> __main_block_impl_0 <span style="color:#f92672">*</span>blockStruct <span style="color:#f92672">=</span> (<span style="color:#66d9ef">__bridge</span> <span style="color:#66d9ef">struct</span> __main_block_impl_0 <span style="color:#f92672">*</span>)block;

        <span style="color:#75715e">// block 中 __main_block_impl_0 结构体内部的 autoVar
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 0x000000010050ab28
</span><span style="color:#75715e"></span>        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%p</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>autoVar); <span style="color:#75715e">// 0x10050ab28
</span><span style="color:#75715e"></span>    }
}

<span style="color:#75715e">// LLDB:
</span><span style="color:#75715e"></span><span style="color:#75715e">// (lldb) p &amp;autoVar
</span><span style="color:#75715e"></span><span style="color:#75715e">// (int *) $0 = 0x00007ffeefbff4d8
</span><span style="color:#75715e"></span><span style="color:#75715e">// (lldb) p &amp;autoVar
</span><span style="color:#75715e"></span><span style="color:#75715e">// (int *) $1 = 0x00000001007162b8
</span><span style="color:#75715e"></span><span style="color:#75715e">// (lldb) p &amp;autoVar
</span><span style="color:#75715e"></span><span style="color:#75715e">// (int *) $2 = 0x000000010050ab28
</span><span style="color:#75715e"></span><span style="color:#75715e">// (lldb) p &amp;(blockStruct-&gt;autoVar)
</span><span style="color:#75715e"></span><span style="color:#75715e">// (__Block_byref_autoVar_0 **) $3 = 0x000000010280f1d0
</span><span style="color:#75715e"></span><span style="color:#75715e">// (lldb) p &amp;(blockStruct-&gt;autoVar-&gt;autoVar)
</span><span style="color:#75715e"></span><span style="color:#75715e">// (int *) $4 = 0x000000010050ab28
</span><span style="color:#75715e"></span><span style="color:#75715e">// (lldb) p 0x000000010050ab28 - 0x000000010050ab10
</span><span style="color:#75715e"></span><span style="color:#75715e">// (long) $5 = 24
</span></code></pre></div><h3 id="heading9">内存管理</h3>
<p>由于 <code>__block</code> 使得 Block 捕获的基础类型自动变量被封装到结构体（Obj-C 对象）中，那么内存管理便必不可少：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span> {
  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>  __Block_byref_foo_0 <span style="color:#f92672">*</span>foo; <span style="color:#75715e">// by ref
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>};

<span style="color:#75715e">// Block 被 copy 到堆上时调用 __main_block_copy_0 将 foo 拷贝到堆上
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_block_copy_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span><span style="color:#f92672">*</span>dst, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span><span style="color:#f92672">*</span>src) {
    <span style="color:#75715e">// _Block_object_assign 将对 foo 形成强引用（Retain）
</span><span style="color:#75715e"></span>    _Block_object_assign((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>dst<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>foo, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>foo, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);
}

<span style="color:#75715e">// Block 从堆上移除时调用 __main_block_dispose_0 将 foo 从堆上移除
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_block_dispose_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span><span style="color:#f92672">*</span>src) {
    <span style="color:#75715e">// _Block_object_dispose 将释放 foo（Release）
</span><span style="color:#75715e"></span>    _Block_object_dispose((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>foo, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_desc_0</span> {
  size_t reserved;
  size_t Block_size;
  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>copy)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span><span style="color:#f92672">*</span>);
  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>dispose)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span><span style="color:#f92672">*</span>);
} __main_block_desc_0_DATA <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span>), __main_block_copy_0, __main_block_dispose_0};
</code></pre></div><p>我们可以发现这与 Block 中捕获对象类型的自动变量时的内存管理类似，不同的是 <code>__block</code> 默认即是强引用，因此 <code>_Block_object_assign</code> 中会进行强引用（Retain）的操作，且 <code>_Block_object_assign</code> &amp; <code>_Block_object_dispose</code> 方法的最后一位参数的不同（对象：<code>BLOCK_FIELD_IS_OBJECT</code>，<code>__block</code>：<code>BLOCK_FIELD_IS_BYREF</code>）。</p>
<h3 id="forwarding"><code>__forwarding</code></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_block_func_0</span>(<span style="color:#66d9ef">struct</span> __main_block_impl_0 <span style="color:#f92672">*</span>__cself) {
  <span style="color:#75715e">// autoVar 为结构体指针
</span><span style="color:#75715e"></span>  __Block_byref_autoVar_0 <span style="color:#f92672">*</span>autoVar <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar; <span style="color:#75715e">// bound by ref
</span><span style="color:#75715e"></span>
            <span style="color:#75715e">// 通过指向自身的指针改变了 autoVar 的值
</span><span style="color:#75715e"></span>            (autoVar<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar) <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
        }
</code></pre></div><p>在 <code>__Block_byref_xxx</code> 结构体仍在栈上时，<code>foo-&gt;__forwarding-&gt;foo</code> 就等同于直接 <code>foo-&gt;foo</code> 来访问，因为此时 <code>__forwarding</code> 就指向自己；而当复制到堆上时，<code>__forwarding</code> 将指向堆上的结构体，保证后续的数据变动是在堆上。</p>
<h3 id="heading10">对象类型</h3>
<p>那么当 <code>__block</code> 遇上对象类型的自动变量呢？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Person</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">assign</span>) NSUInteger age;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Person</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">dealloc</span>
{
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">dealloc</span><span style="color:#e6db74">&#34;</span>);
}
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">void</span>(<span style="color:#f92672">^</span>SomeBlock)(<span style="color:#66d9ef">void</span>);

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">@autoreleasepool</span> {
        <span style="color:#66d9ef">__block</span> Person <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> [[Person alloc] init];
        p.age <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;

        <span style="color:#66d9ef">__block</span> <span style="color:#66d9ef">__weak</span> Person <span style="color:#f92672">*</span>weakP <span style="color:#f92672">=</span> p;

        SomeBlock block <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)weakP.age); <span style="color:#75715e">// 20
</span><span style="color:#75715e"></span>
            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)p.age); <span style="color:#75715e">// 20
</span><span style="color:#75715e"></span>            p <span style="color:#f92672">=</span> [Person new];
            p.age <span style="color:#f92672">=</span> <span style="color:#ae81ff">18</span>;
            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)p.age); <span style="color:#75715e">// 18
</span><span style="color:#75715e"></span>        };

        block();
    }
}
</code></pre></div><p>我们尝试将以上代码翻译为 C/C++：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Block_byref_p_0</span> {
  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>__isa; <span style="color:#75715e">// 8
</span><span style="color:#75715e"></span>__Block_byref_p_0 <span style="color:#f92672">*</span>__forwarding; <span style="color:#75715e">// 8
</span><span style="color:#75715e"></span> <span style="color:#66d9ef">int</span> __flags; <span style="color:#75715e">// 4
</span><span style="color:#75715e"></span> <span style="color:#66d9ef">int</span> __size; <span style="color:#75715e">// 4
</span><span style="color:#75715e"></span> <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>__Block_byref_id_object_copy)(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>); <span style="color:#75715e">// 8
</span><span style="color:#75715e"></span> <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>__Block_byref_id_object_dispose)(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>); <span style="color:#75715e">// 8
</span><span style="color:#75715e"></span> <span style="color:#75715e">// __strong 根据外界强或弱
</span><span style="color:#75715e"></span> Person <span style="color:#f92672">*</span>__strong p;
};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Block_byref_weakP_1</span> {
 <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span> Person <span style="color:#f92672">*</span>__weak weakP;
};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span> {
  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// __Block_byref 为强指针，不受外界改变
</span><span style="color:#75715e"></span>  __Block_byref_weakP_1 <span style="color:#f92672">*</span>weakP; <span style="color:#75715e">// by ref
</span><span style="color:#75715e"></span>  __Block_byref_p_0 <span style="color:#f92672">*</span>p; <span style="color:#75715e">// by ref
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_desc_0</span> {
  size_t reserved;
  size_t Block_size;
  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>copy)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span><span style="color:#f92672">*</span>);
  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>dispose)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span><span style="color:#f92672">*</span>);
} __main_block_desc_0_DATA <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span>), __main_block_copy_0, __main_block_dispose_0};

<span style="color:#75715e">// Block 被 copy 到堆上时调用 __main_block_copy_0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_block_copy_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span><span style="color:#f92672">*</span>dst, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span><span style="color:#f92672">*</span>src) {
    <span style="color:#75715e">// 1⃣️ 将 __Block_byref_weakP_1 *weakP &amp; __Block_byref_p_0 *p 强引用
</span><span style="color:#75715e"></span>    _Block_object_assign((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>dst<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>weakP, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>weakP, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);
    _Block_object_assign((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>dst<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>p, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>p, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);
}

<span style="color:#75715e">// Block 要从堆上移除时调用 __main_block_dispose_0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_block_dispose_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_block_impl_0</span><span style="color:#f92672">*</span>src) {
    <span style="color:#75715e">// 3⃣️ 将 __Block_byref_weakP_1 *weakP &amp; __Block_byref_p_0 *p 释放
</span><span style="color:#75715e"></span>    _Block_object_dispose((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>weakP, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);
    _Block_object_dispose((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>p, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#75715e">/* @autoreleasepool */</span> { __AtAutoreleasePool __autoreleasepool;
        __attribute__((__blocks__(byref))) __Block_byref_p_0 p <span style="color:#f92672">=</span> {(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#ae81ff">0</span>,(__Block_byref_p_0 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>p, <span style="color:#ae81ff">33554432</span>, <span style="color:#66d9ef">sizeof</span>(__Block_byref_p_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((Person <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)((Person <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)objc_getClass(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Person</span><span style="color:#e6db74">&#34;</span>), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">alloc</span><span style="color:#e6db74">&#34;</span>)), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">init</span><span style="color:#e6db74">&#34;</span>))};
        ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(id, SEL, NSUInteger))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)(p.__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>p), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">setAge:</span><span style="color:#e6db74">&#34;</span>), (NSUInteger)<span style="color:#ae81ff">20</span>);

        __attribute__((__blocks__(byref))) __attribute__((objc_ownership(weak))) __Block_byref_weakP_1 weakP <span style="color:#f92672">=</span> {(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#ae81ff">0</span>,(__Block_byref_weakP_1 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>weakP, <span style="color:#ae81ff">33554432</span>, <span style="color:#66d9ef">sizeof</span>(__Block_byref_weakP_1), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, (p.__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>p)};

        SomeBlock block <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__main_block_impl_0((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__main_block_func_0, <span style="color:#f92672">&amp;</span>__main_block_desc_0_DATA, (__Block_byref_weakP_1 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>weakP, (__Block_byref_p_0 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>p, <span style="color:#ae81ff">570425344</span>));

        ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(__block_impl <span style="color:#f92672">*</span>))((__block_impl <span style="color:#f92672">*</span>)block)<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>FuncPtr)((__block_impl <span style="color:#f92672">*</span>)block);
    }
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__Block_byref_id_object_copy_131</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>dst, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>src) {
 <span style="color:#75715e">// 2⃣️ 根据外界对 p / weakP 的强弱引用产生强弱引用（+ 40 即 Person *__strong p; / Person *__weak weakP;）
</span><span style="color:#75715e"></span> _Block_object_assign((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)dst <span style="color:#f92672">+</span> <span style="color:#ae81ff">40</span>, <span style="color:#f92672">*</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> <span style="color:#f92672">*</span>) ((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)src <span style="color:#f92672">+</span> <span style="color:#ae81ff">40</span>), <span style="color:#ae81ff">131</span>);
}
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__Block_byref_id_object_dispose_131</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>src) {
 <span style="color:#75715e">// 4⃣️ 释放
</span><span style="color:#75715e"></span> _Block_object_dispose(<span style="color:#f92672">*</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span> <span style="color:#f92672">*</span>) ((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)src <span style="color:#f92672">+</span> <span style="color:#ae81ff">40</span>), <span style="color:#ae81ff">131</span>);
}
</code></pre></div><p>需要注意的是，MRC 下的 <code>__Block_byref_xxx</code> 对于变量将不会进行持有操作，这也可被用来破解循环引用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">@autoreleasepool</span> {
        <span style="color:#66d9ef">__block</span> Person <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> [[Person alloc] init];
        p.age <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;

        SomeBlock block <span style="color:#f92672">=</span> [<span style="color:#f92672">^</span>{
            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)p.age); <span style="color:#75715e">// 20
</span><span style="color:#75715e"></span>            p <span style="color:#f92672">=</span> [Person new];
            p.age <span style="color:#f92672">=</span> <span style="color:#ae81ff">18</span>;
            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)p.age); <span style="color:#75715e">// 18
</span><span style="color:#75715e"></span>        } <span style="color:#66d9ef">copy</span>];

        <span style="color:#75715e">// 正常来说 Block 如果对 p 进行了强引用，引用计数加一，即使调用一次 release 也不应当 dealloc
</span><span style="color:#75715e"></span>        [p <span style="color:#66d9ef">release</span>]; <span style="color:#75715e">// dealloc
</span><span style="color:#75715e"></span>
        block();

        [block <span style="color:#66d9ef">release</span>];
    }
}
</code></pre></div><h2 id="heading11">循环引用</h2>
<p>我们知道，Obj-C 是根据引用计数来管理对象的内存的，但其中的一个问题便是循环引用，即两个对象以强引用互相指向对方，引用计数无法减少，对象无法释放，导致内存泄漏：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">void</span>(<span style="color:#f92672">^</span>SomeBlock)(<span style="color:#66d9ef">void</span>);

<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Person</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">assign</span>) NSUInteger age;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">copy</span>) SomeBlock block;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Person</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">dealloc</span>
{
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">dealloc</span><span style="color:#e6db74">&#34;</span>);
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">foo</span> {
    <span style="color:#75715e">// Block 捕获了 self，其强引用了 Block，导致双方都无法释放
</span><span style="color:#75715e"></span>    self.block <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)self.age);
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)_age); <span style="color:#75715e">// self-&gt;_age
</span><span style="color:#75715e"></span>    };
}
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">int</span> main(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">@autoreleasepool</span> {
        Person <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> [[Person alloc] init];
        p.age <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;

        p.block <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
            <span style="color:#75715e">// Block 捕获了 p，其强引用了 Block，导致双方都无法释放
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// WARNING: Capturing &#39;p&#39; strongly in this block is likely to lead to a retain cycle
</span><span style="color:#75715e"></span>            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)p.age);
        };

        p.block();
        [p foo];

        <span style="color:#75715e">// Never dealloc
</span><span style="color:#75715e"></span>    }
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// 20
</span></code></pre></div><p><img src="/img/2019/block_in_obj-c/5.png" alt="5"></p>
<h3 id="arc">ARC</h3>
<h4 id="weak--unsafeunretained"><code>__weak</code> &amp; <code>__unsafe_unretained</code></h4>
<p>想要打破循环引用，我们需要一个不增加引用计数的指向。那么到底更改哪个引用呢？我们仍以上图为例：</p>
<ul>
<li>1⃣️ 处的强引用是我们在初始化时 <code>Person *p = [[Person alloc] init];</code> 所赋予的，栈上的 <code>p</code> 指针存储了堆上的对象的内存地址；</li>
<li>2⃣️ 处的强引用是 Block 结构体（<code>__main_block_impl_0</code>）对自身捕获到内部的对象的强引用，其引用是根据外界即 1⃣️ 处声明时的强弱来决定的；</li>
<li>3⃣️ 处的强引用是根据我们在 <code>Person</code> 类中声明的属性修饰 <code>@property (nonatomic, copy) SomeBlock block;</code> 所决定的。</li>
</ul>
<p>而我们需要 Block 应当随 <code>Person</code> 对象销毁而销毁，如果将 3⃣️ 处改为弱引用或 <code>__unsafe_unretained</code>，则可能出现 Block 的提前释放。因此综上，我们可以将 1⃣️ 的引用改为弱引用或 <code>__unsafe_unretained</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// Person.m
</span><span style="color:#75715e"></span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">foo</span> {
    <span style="color:#66d9ef">__weak</span> <span style="color:#66d9ef">typeof</span>(self) weakSelf <span style="color:#f92672">=</span> self;
    self.block <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)weakSelf.age);

        <span style="color:#75715e">// 需要 __strong 避免编译器报错（也保证在下面使用时 self 没有被释放）
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">__strong</span> <span style="color:#66d9ef">typeof</span>(weakSelf) strongSelf <span style="color:#f92672">=</span> weakSelf;
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)strongSelf<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>_age);
    };
}

<span style="color:#75715e">// main.m
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">@autoreleasepool</span> {
        Person <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> [[Person alloc] init];
        p.age <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;

        <span style="color:#75715e">// 也可使用 typeof() 简化类型声明
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// __weak typeof(p) weakP = p;
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">__weak</span> Person <span style="color:#f92672">*</span>weakP <span style="color:#f92672">=</span> p;

        <span style="color:#75715e">// __unsafe_unretained Person *unsafeUnretainedP = p;
</span><span style="color:#75715e"></span>        __unsafe_unretained <span style="color:#66d9ef">typeof</span>(p) unsafeUnretainedP <span style="color:#f92672">=</span> p;

        p.block <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)weakP.age);
            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)unsafeUnretainedP.age);
        };

        p.block();
        [p foo];
    }
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// 20
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span></code></pre></div><p>而 <code>__weak</code> &amp; <code>__unsafe_unretained</code> 的区别在于前者在指向的对象销毁时，指针将自动置为 <code>nil</code>（Autoniling），而后者将保留指向的内存地址。</p>
<h4 id="block1"><code>__block</code></h4>
<p><code>__block</code> 的变量由于可以在 Block 内修改，因此其也可以用来解除循环引用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">__block</span> Person <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> [[Person alloc] init];

p.block <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, p);

    p <span style="color:#f92672">=</span> nil; <span style="color:#75715e">// 将 __Block_byref_p_0 中的 p 置为 nil，打破循环
</span><span style="color:#75715e"></span>};

p.block();

p.block(); <span style="color:#75715e">// CRASH: EXC_BAD_ACCESS
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;Person: 0x1007b9070&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span></code></pre></div><p><img src="/img/2019/block_in_obj-c/6.png" alt="6"></p>
<p>但需要注意：</p>
<ol>
<li>Block 必须执行，才可以将强引用的自动变量置为 <code>nil</code>，从而破解循环引用；</li>
<li>循环引用破解后，Block 和 <code>p</code> 均释放，因此如果后续再次执行 Block 将出现 <code>EXC_BAD_ACCESS</code> 崩溃。</li>
</ol>
<h3 id="mrc">MRC</h3>
<p>MRC 下，我们需要手动将栈上的 Block 复制到堆上，并在结束使用时 <code>release</code>，但循环引用出现时即使手动释放对象也无法销毁：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">Person <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> [[Person alloc] init];

p.block <span style="color:#f92672">=</span> [<span style="color:#f92672">^</span>{
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, p);
} <span style="color:#66d9ef">copy</span>];

p.block();

[p <span style="color:#66d9ef">release</span>]; <span style="color:#75715e">// But never dealloc
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;Person: 0x1007b8f70&gt;
</span></code></pre></div><p>由于 MRC 没有强弱引用的概念，因从破解循环引用只能使用 <code>__unsafe_unretained</code>，其使得 Block 内部不再会对捕获的对象持有：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">__unsafe_unretained Person <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> [[Person alloc] init];

p.block <span style="color:#f92672">=</span> [<span style="color:#f92672">^</span>{
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, p);
} <span style="color:#66d9ef">copy</span>];

p.block();

[p <span style="color:#66d9ef">release</span>];

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;Person: 0x1007a8290&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span></code></pre></div><p><code>__block</code> 其实也可以用来破解 MRC 下的循环引用，因为 <code>__block</code> 修饰的变量在 MRC 下，<code>__Block_byref_xxx</code> 将不会对捕获的变量持有：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">__block</span> Person <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> [[Person alloc] init];

p.block <span style="color:#f92672">=</span> [<span style="color:#f92672">^</span>{
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, p);
} <span style="color:#66d9ef">copy</span>];

p.block();

[p <span style="color:#66d9ef">release</span>];

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;Person: 0x100747970&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span></code></pre></div><h3 id="weakify--strongify"><code>@weakify</code> &amp; <code>@strongify</code></h3>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F">巴科斯范式 - 维基百科</a></li>
</ul>

    </div>
    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>
        <div class="pagination__buttons">
          
          
            <span class="button next">
              <a href="/posts/2019/effective_obj-c_2.0_notes/">
                <span class="button__text">《编写高质量 iOS 与 OS X 代码的 52 个有效方法》阅读笔记</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    

    

    
    
    <div>
      <div id="github-comment">
      </div>

      <script type="text/javascript">
        function getUtterances(isDark) {
          var utterances = document.createElement('script');
          utterances.type = 'text/javascript';
          utterances.async = true;
          utterances.setAttribute('issue-term', "pathname")
          utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
          utterances.setAttribute('label', "comments")
          isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
          utterances.crossorigin = 'anonymous';
          utterances.src = 'https://utteranc.es/client.js';

          return utterances
        }

        var themeToggle = document.querySelector(".theme-toggle")
        themeToggle.addEventListener("click", function () {
          var getTheme = window.localStorage && window.localStorage.getItem("theme")
          var divNode = document.getElementById('github-comment')
          while(divNode.hasChildNodes()) {
            divNode.removeChild(divNode.firstChild);
          }
          
          
          

          
          
          
          
          
          
          document.getElementById('github-comment').appendChild(getUtterances(getTheme !== "dark"))
        })

        var getTheme = window.localStorage && window.localStorage.getItem("theme")
        document.getElementById('github-comment').appendChild(getUtterances(getTheme === "dark"))
      </script>
    </div>
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">All rights reserved by kingcos.me</div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </body>
</html>
