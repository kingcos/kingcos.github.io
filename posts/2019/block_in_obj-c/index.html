<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>Obj-C 中的 Block :: iBlog</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Demo Source Code     2019-07-27 首次提交 - -   2019-11-24 重新整理部分内容；补充《Effective Objective-C 2.0》&amp;amp;《Objective-C 高级编程》相关内容 Block_in_Obj-C objc4-756.2、libclosure-73    Preface 从 OS X Snow Leopard 和 iOS 4 开始，Apple 引入了 Block 的概念。Obj-C 中的 Block 即通常意义上的匿名函数，而之所以引入是因为 C 语言中并不支持匿名函数。这使得 Block 在 Obj-C 中可以称为是一类公民（First-Class Citizen），既可以作为类的属性，也可以作为函数参数或返回值来传递。那么本文就将着眼于此，谈谈 Obj-C 中的 Block。
Prerequisites 匿名函数与 Block 匿名函数顾名思义，即不带名称的函数，而 C 语言中即使是函数指针也仍然需要通过函数名来获得其地址：
// C 语言函数 int cFunc(int arg) { return arg; } int main_1(int argc, const char * argv[]) { int result1 = cFunc(10); // C 语言中的函数指针需要通过函数名来获得其地址  int (*cFuncPtr)(int) = &amp;amp;cFunc; int result2 = (*cFuncPtr)(10); printf(&amp;#34;result1 = %d, result2 = %d\n&amp;#34;, result1, result2); return 0; } // OUTPUT: // result1 = 10, result2 = 10 Obj-C 中的匿名函数被称为 Block，中文有译作块、闭包（Closure），其实很多语言都有类似的机制，比如 Swift 中的 Closure，Java / Python / C&#43;&#43; 11 中的 Lambda（λ）表达式，JavaScript 中的匿名函数等。"/>
<meta name="keywords" content="kingcos.me,maimieng.comios,swift,objective-c,obj-c,objc,oc,geek,python,ruby,golang,go,apple,mac"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/block_in_obj-c/" />





<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Obj-C 中的 Block"/>
<meta name="twitter:description" content="从 OS X Snow Leopard 和 iOS 4 开始，Apple 引入了 Block 的概念。Obj-C 中的 Block 即通常意义上的匿名函数，而之所以引入是因为 C 语言中并不支持匿名函数。这使得 Block 在 Obj-C 中可以称为是一类公民，既可以作为类的属性，也可以作为函数参数或返回值来传递。那么本文就将着眼于此，谈谈 Obj-C 中的 Block。"/>



<meta property="og:title" content="Obj-C 中的 Block" />
<meta property="og:description" content="从 OS X Snow Leopard 和 iOS 4 开始，Apple 引入了 Block 的概念。Obj-C 中的 Block 即通常意义上的匿名函数，而之所以引入是因为 C 语言中并不支持匿名函数。这使得 Block 在 Obj-C 中可以称为是一类公民，既可以作为类的属性，也可以作为函数参数或返回值来传递。那么本文就将着眼于此，谈谈 Obj-C 中的 Block。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2019/block_in_obj-c/" />
<meta property="article:published_time" content="2019-11-24T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-11-24T00:00:00+00:00" /><meta property="og:site_name" content="iBlog" />




<script data-ad-client="ca-pub-9925978992661955" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">kingcos.me</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="post">
    <h2 class="post-title"><a href="/posts/2019/block_in_obj-c/">Obj-C 中的 Block</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            2019-11-24
        </span>
      
      
      
        <span class="post-read-time">— 27 min read</span>
      
    </div>

    
      <span class="post-tags">
        
          #<a href="/tags/focus/">Focus</a>&nbsp;
        
          #<a href="/tags/ios/">iOS</a>&nbsp;
        
          #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      <table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Demo</th>
<th align="center">Source Code</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">2019-07-27</td>
<td align="center">首次提交</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">2019-11-24</td>
<td align="center">重新整理部分内容；补充《Effective Objective-C 2.0》&amp;《Objective-C 高级编程》相关内容</td>
<td align="center"><a href="https://github.com/kingcos/Perspective/tree/writing/Posts/Focus/block_in_obj-c/Block_in_Obj-C">Block_in_Obj-C</a></td>
<td align="center"><a href="https://opensource.apple.com/tarballs/objc4/">objc4-756.2</a>、<a href="https://opensource.apple.com/tarballs/libclosure/">libclosure-73</a></td>
</tr>
</tbody>
</table>
<p><img src="/img/2019/block_in_obj-c/0.png" alt="0"></p>
<h2 id="preface">Preface</h2>
<p>从 OS X Snow Leopard 和 iOS 4 开始，Apple 引入了 Block 的概念。Obj-C 中的 Block 即通常意义上的匿名函数，而之所以引入是因为 C 语言中并不支持匿名函数。这使得 Block 在 Obj-C 中可以称为是一类公民（First-Class Citizen），既可以作为类的属性，也可以作为函数参数或返回值来传递。那么本文就将着眼于此，谈谈 Obj-C 中的 Block。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="prerequisites">Prerequisites</h2>
<h3 id="-block">匿名函数与 Block</h3>
<p>匿名函数顾名思义，即不带名称的函数，而 C 语言中即使是函数指针也仍然需要通过函数名来获得其地址：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// C 语言函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cFunc</span>(<span style="color:#66d9ef">int</span> arg) {
    <span style="color:#66d9ef">return</span> arg;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_1</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">int</span> result1 <span style="color:#f92672">=</span> cFunc(<span style="color:#ae81ff">10</span>);

    <span style="color:#75715e">// C 语言中的函数指针需要通过函数名来获得其地址
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>cFuncPtr)(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>cFunc;
    <span style="color:#66d9ef">int</span> result2 <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>cFuncPtr)(<span style="color:#ae81ff">10</span>);

    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">result1 = %d, result2 = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, result1, result2);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// result1 = 10, result2 = 10
</span></code></pre></div><p>Obj-C 中的匿名函数被称为 Block，中文有译作块、闭包（Closure），其实很多语言都有类似的机制，比如 Swift 中的 Closure，Java / Python / C++ 11 中的 Lambda（λ）表达式，JavaScript 中的匿名函数等。</p>
<h3 id="arc--mrc">ARC &amp; MRC</h3>
<p>Obj-C 作为使用引用计数来进行内存管理语言，虽然 ARC（Automatic Reference Counting，自动引用计数）已经引入多年，但有时仍然需要通过 MRC（Mannul Reference Counting，手动引用计数）了解更加底层的细节与区别。在 Obj-C 中我们可以使用 <code>__has_feature(objc_arc)</code> 宏来区分 ARC 和 MRC 下可以编译的代码。</p>
<p>目前 Xcode 中默认为 ARC，如需切换为 MRC 可以通过 Xcode - Build Settings - Automatic Reference Counting - No 来设置：</p>
<p><img src="/img/2019/block_in_obj-c/3.png" alt="3"></p>
<blockquote>
<p>⚠️：本文中若未指明 MRC 或未使用 <code>__has_feature(objc_arc)</code> 明确编译条件，则默认为 ARC。</p>
</blockquote>
<h2 id="what">What</h2>
<h3 id="heading">语法</h3>
<p>Obj-C 中的 Block 令人十分诟病的一个问题是其语法的繁杂。笔者也时常在 <a href="http://fuckingblocksyntax.com">fuckingblocksyntax.com</a> 查询相应的语法。</p>
<p>声明一个参数为 <code>int</code> 没有返回值的 Block：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// main_2
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 省略返回值的 void
</span><span style="color:#75715e"></span><span style="color:#f92672">^</span>(<span style="color:#66d9ef">int</span> arg) {
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, arg);
};

<span style="color:#75715e">// 完整写法
</span><span style="color:#75715e"></span><span style="color:#f92672">^</span><span style="color:#66d9ef">void</span> (<span style="color:#66d9ef">int</span> arg) {
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, arg);
};
</code></pre></div><p>在语法上，与 C 语言函数不同的是：Block 没有函数名以及 <code>^</code> 记号，后者作为特殊记号将便于查找。BNF（Backus Normal Form，又 Backus-Naur Form，译作巴科斯范式，又巴科斯-诺尔范式）是一种用来描述计算机编程语言语法符号集的规范，通过这个规范在识别每一条编程语言语句时即可构建抽象语法树，进而帮助编译，未来笔者将在编译原理相关内容中深入探究。Block 声明语法的 BNF 如下：</p>
<pre><code>Block_literal_expression ::= ^ block_decl compound_statement_body
block_decl ::=
block_decl ::= parameter_list
block_decl ::= type_expression
</code></pre><p>因此通过上述 BNF 就能清晰的知道 Block 的几种声明语法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// main_2
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 省略返回值 &amp; 参数
</span><span style="color:#75715e"></span><span style="color:#f92672">^</span>{ <span style="color:#75715e">/* compound_statement_body */</span> };
<span style="color:#75715e">// 省略返回值
</span><span style="color:#75715e"></span><span style="color:#f92672">^</span>(<span style="color:#66d9ef">int</span> arg){ <span style="color:#75715e">/* compound_statement_body */</span> };
<span style="color:#75715e">// 省略参数
</span><span style="color:#75715e"></span><span style="color:#f92672">^</span><span style="color:#66d9ef">int</span>{ <span style="color:#75715e">/* compound_statement_body */</span> <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; };
</code></pre></div><p>Obj-C 中的 Block 与其它类型类似，可以作为属性或者变量，也可以在函数中作为参数或者返回值。但由于 Block 的语法繁杂，我们可以用 <code>typedef</code> 定义 Block 的类型，使得 API 更加简洁明了：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// BlockType_1 是一个参数和返回值均为 int 的 Block 类型
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">^</span>BlockType_1)(<span style="color:#66d9ef">int</span>);

<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo_1</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>) BlockType_1 block;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo_1</span>
<span style="color:#75715e">// 作为对象方法参数
</span><span style="color:#75715e"></span>- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">blockAsArg_1:</span>(<span style="color:#66d9ef">int</span>(<span style="color:#f92672">^</span>)(<span style="color:#66d9ef">int</span>))block {
    block(<span style="color:#ae81ff">10</span>);
}
<span style="color:#75715e">// 使用 typedef 作为对象方法参数
</span><span style="color:#75715e"></span>- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">blockAsArg_2:</span>(BlockType_1)block {
    block(<span style="color:#ae81ff">10</span>);
}
<span style="color:#75715e">// 作为对象方法返回值
</span><span style="color:#75715e"></span>- (<span style="color:#66d9ef">int</span>(<span style="color:#f92672">^</span>)(<span style="color:#66d9ef">int</span>))<span style="color:#a6e22e">blockAsReturnValue_1</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">^</span>(<span style="color:#66d9ef">int</span> arg) { <span style="color:#66d9ef">return</span> arg; };
}
<span style="color:#75715e">// 使用 typedef 作为对象方法返回值
</span><span style="color:#75715e"></span>- (BlockType_1)<span style="color:#a6e22e">blockAsReturnValue_2</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">^</span>(<span style="color:#66d9ef">int</span> arg) { <span style="color:#66d9ef">return</span> arg; };
}
<span style="color:#66d9ef">@end</span>

<span style="color:#75715e">// Block 作为 C 语言函数参数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> blockAsArg_1(<span style="color:#66d9ef">int</span> (<span style="color:#f92672">^</span>block)(<span style="color:#66d9ef">int</span>)) {
    block(<span style="color:#ae81ff">10</span>);
}
<span style="color:#75715e">// 使用 typedef 作为 C 语言函数参数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> blockAsArg_2(BlockType_1 block) {
    block(<span style="color:#ae81ff">10</span>);
}

<span style="color:#75715e">// 《Objective-C 高级编程》中提到的，将 Block 以非 typedef 形式作为 C 语言函数的返回值类型；但目前会报错，且尚未找到相应的解决方法：
</span><span style="color:#75715e"></span><span style="color:#75715e">// ERROR: Block pointer to non-function type is invalid
</span><span style="color:#75715e"></span><span style="color:#75715e">// ERROR: Returning &#39;int (^)(int)&#39; from a function with incompatible result type &#39;int (int)&#39;
</span><span style="color:#75715e"></span><span style="color:#75715e">// int (^blockAsReturnValue()(int)) {
</span><span style="color:#75715e"></span><span style="color:#75715e">//     return ^(int arg) { return arg; };
</span><span style="color:#75715e"></span><span style="color:#75715e">// }
</span><span style="color:#75715e"></span>
BlockType_1 blockAsReturnValue() {
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">^</span>(<span style="color:#66d9ef">int</span> arg) { <span style="color:#66d9ef">return</span> arg; };
}

<span style="color:#66d9ef">int</span> main_2(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#75715e">// 声明 Block 类型的变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">^</span>block1)(<span style="color:#66d9ef">int</span>);
    <span style="color:#75715e">// 声明并赋值 Block（省略返回值类型）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span>(<span style="color:#f92672">^</span>block2)(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>(<span style="color:#66d9ef">int</span> arg) { <span style="color:#66d9ef">return</span> arg; };
    block2 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span><span style="color:#66d9ef">int</span>(<span style="color:#66d9ef">int</span> arg) { <span style="color:#66d9ef">return</span> arg; };
    <span style="color:#75715e">// Block 类型的变量之间赋值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">^</span>block3)(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">=</span> block2;

    block1 <span style="color:#f92672">=</span> block2;

    <span style="color:#75715e">// 使用 typedef
</span><span style="color:#75715e"></span>    BlockType_1 block4;
    BlockType_1 block5 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>(<span style="color:#66d9ef">int</span> arg) { <span style="color:#66d9ef">return</span> arg; };
    block5 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span><span style="color:#66d9ef">int</span>(<span style="color:#66d9ef">int</span> arg) { <span style="color:#66d9ef">return</span> arg; };
    BlockType_1 block6 <span style="color:#f92672">=</span> block5;
    block4 <span style="color:#f92672">=</span> block5;

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="heading1">结构</h3>
<p>在 <code>main</code> 函数中声明并执行一个简单的 Block：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_3</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">^</span>block)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">Hello, World!</span><span style="color:#e6db74">&#34;</span>);
    };

    block();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// Hello, World!
</span></code></pre></div><p>为了窥探 Block 的结构，可以尝试使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</code> 命令将以上代码翻译为 C/C++ 代码来分析：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// Block 实现的结构体
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> {
  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>isa;     <span style="color:#75715e">// isa 指针，即 Block 也是 id 类型，即 Obj-C 对象
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> Flags;     <span style="color:#75715e">// 标记，默认会被初始化为 0
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> Reserved;  <span style="color:#75715e">// 保留域（ABI 兼容），默认 0
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>FuncPtr; <span style="color:#75715e">// Block 代码块的函数指针
</span><span style="color:#75715e"></span>};

<span style="color:#75715e">// ➡️ Block 结构体
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_3_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;           <span style="color:#75715e">// 实现（非指针）
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_3_block_desc_0</span><span style="color:#f92672">*</span> Desc; <span style="color:#75715e">// 描述信息（指针）
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 构造函数
</span><span style="color:#75715e"></span>  __main_3_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_3_block_desc_0</span> <span style="color:#f92672">*</span>desc, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock; <span style="color:#75715e">// Block 作为 Obj-C 对象，那么 isa 将指向其类对象，即 _NSConcreteStackBlock
</span><span style="color:#75715e"></span>    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};

<span style="color:#75715e">// Block 内代码块封装在该 C 语言静态函数中，函数命名规则：__CALLER_METHOD_NAME_block_func_NUMBER
</span><span style="color:#75715e"></span><span style="color:#75715e">// 类似 Obj-C 实例方法参数 self 或 C++ 实例方法参数 this，__cself 为指向 Block 结构体的变量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_3_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_3_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {
  NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_b9596e_mi_0);
}

<span style="color:#75715e">// Block 描述信息的结构体静态变量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_3_block_desc_0</span> {
  size_t reserved;   <span style="color:#75715e">// 保留域，默认 0
</span><span style="color:#75715e"></span>  size_t Block_size; <span style="color:#75715e">// Block 大小，sizeof 整个 Block 结构体 ⬇️
</span><span style="color:#75715e"></span>} __main_3_block_desc_0_DATA <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_3_block_impl_0</span>)};

<span style="color:#75715e">// 主函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_3</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#75715e">// 通过 __main_3_block_impl_0 结构体的构造函数初始化，参数为静态函数和描述信息静态变量的地址，将地址存储在 block 变量中
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 忽略类型转换：block = &amp;__main_3_block_impl_0(__main_3_block_func_0, &amp;__main_3_block_desc_0_DATA));
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>block)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__main_3_block_impl_0((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__main_3_block_func_0, <span style="color:#f92672">&amp;</span>__main_3_block_desc_0_DATA));

    <span style="color:#75715e">// 执行 Block（参数 block 即静态函数中的参数 __cself）
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 忽略类型转换：block-&gt;FuncPtr(block);
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 在 __main_block_impl_0 结构体中，impl 是第一个变量，因此其与结构体本身的首地址一致，因此可以强转
</span><span style="color:#75715e"></span>    ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(__block_impl <span style="color:#f92672">*</span>))((__block_impl <span style="color:#f92672">*</span>)block)<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>FuncPtr)((__block_impl <span style="color:#f92672">*</span>)block);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>当声明一个 Block 变量，其中的代码块会被封装到 <code>__main_3_block_func_0</code> 静态函数中（后缀 <code>0</code> 代表序号，后同），描述信息则被初始化并封装到 <code>__main_3_block_desc_0_DATA</code> 静态变量中；这两者在 <code>main</code> 函数中一起构造了 Block 结构体 <code>__main_3_block_impl_0</code>，并将其地址保存在声明的 <code>block</code> 变量中；由于 Block 的结构体直接包含了 <code>__block_impl</code> 结构体，因此在构造函数中，<code>__block_impl</code> 的 <code>isa</code> 指向了 <code>_NSConcreteStackBlock</code> 类对象的地址，也印证了 Block 的本质是特殊的 Obj-C 对象；<code>__block_impl</code> 的 <code>FuncPtr</code> 函数指针则指向包含代码块的静态函数，在 Block 真正执行时，将通过 <code>block-&gt;FuncPtr(block)</code> 找到静态函数并调用。上述代码中的 <code>block</code> 结构正如下图：</p>
<p><img src="/img/2019/block_in_obj-c/1.png" alt="1"></p>
<h2 id="heading2">变量捕获</h2>
<h3 id="heading3">自动变量</h3>
<p>自动变量（Automatic Variable）即局部作用域变量，指在代码块中声明的变量，也可以显式使用 <code>auto</code> 关键字声明。自动变量存储在内存的栈区，离开作用域时会被自动回收：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_4</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block)(<span style="color:#66d9ef">void</span>);

    {
        <span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">int</span> autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>autoConstVar <span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">kingcos.me</span><span style="color:#e6db74">&#34;</span>;

        block <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>() {
            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">autoVar == %d, autoConstVar == %s</span><span style="color:#e6db74">&#34;</span>, autoVar, autoConstVar);
        };

        autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
        <span style="color:#75715e">// const char * 为常量，不可改变存储的类型
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// autoConstVar = 1.5;
</span><span style="color:#75715e"></span>    }

    <span style="color:#75715e">// ERROR: Use of undeclared identifier &#39;autoVar&#39;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// autoVar = 10;
</span><span style="color:#75715e"></span>
    block();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// autoVar == 1, autoConstVar == kingcos.me
</span></code></pre></div><p>如上，我们在代码块外声明了一个 Block，而在代码块内声明了自动变量，并将 <code>block</code> 赋值。超出代码块作用于后，我们已经无法再次访问代码块内部的变量，而 <code>block</code> 执行的结果却是正常的。这是为什么呢？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_4_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_4_block_desc_0</span><span style="color:#f92672">*</span> Desc;
  <span style="color:#66d9ef">int</span> autoVar;              <span style="color:#75715e">// 捕获的自动变量 autoVar
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>autoConstVar; <span style="color:#75715e">// 捕获的变量类型与外界声明完全相同
</span><span style="color:#75715e"></span>
  __main_4_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_4_block_desc_0</span> <span style="color:#f92672">*</span>desc, <span style="color:#66d9ef">int</span> _autoVar, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>_autoConstVar, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> autoVar(_autoVar), autoConstVar(_autoConstVar) { <span style="color:#75715e">// 构造函数初始化内结构体内部的自动变量
</span><span style="color:#75715e"></span>    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_4_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_4_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {
  <span style="color:#75715e">// 从 __celf 取初始化时获得的值
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> autoVar <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar; <span style="color:#75715e">// bound by copy
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>autoConstVar <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoConstVar; <span style="color:#75715e">// bound by copy
</span><span style="color:#75715e"></span>
  NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_27d308_mi_3, autoVar, autoConstVar);
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_4_block_desc_0</span> {
  size_t reserved;
  size_t Block_size;
} __main_4_block_desc_0_DATA <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_4_block_impl_0</span>)};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_4</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#75715e">// 在代码块外声明的 Block 变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>block)(<span style="color:#66d9ef">void</span>);

    {
        <span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">int</span> autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>autoConstV<span style="color:#75715e">// 构造时将外部自动变量的值直接传入
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 忽略类型转换：block = &amp;__main_4_block_impl_0(__main_4_block_func_0, &amp;__main_4_block_desc_0_DATA, autoVar, autoConstVar));
</span><span style="color:#75715e"></span>        block <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__main_4_block_impl_0((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__main_4_block_func_0, <span style="color:#f92672">&amp;</span>__main_4_block_desc_0_DATA, autoVar, autoConstVar));

        autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
    }

    <span style="color:#75715e">// 执行 Block
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 忽略类型转换：block-&gt;FuncPtr(block);
</span><span style="color:#75715e"></span>    ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(__block_impl <span style="color:#f92672">*</span>))((__block_impl <span style="color:#f92672">*</span>)block)<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>FuncPtr)((__block_impl <span style="color:#f92672">*</span>)block);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>为了避免自动变量的提前释放，Block 会将其内部使用到的自动变量捕获到结构体内部（按值传递），这样即使超出自动变量的作用域或者在 Block 外更改了原有的变量值，也不会影响 Block 中已经被捕获的那个变量。</p>
<p>那么在 Obj-C 对象方法中如果有 Block 使用到了 <code>self</code> 或者成员变量呢？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo_2</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">copy</span>) NSString <span style="color:#f92672">*</span>prop;

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">bar_1</span>;
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">bar_2</span>;

+ (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">bar</span>;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo_2</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">dealloc</span>
{
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">dealloc</span><span style="color:#e6db74">&#34;</span>);
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">bar_1</span> {
    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block_1)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>() {
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">self == %@</span><span style="color:#e6db74">&#34;</span>, self);
    };

    block_1();
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">bar_2</span> {
    self.prop <span style="color:#f92672">=</span> <span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">kingcos.me</span><span style="color:#e6db74">&#34;</span>;

    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block_2)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>() {
        <span style="color:#75715e">// WARNING: Block implicitly retains &#39;self&#39;; explicitly mention &#39;self&#39; to indicate this is intended behavior
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// NSLog(@&#34;_prop == %@.&#34;, _prop);
</span><span style="color:#75715e"></span>
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">_prop == %@</span><span style="color:#e6db74">&#34;</span>, self<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>_prop);
    };

    block_2();
}

+ (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">bar</span> {
    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>() {
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">self == %@</span><span style="color:#e6db74">&#34;</span>, self);
    };

    block();
}
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">int</span> main_4(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    Foo_2 <span style="color:#f92672">*</span>foo <span style="color:#f92672">=</span> [[Foo_2 alloc] init];
    [foo bar_1];
    [foo bar_2];

    [Foo_2 bar];

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// self == &lt;Foo_2: 0x100532d80&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// _prop == kingcos.me
</span><span style="color:#75715e"></span><span style="color:#75715e">// self == Foo_2
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span></code></pre></div><p>Obj-C 方法里使用到的 <code>self</code> 来自于其默认参数（另一个默认参数是 <code>_cmd</code>），而函数参数的作用域也仅在当前函数体内。因此 Block 内如果使用到 <code>self</code> 或者成员变量（本质也是通过 <code>self</code> 进行访问的）则也会对其进行捕获：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Foo_2__bar_1_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Foo_2__bar_1_block_desc_0</span><span style="color:#f92672">*</span> Desc;
  Foo_2 <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> __strong self; <span style="color:#75715e">// 捕获的 self
</span><span style="color:#75715e"></span>
  __Foo_2__bar_1_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Foo_2__bar_1_block_desc_0</span> <span style="color:#f92672">*</span>desc, Foo_2 <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> __strong _self, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> self(_self) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__Foo_2__bar_1_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Foo_2__bar_1_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {
  <span style="color:#75715e">// 执行时取出 self
</span><span style="color:#75715e"></span>  Foo_2 <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> __strong self <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>self; <span style="color:#75715e">// bound by copy
</span><span style="color:#75715e"></span>
  NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_169b69_mi_1, self);
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Foo_2__bar_2_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Foo_2__bar_2_block_desc_0</span><span style="color:#f92672">*</span> Desc;
  Foo_2 <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> __strong self; <span style="color:#75715e">// 捕获的 self
</span><span style="color:#75715e"></span>
  __Foo_2__bar_2_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Foo_2__bar_2_block_desc_0</span> <span style="color:#f92672">*</span>desc, Foo_2 <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> __strong _self, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> self(_self) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__Foo_2__bar_2_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Foo_2__bar_2_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {
  Foo_2 <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> __strong self <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>self; <span style="color:#75715e">// bound by copy
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// self + OBJC_IVAR_$_Foo_2$_prop：成员变量是根据 self 做的偏移
</span><span style="color:#75715e"></span>  NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_169b69_mi_3, (<span style="color:#f92672">*</span>(NSString <span style="color:#f92672">*</span>__strong <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)self <span style="color:#f92672">+</span> OBJC_IVAR_<span style="color:#960050;background-color:#1e0010">$</span>_Foo_2<span style="color:#960050;background-color:#1e0010">$</span>_prop)));
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Foo_2__bar_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Foo_2__bar_block_desc_0</span><span style="color:#f92672">*</span> Desc;
  <span style="color:#66d9ef">const</span> Class self; <span style="color:#75715e">// 对于类方法，则捕获的是类对象
</span><span style="color:#75715e"></span>  __Foo_2__bar_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Foo_2__bar_block_desc_0</span> <span style="color:#f92672">*</span>desc, <span style="color:#66d9ef">const</span> Class _self, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> self(_self) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__Foo_2__bar_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Foo_2__bar_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {
  <span style="color:#66d9ef">const</span> Class self <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>self; <span style="color:#75715e">// bound by copy
</span><span style="color:#75715e"></span>
  NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_169b69_mi_4, self);
}
</code></pre></div><h3 id="heading4">局部静态变量</h3>
<p>局部静态变量指定义在代码块内的静态变量，其作用域是在代码块内，但其生命周期并不会随代码块结束：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_5</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block)(<span style="color:#66d9ef">void</span>);

    {
        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

        block <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>() {
            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">a == %d</span><span style="color:#e6db74">&#34;</span>, a);
        };

        a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
    }

    block();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// a == 10
</span></code></pre></div><p>不同于自动变量，对于局部静态变量，由于其生命周期随程序退出才结束，因此在 Block 内部只需要将局部静态变量的地址进行捕获即可（按引用传递）。这样即使超过局部静态变量的作用域但 Block 中仍然可以通过地址访问到，且当 Block 执行前如果改变了局部静态变量的值，那么执行时也将根据地址获取到最新值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_desc_0</span><span style="color:#f92672">*</span> Desc;
  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a; <span style="color:#75715e">// 捕获的变量，类型为指向 int 类型的指针
</span><span style="color:#75715e"></span>  __main_5_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_desc_0</span> <span style="color:#f92672">*</span>desc, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>_a, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> a(_a) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_5_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {
  <span style="color:#75715e">// int *a = &amp;a;（外界 a 的地址）
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>a; <span style="color:#75715e">// bound by copy
</span><span style="color:#75715e"></span>
  NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_0fafd0_mi_4, (<span style="color:#f92672">*</span>a));
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_desc_0</span> {
  size_t reserved;
  size_t Block_size;
} __main_5_block_desc_0_DATA <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_impl_0</span>)};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_5</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>block)(<span style="color:#66d9ef">void</span>);

    {
        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

        <span style="color:#75715e">// 忽略类型转换：block = &amp;__main_5_block_impl_0(__main_5_block_func_0, &amp;__main_5_block_desc_0_DATA, &amp;a);（&amp;a 即 a 的地址作为参数传入）
</span><span style="color:#75715e"></span>        block <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__main_5_block_impl_0((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__main_5_block_func_0, <span style="color:#f92672">&amp;</span>__main_5_block_desc_0_DATA, <span style="color:#f92672">&amp;</span>a));

        <span style="color:#75715e">// a 的值发生改变
</span><span style="color:#75715e"></span>        a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
    }

    ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(__block_impl <span style="color:#f92672">*</span>))((__block_impl <span style="color:#f92672">*</span>)block)<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>FuncPtr)((__block_impl <span style="color:#f92672">*</span>)block);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="heading5">全局变量</h3>
<p>全局变量即定义在所有函数体外的变量，只有当程序退出时其生命周期和作用域才结束：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// 全局变量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> globalVar_1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#75715e">// 全局静态变量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> staticGlobalVar_1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_6</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>() {
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">globalVar_1 == %d, staticGlobalVar_1 == %d</span><span style="color:#e6db74">&#34;</span>, globalVar_1, staticGlobalVar_1);
    };

    globalVar_1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
    staticGlobalVar_1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;

    block();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTOUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// globalVar_1 == 10, staticGlobalVar_1 == 20
</span></code></pre></div><p>因此对于全局变量，Block 并不会去捕获，而是在使用时直接进行读取即可：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> globalVar_1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> staticGlobalVar_1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_6_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_6_block_desc_0</span><span style="color:#f92672">*</span> Desc;
  <span style="color:#75715e">// 没有捕获
</span><span style="color:#75715e"></span>
  __main_6_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_6_block_desc_0</span> <span style="color:#f92672">*</span>desc, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_6_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_6_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {
  <span style="color:#75715e">// 直接访问
</span><span style="color:#75715e"></span>  NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_d50b04_mi_8, globalVar_1, staticGlobalVar_1);
}
</code></pre></div><h3 id="c-">C 语言数组</h3>
<p>需要注意的是，当 Block 并不能捕获 C 语言中的数组。实际上这在 C 语言的函数中也是不支持的，猜测这是因为 Block 遵循了类似 C 语言的规范（参考《Objective-C 高级编程》），这里可以使用指针代替：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cFunc_2</span>(<span style="color:#66d9ef">char</span> a[<span style="color:#ae81ff">10</span>]) {
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, a[<span style="color:#ae81ff">0</span>]);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cFunc_3</span>(<span style="color:#66d9ef">char</span> a[<span style="color:#ae81ff">10</span>]) {
    <span style="color:#75715e">// C 语言不允许数组类型变量赋值给另外的数组类型变量
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// ERROR: Array initializer must be an initializer list or string literal
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// char b[10] = a;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// printf(&#34;%d\n&#34;, b[0]);
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_7</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> cLocalArr[] <span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">kingcos.me</span><span style="color:#e6db74">&#34;</span>;
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cLocalString <span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">kingcos.me</span><span style="color:#e6db74">&#34;</span>;

    <span style="color:#f92672">^</span>{
        <span style="color:#75715e">// Block 不会对 C 语言数组进行捕获
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// ERROR: Cannot refer to declaration with an array type inside block
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// printf(&#34;%c\n&#34;, cLocalArr[7]);
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">// 使用指针代替
</span><span style="color:#75715e"></span>        printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%c</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, cLocalString[<span style="color:#ae81ff">7</span>]);
    }();

    <span style="color:#75715e">// 猜测 Block 遵循了类似 C 语言的规范
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> a[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">2</span>};

    cFunc_2(a);
    cFunc_3(a);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// .
</span><span style="color:#75715e"></span><span style="color:#75715e">// 2
</span></code></pre></div><h2 id="heading6">类型</h2>
<p>Obj-C 中的 Block 根据其存储在不同的内存区域被分为三种：<code>__NSGlobalBlock__</code>、<code>__NSStackBlock__</code>、<code>__NSMallocBlock__</code>，它们又各自继承自 <code>__NSGlobalBlock</code>、<code>__NSMallocBlock</code>、<code>__NSStackBlock</code>，这些父类又都继承自 <code>NSBlock</code>，<code>NSBlock</code> 又继承自 <code>NSObject</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_8</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block1)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>() {
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">Hello, world!</span><span style="color:#e6db74">&#34;</span>);
    };

    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block2)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>() {
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, a);
    };

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@ %@ %@</span><span style="color:#e6db74">&#34;</span>, [block1 <span style="color:#66d9ef">class</span>], [block2 <span style="color:#66d9ef">class</span>], [<span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, a);
    } <span style="color:#66d9ef">class</span>]);

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@ %@ %@</span><span style="color:#e6db74">&#34;</span>, [block1 superclass], [block2 superclass],[<span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, a);
    } superclass]);

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@ %@ %@</span><span style="color:#e6db74">&#34;</span>, [[block1 superclass] superclass], [[block2 superclass] superclass],[[<span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, a);
    } superclass] superclass]);

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@ %@ %@</span><span style="color:#e6db74">&#34;</span>, [[[block1 superclass] superclass] superclass], [[[block2 superclass] superclass] superclass],[[[<span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, a);
    } superclass] superclass] superclass]);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// __NSGlobalBlock__ __NSMallocBlock__ __NSStackBlock__
</span><span style="color:#75715e"></span><span style="color:#75715e">// __NSGlobalBlock __NSMallocBlock __NSStackBlock
</span><span style="color:#75715e"></span><span style="color:#75715e">// NSBlock NSBlock NSBlock
</span><span style="color:#75715e"></span><span style="color:#75715e">// NSObject NSObject NSObject
</span></code></pre></div><blockquote>
<p>⚠️</p>
<p>在上一节中，我们可以从「翻译」后的 C++ 代码中看到 Block 内部的 <code>isa</code> 指针均默认指向了 <code>_NSConcreteStackBlock</code>，但其实在 macOS 的 Xcode 中运行时并不存在「翻译」这一步骤，因此我们最好使用运行时的方法来真正确定 Block 的具体类型。</p>
</blockquote>
<h3 id="nsglobalblock"><code>__NSGlobalBlock__</code></h3>
<p>内部没有访问外界<strong>自动变量</strong>的 Block 将在执行时不依赖上下文，该类型的 Block 属于 <code>__NSGlobalBlock__</code>，存储在内存的数据区（Data 段），该区域通常也会存放全局变量：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> globalVar_2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_9</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>gloablBlock)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        <span style="color:#75715e">// 没有访问任何外界变量
</span><span style="color:#75715e"></span>        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">This is a __NSGlobalBlock__.</span><span style="color:#e6db74">&#34;</span>);
    };

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, [gloablBlock <span style="color:#66d9ef">class</span>]);

    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> staticVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

    gloablBlock <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        <span style="color:#75715e">// 访问了全局变量或局部静态变量
</span><span style="color:#75715e"></span>        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">globalVar2 == %d, staticVar == %d.</span><span style="color:#e6db74">&#34;</span>, globalVar_2, staticVar);
    };

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, [gloablBlock <span style="color:#66d9ef">class</span>]);

    <span style="color:#75715e">// 该 Block 实际初始化时将：
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// impl.isa = &amp;_NSConcreteGlobalBlock;
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// __NSGlobalBlock__
</span><span style="color:#75715e"></span><span style="color:#75715e">// __NSGlobalBlock__
</span></code></pre></div><p>对 <code>__NSGlobalBlock__</code> 类型的 Block 执行 <code>copy</code> 操作并不会将其拷贝至堆中，而是仍将返回 <code>__NSGlobalBlock__</code>。</p>
<h3 id="nsstackblock"><code>__NSStackBlock__</code></h3>
<h4 id="what1">What</h4>
<p>自动变量存储在内存的栈区，当 Block 内访问了外界的自动变量时会对其进行捕获，此时 Block 本身也被分配在栈区，属于 <code>__NSStackBlock__</code> 类型：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_10</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>stackBlock)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">c == %d.</span><span style="color:#e6db74">&#34;</span>, c);
    };

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, [stackBlock <span style="color:#66d9ef">class</span>]);
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// stackBlock 初始化时将：
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// impl.isa = &amp;_NSConcreteStackBlock;
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">//  __NSStackBlock__
</span></code></pre></div><p>栈区的内存不需要开发者手动管理，当作用域结束时栈区内存将会被自动回收。所以即使 <code>__NSStackBlock__</code> 类型的 Block 内部捕获了自动变量，但 Block 本身和捕获的变量也仍然存储在栈区，会随着其作用域结束而释放：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo_3</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo_3</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">dealloc</span>
{
<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    [super dealloc]; <span style="color:#75715e">// MRC 下需手动调用下父类的 dealloc
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">dealloc</span><span style="color:#e6db74">&#34;</span>);
}
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>stackBlock_1)(<span style="color:#66d9ef">void</span>);
<span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>stackBlock_2)(<span style="color:#66d9ef">void</span>);

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">initBlockInARC</span>() {
<span style="color:#75715e">#</span><span style="color:#75715e">if __has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 初始化，引用计数 +1
</span><span style="color:#75715e"></span>    Foo_3 <span style="color:#f92672">*</span>strongF <span style="color:#f92672">=</span> [[Foo_3 alloc] init];

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%ld</span><span style="color:#e6db74">&#34;</span>, CFGetRetainCount((<span style="color:#66d9ef">__bridge</span> CFTypeRef)(strongF)));

    <span style="color:#75715e">// 弱引用，引用计数不变 +0
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">__weak</span> Foo_3 <span style="color:#f92672">*</span>weakF <span style="color:#f92672">=</span> strongF;

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%ld</span><span style="color:#e6db74">&#34;</span>, CFGetRetainCount((<span style="color:#66d9ef">__bridge</span> CFTypeRef)(strongF)));

    <span style="color:#75715e">// Block 捕获，引用计数 +1
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// __NSStackBlock__
</span><span style="color:#75715e"></span>    <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, strongF);
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, weakF);
    };

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%ld</span><span style="color:#e6db74">&#34;</span>, CFGetRetainCount((<span style="color:#66d9ef">__bridge</span> CFTypeRef)(strongF)));
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">initBlockInMRC</span>() {
<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

    stackBlock_1 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">c == %d</span><span style="color:#e6db74">&#34;</span>, c);
    };

    <span style="color:#75715e">// 初始化，引用计数 +1
</span><span style="color:#75715e"></span>    Foo_3 <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> [[Foo_3 alloc] init];

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%ld</span><span style="color:#e6db74">&#34;</span>, [f retainCount]);

    <span style="color:#75715e">// MRC 下 stackBlock_2 捕获 f 但不持有，引用计数 +0
</span><span style="color:#75715e"></span>    stackBlock_2 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
       NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">f == %@</span><span style="color:#e6db74">&#34;</span>, f);
    };

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%ld</span><span style="color:#e6db74">&#34;</span>, [f retainCount]);

    [f <span style="color:#66d9ef">release</span>];
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_11</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
<span style="color:#75715e">#</span><span style="color:#75715e">if __has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 初始化 stackBlock
</span><span style="color:#75715e"></span>    initBlockInARC();
<span style="color:#75715e">#</span><span style="color:#75715e">else</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 初始化 stackBlock
</span><span style="color:#75715e"></span>    initBlockInMRC();

    <span style="color:#75715e">// 执行 stackBlock_1
</span><span style="color:#75715e"></span>    stackBlock_1(); <span style="color:#75715e">// c == -272632744
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 执行 stackBlock_2
</span><span style="color:#75715e"></span>    stackBlock_2(); <span style="color:#75715e">// CRASH: objc[59614]: Attempt to use unknown class 0x7ffeefbff428.
</span><span style="color:#75715e"></span>
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">stackBlock_1 is a %@.</span><span style="color:#e6db74">&#34;</span>, [stackBlock_1 <span style="color:#66d9ef">class</span>]); <span style="color:#75715e">// CRASH: EXC_BAD_ACCESS
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// MRC OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// 1
</span><span style="color:#75715e"></span><span style="color:#75715e">// 1
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// ARC OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// 1
</span><span style="color:#75715e"></span><span style="color:#75715e">// 1
</span><span style="color:#75715e"></span><span style="color:#75715e">// 2
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span></code></pre></div><p>MRC 下，<code>__NSStackBlock__</code> 类型的 Block 中虽然捕获了对象类型的自动变量，但没有改变其引用计数，即不会进行 <code>retain</code> 持有操作。而 <code>main</code> 函数中执行到 Block 时其本身已经被系统回收，捕获的自动变量 <code>c</code> 和 <code>f</code> 也已经从栈上释放，因此访问时出现了脏数据，访问 Block 本身也出现了 <code>EXC_BAD_ACCESS</code> 崩溃。为了避免这种问题，我们需要将 Block 分配在堆上（即 <code>__NSMallocBlock__</code>），这是因为堆区的内存由开发者自己管理，可以避免被自动回收。</p>
<p>ARC 下，<code>__NSStackBlock__</code> 类型的 Block 中捕获了 <code>strongP</code> 和 <code>weakP</code>（可以通过为翻译 Obj-C 代码的命令额外添加 <code>-fobjc-arc -fobjc-runtime=ios-13.0.0</code> 参数强制使用 ARC 并指定运行时平台和版本，这样即可输出带有部分运行时关键字的 C/C++ 代码，如下），虽然强引用会导致其引用计数增加，但由于 Block 本身在栈上并仍会随作用域超出而销毁，捕获的自动变量同理也会被销毁。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__initBlockInARC_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__initBlockInARC_block_desc_0</span><span style="color:#f92672">*</span> Desc;
  Foo_3 <span style="color:#f92672">*</span>__strong strongF; <span style="color:#75715e">// ⚠️ 强引用
</span><span style="color:#75715e"></span>  Foo_3 <span style="color:#f92672">*</span>__weak weakF;     <span style="color:#75715e">// ⚠️ 弱引用
</span><span style="color:#75715e"></span>
  __initBlockInARC_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__initBlockInARC_block_desc_0</span> <span style="color:#f92672">*</span>desc, Foo_3 <span style="color:#f92672">*</span>__strong _strongF, Foo_3 <span style="color:#f92672">*</span>__weak _weakF, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> strongF(_strongF), weakF(_weakF) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};
</code></pre></div><h3 id="nsmallocblock"><code>__NSMallocBlock__</code></h3>
<h4 id="what2">What</h4>
<p><code>__NSMallocBlock__</code> 类型的 Block 存储在内存的堆区，堆区是通常用作动态分配（Malloc）的内存：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo_4</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo_4</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">dealloc</span>
{
<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    [super dealloc];
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">dealloc</span><span style="color:#e6db74">&#34;</span>);
}
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">void</span>(<span style="color:#f92672">^</span>BlockType_2)(<span style="color:#66d9ef">void</span>);

<span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>mallocBlock_1)(<span style="color:#66d9ef">void</span>);
<span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>mallocBlock_2)(<span style="color:#66d9ef">void</span>);

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">initBlock</span>() {
<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

    mallocBlock_1 <span style="color:#f92672">=</span> [<span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">c == %d</span><span style="color:#e6db74">&#34;</span>, c);
    } <span style="color:#66d9ef">copy</span>];

    Foo_4 <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> [[Foo_4 alloc] init];

    mallocBlock_2 <span style="color:#f92672">=</span> [<span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, f);
    } <span style="color:#66d9ef">copy</span>];

    [f <span style="color:#66d9ef">release</span>];
<span style="color:#75715e">#</span><span style="color:#75715e">else</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

    mallocBlock_1 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">c == %d</span><span style="color:#e6db74">&#34;</span>, c);
    };

    Foo_4 <span style="color:#f92672">*</span>strongF <span style="color:#f92672">=</span> [[Foo_4 alloc] init];
    <span style="color:#66d9ef">__weak</span> Foo_4 <span style="color:#f92672">*</span>weakF <span style="color:#f92672">=</span> strongF;

    <span style="color:#75715e">// 1⃣️ ARC 下强指针 mallocBlock_2 指向的 Block 会被自动拷贝为 __NSMallocBlock__
</span><span style="color:#75715e"></span>    mallocBlock_2 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, strongF);
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, weakF);
    };

    <span style="color:#75715e">// 使用弱引用指针指向的 Block，将仍然是 __NSStackBlock__，编译将提示以下警告
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// WARNING: Assigning block literal to a weak variable; object will be released after assignment
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">__weak</span> BlockType_2 weakStackBlock <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, strongF);
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, weakF);
    };

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">weakStackBlock is %@</span><span style="color:#e6db74">&#34;</span>, weakStackBlock);

    <span style="color:#75715e">// 3⃣️ Block 作为 Cocoa API 中方法名含有 `usingBlock` 的参数时会被自动拷贝为 __NSMallocBlock__
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 4⃣️ Block 作为 GCD API 参数时会被自动拷贝为 __NSMallocBlock__
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>}

BlockType_2 <span style="color:#a6e22e">returnMallocBlock</span>() {
    <span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">int</span> autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// MRC 下如果直接返回 Block，将报错「Returning block that lives on the local stack」
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 即编译器已经发现返回的 Block 是在栈上，一旦函数体走完，Block 就会被销毁，因此在 MRC 下需要手动 copy：
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> [<span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, autoVar);
    } <span style="color:#66d9ef">copy</span>];
<span style="color:#75715e">#</span><span style="color:#75715e">else</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 2⃣️ ARC 下 Block 作为函数返回值会被自动拷贝为 __NSMallocBlock__
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, autoVar);
    };
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_12</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    initBlock();

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">mallocBlock_1 is %@</span><span style="color:#e6db74">&#34;</span>, [mallocBlock_1 <span style="color:#66d9ef">class</span>]);
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">mallocBlock_2 is %@</span><span style="color:#e6db74">&#34;</span>, [mallocBlock_2 <span style="color:#66d9ef">class</span>]);
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">returnMallocBlock() is %@</span><span style="color:#e6db74">&#34;</span>, [returnMallocBlock() <span style="color:#66d9ef">class</span>]);

    mallocBlock_1();
    mallocBlock_2();

<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    [mallocBlock_1 <span style="color:#66d9ef">release</span>];
    [mallocBlock_2 <span style="color:#66d9ef">release</span>];
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// MRC OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// mallocBlock_1 is __NSMallocBlock__
</span><span style="color:#75715e"></span><span style="color:#75715e">// mallocBlock_2 is __NSMallocBlock__
</span><span style="color:#75715e"></span><span style="color:#75715e">// returnMallocBlock() is __NSMallocBlock__
</span><span style="color:#75715e"></span><span style="color:#75715e">// c == 10
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;Foo_4: 0x100559170&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// ARC OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// weakStackBlock is &lt;__NSStackBlock__: 0x7ffeefbff3d0&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// mallocBlock_1 is __NSMallocBlock__
</span><span style="color:#75715e"></span><span style="color:#75715e">// mallocBlock_2 is __NSMallocBlock__
</span><span style="color:#75715e"></span><span style="color:#75715e">// returnMallocBlock() is __NSMallocBlock__
</span><span style="color:#75715e"></span><span style="color:#75715e">// c == 10
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;Foo_4: 0x1022a7e40&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;Foo_4: 0x1022a7e40&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// ⚠️：此处 mallocBlock_1 &amp; mallocBlock_2 全局变量还没有释放，因而持有的 strongF 也没有被释放
</span></code></pre></div><ul>
<li>MRC 下，对于 <code>__NSStackBlock__</code> 类型的 Block，只要再对其执行 <code>copy</code> 操作（在 C 语言中对应为 <code>Block_Copy</code>）即可从栈区拷贝到堆区。Block 和其中捕获的自动变量将均在堆区，在主动释放前，就都可以访问到；</li>
<li>ARC 下，需要我们手动 <code>copy</code> 或者编译器会根据情况将 <code>__NSStackBlock__</code> 类型的 Block 自动 <code>copy</code> 到堆上：
<ol>
<li>强指针指向的 Block 会被自动拷贝；</li>
<li>Block 作为函数返回值会被自动拷贝；</li>
<li>Block 作为 Cocoa API 中方法名含有 <code>usingBlock</code> 的参数时会被自动拷贝；</li>
<li>Block 作为 GCD API 参数时会被自动拷贝。</li>
</ol>
</li>
<li>当拷贝到堆上后，Block 将把 <code>_NSConcreteMallocBlock</code> 类对象写入到 <code>isa</code> 中，即 <code>isa = &amp;_NSConcreteMallocBlock</code>。</li>
</ul>
<p>因此，Block 作为属性时应当使用 <code>copy</code> 或 <code>strong</code> 修饰（推荐 <code>copy</code>）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo_5</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">// MRC
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">copy</span>) <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block_1)(<span style="color:#66d9ef">void</span>);
<span style="color:#75715e">#</span><span style="color:#75715e">else</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">// ARC
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">copy</span>) <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block_2)(<span style="color:#66d9ef">void</span>);
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">strong</span>) <span style="color:#66d9ef">void</span> (<span style="color:#f92672">^</span>block_3)(<span style="color:#66d9ef">void</span>);
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo_5</span>
<span style="color:#66d9ef">@end</span>
</code></pre></div><h4 id="nsstackblock-"><code>__NSStackBlock__</code> 拷贝到堆上的细节</h4>
<p>上一节提到，ARC 下，编译器会根据情况将 <code>__NSStackBlock__</code> 类型的 Block 自动 <code>copy</code> 到堆上，那么在「拷贝」时到底会发生什么呢？</p>
<p>这里以返回一个 <code>__NSStackBlock__</code> 的函数为例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">#</span><span style="color:#75715e">if __has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span>(<span style="color:#f92672">^</span>BlockType_3)(<span style="color:#66d9ef">int</span>);

BlockType_3 <span style="color:#a6e22e">returnSomeBlock</span>(<span style="color:#66d9ef">int</span> arg) {
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">^</span>(<span style="color:#66d9ef">int</span> param){ <span style="color:#66d9ef">return</span> arg <span style="color:#f92672">*</span> param; };
}
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_13</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
<span style="color:#75715e">#</span><span style="color:#75715e">if __has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, returnSomeBlock(<span style="color:#ae81ff">10</span>));
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;__NSMallocBlock__: 0x1006baa60&gt;
</span></code></pre></div><p>虽然 <code>returnSomeBlock</code> 函数返回了一个栈上的 Block，但其实 ARC 已经为我们默默将其拷贝到堆。尝试将上述代码翻译为 C/C++ 代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">BlockType_3 <span style="color:#a6e22e">returnSomeBlock</span>(<span style="color:#66d9ef">int</span> arg) {
    <span style="color:#66d9ef">return</span> ((<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>)(<span style="color:#66d9ef">int</span>))<span style="color:#f92672">&amp;</span>__returnSomeBlock_block_impl_0((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__returnSomeBlock_block_func_0, <span style="color:#f92672">&amp;</span>__returnSomeBlock_block_desc_0_DATA, arg));
}
</code></pre></div><p>但从这里似乎并不能看到 ARC 的所作所为。通过一番查阅，ARC 是在代码生成阶段插入了 <code>retain</code> / <code>release</code> LLVM 位代码（Bitcode），所以只能选择在汇编层面一探究竟了：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">Block_in_Obj-C</span><span style="color:#960050;background-color:#1e0010">`</span><span style="color:#66d9ef">returnSomeBlock</span>:
    <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x100003390</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">0</span><span style="color:#960050;background-color:#1e0010">&gt;</span>:  <span style="color:#66d9ef">pushq</span>  %rbp
    <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x100003391</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">&gt;</span>:  <span style="color:#66d9ef">movq</span>   %rsp, %rbp
    <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x100003394</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">4</span><span style="color:#960050;background-color:#1e0010">&gt;</span>:  <span style="color:#66d9ef">subq</span>   <span style="color:#66d9ef">$0x30</span>, %rsp
    <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x100003398</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">8</span><span style="color:#960050;background-color:#1e0010">&gt;</span>:  <span style="color:#66d9ef">movl</span>   %edi, -<span style="color:#ae81ff">0x4</span>(%rbp)
<span style="color:#960050;background-color:#1e0010">-</span><span style="color:#960050;background-color:#1e0010">&gt;</span>  <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x10000339b</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">11</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">movq</span>   <span style="color:#ae81ff">0xc5e</span>(%rip), %rax         <span style="color:#75715e">; (void *)0x00007fff8dfbbe40: _NSConcreteStackBlock
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x1000033a2</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">18</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">movq</span>   %rax, -<span style="color:#ae81ff">0x28</span>(%rbp)
    <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x1000033a6</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">22</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">movl</span>   <span style="color:#66d9ef">$0xc0000000</span>, -<span style="color:#ae81ff">0x20</span>(%rbp)  <span style="color:#75715e">; imm = 0xC0000000
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x1000033ad</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">29</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">movl</span>   <span style="color:#66d9ef">$0x0</span>, -<span style="color:#ae81ff">0x1c</span>(%rbp)
    <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x1000033b4</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">36</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">leaq</span>   <span style="color:#ae81ff">0x35</span>(%rip), %rax          <span style="color:#75715e">; __returnSomeBlock_block_invoke at main.m:551
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x1000033bb</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">43</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">movq</span>   %rax, -<span style="color:#ae81ff">0x18</span>(%rbp)
    <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x1000033bf</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">47</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">leaq</span>   <span style="color:#ae81ff">0x1022</span>(%rip), %rax        <span style="color:#75715e">; __block_descriptor_36_e8_i12?0i8l
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x1000033c6</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">54</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">movq</span>   %rax, -<span style="color:#ae81ff">0x10</span>(%rbp)
    <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x1000033ca</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">58</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">movl</span>   -<span style="color:#ae81ff">0x4</span>(%rbp), %edi
    <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x1000033cd</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">61</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">movl</span>   %edi, -<span style="color:#ae81ff">0x8</span>(%rbp)
    <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x1000033d0</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">64</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">leaq</span>   -<span style="color:#ae81ff">0x28</span>(%rbp), %rdi
    <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x1000033d4</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">68</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">callq</span>  <span style="color:#ae81ff">0x100003ac0</span>               <span style="color:#75715e">; symbol stub for: objc_retainBlock
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x1000033d9</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">73</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">movq</span>   %rax, %rdi
    <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x1000033dc</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">76</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">addq</span>   <span style="color:#66d9ef">$0x30</span>, %rsp
    <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x1000033e0</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">80</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">popq</span>   %rbp
    <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x1000033e1</span> <span style="color:#960050;background-color:#1e0010">&lt;</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">81</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">jmp</span>    <span style="color:#ae81ff">0x100003a8a</span>               <span style="color:#75715e">; symbol stub for: objc_autoreleaseReturnValue
</span></code></pre></div><blockquote>
<p>如何查看 Xcode 项目的汇编代码呢？</p>
<ol>
<li>在 Block 内部打个断点，当运行至断点时，菜单栏 - Debug - Debug Workflow - Always Show Disassembly，即可自动跳转至汇编视图；</li>
<li>使用 Mac 自带的 <code>otool -tvV PRODUCT_PATH</code> 命令即可将 Xcode 编译后的二进制产物（Products 目录下）的汇编指令打印出来。</li>
</ol>
</blockquote>
<p>这里我们暂时没必要搞清楚每一条汇编指令，而是着重看一下右侧的注释 <code>objc_retainBlock</code> 和 <code>objc_autoreleaseReturnValue</code> 与 ARC 有关的指令，因此就基本可以得出 <code>returnSomeBlock</code> 在 ARC 下的伪代码（同时参考了《Objective-C 高级编程》）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">BlockType_3 <span style="color:#a6e22e">returnSomeBlock</span>(<span style="color:#66d9ef">int</span> arg) {
    <span style="color:#75715e">// 构造 Block，赋值给 tmp 变量（默认是强指针引用）
</span><span style="color:#75715e"></span>    BlockType_3 __strong tmp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>__returnSomeBlock_block_impl_0(
        __returnSomeBlock_block_func_0,
        <span style="color:#f92672">&amp;</span>__returnSomeBlock_block_desc_0_DATA,
        arg
    );
    <span style="color:#75715e">// 根据 objc4 - NSObject.mm，等同 tmp = _Block_copy(tmp);，_Block_copy 的源码 Apple 开源在 libclosure
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 将栈上的 Block 拷贝到堆上，并将堆上 Block 地址返回给 tmp 保存
</span><span style="color:#75715e"></span>    tmp <span style="color:#f92672">=</span> objc_retainBlock(tmp);
    <span style="color:#75715e">// 注册到自动释放池并返回
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> objc_autoreleaseReturnValue(tmp);
}
</code></pre></div><p>除了上述四个条件，ARC 对于 Block 并不是完全「可靠」的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">void</span>(<span style="color:#f92672">^</span>BlockType_4)(<span style="color:#66d9ef">void</span>);

NSArray <span style="color:#f92672">*</span><span style="color:#a6e22e">returnBlocksArray_1</span>() {
    <span style="color:#66d9ef">int</span> autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">return</span> [[NSArray alloc] initWithObjects:
            <span style="color:#f92672">^</span>{ NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, autoVar); },
            <span style="color:#f92672">^</span>{ NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, autoVar); },
            nil];
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_14</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    NSArray <span style="color:#f92672">*</span>arr_1 <span style="color:#f92672">=</span> returnBlocksArray_1();
    BlockType_4 block_1 <span style="color:#f92672">=</span> (BlockType_4)[arr_1 objectAtIndex:<span style="color:#ae81ff">0</span>];
    block_1();
    <span style="color:#75715e">// CRASH: EXC_BAD_ACCESS
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// block_1 = (BlockType_4)[arr_1 objectAtIndex:1];
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// 1
</span></code></pre></div><p>在使用 <code>initWithObjects:</code> API 构建 <code>NSArray</code> 数组时，编译器并没有把作为参数且放置在栈上的 Block 自动拷贝到堆上，当栈区内存空间回收后去执行 Block 从而导致了崩溃：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">NSArray <span style="color:#f92672">*</span><span style="color:#a6e22e">returnBlocksArray_2</span>() {
    <span style="color:#66d9ef">int</span> autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

    <span style="color:#75715e">// 拷贝到堆上
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> [[NSArray alloc] initWithObjects:
            [<span style="color:#f92672">^</span>{ NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, autoVar); } <span style="color:#66d9ef">copy</span>],
            [<span style="color:#f92672">^</span>{ NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, autoVar); } <span style="color:#66d9ef">copy</span>],
            nil];
}

NSArray <span style="color:#f92672">*</span><span style="color:#a6e22e">returnBlocksArray_3</span>() {
    <span style="color:#66d9ef">int</span> autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;

    <span style="color:#75715e">// 使用强指针指向
</span><span style="color:#75715e"></span>    BlockType_4 block <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{ NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, autoVar); };

    <span style="color:#66d9ef">return</span> [[NSArray alloc] initWithObjects:
            block,
            block,
            nil];
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_14</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    NSArray <span style="color:#f92672">*</span>arr_2 <span style="color:#f92672">=</span> returnBlocksArray_2();
    BlockType_4 block_2 <span style="color:#f92672">=</span> (BlockType_4)[arr_2 objectAtIndex:<span style="color:#ae81ff">0</span>];
    block_2();
    block_2 <span style="color:#f92672">=</span> (BlockType_4)[arr_2 objectAtIndex:<span style="color:#ae81ff">1</span>];
    block_2();

    NSArray <span style="color:#f92672">*</span>arr_3 <span style="color:#f92672">=</span> returnBlocksArray_3();
    BlockType_4 block_3 <span style="color:#f92672">=</span> (BlockType_4)[arr_3 objectAtIndex:<span style="color:#ae81ff">0</span>];
    block_3();
    block_3 <span style="color:#f92672">=</span> (BlockType_4)[arr_3 objectAtIndex:<span style="color:#ae81ff">1</span>];
    block_3();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// 10
</span><span style="color:#75715e"></span><span style="color:#75715e">// 10
</span><span style="color:#75715e"></span><span style="color:#75715e">// 100
</span><span style="color:#75715e"></span><span style="color:#75715e">// 100
</span></code></pre></div><p>即使在 ARC 下，我们有时也需要手动调用 <code>copy</code> 将 Block 拷贝至堆上或使用强指针指向，而对同一个 Block 多次 <code>copy</code> 会有什么问题么？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_14</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">int</span> autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    BlockType_4 block_4 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{ NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, autoVar); };
    block_4 <span style="color:#f92672">=</span> [[[block_4 <span style="color:#66d9ef">copy</span>] <span style="color:#66d9ef">copy</span>] <span style="color:#66d9ef">copy</span>];

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%ld</span><span style="color:#e6db74">&#34;</span>, CFGetRetainCount((<span style="color:#66d9ef">__bridge</span> CFTypeRef)(block_4)));

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// 1
</span></code></pre></div><p>其实只有第一次 <code>copy</code> 时，栈上的 Block 将被拷贝至堆上一份，后续的 <code>copy</code> 则是对堆上的拷贝进行拷贝，即仅仅递增引用计数。如 <code>block_4 = [[[block_4 copy] copy] copy];</code> 则最终仍只有 <code>block_4</code> 指向堆上的 Block，因此其引用计数仍为 <code>1</code>。</p>
<p>不同于基础类型，对于对象类型的自动变量总是更多地涉及到内存管理方面：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo_6</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo_6</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">dealloc</span>
{
    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">dealloc</span><span style="color:#e6db74">&#34;</span>);
}
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">int</span> main_15(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    Foo_6 <span style="color:#f92672">*</span>strongF <span style="color:#f92672">=</span> [[Foo_6 alloc] init];

    <span style="color:#66d9ef">__weak</span> Foo_6 <span style="color:#f92672">*</span>weakF <span style="color:#f92672">=</span> strongF;

    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">^</span>someBlcok)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, strongF);
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, weakF);
    };

    someBlcok();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;Foo_6: 0x1007ab750&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;Foo_6: 0x1007ab750&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span></code></pre></div><p>将上述翻译为 C/C++ 代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_15_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_15_block_desc_0</span><span style="color:#f92672">*</span> Desc;
  Foo_6 <span style="color:#f92672">*</span>__strong strongF; <span style="color:#75715e">// 默认强引用
</span><span style="color:#75715e"></span>  Foo_6 <span style="color:#f92672">*</span>__weak weakF;     <span style="color:#75715e">// 显式弱引用
</span><span style="color:#75715e"></span>  __main_15_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_15_block_desc_0</span> <span style="color:#f92672">*</span>desc, Foo_6 <span style="color:#f92672">*</span>__strong _strongF, Foo_6 <span style="color:#f92672">*</span>__weak _weakF, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> strongF(_strongF), weakF(_weakF) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_15_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_15_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {
  Foo_6 <span style="color:#f92672">*</span>__strong strongF <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>strongF; <span style="color:#75715e">// bound by copy
</span><span style="color:#75715e"></span>  Foo_6 <span style="color:#f92672">*</span>__weak weakF <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>weakF; <span style="color:#75715e">// bound by copy
</span><span style="color:#75715e"></span>
  NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_e96639_mi_49, strongF);
  NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_e96639_mi_50, weakF);
}

<span style="color:#75715e">// 栈上的 Block 拷贝到堆时，会调用 __main_block_copy_0 方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_15_block_copy_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_15_block_impl_0</span><span style="color:#f92672">*</span>dst, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_15_block_impl_0</span><span style="color:#f92672">*</span>src) {
    <span style="color:#75715e">// _Block_object_assign 函数会根据自动变量的修饰符（__strong / __weak）作出相应的操作，形成强引用或弱引用（类似 Retain，将对象赋值在对象类型的结构体成员变量中）
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// BLOCK_FIELD_IS_OBJECT 为 flags，函数内部根据此参数决定相应的处理逻辑；该 flag 对应为 _Block_retain_object
</span><span style="color:#75715e"></span>    _Block_object_assign((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>dst<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>strongF, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>strongF, <span style="color:#ae81ff">3</span><span style="color:#75715e">/*BLOCK_FIELD_IS_OBJECT*/</span>); <span style="color:#75715e">// 对外界 strongF 强引用
</span><span style="color:#75715e"></span>    _Block_object_assign((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>dst<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>weakF, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>weakF, <span style="color:#ae81ff">3</span><span style="color:#75715e">/*BLOCK_FIELD_IS_OBJECT*/</span>);     <span style="color:#75715e">// 对外界 weakF 弱引用
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// _Block_object_assign 的源码 Apple 开源在 libclosure，此处暂略
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 堆上的 Block 销毁时，会调用 __main_15_block_dispose_0 方法，类似对象的 dealloc 方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_15_block_dispose_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_15_block_impl_0</span><span style="color:#f92672">*</span>src) {
    <span style="color:#75715e">// _Block_object_dispose 函数使得自动变量的引用计数减一（类似 Release，释放赋值在对象类型的结构体成员变量中的对象）
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// BLOCK_FIELD_IS_OBJECT 对应为 _Block_release_object(object);
</span><span style="color:#75715e"></span>    _Block_object_dispose((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>strongF, <span style="color:#ae81ff">3</span><span style="color:#75715e">/*BLOCK_FIELD_IS_OBJECT*/</span>);
    _Block_object_dispose((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>weakF, <span style="color:#ae81ff">3</span><span style="color:#75715e">/*BLOCK_FIELD_IS_OBJECT*/</span>);
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_15_block_desc_0</span> {
  size_t reserved;
  size_t Block_size;
  <span style="color:#75715e">// 当在 Block 中访问对象类型的自动变量时会增加额外的域来协助管理内存
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>copy)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_15_block_impl_0</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_15_block_impl_0</span><span style="color:#f92672">*</span>);
  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>dispose)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_15_block_impl_0</span><span style="color:#f92672">*</span>);
} __main_15_block_desc_0_DATA <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_15_block_impl_0</span>), __main_15_block_copy_0, __main_15_block_dispose_0};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_15</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    Foo_6 <span style="color:#f92672">*</span>strongF <span style="color:#f92672">=</span> ((Foo_6 <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)((Foo_6 <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)objc_getClass(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Foo_6</span><span style="color:#e6db74">&#34;</span>), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">alloc</span><span style="color:#e6db74">&#34;</span>)), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">init</span><span style="color:#e6db74">&#34;</span>));

    __attribute__((objc_ownership(weak))) Foo_6 <span style="color:#f92672">*</span>weakF <span style="color:#f92672">=</span> strongF;

    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>someBlcok)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__main_15_block_impl_0((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__main_15_block_func_0, <span style="color:#f92672">&amp;</span>__main_15_block_desc_0_DATA, strongF, weakF, <span style="color:#ae81ff">570425344</span>));

    ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(__block_impl <span style="color:#f92672">*</span>))((__block_impl <span style="color:#f92672">*</span>)someBlcok)<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>FuncPtr)((__block_impl <span style="color:#f92672">*</span>)someBlcok);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="block"><code>__block</code></h2>
<h3 id="heading7">本质</h3>
<p>上面的例子中 Block 内部只是访问了外界的变量，接下来我们尝试下在 Block 内修改变量值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// 静态全局变量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> staticGlobalVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#75715e">// 全局变量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> globalVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_16</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#75715e">// 自动变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#75715e">// 静态变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> staticVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">auto</span> NSMutableArray <span style="color:#f92672">*</span>autoArray <span style="color:#f92672">=</span> [[NSMutableArray alloc] init];

    <span style="color:#f92672">^</span>{
        <span style="color:#75715e">// ERROR: Variable is not assignable (missing __block type specifier)
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// autoVar = 10;
</span><span style="color:#75715e"></span>
        staticVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
        staticGlobalVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
        globalVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

        [autoArray addObject:<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">kingcos.me</span><span style="color:#e6db74">&#34;</span>];

        <span style="color:#75715e">// ERROR: Variable is not assignable (missing __block type specifier)
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// autoArray = [[NSMutableArray alloc] init];
</span><span style="color:#75715e"></span>    }();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>对于局部静态变量和全局静态变量，Block 内可以直接修改这些变量的值。而对于自动变量编译器则会报错 <code>Variable is not assignable (missing __block type specifier)</code>（变量未分配（丢失 <code>__block</code> 类型限定符）），那么这里的 <code>__block</code> 是什么呢？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_17</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">^</span>block1)(<span style="color:#66d9ef">void</span>);
    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">^</span>block2)(<span style="color:#66d9ef">void</span>);

    {
        <span style="color:#66d9ef">__block</span> <span style="color:#66d9ef">int</span> autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">__block</span> <span style="color:#66d9ef">auto</span> NSMutableArray <span style="color:#f92672">*</span>autoArray <span style="color:#f92672">=</span> [[NSMutableArray alloc] init];

        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">autoVar = %d</span><span style="color:#e6db74">&#34;</span>, autoVar);

        block1 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
            autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
            autoArray <span style="color:#f92672">=</span> [[NSMutableArray alloc] init];

            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">autoVar = %d</span><span style="color:#e6db74">&#34;</span>, autoVar);
        };

        block2 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
            autoVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;

            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">autoVar = %d</span><span style="color:#e6db74">&#34;</span>, autoVar);
        };

        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">autoVar = %d</span><span style="color:#e6db74">&#34;</span>, autoVar);
    }

    block1();
    block2();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// autoVar = 1
</span><span style="color:#75715e"></span><span style="color:#75715e">// autoVar = 1
</span><span style="color:#75715e"></span><span style="color:#75715e">// autoVar = 10
</span><span style="color:#75715e"></span><span style="color:#75715e">// autoVar = 20
</span></code></pre></div><p>如上，使用 <code>__block</code> 修饰的自动变量，在 Block 内部确实可以修改，尝试将以上代码翻译为 C++：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 将自动变量包装的结构体
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Block_byref_autoVar_0</span> {
  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>__isa; <span style="color:#75715e">// 标志着这是个 Obj-C 对象
</span><span style="color:#75715e"></span>__Block_byref_autoVar_0 <span style="color:#f92672">*</span>__forwarding; <span style="color:#75715e">// 结构体本身的地址
</span><span style="color:#75715e"></span> <span style="color:#66d9ef">int</span> __flags; <span style="color:#75715e">// 标志位
</span><span style="color:#75715e"></span> <span style="color:#66d9ef">int</span> __size;  <span style="color:#75715e">// sizeof 结构体的大小
</span><span style="color:#75715e"></span> <span style="color:#66d9ef">int</span> autoVar; <span style="color:#75715e">// 自动变量，初始化时赋值
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Block_byref_autoArray_1</span> {
  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>__isa;
__Block_byref_autoArray_1 <span style="color:#f92672">*</span>__forwarding;
 <span style="color:#66d9ef">int</span> __flags;
 <span style="color:#66d9ef">int</span> __size;
 <span style="color:#75715e">// 内存管理方法
</span><span style="color:#75715e"></span> <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>__Block_byref_id_object_copy)(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>);
 <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>__Block_byref_id_object_dispose)(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>);
  NSMutableArray <span style="color:#f92672">*</span>__strong autoArray; <span style="color:#75715e">// 对象类型的自动变量
</span><span style="color:#75715e"></span>};

<span style="color:#75715e">// Block 结构体
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_desc_0</span><span style="color:#f92672">*</span> Desc;
  <span style="color:#75715e">// 不使用 __block 时为 int autoVar;，此时为指向 __Block_byref_autoVar_0 的指针
</span><span style="color:#75715e"></span>  __Block_byref_autoVar_0 <span style="color:#f92672">*</span>autoVar; <span style="color:#75715e">// by ref
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 不使用 __block 时为 NSMutableArray *autoArray;，此时为指向 __Block_byref_autoArray_1 的指针
</span><span style="color:#75715e"></span>  __Block_byref_autoArray_1 <span style="color:#f92672">*</span>autoArray; <span style="color:#75715e">// by ref
</span><span style="color:#75715e"></span>  __main_17_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_5_block_desc_0</span> <span style="color:#f92672">*</span>desc, __Block_byref_autoVar_0 <span style="color:#f92672">*</span>_autoVar, __Block_byref_autoArray_1 <span style="color:#f92672">*</span>_autoArray, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> autoVar(_autoVar<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding), autoArray(_autoArray<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_17_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {
  <span style="color:#75715e">// 指向结构体的指针
</span><span style="color:#75715e"></span>  __Block_byref_autoVar_0 <span style="color:#f92672">*</span>autoVar <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar; <span style="color:#75715e">// bound by ref
</span><span style="color:#75715e"></span>  __Block_byref_autoArray_1 <span style="color:#f92672">*</span>autoArray <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoArray; <span style="color:#75715e">// bound by ref
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// 通过指向自身的指针改变了值
</span><span style="color:#75715e"></span>  (autoVar<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar) <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
  (autoArray<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoArray) <span style="color:#f92672">=</span> ((NSMutableArray <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)((NSMutableArray <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)objc_getClass(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">NSMutableArray</span><span style="color:#e6db74">&#34;</span>), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">alloc</span><span style="color:#e6db74">&#34;</span>)), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">init</span><span style="color:#e6db74">&#34;</span>));
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_17_block_copy_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_impl_0</span><span style="color:#f92672">*</span>dst, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_impl_0</span><span style="color:#f92672">*</span>src) {
    _Block_object_assign((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>dst<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);
    _Block_object_assign((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>dst<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoArray, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoArray, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_17_block_dispose_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_impl_0</span><span style="color:#f92672">*</span>src) {
    _Block_object_dispose((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);
    _Block_object_dispose((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoArray, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_desc_0</span> {
  size_t reserved;
  size_t Block_size;
  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>copy)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_impl_0</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_impl_0</span><span style="color:#f92672">*</span>);
  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>dispose)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_impl_0</span><span style="color:#f92672">*</span>);
} __main_17_block_desc_0_DATA <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_impl_0</span>), __main_17_block_copy_0, __main_17_block_dispose_0};

<span style="color:#75715e">// 第二个 Block
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_impl_1</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_desc_1</span><span style="color:#f92672">*</span> Desc;
  __Block_byref_autoVar_0 <span style="color:#f92672">*</span>autoVar; <span style="color:#75715e">// by ref
</span><span style="color:#75715e"></span>  __main_17_block_impl_1(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_desc_1</span> <span style="color:#f92672">*</span>desc, __Block_byref_autoVar_0 <span style="color:#f92672">*</span>_autoVar, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> autoVar(_autoVar<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_17_block_func_1</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_impl_1</span> <span style="color:#f92672">*</span>__cself) {
  __Block_byref_autoVar_0 <span style="color:#f92672">*</span>autoVar <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar; <span style="color:#75715e">// bound by ref
</span><span style="color:#75715e"></span>
  (autoVar<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar) <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_17_block_copy_1</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_impl_1</span><span style="color:#f92672">*</span>dst, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_impl_1</span><span style="color:#f92672">*</span>src) {
    _Block_object_assign((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>dst<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_17_block_dispose_1</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_impl_1</span><span style="color:#f92672">*</span>src) {
    _Block_object_dispose((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_desc_1</span> {
  size_t reserved;
  size_t Block_size;
  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>copy)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_impl_1</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_impl_1</span><span style="color:#f92672">*</span>);
  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>dispose)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_impl_1</span><span style="color:#f92672">*</span>);
} __main_17_block_desc_1_DATA <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_17_block_impl_1</span>), __main_17_block_copy_1, __main_17_block_dispose_1};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_17</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>block1)(<span style="color:#66d9ef">void</span>);
    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>block2)(<span style="color:#66d9ef">void</span>);

    {
        <span style="color:#75715e">// 初始化 __Block_byref_autoVar_0 结构体，将 autoVar 的地址赋值给结构体中的 __forwarding 指针
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// __Block_byref_autoVar_0 autoVar = {0, &amp;autoVar, 0, sizeof(__Block_byref_autoVar_0), 0（初始值）}
</span><span style="color:#75715e"></span>        __attribute__((__blocks__(byref))) __Block_byref_autoVar_0 autoVar <span style="color:#f92672">=</span> {(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#ae81ff">0</span>,(__Block_byref_autoVar_0 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>autoVar, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(__Block_byref_autoVar_0), <span style="color:#ae81ff">0</span>};

        <span style="color:#75715e">// 初始化 __Block_byref_autoArray_1 结构体，将 autoArray 的地址赋值给结构体中的 __forwarding 指针
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// __Block_byref_autoArray_1 autoArray = {0, &amp;autoArray, 33554432, sizeof(__Block_byref_autoArray_1), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, NSMutableArray（初始值）}
</span><span style="color:#75715e"></span>        __attribute__((__blocks__(byref))) <span style="color:#66d9ef">auto</span> __Block_byref_autoArray_1 autoArray <span style="color:#f92672">=</span> {(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#ae81ff">0</span>,(__Block_byref_autoArray_1 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>autoArray, <span style="color:#ae81ff">33554432</span>, <span style="color:#66d9ef">sizeof</span>(__Block_byref_autoArray_1), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSMutableArray <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)((NSMutableArray <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)objc_getClass(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">NSMutableArray</span><span style="color:#e6db74">&#34;</span>), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">alloc</span><span style="color:#e6db74">&#34;</span>)), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">init</span><span style="color:#e6db74">&#34;</span>))};

        <span style="color:#75715e">// 外界通过 __forwarding 访问 __block 变量
</span><span style="color:#75715e"></span>        NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_8f352d_mi_52, (autoVar.__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar));

        <span style="color:#75715e">// 忽略类型转换：block1 = &amp;__main_17_block_impl_0(__main_17_block_func_0, &amp;__main_17_block_desc_0_DATA, &amp;autoVar, &amp;autoArray, 570425344);
</span><span style="color:#75715e"></span>        block1 <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__main_17_block_impl_0((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__main_17_block_func_0, <span style="color:#f92672">&amp;</span>__main_17_block_desc_0_DATA, (__Block_byref_autoVar_0 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>autoVar, (__Block_byref_autoArray_1 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>autoArray, <span style="color:#ae81ff">570425344</span>));

        <span style="color:#75715e">// 忽略类型转换：block2 = &amp;__main_17_block_impl_1(__main_17_block_func_1, &amp;___main_17_block_desc_1_DATA, &amp;autoVar, 570425344);
</span><span style="color:#75715e"></span>        block2 <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__main_17_block_impl_1((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__main_17_block_func_1, <span style="color:#f92672">&amp;</span>__main_17_block_desc_1_DATA, (__Block_byref_autoVar_0 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>autoVar, <span style="color:#ae81ff">570425344</span>));

        <span style="color:#75715e">// 外界通过 __forwarding 访问 __block 变量
</span><span style="color:#75715e"></span>        NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_8f352d_mi_55, (autoVar.__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>autoVar));
    }

    ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(__block_impl <span style="color:#f92672">*</span>))((__block_impl <span style="color:#f92672">*</span>)block1)<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>FuncPtr)((__block_impl <span style="color:#f92672">*</span>)block1);
    ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(__block_impl <span style="color:#f92672">*</span>))((__block_impl <span style="color:#f92672">*</span>)block2)<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>FuncPtr)((__block_impl <span style="color:#f92672">*</span>)block2);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><code>__block</code> 将 <code>autoVar</code> 封装到 <code>__Block_byref_autoVar_0</code> 结构体中，将 <code>autoArray</code> 封装到 <code>__Block_byref_autoArray_1</code> 结构体中，其中的 <code>isa</code> 指针标志着该结构体本质也属于 Obj-C 对象；<code>__forwarding</code> 指针指向了该结构体本身，在初始化时被赋值为声明的结构体的地址；<code>__size</code> 为该结构体的大小信息；<code>autoVar</code> 和 <code>autoArray</code> 为捕获的变量本身。因此捕获了 <code>__block</code> 变量的 Block 结构如下图所示：</p>
<p><img src="/img/2019/block_in_obj-c/4.png" alt="4"></p>
<h3 id="forwarding"><code>__forwarding</code></h3>
<p>当 Block 被分配在栈上时，其内部使用到的 <code>__block</code> 变量也会被分配在栈上；当 Block 超出作用域被销毁时，<code>__block</code> 变量则也会被销毁。当 Block 从栈拷贝到堆上时，其内部使用到的 <code>__block</code> 变量也会同时被拷贝到堆上，并被堆上的 Block 持有。当多个 Block 使用同一个 <code>__block</code> 变量时，第一个被拷贝到堆上的 Block 会将其同时拷贝到堆上并被该 Block 持有；当其它 Block 被拷贝到堆上后，将持有该变量，引用计数递增。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_18</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">^</span>block1)(<span style="color:#66d9ef">void</span>);
    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">^</span>block2)(<span style="color:#66d9ef">void</span>);

    {
        <span style="color:#75715e">// 声明 __block 变量 blockVar
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">__block</span> <span style="color:#66d9ef">int</span> blockVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

        <span style="color:#75715e">// blockVar 默认在栈上
</span><span style="color:#75715e"></span>        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">1 - %p</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>blockVar); <span style="color:#75715e">// 1 - 0x7ffeefbff3d8
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">// 栈上的 Block 捕获，Block 本身在栈上
</span><span style="color:#75715e"></span>        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">2 - %p</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">^</span>{
            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%p</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>blockVar);
        }); <span style="color:#75715e">// 2 - 0x7ffeefbff388
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">// 栈上的 Block 捕获对 blockVar 无影响
</span><span style="color:#75715e"></span>        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">3 - %p</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>blockVar); <span style="color:#75715e">// 3 - 0x7ffeefbff3d8
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">// 栈上的 Block 捕获并执行
</span><span style="color:#75715e"></span>        <span style="color:#f92672">^</span>{
            <span style="color:#75715e">// 捕获的 blockVar 仍在栈上
</span><span style="color:#75715e"></span>            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">4 - %p</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>blockVar); <span style="color:#75715e">// 4 - 0x7ffeefbff3d8
</span><span style="color:#75715e"></span>        }();

        <span style="color:#75715e">// 栈上的 Block 执行对 blockVar 无影响
</span><span style="color:#75715e"></span>        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">5 - %p</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>blockVar);

        <span style="color:#75715e">// 栈上的 Block 被强指针引用，将拷贝至堆上
</span><span style="color:#75715e"></span>        block1 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
            <span style="color:#75715e">// 捕获的 blockVar 也在堆上
</span><span style="color:#75715e"></span>            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">6 - %p</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>blockVar); <span style="color:#75715e">// 6 - 0x100500eb8
</span><span style="color:#75715e"></span>        };

        <span style="color:#75715e">// 此时 blockVar 已被拷贝至堆上
</span><span style="color:#75715e"></span>        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">7 - %p</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>blockVar); <span style="color:#75715e">// 7 - 0x100500eb8
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">// block1 在堆上
</span><span style="color:#75715e"></span>        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">8 - %p</span><span style="color:#e6db74">&#34;</span>, block1); <span style="color:#75715e">// 8 - 0x100500bb0
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">// 另一个栈上的 Block 捕获并执行
</span><span style="color:#75715e"></span>        <span style="color:#f92672">^</span>{
            <span style="color:#75715e">// 捕获的 blockVar 也在堆上
</span><span style="color:#75715e"></span>            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">9 - %p</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>blockVar); <span style="color:#75715e">// 9 - 0x100500eb8
</span><span style="color:#75715e"></span>        }();

        <span style="color:#75715e">// blockVar 再次被栈上 Block 捕获，此时仍在堆上
</span><span style="color:#75715e"></span>        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">10 - %p</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>blockVar); <span style="color:#75715e">// 10 - 0x100500eb8
</span><span style="color:#75715e"></span>
        block1();

        <span style="color:#75715e">// blockVar 此时仍在堆上
</span><span style="color:#75715e"></span>        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">11 - %p</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>blockVar); <span style="color:#75715e">// 11 - 0x100701f18
</span><span style="color:#75715e"></span>
        <span style="color:#75715e">// 第二个栈上的 Block 被强指针引用，拷贝至堆上
</span><span style="color:#75715e"></span>        block2 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
            <span style="color:#75715e">// 捕获的 blockVar 也在堆上
</span><span style="color:#75715e"></span>            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">12 - %p</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>blockVar); <span style="color:#75715e">// 12 - 0x100701f18
</span><span style="color:#75715e"></span>        };

        <span style="color:#75715e">// blockVar 再次被堆上 Block 捕获，此时仍在堆上
</span><span style="color:#75715e"></span>        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">13 - %p</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>blockVar); <span style="color:#75715e">// 13 - 0x100701f18
</span><span style="color:#75715e"></span>    }

    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">14 - %p</span><span style="color:#e6db74">&#34;</span>, block1); <span style="color:#75715e">// 14 - 0x100500bb0
</span><span style="color:#75715e"></span>    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">15 - %p</span><span style="color:#e6db74">&#34;</span>, block2); <span style="color:#75715e">// 15 - 0x100500940
</span><span style="color:#75715e"></span>
    block1();
    block2();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>将上述翻译为 C/C++ 代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_18_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_18_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {
  __Block_byref_blockVar_2 <span style="color:#f92672">*</span>blockVar <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>blockVar; <span style="color:#75715e">// bound by ref
</span><span style="color:#75715e"></span>
  NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_58, <span style="color:#f92672">&amp;</span>(blockVar<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>blockVar));
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_18_block_func_1</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_18_block_impl_1</span> <span style="color:#f92672">*</span>__cself) {
  __Block_byref_blockVar_2 <span style="color:#f92672">*</span>blockVar <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>blockVar; <span style="color:#75715e">// bound by ref
</span><span style="color:#75715e"></span>
  NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_60, <span style="color:#f92672">&amp;</span>(blockVar<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>blockVar));
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_18_block_func_2</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_18_block_impl_2</span> <span style="color:#f92672">*</span>__cself) {
  __Block_byref_blockVar_2 <span style="color:#f92672">*</span>blockVar <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>blockVar; <span style="color:#75715e">// bound by ref
</span><span style="color:#75715e"></span>
  NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_62, <span style="color:#f92672">&amp;</span>(blockVar<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>blockVar));
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_18</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>block1)(<span style="color:#66d9ef">void</span>);
    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>block2)(<span style="color:#66d9ef">void</span>);

    {
        __attribute__((__blocks__(byref))) __Block_byref_blockVar_2 blockVar <span style="color:#f92672">=</span> {(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#ae81ff">0</span>,(__Block_byref_blockVar_2 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>blockVar, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(__Block_byref_blockVar_2), <span style="color:#ae81ff">10</span>};

        <span style="color:#75715e">// blockVar.__forwarding-&gt;blockVar
</span><span style="color:#75715e"></span>        NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_56, <span style="color:#f92672">&amp;</span>(blockVar.__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>blockVar));


        NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_57, ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__main_18_block_impl_0((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__main_18_block_func_0, <span style="color:#f92672">&amp;</span>__main_18_block_desc_0_DATA, (__Block_byref_blockVar_2 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>blockVar, <span style="color:#ae81ff">570425344</span>)));

        NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_59, <span style="color:#f92672">&amp;</span>(blockVar.__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>blockVar));


        ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__main_18_block_impl_1((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__main_18_block_func_1, <span style="color:#f92672">&amp;</span>__main_18_block_desc_1_DATA, (__Block_byref_blockVar_2 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>blockVar, <span style="color:#ae81ff">570425344</span>))();


        NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_61, <span style="color:#f92672">&amp;</span>(blockVar.__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>blockVar));


        block1 <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__main_18_block_impl_2((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__main_18_block_func_2, <span style="color:#f92672">&amp;</span>__main_18_block_desc_2_DATA, (__Block_byref_blockVar_2 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>blockVar, <span style="color:#ae81ff">570425344</span>));


        NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_63, <span style="color:#f92672">&amp;</span>(blockVar.__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>blockVar));


        NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_64, block1);


        ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__main_18_block_impl_3((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__main_18_block_func_3, <span style="color:#f92672">&amp;</span>__main_18_block_desc_3_DATA, (__Block_byref_blockVar_2 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>blockVar, <span style="color:#ae81ff">570425344</span>))();


        NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_66, <span style="color:#f92672">&amp;</span>(blockVar.__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>blockVar));

        ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(__block_impl <span style="color:#f92672">*</span>))((__block_impl <span style="color:#f92672">*</span>)block1)<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>FuncPtr)((__block_impl <span style="color:#f92672">*</span>)block1);


        NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_67, <span style="color:#f92672">&amp;</span>(blockVar.__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>blockVar));


        block2 <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__main_18_block_impl_4((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__main_18_block_func_4, <span style="color:#f92672">&amp;</span>__main_18_block_desc_4_DATA, (__Block_byref_blockVar_2 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>blockVar, <span style="color:#ae81ff">570425344</span>));


        NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_69, <span style="color:#f92672">&amp;</span>(blockVar.__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>blockVar));
    }

    NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_70, block1);
    NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ed7da6_mi_71, block2);

    ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(__block_impl <span style="color:#f92672">*</span>))((__block_impl <span style="color:#f92672">*</span>)block1)<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>FuncPtr)((__block_impl <span style="color:#f92672">*</span>)block1);
    ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(__block_impl <span style="color:#f92672">*</span>))((__block_impl <span style="color:#f92672">*</span>)block2)<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>FuncPtr)((__block_impl <span style="color:#f92672">*</span>)block2);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>由上我们可以看出，<code>__block</code> 变量从声明后，无论在 Block 内外去访问均是通过结构体的 <code>__forwarding</code> 指针即 <code>blockVar.__forwarding-&gt;blockVar</code>。当 <code>__block</code> 变量在栈上时，<code>blockVar.__forwarding-&gt;blockVar</code> 就等同于直接通过 <code>blockVar-&gt;blockVar</code> 来访问的，因为此时 <code>__forwarding</code> 就指向栈上的结构体本身；而当 Block 拷贝到堆上时，<code>__block</code> 变量也会被拷贝到堆上，此时栈上的 <code>__forwarding</code> 将替换为指向堆上的结构体，而堆上的结构体里的 <code>__forwarding</code> 将指向堆上的结构体本身，从而保证后续的数据变动均是在堆上。</p>
<p>因此 <code>__forwarding</code> 存在的意义是无论 <code>__block</code> 配置在栈上还是堆上都能正确地访问 <code>__block</code> 变量。</p>
<h3 id="heading8">内存管理</h3>
<p>对于对象类型的 <code>__block</code> 变量自然也会更多涉及到内存管理方面：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo_7</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">assign</span>) <span style="color:#66d9ef">int</span> bar;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo_7</span>
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">int</span> main_19(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">__block</span> Foo_7 <span style="color:#f92672">*</span>strongF <span style="color:#f92672">=</span> [[Foo_7 alloc] init];
    strongF.bar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

    <span style="color:#66d9ef">__block</span> <span style="color:#66d9ef">__weak</span> Foo_7 <span style="color:#f92672">*</span>weakF <span style="color:#f92672">=</span> strongF;

    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">^</span>block)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)weakF.bar);
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)strongF.bar);

        strongF <span style="color:#f92672">=</span> [Foo_7 new];
        strongF.bar <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)strongF.bar);
    };

    block();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// 10
</span><span style="color:#75715e"></span><span style="color:#75715e">// 10
</span><span style="color:#75715e"></span><span style="color:#75715e">// 100
</span></code></pre></div><p>将上述翻译为 C/C++ 代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Block_byref_strongF_3</span> {
  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>__isa;
__Block_byref_strongF_3 <span style="color:#f92672">*</span>__forwarding;
 <span style="color:#66d9ef">int</span> __flags;
 <span style="color:#66d9ef">int</span> __size;
 <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>__Block_byref_id_object_copy)(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>); <span style="color:#75715e">// 内存管理域
</span><span style="color:#75715e"></span> <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>__Block_byref_id_object_dispose)(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>);     <span style="color:#75715e">// 内存管理域
</span><span style="color:#75715e"></span> Foo_7 <span style="color:#f92672">*</span>__strong strongF; <span style="color:#75715e">// 根据外界强引用而强引用
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__Block_byref_weakF_4</span> {
  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>__isa;
__Block_byref_weakF_4 <span style="color:#f92672">*</span>__forwarding;
 <span style="color:#66d9ef">int</span> __flags;
 <span style="color:#66d9ef">int</span> __size;
 <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>__Block_byref_id_object_copy)(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>); <span style="color:#75715e">// 内存管理域
</span><span style="color:#75715e"></span> <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>__Block_byref_id_object_dispose)(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>);     <span style="color:#75715e">// 内存管理域
</span><span style="color:#75715e"></span> Foo_7 <span style="color:#f92672">*</span>__weak weakF; <span style="color:#75715e">// 根据外界弱引用而弱引用
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_19_block_impl_0</span> {
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__block_impl</span> impl;
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_19_block_desc_0</span><span style="color:#f92672">*</span> Desc;
  <span style="color:#75715e">// 引用 __block 变量的结构体，但这里均为强指针，不受外界改变
</span><span style="color:#75715e"></span>  __Block_byref_weakF_4 <span style="color:#f92672">*</span>weakF; <span style="color:#75715e">// by ref
</span><span style="color:#75715e"></span>  __Block_byref_strongF_3 <span style="color:#f92672">*</span>strongF; <span style="color:#75715e">// by ref
</span><span style="color:#75715e"></span>  __main_19_block_impl_0(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>fp, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_19_block_desc_0</span> <span style="color:#f92672">*</span>desc, __Block_byref_weakF_4 <span style="color:#f92672">*</span>_weakF, __Block_byref_strongF_3 <span style="color:#f92672">*</span>_strongF, <span style="color:#66d9ef">int</span> flags<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> weakF(_weakF<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding), strongF(_strongF<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding) {
    impl.isa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>_NSConcreteStackBlock;
    impl.Flags <span style="color:#f92672">=</span> flags;
    impl.FuncPtr <span style="color:#f92672">=</span> fp;
    Desc <span style="color:#f92672">=</span> desc;
  }
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_19_block_func_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_19_block_impl_0</span> <span style="color:#f92672">*</span>__cself) {
  __Block_byref_weakF_4 <span style="color:#f92672">*</span>weakF <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>weakF; <span style="color:#75715e">// bound by ref
</span><span style="color:#75715e"></span>  __Block_byref_strongF_3 <span style="color:#f92672">*</span>strongF <span style="color:#f92672">=</span> __cself<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>strongF; <span style="color:#75715e">// bound by ref
</span><span style="color:#75715e"></span>
  NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ee0da7_mi_72, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)((<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)(weakF<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>weakF), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">bar</span><span style="color:#e6db74">&#34;</span>)));
  NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ee0da7_mi_73, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)((<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)(strongF<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>strongF), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">bar</span><span style="color:#e6db74">&#34;</span>)));

  (strongF<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>strongF) <span style="color:#f92672">=</span> ((Foo_7 <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)objc_getClass(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Foo_7</span><span style="color:#e6db74">&#34;</span>), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">new</span><span style="color:#e6db74">&#34;</span>));
  ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(id, SEL, <span style="color:#66d9ef">int</span>))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)(strongF<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>strongF), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">setBar:</span><span style="color:#e6db74">&#34;</span>), <span style="color:#ae81ff">100</span>);
  NSLog((NSString <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_ee0da7_mi_74, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)((<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)(strongF<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>strongF), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">bar</span><span style="color:#e6db74">&#34;</span>)));
}

<span style="color:#75715e">// 栈上的 Block 拷贝到堆时，会调用 __main_19_block_copy_0 方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_19_block_copy_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_19_block_impl_0</span><span style="color:#f92672">*</span>dst, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_19_block_impl_0</span><span style="color:#f92672">*</span>src) {
    <span style="color:#75715e">// _Block_object_assign 将对 strongF &amp; weakF 形成强引用（Retain）
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// BLOCK_FIELD_IS_BYREF flag 对应为 _Block_byref_copy
</span><span style="color:#75715e"></span>    _Block_object_assign((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>dst<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>weakF, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>weakF, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);
    _Block_object_assign((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>dst<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>strongF, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>strongF, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);
}

<span style="color:#75715e">// 堆上的 Block 销毁时，会调用 __main_19_block_dispose_0 方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__main_19_block_dispose_0</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_19_block_impl_0</span><span style="color:#f92672">*</span>src) {
    <span style="color:#75715e">// _Block_object_dispose 将释放 strongF &amp; weakF （Release）
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// BLOCK_FIELD_IS_BYREF flag 对应为 _Block_byref_release
</span><span style="color:#75715e"></span>    _Block_object_dispose((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>weakF, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);
    _Block_object_dispose((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)src<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>strongF, <span style="color:#ae81ff">8</span><span style="color:#75715e">/*BLOCK_FIELD_IS_BYREF*/</span>);
}

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_19_block_desc_0</span> {
  size_t reserved;
  size_t Block_size;
  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>copy)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_19_block_impl_0</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_19_block_impl_0</span><span style="color:#f92672">*</span>);
  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>dispose)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_19_block_impl_0</span><span style="color:#f92672">*</span>);
} __main_19_block_desc_0_DATA <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__main_19_block_impl_0</span>), __main_19_block_copy_0, __main_19_block_dispose_0};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_19</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    __attribute__((__blocks__(byref))) __Block_byref_strongF_3 strongF <span style="color:#f92672">=</span> {(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#ae81ff">0</span>,(__Block_byref_strongF_3 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>strongF, <span style="color:#ae81ff">33554432</span>, <span style="color:#66d9ef">sizeof</span>(__Block_byref_strongF_3), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((Foo_7 <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)((Foo_7 <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>)(id, SEL))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)objc_getClass(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Foo_7</span><span style="color:#e6db74">&#34;</span>), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">alloc</span><span style="color:#e6db74">&#34;</span>)), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">init</span><span style="color:#e6db74">&#34;</span>))};
    ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(id, SEL, <span style="color:#66d9ef">int</span>))(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)objc_msgSend)((id)(strongF.__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>strongF), sel_registerName(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">setBar:</span><span style="color:#e6db74">&#34;</span>), <span style="color:#ae81ff">10</span>);

    __attribute__((__blocks__(byref))) __attribute__((objc_ownership(weak))) __Block_byref_weakF_4 weakF <span style="color:#f92672">=</span> {(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#ae81ff">0</span>,(__Block_byref_weakF_4 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>weakF, <span style="color:#ae81ff">33554432</span>, <span style="color:#66d9ef">sizeof</span>(__Block_byref_weakF_4), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, (strongF.__forwarding<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>strongF)};

    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>block)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())<span style="color:#f92672">&amp;</span>__main_19_block_impl_0((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)__main_19_block_func_0, <span style="color:#f92672">&amp;</span>__main_19_block_desc_0_DATA, (__Block_byref_weakF_4 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>weakF, (__Block_byref_strongF_3 <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>strongF, <span style="color:#ae81ff">570425344</span>));

    ((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(__block_impl <span style="color:#f92672">*</span>))((__block_impl <span style="color:#f92672">*</span>)block)<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>FuncPtr)((__block_impl <span style="color:#f92672">*</span>)block);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>由此可以发现这与 Block 中捕获对象类型的自动变量时的内存管理类似，不同的是 <code>__block</code> 结构体指针在 Block 内部默认是强引用，因此 <code>_Block_object_assign</code> 中会进行强引用（Retain）的操作；而且 <code>_Block_object_assign</code> &amp; <code>_Block_object_dispose</code> 方法的最后一位参数的不同（对象：<code>BLOCK_FIELD_IS_OBJECT</code>，<code>__block</code>：<code>BLOCK_FIELD_IS_BYREF</code>），用来函数内部区分两者。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_20</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">^</span>block_1)(<span style="color:#66d9ef">void</span>);
    {
        NSMutableArray <span style="color:#f92672">*</span>arr <span style="color:#f92672">=</span> [[NSMutableArray alloc] init];
        <span style="color:#75715e">// 弱引用
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">__weak</span> NSMutableArray <span style="color:#f92672">*</span>weakArr <span style="color:#f92672">=</span> arr;

        block_1 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>(){
            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, weakArr);
        };

        block_1();
    }

    block_1();

    {
        NSMutableArray <span style="color:#f92672">*</span>arr <span style="color:#f92672">=</span> [[NSMutableArray alloc] init];
        <span style="color:#75715e">// __block 下弱引用
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">__block</span> <span style="color:#66d9ef">__weak</span> NSMutableArray <span style="color:#f92672">*</span> weakArr <span style="color:#f92672">=</span> arr;

        block_1 <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>(){
            NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, weakArr);
        };

        block_1();
    }

    block_1();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// ()
</span><span style="color:#75715e"></span><span style="color:#75715e">// (null)
</span><span style="color:#75715e"></span><span style="color:#75715e">// ()
</span><span style="color:#75715e"></span><span style="color:#75715e">// (null)
</span></code></pre></div><p>这一例中，默认强指针引用的 <code>arr</code> 会在作用域（代码块）结束时被释放，因此 <code>__weak</code> 的弱引用指针将指向 <code>nil</code>（<code>__unsafe_unretained</code> 则不会自动清空）。代码可以正常执行，但弱引用处的对象便无法输出，即使带有 <code>__block</code>，其结构体中弱指针指向的对象也会被清空而无法输出。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo_8</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo_8</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">dealloc</span>
{
<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    [super dealloc];
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">dealloc</span><span style="color:#e6db74">&#34;</span>);
}
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">int</span> main_21(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">__block</span> Foo_8 <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> [[Foo_8 alloc] init];

    <span style="color:#66d9ef">void</span>(<span style="color:#f92672">^</span>block)(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> [<span style="color:#f92672">^</span>{
        <span style="color:#75715e">// 若不注释 [f release]; 一行则会崩溃
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// CRASH: EXC_BAD_INSTRUCTION
</span><span style="color:#75715e"></span>        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, f);

        f <span style="color:#f92672">=</span> [Foo_8 new];

        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, f);
    } <span style="color:#66d9ef">copy</span>];

    <span style="color:#75715e">// [f release]; // dealloc
</span><span style="color:#75715e"></span>
    block();

    [block <span style="color:#66d9ef">release</span>];
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>MRC 下需要注意的一点是，如上代码我们可能会以为 <code>block</code> 会对外界 <code>f</code> 进行持有，进而引用计数增加，所以在 <code>block</code> 声明后对 <code>f</code> 进行 <code>release</code>，最终在 <code>block</code> 执行后对其本身 <code>release</code>，<code>f</code> 在此时释放，调用 <code>dealloc</code>。然而此时却在 <code>block</code> 执行时发生了崩溃，这是因为 MRC 下的 <code>__Block_byref_xxx</code> 对于变量并不会进行持有操作，这也可被用来破解循环引用。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="heading9">循环引用</h2>
<p>我们知道，Obj-C 通过引用计数来管理对象的内存，但其中的一个问题便是循环引用，即两个对象均以强引用互相指向对方，此时两个对象都将无法释放，导致内存泄漏：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">void</span>(<span style="color:#f92672">^</span>BlockType_5)(<span style="color:#66d9ef">void</span>);

<span style="color:#66d9ef">@interface</span> <span style="color:#a6e22e">Foo_9</span> : <span style="color:#a6e22e">NSObject</span>
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">assign</span>) NSUInteger bar;
<span style="color:#66d9ef">@property</span> (<span style="color:#66d9ef">nonatomic</span>, <span style="color:#66d9ef">copy</span>) BlockType_5 block;
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Foo_9</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">dealloc</span>
{
<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    [super dealloc];
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">dealloc</span><span style="color:#e6db74">&#34;</span>);
}

- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">foo_1</span> {
    <span style="color:#75715e">// Block 捕获了 self，其强引用了 Block，导致双方都无法释放
</span><span style="color:#75715e"></span>    self.block <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        <span style="color:#75715e">// WARNING: Capturing &#39;self&#39; strongly in this block is likely to lead to a retain cycle
</span><span style="color:#75715e"></span>        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)self.bar);
        <span style="color:#75715e">// WARNING: Block implicitly retains &#39;self&#39;; explicitly mention &#39;self&#39; to indicate this is intended behavior
</span><span style="color:#75715e"></span>        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)_bar); <span style="color:#75715e">// self-&gt;_bar
</span><span style="color:#75715e"></span>    };
}
<span style="color:#66d9ef">@end</span>

<span style="color:#66d9ef">int</span> main_22(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
<span style="color:#75715e">#</span><span style="color:#75715e">if __has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    Foo_9 <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> [[Foo_9 alloc] init];
    f.bar <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;

    f.block <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        <span style="color:#75715e">// Block 捕获了 f，其强引用了 Block，导致双方都无法释放
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// WARNING: Capturing &#39;f&#39; strongly in this block is likely to lead to a retain cycle
</span><span style="color:#75715e"></span>        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)f.bar);
    };

    f.block();
    [f foo_1];

    <span style="color:#75715e">// Never call dealloc
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// 20
</span></code></pre></div><p><img src="/img/2019/block_in_obj-c/5.png" alt="5"></p>
<h3 id="arc">ARC</h3>
<h4 id="weak--unsafeunretained"><code>__weak</code> &amp; <code>__unsafe_unretained</code></h4>
<p>想要打破循环引用，我们需要一个不增加引用计数的指向。那么到底更改哪个引用呢？我们仍以上图为例：</p>
<ul>
<li>1⃣️ 处的强引用是我们在初始化时 <code>Foo_9 *f = [[Foo_9 alloc] init];</code> 所赋予的，栈上的 <code>f</code> 指针存储了堆上的对象的内存地址；</li>
<li>2⃣️ 处的强引用是 Block 结构体（<code>__main_22_block_impl_0</code>）对自身捕获到内部的对象的强引用，其引用是根据外界即 1⃣️ 处声明时的强弱来决定的；</li>
<li>3⃣️ 处的强引用是根据我们在 <code>Foo_9</code> 类中声明的属性修饰 <code>@property (nonatomic, copy) BlockType_5 block;</code> 所决定的。</li>
</ul>
<p>而我们需要 Block 应当随 <code>Foo_9</code> 对象销毁而销毁，如果将 3⃣️ 处改为弱引用或 <code>__unsafe_unretained</code>，则可能出现 Block 的提前释放。因此综上，我们可以将 1⃣️ 的引用改为弱引用或 <code>__unsafe_unretained</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// Foo_9
</span><span style="color:#75715e"></span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">foo_2</span> {
    <span style="color:#66d9ef">__weak</span> <span style="color:#66d9ef">typeof</span>(self) weakSelf <span style="color:#f92672">=</span> self;
    self.block <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)weakSelf.bar);

        <span style="color:#75715e">// 需要 __strong 避免编译器报错（也保证在下面使用时 self 没有被释放）
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">__strong</span> <span style="color:#66d9ef">typeof</span>(weakSelf) strongSelf <span style="color:#f92672">=</span> weakSelf;
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)strongSelf<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>_bar);
    };
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_23</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
<span style="color:#75715e">#</span><span style="color:#75715e">if __has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    Foo_9 <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> [[Foo_9 alloc] init];
    f.bar <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>;

    <span style="color:#75715e">// 也可使用 typeof() 简化类型声明
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// __weak typeof(f) weakF = f;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">__weak</span> Foo_9 <span style="color:#f92672">*</span>weakF <span style="color:#f92672">=</span> f;

    <span style="color:#75715e">// __unsafe_unretained Foo_9 *unsafeUnretainedF = f;
</span><span style="color:#75715e"></span>    __unsafe_unretained <span style="color:#66d9ef">typeof</span>(f) unsafeUnretainedF <span style="color:#f92672">=</span> f;

    f.block <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)weakF.bar);
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%lu</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)unsafeUnretainedF.bar);
    };

    f.block();
    [f foo_2];
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// 30
</span><span style="color:#75715e"></span><span style="color:#75715e">// 30
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span></code></pre></div><p>而 <code>__weak</code> &amp; <code>__unsafe_unretained</code> 的区别在于前者在指向的对象销毁时，指针将自动置为 <code>nil</code>（Autoniling），而后者将保留指向的内存地址。</p>
<h4 id="block1"><code>__block</code></h4>
<p><code>__block</code> 变量由于可以在 Block 内直接更改，因此其也可以用来解除循环引用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_24</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
<span style="color:#75715e">#</span><span style="color:#75715e">if __has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">__block</span> Foo_9 <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> [[Foo_9 alloc] init];
    f.bar <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>;

    f.block <span style="color:#f92672">=</span> <span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, f);

        f <span style="color:#f92672">=</span> nil; <span style="color:#75715e">// 将 __Block_byref 中的 f 置为 nil，打破循环
</span><span style="color:#75715e"></span>    };

    f.block();

    <span style="color:#75715e">// CRASH: EXC_BAD_ACCESS
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// f.block();
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;Foo_9: 0x1035005a0&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span></code></pre></div><p><img src="/img/2019/block_in_obj-c/6.png" alt="6"></p>
<p>但需要注意：</p>
<ol>
<li>Block 必须执行，才可以将强引用的自动变量置为 <code>nil</code>，从而破解循环引用；</li>
<li>循环引用破解后，Block 和 <code>f</code> 均释放，因此如果后续再次执行 Block 将发生 <code>EXC_BAD_ACCESS</code> 崩溃。</li>
</ol>
<h3 id="mrc">MRC</h3>
<p>MRC 下，我们需要手动将栈上的 Block 拷贝到堆上，并在结束使用时 <code>release</code>，但循环引用出现时即使手动释放对象也无法销毁：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_25</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    Foo_9 <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> [[Foo_9 alloc] init];

    f.block <span style="color:#f92672">=</span> [<span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, f);
    } <span style="color:#66d9ef">copy</span>];

    f.block();

    [f <span style="color:#66d9ef">release</span>]; <span style="color:#75715e">// Never call dealloc
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;Foo_9: 0x1006bab90&gt;
</span></code></pre></div><p>由于 MRC 没有强弱引用的概念，因从破解循环引用只能使用 <code>__unsafe_unretained</code>，其使得 Block 内部不再会对捕获的对象持有：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_26</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    __unsafe_unretained Foo_9 <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> [[Foo_9 alloc] init];

    f.block <span style="color:#f92672">=</span> [<span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, f);
    } <span style="color:#66d9ef">copy</span>];

    f.block();

    [f <span style="color:#66d9ef">release</span>]; <span style="color:#75715e">// Never call dealloc
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;Foo_9: 0x100507320&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span></code></pre></div><p><code>__block</code> 其实也可以用来破解 MRC 下的循环引用，因为 <code>__block</code> 修饰的变量在 MRC 下，<code>__Block_byref_xxx</code> 将不会对捕获的变量持有：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main_27</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> argv[]) {
<span style="color:#75715e">#</span><span style="color:#75715e">if !__has_feature(objc_arc)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">__block</span> Foo_9 <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> [[Foo_9 alloc] init];

    f.block <span style="color:#f92672">=</span> [<span style="color:#f92672">^</span>{
        NSLog(<span style="color:#e6db74">@&#34;</span><span style="color:#e6db74">%@</span><span style="color:#e6db74">&#34;</span>, f);
    } <span style="color:#66d9ef">copy</span>];

    f.block();

    [f <span style="color:#66d9ef">release</span>];
<span style="color:#75715e">#</span><span style="color:#75715e">endif</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e"></span><span style="color:#75715e">// &lt;Foo_9: 0x100532c60&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">// dealloc
</span></code></pre></div><h3 id="weakify--strongify"><code>@weakify</code> &amp; <code>@strongify</code></h3>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="reference">Reference</h2>
<ul>
<li>
<p><a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F">巴科斯范式 - 维基百科</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/10429857/is-it-possible-to-see-the-code-generated-by-arc-at-compile-time">Is it possible to see the code generated by ARC at compile time? - StackOverflow</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/7997666/storing-blocks-in-an-array">Storing Blocks in an Array - StackOverflow</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/23334863/should-i-still-copy-block-copy-the-blocks-under-arc/23352604">Should I still copy/Block_copy the blocks under ARC? - StackOverflow</a></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
</li>
</ul>

    </div>
    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>
        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="/posts/2019/obj-c_to_c&#43;&#43;/">
                <span class="button__icon">←</span>
                <span class="button__text">将 Obj-C 代码翻译为 C/C&#43;&#43; 代码</span>
              </a>
            </span>
          
          
            <span class="button next">
              <a href="/posts/2019/effective_obj-c_2.0_notes/">
                <span class="button__text">《编写高质量 iOS 与 OS X 代码的 52 个有效方法》阅读笔记</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    

    

    
    
    <div>
      <div id="github-comment">
      </div>

      <script type="text/javascript">
        function getUtterances(isDark) {
          var utterances = document.createElement('script');
          utterances.type = 'text/javascript';
          utterances.async = true;
          utterances.setAttribute('issue-term', "pathname")
          utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
          utterances.setAttribute('label', "comments")
          isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
          utterances.crossorigin = 'anonymous';
          utterances.src = 'https://utteranc.es/client.js';

          return utterances
        }

        var themeToggle = document.querySelector(".theme-toggle")
        themeToggle.addEventListener("click", function () {
          var getTheme = window.localStorage && window.localStorage.getItem("theme")
          var divNode = document.getElementById('github-comment')
          while(divNode.hasChildNodes()) {
            divNode.removeChild(divNode.firstChild);
          }
          
          
          

          
          
          
          
          
          
          document.getElementById('github-comment').appendChild(getUtterances(getTheme !== "dark"))
        })

        var getTheme = window.localStorage && window.localStorage.getItem("theme")
        document.getElementById('github-comment').appendChild(getUtterances(getTheme === "dark"))
      </script>
    </div>
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">All rights reserved by kingcos.me</div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </body>
</html>
