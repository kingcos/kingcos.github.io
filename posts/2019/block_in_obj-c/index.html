<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>Obj-C 中的 Block :: iBlog</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Notes     2019-07-27 首次提交 -   2019-11-21 整理部分细节 -    Preface Obj-C 中的 Block，即闭包，使得我们能够将代码块封装为变量，可以作为参数在方法中传递。当我们需要做一些异步行为时，总是希望能够在异步动作完成时可以在回调中执行额外的动作，那么此时我们就可以选择使用 Block 来作为 handler，其相较于 Delegate 更加简洁。那么本文就将着眼于 Obj-C 中 Block，谈谈其中的原理。
对于设计 handler API，可参考《编写高质量 iOS 与 OS X 代码的 52 个有效方法》一书中所提到的，通常我们可以将成功与失败情况放在同一个 handler 中处理；另外我们可以仿照 NSNotificationCenter API，通过增加一个参数来让外界决定 handler 执行的队列。
 ⚠️
在 Obj-C 中我们可以使用 __has_feature(objc_arc) 宏来区分 ARC（Automatic Reference Counting）和 MRC（Mannul Reference Counting）下可以编译的代码。目前 Xcode 中默认开启了 ARC，切换为 MRC 可以通过 Xcode - Build Settings - Automatic Reference Counting（自动引用计数）- No 来设置，具体可参照下图："/>
<meta name="keywords" content="kingcos.me,maimieng.comios,swift,objective-c,obj-c,objc,oc,geek,python,ruby,golang,go,apple,mac"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/block_in_obj-c/" />





<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Obj-C 中的 Block"/>
<meta name="twitter:description" content="Obj-C 中的 Block，即闭包，使得我们能够将代码块封装为变量，可以作为参数在方法中传递。当我们需要做一些异步行为时，总是希望能够在异步动作完成时可以在回调中执行额外的动作，那么此时我们就可以选择使用 Block 来作为 handler，其相较于 Delegate 更加简洁。那么本文就将着眼于 Obj-C 中 Block，谈谈其中的原理。"/>



<meta property="og:title" content="Obj-C 中的 Block" />
<meta property="og:description" content="Obj-C 中的 Block，即闭包，使得我们能够将代码块封装为变量，可以作为参数在方法中传递。当我们需要做一些异步行为时，总是希望能够在异步动作完成时可以在回调中执行额外的动作，那么此时我们就可以选择使用 Block 来作为 handler，其相较于 Delegate 更加简洁。那么本文就将着眼于 Obj-C 中 Block，谈谈其中的原理。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2019/block_in_obj-c/" />
<meta property="article:published_time" content="2019-07-27T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-07-27T00:00:00+00:00" /><meta property="og:site_name" content="iBlog" />






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">kingcos.me</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="post">
    <h2 class="post-title"><a href="/posts/2019/block_in_obj-c/">Obj-C 中的 Block</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            2019-07-27
        </span>
      
      
      
        <span class="post-read-time">— 17 min read</span>
      
    </div>

    
      <span class="post-tags">
        
          #<a href="/tags/focus/">Focus</a>&nbsp;
        
          #<a href="/tags/ios/">iOS</a>&nbsp;
        
          #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Notes</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2019-07-27</td>
<td align="center">首次提交</td>
<td align="center">-</td>
</tr>

<tr>
<td align="center">2019-11-21</td>
<td align="center">整理部分细节</td>
<td align="center">-</td>
</tr>
</tbody>
</table>

<p><img src="/img/2019/block_in_obj-c/0.png" alt="0" /></p>

<h2 id="preface">Preface</h2>

<p>Obj-C 中的 Block，即闭包，使得我们能够将代码块封装为变量，可以作为参数在方法中传递。当我们需要做一些异步行为时，总是希望能够在异步动作完成时可以在回调中执行额外的动作，那么此时我们就可以选择使用 Block 来作为 handler，其相较于 Delegate 更加简洁。那么本文就将着眼于 Obj-C 中 Block，谈谈其中的原理。</p>

<p>对于设计 handler API，可参考《编写高质量 iOS 与 OS X 代码的 52 个有效方法》一书中所提到的，通常我们可以将成功与失败情况放在同一个 handler 中处理；另外我们可以仿照 <code>NSNotificationCenter</code> API，通过增加一个参数来让外界决定 handler 执行的队列。</p>

<blockquote>
<p>⚠️</p>

<p>在 Obj-C 中我们可以使用 <code>__has_feature(objc_arc)</code> 宏来区分 ARC（Automatic Reference Counting）和 MRC（Mannul Reference Counting）下可以编译的代码。目前 Xcode 中默认开启了 ARC，切换为 MRC 可以通过 Xcode - Build Settings - Automatic Reference Counting（自动引用计数）- No 来设置，具体可参照下图：</p>

<p><img src="/img/2019/block_in_obj-c/3.png" alt="3" /></p>
</blockquote>

<h2 id="what">What</h2>

<p>在 <code>main</code> 函数中声明并执行一个简单的 Block：</p>

<pre><code class="language-objectivec">// main.m

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        ^{
            NSLog(@&quot;Hello, World!&quot;);
        }();
    }
    return 0;
}

// OUTPUT:
// Hello, World!
</code></pre>

<p>为了窥探 Block 的结构，可以尝试使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</code> 命令将以上代码翻译为 C/C++ 代码来分析：</p>

<pre><code class="language-cpp">struct __block_impl {
  void *isa;     // isa 指针
  int Flags;     // 标记，默认会被初始化为 0
  int Reserved;  // 保留域
  void *FuncPtr; // Block 代码块的函数指针
};

static struct __main_block_desc_0 {
  size_t reserved;   // 保留域，默认 0
  size_t Block_size; // Block 大小，sizeof 整个 Block 结构体
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

// ➡️ Block：
struct __main_block_impl_0 {
  struct __block_impl impl;         // 实现（非指针）
  struct __main_block_desc_0* Desc; // 描述信息的指针
  // 构造函数
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

// 静态函数封装 Block 内代码块
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {

            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_429af3_mi_0);
        }

// 声明 block 变量（指向 _main_block_impl_0 的指针）
// void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));
void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));

// 执行 Block 内部代码
// 在 __main_block_impl_0 结构体中，impl 是第一个变量，因此其与结构体本身的首地址一致，因此可以强转
// block-&gt;FuncPtr(block);
((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
</code></pre>

<p>如上，当声明 Block 后，其中的代码块会被封装到 <code>__main_block_func_0</code> 静态函数中（后缀 <code>0</code> 代表序号，后同），用来和 <code>__main_block_desc_0_DATA</code> 一起构造 <code>__main_block_impl_0</code>，并在其构造函数中将函数指针赋值给 <code>FuncPtr</code>；最终在 Block 真正调用时，通过 <code>block-&gt;FuncPtr(block)</code> 执行代码块。</p>

<p>所以 Obj-C 的 Block 即是 <code>__main_block_impl_0</code> 结构体。该结构体中又直接包含了 <code>__block_impl</code> 结构体，以及指向 <code>__main_block_desc_0</code> 结构体的指针。在 <code>__block_impl</code> 结构体中，<code>isa</code> 暗示了其本质是 Obj-C 对象的事实，而 <code>FuncPtr</code> 函数指针则指向将要执行的静态函数：</p>

<p><img src="/img/2019/block_in_obj-c/1.png" alt="1" /></p>

<p>总之，Block 是<strong>封装了函数调用以及函数调用环境的 Obj-C 对象</strong>。</p>

<h2 id="变量捕获">变量捕获</h2>

<h3 id="局部变量">局部变量</h3>

<h4 id="自动变量">自动变量</h4>

<p>自动变量（Automatic Variable）即局部作用域变量，指在代码块中声明的变量，离开作用域时会被自动销毁，声明时也可以显式使用 <code>auto</code> 关键字：</p>

<pre><code class="language-objectivec">// main.m

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        auto int a = 1;
        int b = 2;

        void (^block)(void) = ^() {
            NSLog(@&quot;a == %d, b == %d&quot;, a, b);
        };

        block();
    }
    return 0;
}

// OUTPUT:
// a == 1, b = 2
</code></pre>

<p>由于 Block 可以被代码块外声明的变量持有，因此自动变量的生命周期可能早于 Block 本身结束。所以 Block 会将自动变量捕获到结构体内部（即按值传递），这样即使在 Block 声明后更改了原有的变量值或者自动变量的生命周期结束，也不会影响已经被捕获的那个变量：</p>

<pre><code class="language-cpp">struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  int a; // ⚠️ 捕获的变量
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  // a：取值
  int a = __cself-&gt;a; // bound by copy

    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_3c9d7c_mi_0, a);
}

int a = 1;
// a 作为参数传入
// 忽略类型转换：void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, a));
void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));
// 忽略类型转换：block-&gt;FuncPtr(block);
((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
</code></pre>

<p>Obj-C 中方法的两个默认参数 <code>self</code> 和 <code>_cmd</code> 的作用域仅在函数体内，也属于自动变量，因此 Block 内如果使用到 <code>self</code> 也会对其进行捕获：</p>

<pre><code class="language-cpp">// - (void)objectFunc
static void _I_A_objectFunc(A * self, SEL _cmd) {
    void (*block)(void) = ((void (*)())&amp;__A__objectFunc_block_impl_0((void *)__A__objectFunc_block_func_0, &amp;__A__objectFunc_block_desc_0_DATA, self, 570425344));

    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
}

struct __A__block_block_impl_0 {
  struct __block_impl impl;
  struct __A__block_block_desc_0* Desc;
  A *self; // ⚠️ 捕获的 self
  __A__block_block_impl_0(void *fp, struct __A__block_block_desc_0 *desc, A *_self, int flags=0) : self(_self) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __A__block_block_func_0(struct __A__block_block_impl_0 *__cself) {
  A *self = __cself-&gt;self; // bound by copy

        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_A_2e834a_mi_0, self);
    }
</code></pre>

<p>而如果 Block 中引入了成员变量，本质其实是通过 <code>self</code> 进行访问的，因此同理也会对 <code>self</code> 本身进行捕获：</p>

<pre><code class="language-cpp">struct __A__objectFunc_block_impl_0 {
  struct __block_impl impl;
  struct __A__objectFunc_block_desc_0* Desc;
  A *self; // ⚠️ 捕获的 self
  __A__objectFunc_block_impl_0(void *fp, struct __A__objectFunc_block_desc_0 *desc, A *_self, int flags=0) : self(_self) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __A__objectFunc_block_func_0(struct __A__objectFunc_block_impl_0 *__cself) {
  A *self = __cself-&gt;self; // bound by copy

        // self + OBJC_IVAR_$_A$_memVar：成员变量是根据 self 做的偏移
        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_A_f4faca_mi_0, (*(NSString **)((char *)self + OBJC_IVAR_$_A$_memVar)));
    }
</code></pre>

<h4 id="局部静态变量">局部静态变量</h4>

<p>局部静态变量指定义在代码块内的静态变量，其作用域是在代码块内，但其生命周期并不会随代码块结束：</p>

<pre><code class="language-objectivec">// main.m

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        static int a = 1;

        void (^block)(void) = ^() {
            NSLog(@&quot;a == %d&quot;, a);
        };
        a = 10;

        block();
    }
    return 0;
}

// OUTPUT:
// a == 10
</code></pre>

<p>由于静态局部变量的生命周期随程序退出而结束，Block 只需要将局部静态变量的<strong>地址</strong>进行捕获即可（即按引用传递）。这样即使超过静态局部变量的作用域但 Block 中仍然可以访问到，且当 Block 执行前如果改变了局部静态变量的值，那么执行时也将根据地址获取到最新值：</p>

<pre><code class="language-cpp">struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  int *a; // ⚠️ 捕获的变量地址
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  // *a：取地址中存储的值
  int *a = __cself-&gt;a; // bound by copy

    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_adf509_mi_0, (*a));
}

static int a = 1;
// &amp;a 即 a 的地址作为参数传入
// 忽略类型转换：void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;a);
void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;a));

// a 的值被改变
a = 10;

((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
</code></pre>

<h3 id="全局变量">全局变量</h3>

<p>全局变量即定义在所有函数体外的变量，只有当程序退出时其生命周期才结束：</p>

<pre><code class="language-objectivec">// main.m

// 全局变量：
int a = 1;
static int b = 2;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        void (^block)(void) = ^() {
            NSLog(@&quot;a == %d, b == %d&quot;, a, b);
        };

        a = 10;
        b = 20;

        block();
    }
}

// OUTOUT:
// a == 10, b == 20
</code></pre>

<p>因此对于全局变量，Block 并不会去捕获，而是在使用时直接进行读取即可：</p>

<pre><code class="language-cpp">int a = 1;
static int b = 2;

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {

            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_437bca_mi_0, a, b);
        }
</code></pre>

<h2 id="类型">类型</h2>

<p>Obj-C 中的 Block 根据其存储在不同的内存区域被分为三种：<code>__NSGlobalBlock__</code>、<code>__NSStackBlock__</code>、<code>__NSMallocBlock__</code>，它们又各自继承自 <code>__NSGlobalBlock</code>、<code>__NSMallocBlock</code>、<code>__NSStackBlock</code>，这些父类又都继承自 <code>NSBlock</code>，<code>NSBlock</code> 又继承自 <code>NSObject</code>：</p>

<pre><code class="language-objectivec">void (^block1)(void) = ^() {
    NSLog(@&quot;Hello, world!&quot;);
};

int a = 1;
void (^block2)(void) = ^() {
    NSLog(@&quot;%d&quot;, a);
};

NSLog(@&quot;%@ %@ %@&quot;, [block1 class], [block2 class], [^{
    NSLog(@&quot;%d&quot;, a);
} class]);

NSLog(@&quot;%@ %@ %@&quot;, [block1 superclass], [block2 superclass],[^{
    NSLog(@&quot;%d&quot;, a);
} superclass]);

NSLog(@&quot;%@ %@ %@&quot;, [[block1 superclass] superclass], [[block2 superclass] superclass],[[^{
    NSLog(@&quot;%d&quot;, a);
} superclass] superclass]);

NSLog(@&quot;%@ %@ %@&quot;, [[[block1 superclass] superclass] superclass], [[[block2 superclass] superclass] superclass],[[[^{
    NSLog(@&quot;%d&quot;, a);
} superclass] superclass] superclass]);

// OUTPUT:
// __NSGlobalBlock__ __NSMallocBlock__ __NSStackBlock__
// __NSGlobalBlock __NSMallocBlock __NSStackBlock
// NSBlock NSBlock NSBlock
// NSObject NSObject NSObject
</code></pre>

<blockquote>
<p>⚠️</p>

<p>在上一节中，我们可以从翻译的 C++ 代码中看到 Block 内部的 <code>isa</code> 指针指向了 <code>&amp;_NSConcreteStackBlock</code>，但其实在 Xcode 中运行时并不存在「翻译」这一步骤，因此我们最好使用运行时的方法来真正确定 Block 的具体类型。</p>
</blockquote>

<h3 id="nsglobalblock"><code>__NSGlobalBlock__</code></h3>

<p>内部没有访问外界<strong>自动变量</strong>的 Block 均属于 <code>__NSGlobalBlock__</code>，其存储在内存的数据区（Data 段），该区域通常也会存放全局变量：</p>

<pre><code class="language-objectivec">// main.m

int a = 1;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        void (^gloablBlock)(void) = ^{
            // 没有访问任何外界变量
            NSLog(@&quot;This is a __NSGlobalBlock__.&quot;);
        };

        NSLog(@&quot;%@&quot;, [gloablBlock class]);

        static int b = 1;

        gloablBlock = ^{
            // 访问了全局变量或局部静态变量
            NSLog(@&quot;a == %d, b == %d.&quot;, a, b);
        };

        NSLog(@&quot;%@&quot;, [gloablBlock class]);
    }
}

// OUTPUT:
// __NSGlobalBlock__
// __NSGlobalBlock__
</code></pre>

<p>对 <code>__NSGlobalBlock__</code> 类型的 Block 执行 <code>copy</code> 操作仍将返回 <code>__NSGlobalBlock__</code>。</p>

<h3 id="nsstackblock"><code>__NSStackBlock__</code></h3>

<h4 id="what-1">What</h4>

<p>自动变量存储在内存的栈区，当 Block 内访问了外界的自动变量时会对其进行捕获，此时 Block 本身也被分配在栈区，即为 <code>__NSStackBlock__</code> 类型：</p>

<pre><code class="language-objectivec">#if !__has_feature(objc_arc)
int c = 1;

void (^stackBlock)(void) = ^{
    NSLog(@&quot;c == %d.&quot;, c);
};

NSLog(@&quot;%@&quot;, [stackBlock class]);
#endif

// OUTPUT:
//  __NSStackBlock__
</code></pre>

<p>栈区的内存不需要开发者手动管理，当作用域结束时栈区内存将会被自动回收。所以即使 <code>__NSStackBlock__</code> 类型的 Block 内部捕获了自动变量，但 Block 本身和捕获的变量也仍然存储在栈区，会随着其作用域结束而释放：</p>

<pre><code class="language-objectivec">// main.m

#if !__has_feature(objc_arc)
@interface Person : NSObject
@end

@implementation Person
- (void)dealloc
{
#if !__has_feature(objc_arc)
    [super dealloc];
#endif
    NSLog(@&quot;dealloc&quot;);
}
@end

void (^stackBlock1)(void);
void (^stackBlock2)(void);

void initBlock() {
#if !__has_feature(objc_arc)
    int c = 10;

    stackBlock1 = ^{
        NSLog(@&quot;c == %d&quot;, c);
    };

    // -----

    Person *p = [[Person alloc] init];

    NSLog(@&quot;%ld&quot;, [p retainCount]);

    stackBlock2 = ^{
       NSLog(@&quot;p == %@&quot;, p);
    };

    NSLog(@&quot;%ld&quot;, [p retainCount]);

    [p release];
#else
    Person *strongP = [[Person alloc] init];

    NSLog(@&quot;%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(strongP)));

    __weak Person *weakP = strongP;

    NSLog(@&quot;%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(strongP)));

    // __NSStackBlock__
    ^{
        NSLog(@&quot;%@&quot;, strongP);
        NSLog(@&quot;%@&quot;, weakP);
    };

    NSLog(@&quot;%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(strongP)));
#endif
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // 初始化 stackBlock
        initBlock();
        NSLog(@&quot;---&quot;);
#if !__has_feature(objc_arc)
        // 执行 stackBlock1
        stackBlock1(); // c == -272632744
        // 执行 stackBlock2
        stackBlock2(); // CRASH: objc[59614]: Attempt to use unknown class 0x7ffeefbff428.

        NSLog(@&quot;stackBlock is a %@.&quot;, [stackBlock1 class]); // CRASH: EXC_BAD_ACCESS
#endif
    }
}

// MRC OUTPUT:
// 1
// 1
// dealloc
// ---

// ARC OUTPUT:
// 1
// 1
// 2
// dealloc
// ---
</code></pre>

<p>MRC 下，<code>__NSStackBlock__</code> 类型的 Block 捕获对象类型的自动变量但并不会改变其引用计数，即不会进行 <code>retain</code> 持有操作。而 <code>main</code> 函数中的执行到 Block 时自动变量 <code>c</code> 和 <code>p</code> 其实已经被释放，因此访问时出现了脏数据，访问 Block 本身也出现了 <code>EXC_BAD_ACCESS</code> 崩溃。为了避免这种问题，我们需要将其分配在堆上（即 <code>__NSMallocBlock__</code>），这是因为堆区的内存由开发者自己管理，可以避免被自动回收。</p>

<p>ARC 下，<code>__NSStackBlock__</code> 类型的 Block 中捕获了 <code>strongP</code> 和 <code>weakP</code>（可以通过为翻译 Obj-C 代码的命令额外添加 <code>-fobjc-arc -fobjc-runtime=ios-13.0.0</code> 参数强制使用 ARC 并指定运行时平台和版本，这样即可输出带有部分运行时关键字的 C/C++ 代码，如下），虽然强引用会导致其引用计数增加，但 Block 本身仍会随作用域超出而销毁，而自动变量也会被销毁。</p>

<pre><code class="language-cpp">struct __initBlock_block_impl_0 {
  // ...
  Person *__strong strongP; // ⚠️ 强引用
  Person *__weak weakP;     // ⚠️ 弱引用
  // ...
};
</code></pre>

<h3 id="nsmallocblock"><code>__NSMallocBlock__</code></h3>

<h4 id="what-2">What</h4>

<p><code>__NSMallocBlock__</code> 类型的 Block 存储在内存的堆区，堆区是通常用作动态分配（Malloc）的内存。</p>

<pre><code class="language-objectivec">// main.m

@interface Person : NSObject
@end

@implementation Person
- (void)dealloc
{
#if !__has_feature(objc_arc)
    [super dealloc];
#endif
    NSLog(@&quot;dealloc&quot;);
}
@end

// 使用 typedef 定义 Block 的类型，可以使得 API 更加简单友好
typedef void(^SomeBlock)(void);

void (^mallocBlock1)(void);
void (^mallocBlock2)(void);

void initBlock() {
#if !__has_feature(objc_arc)
    int c = 10;

    mallocBlock1 = [^{
        NSLog(@&quot;c == %d&quot;, c);
    } copy];

    // ---

    Person *p = [[Person alloc] init];

    mallocBlock2 = [^{
        NSLog(@&quot;%@&quot;, p);
    } copy];

    [p release];
#else
    int c = 10;

    mallocBlock1 = ^{
        NSLog(@&quot;c == %d&quot;, c);
    };

    // ---

    Person *strongP = [[Person alloc] init];
    __weak Person *weakP = strongP;

    // 1⃣️ ARC 下强指针 mallocBlock2 指向的 Block 会被自动拷贝为 __NSMallocBlock__
    mallocBlock2 = ^{
        NSLog(@&quot;%@&quot;, strongP);
        NSLog(@&quot;%@&quot;, weakP);
    };

    // 使用弱引用指针指向的 Block，将仍然是 __NSStackBlock__，编译将提示以下警告
    // WARNING: Assigning block literal to a weak variable; object will be released after assignment
    __weak SomeBlock weakStackBlock = ^{
        NSLog(@&quot;%@&quot;, strongP);
        NSLog(@&quot;%@&quot;, weakP);
    };

    NSLog(@&quot;weakStackBlock is %@&quot;, weakStackBlock);

    // 3⃣️ Block 作为 Cocoa API 中方法名含有 `usingBlock` 的参数时会被自动拷贝为 __NSMallocBlock__（较难证明）
    // 4⃣️ Block 作为 GCD API 参数时会被自动拷贝为 __NSMallocBlock__（较难证明）
#endif
}

SomeBlock returnMallocBlock() {
    auto int autoVar = 10;

#if !__has_feature(objc_arc)
    // MRC 下如果直接返回 Block，将报错「Returning block that lives on the local stack」
    // 即编译器已经发现返回的 Block 是在栈上，一旦函数体走完，Block 就会被销毁，因此在 MRC 下需要手动 copy：
    return [^{
        NSLog(@&quot;%d&quot;, autoVar);
    } copy];
#else
    // 2⃣️ ARC 下 Block 作为函数返回值会被自动拷贝为 __NSMallocBlock__
    return ^{
        NSLog(@&quot;%d&quot;, autoVar);
    };
#endif
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        initBlock();

        NSLog(@&quot;mallocBlock1 is %@&quot;, [mallocBlock1 class]);
        NSLog(@&quot;mallocBlock2 is %@&quot;, [mallocBlock2 class]);
        NSLog(@&quot;returnMallocBlock() is %@&quot;, [returnMallocBlock() class]);

        mallocBlock1();
        mallocBlock2();

#if !__has_feature(objc_arc)
        [mallocBlock1 release];
        [mallocBlock2 release];
#endif

// MRC OUTPUT:
// mallocBlock1 is __NSMallocBlock__
// mallocBlock2 is __NSMallocBlock__
// returnMallocBlock() is __NSMallocBlock__
// c == 10
// &lt;Person: 0x102a08970&gt;
// dealloc

// ARC OUTPUT:
// weakStackBlock is &lt;__NSStackBlock__: 0x7ffeefbff3d0&gt;
// mallocBlock1 is __NSMallocBlock__
// mallocBlock2 is __NSMallocBlock__
// returnMallocBlock() is __NSMallocBlock__
// c == 10
// &lt;Person: 0x1007712c0&gt;
// &lt;Person: 0x1007712c0&gt;
</code></pre>

<ul>
<li>MRC 下，对于 <code>__NSStackBlock__</code> 类型的 Block，我们只要再对执行 <code>copy</code> 操作即可从栈区拷贝到堆区。堆区内存由我们来负责管理，Block 和其中捕获的自动变量均在堆区，在我们主动释放前，均可以访问到；</li>
<li>ARC 下，编译器会根据情况将 <code>__NSStackBlock__</code> 类型的 Block 自动 <code>copy</code> 到堆上：

<ol>
<li>强指针指向的 Block 会被自动拷贝</li>
<li>Block 作为函数返回值会被自动拷贝</li>
<li>Block 作为 Cocoa API 中方法名含有 <code>usingBlock</code> 的参数时会被自动拷贝（较难证明）</li>
<li>Block 作为 GCD API 参数时会被自动拷贝（较难证明）</li>
</ol></li>
</ul>

<!-- 对 `__NSMallocBlock__` 类型的 Block 再次执行 `copy` 操作将导致引用计数增加（相当于 `ratain`）。 -->

<p>因此，Block 作为属性时应当使用 <code>copy</code> 或 <code>strong</code> 修饰：</p>

<pre><code class="language-objectivec">#if !__has_feature(objc_arc)
// MRC
@property (nonatomic, copy) void (^block1)(void);
#else
// ARC
@property (nonatomic, copy) void (^block2)(void);
@property (nonatomic, strong) void (^block3)(void);
#endif
</code></pre>

<h4 id="nsstackblock-拷贝到堆上的细节"><code>__NSStackBlock__</code> 拷贝到堆上的细节</h4>

<p>ARC 下，当 <code>__NSStackBlock__</code> 被强指针指向时会被拷贝到堆上，那么在「拷贝」时会发生什么呢？</p>

<pre><code class="language-objectivec">SomeBlock block;
{
    Person *p = [[Person alloc] init];
    p.age = 20;

    __weak Person *weakP = p;

    // __NSMallocBlock__
    block = ^{
        NSLog(@&quot;%lu&quot;, (unsigned long)p.age);
        NSLog(@&quot;%lu&quot;, (unsigned long)weakP.age);
    };
};
NSLog(@&quot;---&quot;);

// OUTPUT:
// ---
// dealloc
</code></pre>

<p>我们将以上代码使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -fobjc-arc -fobjc-runtime=ios-8.0.0 -o main.cpp</code> 翻译为 C/C++ 代码：</p>

<pre><code class="language-cpp">struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  // 默认强引用
  Person *__strong p;
  // 显式弱引用
  Person *__weak weakP;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, Person *__strong _p, Person *__weak _weakP, int flags=0) : p(_p), weakP(_weakP) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  Person *__strong p = __cself-&gt;p; // bound by copy
  Person *__weak weakP = __cself-&gt;weakP; // bound by copy

        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_38be7e_mi_1, (unsigned long)((NSUInteger (*)(id, SEL))(void *)objc_msgSend)((id)p, sel_registerName(&quot;age&quot;)));
        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_ps_0m9gnvtj0893vpf1cr595djh0000gn_T_main_38be7e_mi_2, (unsigned long)((NSUInteger (*)(id, SEL))(void *)objc_msgSend)((id)weakP, sel_registerName(&quot;age&quot;)));
    }

// 栈上的 Block 拷贝到堆时，会调用 __main_block_copy_0 方法
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {
    // _Block_object_assign 函数会根据自动变量的修饰符（如上 Person *__strong p;）作出相应的操作，形成强引用或弱引用（类似 Retain）：
    // 对外界 p 强引用，对外界 weakP 弱引用
    _Block_object_assign((void*)&amp;dst-&gt;p, (void*)src-&gt;p, 3/*BLOCK_FIELD_IS_OBJECT*/);
    _Block_object_assign((void*)&amp;dst-&gt;weakP, (void*)src-&gt;weakP, 3/*BLOCK_FIELD_IS_OBJECT*/);
    }

// 栈上的 Block 销毁时
static void __main_block_dispose_0(struct __main_block_impl_0*src) {
    // _Block_object_dispose 函数使得自动变量的引用计数减一（类似 Release）
    _Block_object_dispose((void*)src-&gt;p, 3/*BLOCK_FIELD_IS_OBJECT*/);
    _Block_object_dispose((void*)src-&gt;weakP, 3/*BLOCK_FIELD_IS_OBJECT*/);
    }

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  // 当在 Block 中访问对象类型时会增加额外的域来管理内存
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
</code></pre>

<h2 id="block"><code>__block</code></h2>

<h3 id="本质">本质</h3>

<p>上面的 Demo 中，Block 只是访问了外界的变量，但没有进行过修改，接下来我们尝试下：</p>

<pre><code class="language-objectivec">static int staticGlobalVar = 0;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        int autoVar = 0;
        static int staticVar = 0;

        ^{
            // Error: Variable is not assignable (missing __block type specifier)
            // autoVar = 10;

            staticVar = 10;
            staticGlobalVar = 10;
        }();
    }
}
</code></pre>

<p>Block 中按引用捕获静态局部变量，以及不捕获全局静态变量，可以直接修改这些变量的值。而对于自动变量，由于其是值传递，内部的 <code>autoVar</code> 与外界已无关系，所以此时不能在内部修改，编译器将提示 <code>Variable is not assignable (missing __block type specifier)</code>，那么这里的 <code>__block</code> 是什么呢？</p>

<pre><code class="language-obejctivec">int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __block int autoVar = 0;

        ^{
            autoVar = 10;
        }();
    }
}
</code></pre>

<p>我们尝试将以上代码翻译为 C++：</p>

<pre><code class="language-cpp">// 将自动变量包装的结构体（Obj-C 对象）
struct __Block_byref_autoVar_0 {
  void *__isa;
__Block_byref_autoVar_0 *__forwarding;
 int __flags;
 int __size;
 // 自动变量
 int autoVar;
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  // 原本为 int autoVar;
  __Block_byref_autoVar_0 *autoVar; // by ref
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_autoVar_0 *_autoVar, int flags=0) : autoVar(_autoVar-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  // autoVar 为结构体指针
  __Block_byref_autoVar_0 *autoVar = __cself-&gt;autoVar; // bound by ref

            // 通过指向自身的指针改变了 autoVar 的值
            (autoVar-&gt;__forwarding-&gt;autoVar) = 10;
        }

int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;
        // 初始化 __Block_byref_autoVar_0 结构体，将 autoVar 的地址赋值给结构体中 __forwarding 指针，值本身赋值给结构体中的 autoVar
        // __Block_byref_autoVar_0 autoVar = {0, &amp;autoVar, 0, sizeof(__Block_byref_autoVar_0), 0}
        __attribute__((__blocks__(byref))) __Block_byref_autoVar_0 autoVar = {(void*)0,(__Block_byref_autoVar_0 *)&amp;autoVar, 0, sizeof(__Block_byref_autoVar_0), 0};

        ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_autoVar_0 *)&amp;autoVar, 570425344))();
    }
}
</code></pre>

<p><code>__block</code> 将原本要捕获的变量类型封装为 <code>__Block_byref_autoVar_0</code> 结构体，其中也含有 <code>isa</code> 指针，因此本质上是个 Obj-C 对象；<code>__forwarding</code> 指向了该结构体本身，在赋值时被赋值为声明的结构体的地址；<code>__size</code> 即该结构体的大小；<code>autoVar</code> 即捕获的变量本身。这样，在 Block 内部改变变量值时，其实是更改了引用的结构体指向自身的变量值，而非直接修改值原本传递捕获的变量值。捕获了 <code>__block</code> 变量的 Block 结构如下图所示：</p>

<p><img src="/img/2019/block_in_obj-c/4.png" alt="4" /></p>

<pre><code class="language-objectivec">__block Person *p = [[Person alloc] init];
p.age = 20;

block = ^{
    // Block 中想要改变自动变量的指针内容（即其存储的对象内存地址）也必须使用 __block
    p = [[Person alloc] init];
};
</code></pre>

<p>对于对象类型的自动变量 <code>__Block_byref_xxx</code> 结构体将有些变化：</p>

<pre><code class="language-cpp">struct __Block_byref_p_0 {
  void *__isa;
__Block_byref_p_0 *__forwarding;
 int __flags;
 int __size;
 // copy dispose 用作其内存管理
 void (*__Block_byref_id_object_copy)(void*, void*);
 void (*__Block_byref_id_object_dispose)(void*);
 Person *__strong p;
};
</code></pre>

<h3 id="细节">细节</h3>

<p>虽然 <code>__block</code> 将原本的自动变量封装到结构体中，但其实在使用时开发者几乎对此没有感知：</p>

<pre><code class="language-objectivec">typedef void(^SomeBlock)(void);

struct __block_impl {
    void *isa;
    int Flags;
    int Reserved;
    void *FuncPtr;
};

static struct __main_block_desc_0 {
    size_t reserved;
    size_t Block_size;
//    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
//    void (*dispose)(struct __main_block_impl_0*);
};

// 0x000000010050ab10
struct __Block_byref_autoVar_0 {
    void *__isa; // 8
    struct __Block_byref_autoVar_0 *__forwarding; // 8
    int __flags; // 4
    int __size;  // 4
    int autoVar; // 4 // 0x000000010050ab28 =&gt; 0x000000010050ab10 + 24
};

struct __main_block_impl_0 {
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    struct __Block_byref_autoVar_0 *autoVar; // by ref
};

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // 0x00007ffeefbff4d8
        __block int autoVar = 0;
        // 0x00007ffeefbff4bc
        int autoVar2 = 0;

        SomeBlock block = ^{
            // block 中 __main_block_impl_0 结构体内部的 autoVar
            // 0x000000010050ab28
            autoVar = 10;
        };
        block();

        // 将 block 转换为 __main_block_impl_0 结构体
        struct __main_block_impl_0 *blockStruct = (__bridge struct __main_block_impl_0 *)block;

        // block 中 __main_block_impl_0 结构体内部的 autoVar
        // 0x000000010050ab28
        NSLog(@&quot;%p&quot;, &amp;autoVar); // 0x10050ab28
    }
}

// LLDB:
// (lldb) p &amp;autoVar
// (int *) $0 = 0x00007ffeefbff4d8
// (lldb) p &amp;autoVar
// (int *) $1 = 0x00000001007162b8
// (lldb) p &amp;autoVar
// (int *) $2 = 0x000000010050ab28
// (lldb) p &amp;(blockStruct-&gt;autoVar)
// (__Block_byref_autoVar_0 **) $3 = 0x000000010280f1d0
// (lldb) p &amp;(blockStruct-&gt;autoVar-&gt;autoVar)
// (int *) $4 = 0x000000010050ab28
// (lldb) p 0x000000010050ab28 - 0x000000010050ab10
// (long) $5 = 24
</code></pre>

<h3 id="内存管理">内存管理</h3>

<p>由于 <code>__block</code> 使得 Block 捕获的基础类型自动变量被封装到结构体（Obj-C 对象）中，那么内存管理便必不可少：</p>

<pre><code class="language-cpp">struct __main_block_impl_0 {
  // ...
  __Block_byref_foo_0 *foo; // by ref
  // ...
};

// Block 被 copy 到堆上时调用 __main_block_copy_0 将 foo 拷贝到堆上
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {
    // _Block_object_assign 将对 foo 形成强引用（Retain）
    _Block_object_assign((void*)&amp;dst-&gt;foo, (void*)src-&gt;foo, 8/*BLOCK_FIELD_IS_BYREF*/);
}

// Block 从堆上移除时调用 __main_block_dispose_0 将 foo 从堆上移除
static void __main_block_dispose_0(struct __main_block_impl_0*src) {
    // _Block_object_dispose 将释放 foo（Release）
    _Block_object_dispose((void*)src-&gt;foo, 8/*BLOCK_FIELD_IS_BYREF*/);
}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
</code></pre>

<p>我们可以发现这与 Block 中捕获对象类型的自动变量时的内存管理类似，不同的是 <code>__block</code> 默认即是强引用，因此 <code>_Block_object_assign</code> 中会进行强引用（Retain）的操作，且 <code>_Block_object_assign</code> &amp; <code>_Block_object_dispose</code> 方法的最后一位参数的不同（对象：<code>BLOCK_FIELD_IS_OBJECT</code>，<code>__block</code>：<code>BLOCK_FIELD_IS_BYREF</code>）。</p>

<h3 id="forwarding"><code>__forwarding</code></h3>

<pre><code class="language-objectivec">static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  // autoVar 为结构体指针
  __Block_byref_autoVar_0 *autoVar = __cself-&gt;autoVar; // bound by ref

            // 通过指向自身的指针改变了 autoVar 的值
            (autoVar-&gt;__forwarding-&gt;autoVar) = 10;
        }
</code></pre>

<p>在 <code>__Block_byref_xxx</code> 结构体仍在栈上时，<code>foo-&gt;__forwarding-&gt;foo</code> 就等同于直接 <code>foo-&gt;foo</code> 来访问，因为此时 <code>__forwarding</code> 就指向自己；而当复制到堆上时，<code>__forwarding</code> 将指向堆上的结构体，保证后续的数据变动是在堆上。</p>

<h3 id="对象类型">对象类型</h3>

<p>那么当 <code>__block</code> 遇上对象类型的自动变量呢？</p>

<pre><code class="language-objectivec">@interface Person : NSObject
@property (nonatomic, assign) NSUInteger age;
@end

@implementation Person
- (void)dealloc
{
    NSLog(@&quot;dealloc&quot;);
}
@end

typedef void(^SomeBlock)(void);

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __block Person *p = [[Person alloc] init];
        p.age = 20;

        __block __weak Person *weakP = p;

        SomeBlock block = ^{
            NSLog(@&quot;%lu&quot;, (unsigned long)weakP.age); // 20

            NSLog(@&quot;%lu&quot;, (unsigned long)p.age); // 20
            p = [Person new];
            p.age = 18;
            NSLog(@&quot;%lu&quot;, (unsigned long)p.age); // 18
        };

        block();
    }
}
</code></pre>

<p>我们尝试将以上代码翻译为 C/C++：</p>

<pre><code class="language-cpp">struct __Block_byref_p_0 {
  void *__isa; // 8
__Block_byref_p_0 *__forwarding; // 8
 int __flags; // 4
 int __size; // 4
 void (*__Block_byref_id_object_copy)(void*, void*); // 8
 void (*__Block_byref_id_object_dispose)(void*); // 8
 // __strong 根据外界强或弱
 Person *__strong p;
};

struct __Block_byref_weakP_1 {
 // ...
 Person *__weak weakP;
};

struct __main_block_impl_0 {
  // ...
  // __Block_byref 为强指针，不受外界改变
  __Block_byref_weakP_1 *weakP; // by ref
  __Block_byref_p_0 *p; // by ref
  // ...
};

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};

// Block 被 copy 到堆上时调用 __main_block_copy_0
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {
    // 1⃣️ 将 __Block_byref_weakP_1 *weakP &amp; __Block_byref_p_0 *p 强引用
    _Block_object_assign((void*)&amp;dst-&gt;weakP, (void*)src-&gt;weakP, 8/*BLOCK_FIELD_IS_BYREF*/);
    _Block_object_assign((void*)&amp;dst-&gt;p, (void*)src-&gt;p, 8/*BLOCK_FIELD_IS_BYREF*/);
}

// Block 要从堆上移除时调用 __main_block_dispose_0
static void __main_block_dispose_0(struct __main_block_impl_0*src) {
    // 3⃣️ 将 __Block_byref_weakP_1 *weakP &amp; __Block_byref_p_0 *p 释放
    _Block_object_dispose((void*)src-&gt;weakP, 8/*BLOCK_FIELD_IS_BYREF*/);
    _Block_object_dispose((void*)src-&gt;p, 8/*BLOCK_FIELD_IS_BYREF*/);
}

int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;
        __attribute__((__blocks__(byref))) __Block_byref_p_0 p = {(void*)0,(__Block_byref_p_0 *)&amp;p, 33554432, sizeof(__Block_byref_p_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;Person&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;))};
        ((void (*)(id, SEL, NSUInteger))(void *)objc_msgSend)((id)(p.__forwarding-&gt;p), sel_registerName(&quot;setAge:&quot;), (NSUInteger)20);

        __attribute__((__blocks__(byref))) __attribute__((objc_ownership(weak))) __Block_byref_weakP_1 weakP = {(void*)0,(__Block_byref_weakP_1 *)&amp;weakP, 33554432, sizeof(__Block_byref_weakP_1), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, (p.__forwarding-&gt;p)};

        SomeBlock block = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_weakP_1 *)&amp;weakP, (__Block_byref_p_0 *)&amp;p, 570425344));

        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
    }
}

static void __Block_byref_id_object_copy_131(void *dst, void *src) {
 // 2⃣️ 根据外界对 p / weakP 的强弱引用产生强弱引用（+ 40 即 Person *__strong p; / Person *__weak weakP;）
 _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);
}
static void __Block_byref_id_object_dispose_131(void *src) {
 // 4⃣️ 释放
 _Block_object_dispose(*(void * *) ((char*)src + 40), 131);
}
</code></pre>

<blockquote>
<p>特殊情况</p>

<p>MRC 下 <code>__Block_byref_xxx</code> 对于变量将总是弱引用（即不会进行 Retain），这也可被用来破解循环引用：</p>
</blockquote>

<pre><code class="language-objectivec">int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __block Person *p = [[Person alloc] init];
        p.age = 20;

        SomeBlock block = [^{
            NSLog(@&quot;%lu&quot;, (unsigned long)p.age); // 20
            p = [Person new];
            p.age = 18;
            NSLog(@&quot;%lu&quot;, (unsigned long)p.age); // 18
        } copy];

        // 正常来说 Block 如果对 p 进行了强引用，引用计数加一，即使调用一次 release 也不应当 dealloc
        [p release]; // dealloc

        block();

        [block release];
    }
}
</code></pre>

<h2 id="循环引用">循环引用</h2>

<p>我们知道，Obj-C 是根据引用计数来管理对象的内存的，但其中的一个问题便是循环引用，即两个对象以强引用互相指向对方，引用计数无法减少，对象无法释放，很容易导致内存泄漏：</p>

<pre><code class="language-objectivec">typedef void(^SomeBlock)(void);

@interface Person : NSObject
@property (nonatomic, assign) NSUInteger age;
@property (nonatomic, copy) SomeBlock block;
@end

@implementation Person

- (void)dealloc
{
    NSLog(@&quot;dealloc&quot;);
}

- (void)foo {
    // ➡️ Block 捕获了 self，self 中强引用 Block，导致双方都无法释放
    self.block = ^{
        NSLog(@&quot;%lu&quot;, (unsigned long)self.age);
        NSLog(@&quot;%lu&quot;, (unsigned long)_age); // self._age
    };
}

@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Person *p = [[Person alloc] init];
        p.age = 20;

        p.block = ^{
            // ➡️ Block 捕获了 p，p 中强引用 Block，导致双方都无法释放（如下图）
            // Capturing 'p' strongly in this block is likely to lead to a retain cycle
            NSLog(@&quot;%lu&quot;, (unsigned long)p.age);
        };

        p.block();
        [p foo];

        // Never dealloc
    }
}

// OUTPUT:
// 20
</code></pre>

<p><img src="/img/2019/block_in_obj-c/5.png" alt="5" /></p>

<h3 id="arc">ARC</h3>

<h4 id="weak-unsafe-unretained"><code>__weak</code> &amp; <code>__unsafe_unretained</code></h4>

<p>想要打破循环引用，我们需要一个不增加引用计数的指向。那么到底更改哪个引用呢？我们仍以上图为例：</p>

<ul>
<li>1⃣️ 处的强引用是我们在初始化时 <code>Person *p = [[Person alloc] init];</code> 所赋予的，栈上的 <code>p</code> 指针存储了堆上的 对象的内存地址；</li>
<li>2⃣️ 处的强引用是 Block 结构体（<code>__main_block_impl_0</code>）对自身捕获到内部的对象的强引用，其引用是根据外界即 1⃣️ 处声明时的强弱来决定的；</li>
<li>3⃣️ 处的强引用是根据我们在 <code>Person</code> 类中声明的属性修饰 <code>@property (nonatomic, copy) SomeBlock block;</code> 所决定的。</li>
</ul>

<p>而我们需要 Block 应当随 <code>Person</code> 对象销毁而销毁，如果将 3⃣️ 处改为弱引用或 <code>__unsafe_unretained</code>，则可能出现 Block 的提前释放。因此综上，我们可以将 1⃣️ 的引用改为弱引用或 <code>__unsafe_unretained</code>：</p>

<pre><code class="language-objectivec">// Person.m
- (void)foo {
    __weak typeof(self) weakSelf = self;
    self.block = ^{
        NSLog(@&quot;%lu&quot;, (unsigned long)weakSelf.age);

        // 需要 __strong 避免编译器报错（也保证在下面使用时 self 没有被释放）
        __strong typeof(weakSelf) strongSelf = weakSelf;
        NSLog(@&quot;%lu&quot;, (unsigned long)strongSelf-&gt;_age);
    };
}

// main.m
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Person *p = [[Person alloc] init];
        p.age = 20;

        // 也可使用 typeof() 简化类型声明
        // __weak typeof(p) weakP = p;
        __weak Person *weakP = p;

        // __unsafe_unretained Person *unsafeUnretainedP = p;
        __unsafe_unretained typeof(p) unsafeUnretainedP = p;

        p.block = ^{
            NSLog(@&quot;%lu&quot;, (unsigned long)weakP.age);
            NSLog(@&quot;%lu&quot;, (unsigned long)unsafeUnretainedP.age);
        };

        p.block();
        [p foo];
    }
}

// OUTPUT:
// 20
// dealloc
</code></pre>

<p>而 <code>__weak</code> &amp; <code>__unsafe_unretained</code> 的区别在于前者在指向的对象销毁时，指针将自动置为 <code>nil</code>（Autoniling），而后者将保留指向的内存地址。</p>

<h4 id="block-1"><code>__block</code></h4>

<p><code>__block</code> 的变量由于可以在 Block 内修改，因此其也可以用来解除循环引用：</p>

<pre><code class="language-objectivec">int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __block Person *p = [[Person alloc] init];
        p.age = 20;

        p.block = ^{
            NSLog(@&quot;%lu&quot;, (unsigned long)p.age);

            p = nil;
        };

        p.block();

        p.block = ^{
            NSLog(@&quot;%lu&quot;, (unsigned long)p.age);

            // 将 __Block_byref_p_0 中的 p 置为 nil，打破循环
            p = nil;
        };

        // p.block();
    }
}

// OUTPUT:
// 20
// dealloc
</code></pre>

<p><img src="/img/2019/block_in_obj-c/6.png" alt="6" /></p>

<p>但需要注意：</p>

<ol>
<li>Block 必须执行才可以置为 <code>nil</code>，破解循环引用；</li>
<li><code>p = nil;</code> 被首次执行时就会释放，因此如果后续再次执行 Block 将出现 <code>EXC_BAD_ACCESS</code> 错误。</li>
</ol>

<h3 id="mrc">MRC</h3>

<p>MRC 下，我们需要手动将栈上的 Block 复制到堆上，并在结束使用时手动释放（Release），但循环引用出现时即使手动释放对象也无法销毁：</p>

<pre><code class="language-objectivec">@interface Person : NSObject
@property (nonatomic, assign) NSUInteger age;
@property (nonatomic, copy) SomeBlock block;
@end

@implementation Person
- (void)dealloc
{
    [super dealloc];
    NSLog(@&quot;dealloc&quot;);
}
@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Person *p = [[Person alloc] init];
        p.age = 20;

        p.block = [^{
            NSLog(@&quot;%lu&quot;, (unsigned long)p.age);
        } copy];

        p.block();

        [p release];

        // Never dealloc
    }
}

// OUTPUT:
// 20
</code></pre>

<p>由于 MRC 没有强弱引用的概念，因从破解循环引用只能使用 <code>__unsafe_unretained</code>，其使得 Block 内部不会对捕获的对象持有（Retain）：</p>

<pre><code class="language-objectivec">int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __unsafe_unretained Person *p = [[Person alloc] init];
        p.age = 20;

        p.block = [^{
            NSLog(@&quot;%lu&quot;, (unsigned long)p.age);
        } copy];

        p.block();

        [p release];
    }
}

// OUTPUT:
// 20
// dealloc
</code></pre>

<p>当然，正如 <code>__block</code> 一节中所述，其也可以用来破解 MRC 下的循环引用，因为 <code>__block</code> 修饰的变量在 MRC 下，<code>__Block_byref_xxx</code> 将不会对捕获的变量持有（Retain）。</p>

<pre><code class="language-objectivec">int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __block Person *p = [[Person alloc] init];
        p.age = 20;

        p.block = [^{
            NSLog(@&quot;%lu&quot;, (unsigned long)p.age);
        } copy];

        p.block();

        [p release];
    }
}

// OUTPUT:
// 20
// dealloc
</code></pre>

    </div>
    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>
        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="/posts/2019/link_map_file_in_xcode/">
                <span class="button__icon">←</span>
                <span class="button__text">Xcode 中的 Link Map 文件</span>
              </a>
            </span>
          
          
            <span class="button next">
              <a href="/posts/2019/const_static_extern_in_cpp/">
                <span class="button__text">C/C&#43;&#43; 中的 const、static &amp; extern</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    

    

    
    
    <div>
      <div id="github-comment">
      </div>

      <script type="text/javascript">
        function getUtterances(isDark) {
          var utterances = document.createElement('script');
          utterances.type = 'text/javascript';
          utterances.async = true;
          utterances.setAttribute('issue-term', "pathname")
          utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
          utterances.setAttribute('label', "comments")
          isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
          utterances.crossorigin = 'anonymous';
          utterances.src = 'https://utteranc.es/client.js';

          return utterances
        }

        var themeToggle = document.querySelector(".theme-toggle")
        themeToggle.addEventListener("click", function () {
          var getTheme = window.localStorage && window.localStorage.getItem("theme")
          var divNode = document.getElementById('github-comment')
          while(divNode.hasChildNodes()) {
            divNode.removeChild(divNode.firstChild);
          }
          
          
          

          
          
          
          
          
          
          document.getElementById('github-comment').appendChild(getUtterances(getTheme !== "dark"))
        })

        var getTheme = window.localStorage && window.localStorage.getItem("theme")
        document.getElementById('github-comment').appendChild(getUtterances(getTheme === "dark"))
      </script>
    </div>
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">All rights reserved by kingcos.me</div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </body>
</html>
