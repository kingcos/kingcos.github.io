<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>iOS 中的 KVC :: iBlog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes     2019-03-25 首次提交    Preface KVC，即 Key-Value Coding，译作键值编码（下文简称 KVC）。当对象兼容 KVC 时，可以通过统一的 API 访问对象中某个键对应的属性值。Cocoa 中的许多功能都依赖 KVC，比如，KVO、Cocoa 绑定机制、Core Data、以及 AppleScript 等。本文将主要探讨 KVC 及其本质相关，关于其它的内容可参考文末的「Reference」。
Basics How #import &amp;lt;Foundation/Foundation.h&amp;gt; @interface Speaker : NSObject @property (nonatomic) int volume; @end @implementation Speaker @end @interface Computer : NSObject @property (nonatomic) NSString *name; @property (nonatomic) NSArray *speakers; @end @implementation Computer @end int main(int argc, const char * argv[]) { @autoreleasepool { Computer *cpt = [[Computer alloc] init]; // ➡️ 通过 setter 设置 [cpt setName:@&amp;quot;My Mac 1&amp;quot;]; // ➡️ 通过 getter 读取 NSLog(@&amp;quot;name from getter - %@&amp;quot;, [cpt name]); // ➡️ 通过 setValue:forKey: 设置 [cpt setValue:@&amp;quot;My Mac 2&amp;quot; forKey:@&amp;quot;name&amp;quot;]; // ➡️ 通过 valueForKey: 读取 NSLog(@&amp;quot;name from KVC - %@&amp;quot;, [cpt valueForKey:@&amp;quot;name&amp;quot;]); Speaker *s1 = [[Speaker alloc] init]; s1."/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/kvc_in_ios/" />


<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/green.css">



<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="/img/favicon/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="iOS 中的 KVC :: iBlog — " />
<meta name="twitter:description" content="Date Notes     2019-03-25 首次提交    Preface KVC，即 Key-Value Coding，译作键值编码（下文简称 KVC）。当对象兼容 KVC 时，可以通过统一的 API 访问对象中某个键对应的属性值。Cocoa 中的许多功能都依赖 KVC，比如，KVO、Cocoa 绑定机制、Core Data、以及 AppleScript 等。本文将主要探讨 KVC 及其本质相关，关于其它的内容可参考文末的「Reference」。
Basics How #import &amp;lt;Foundation/Foundation.h&amp;gt; @interface Speaker : NSObject @property (nonatomic) int volume; @end @implementation Speaker @end @interface Computer : NSObject @property (nonatomic) NSString *name; @property (nonatomic) NSArray *speakers; @end @implementation Computer @end int main(int argc, const char * argv[]) { @autoreleasepool { Computer *cpt = [[Computer alloc] init]; // ➡️ 通过 setter 设置 [cpt setName:@&amp;quot;My Mac 1&amp;quot;]; // ➡️ 通过 getter 读取 NSLog(@&amp;quot;name from getter - %@&amp;quot;, [cpt name]); // ➡️ 通过 setValue:forKey: 设置 [cpt setValue:@&amp;quot;My Mac 2&amp;quot; forKey:@&amp;quot;name&amp;quot;]; // ➡️ 通过 valueForKey: 读取 NSLog(@&amp;quot;name from KVC - %@&amp;quot;, [cpt valueForKey:@&amp;quot;name&amp;quot;]); Speaker *s1 = [[Speaker alloc] init]; s1." />
<meta name="twitter:site" content="/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="iOS 中的 KVC :: iBlog — ">
<meta property="og:description" content="Date Notes     2019-03-25 首次提交    Preface KVC，即 Key-Value Coding，译作键值编码（下文简称 KVC）。当对象兼容 KVC 时，可以通过统一的 API 访问对象中某个键对应的属性值。Cocoa 中的许多功能都依赖 KVC，比如，KVO、Cocoa 绑定机制、Core Data、以及 AppleScript 等。本文将主要探讨 KVC 及其本质相关，关于其它的内容可参考文末的「Reference」。
Basics How #import &amp;lt;Foundation/Foundation.h&amp;gt; @interface Speaker : NSObject @property (nonatomic) int volume; @end @implementation Speaker @end @interface Computer : NSObject @property (nonatomic) NSString *name; @property (nonatomic) NSArray *speakers; @end @implementation Computer @end int main(int argc, const char * argv[]) { @autoreleasepool { Computer *cpt = [[Computer alloc] init]; // ➡️ 通过 setter 设置 [cpt setName:@&amp;quot;My Mac 1&amp;quot;]; // ➡️ 通过 getter 读取 NSLog(@&amp;quot;name from getter - %@&amp;quot;, [cpt name]); // ➡️ 通过 setValue:forKey: 设置 [cpt setValue:@&amp;quot;My Mac 2&amp;quot; forKey:@&amp;quot;name&amp;quot;]; // ➡️ 通过 valueForKey: 读取 NSLog(@&amp;quot;name from KVC - %@&amp;quot;, [cpt valueForKey:@&amp;quot;name&amp;quot;]); Speaker *s1 = [[Speaker alloc] init]; s1." />
<meta property="og:url" content="/posts/2019/kvc_in_ios/" />
<meta property="og:site_name" content="iOS 中的 KVC" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-03-25 00:00:00 &#43;0000 UTC" />











</head>
<body class="">


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    iBlog
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About &amp; AMA</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About &amp; AMA</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/2019/kvc_in_ios/">iOS 中的 KVC</a></h1>
  <div class="post-meta">
    <span class="post-date">
      2019-03-25
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/focus/">Focus</a>&nbsp;
    
    #<a href="/tags/ios/">iOS</a>&nbsp;
    
    #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2019-03-25</td>
<td align="center">首次提交</td>
</tr>
</tbody>
</table>

<h2 id="preface">Preface</h2>

<p>KVC，即 Key-Value Coding，译作键值编码（下文简称 KVC）。当对象兼容 KVC 时，可以通过统一的 API 访问对象中某个键对应的属性值。Cocoa 中的许多功能都依赖 KVC，比如，KVO、Cocoa 绑定机制、Core Data、以及 AppleScript 等。本文将主要探讨 KVC 及其本质相关，关于其它的内容可参考文末的「Reference」。</p>

<h2 id="basics">Basics</h2>

<h3 id="how">How</h3>

<pre><code class="language-objectivec">#import &lt;Foundation/Foundation.h&gt;

@interface Speaker : NSObject
@property (nonatomic) int volume;
@end

@implementation Speaker
@end

@interface Computer : NSObject
@property (nonatomic) NSString *name;
@property (nonatomic) NSArray *speakers;
@end

@implementation Computer
@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Computer *cpt = [[Computer alloc] init];
        // ➡️ 通过 setter 设置
        [cpt setName:@&quot;My Mac 1&quot;];
        // ➡️ 通过 getter 读取
        NSLog(@&quot;name from getter - %@&quot;, [cpt name]);
        
        // ➡️ 通过 setValue:forKey: 设置
        [cpt setValue:@&quot;My Mac 2&quot; forKey:@&quot;name&quot;];
        // ➡️ 通过 valueForKey: 读取
        NSLog(@&quot;name from KVC - %@&quot;, [cpt valueForKey:@&quot;name&quot;]);
        
        Speaker *s1 = [[Speaker alloc] init];
        s1.volume = 5;
        Speaker *s2 = [[Speaker alloc] init];
        s2.volume = 5;
        cpt.speakers = @[s1, s2];
        // ➡️ 通过 setValue:forKeyPath: 设置
        [cpt setValue:@10 forKeyPath:@&quot;speakers.volume&quot;];
        // ➡️ 通过 valueForKeyPath: 读取
        NSLog(@&quot;speakers.volume - %@&quot;, [cpt valueForKeyPath:@&quot;speakers.volume&quot;]);
        
        // ➡️ dictionaryWithValuesForKeys
        NSLog(@&quot;%@&quot;, [cpt dictionaryWithValuesForKeys:@[@&quot;name&quot;, @&quot;speakers&quot;]]);
    }
    return 0;
}

// OUTPUT:
// name from getter - My Mac 1
// name from KVC - My Mac 2
// speakers.volume - (
//     10,
//     10
// )
// {
//     name = &quot;My Mac 2&quot;;
//     speakers =     (
//         &quot;&lt;Speaker: 0x100501610&gt;&quot;,
//         &quot;&lt;Speaker: 0x1005018f0&gt;&quot;
//     );
// }
</code></pre>

<p>定义一个 <code>Computer</code> 类，其拥有 <code>name</code> 和 <code>speakers</code> 属性，后者为数组类型，是容纳 <code>Speaker</code> 类型对象的集合。访问对象的属性，最自然的是通过 getter &amp; setter，但 KVC 提供了通过键或键路径统一访问属性的方式。<code>setValue:forKey:</code> 和 <code>valueForKey:</code> 可以通过键来使用，键即是属性的名称，使用 ASCII 编码，不支持空格；<code>setValue:forKeyPath:</code> 和 <code>valueForKeyPath:</code> 是对应的键路径方法，键路径通过 <code>.</code> 连接键，对于多级嵌套的类型提供了便捷的方式。<code>dictionaryWithValuesForKeys:</code> 支持通过多个键（非键路径）的数组返回包含键和对应值的字典。</p>

<h3 id="why">Why</h3>

<p>KVC 中的方法都定义在 NSObject 的 <code>NSKeyValueCoding</code> 分类（Category）中，所以所有基于 NSObject 类型的对象都是 KVC 兼容的。那么 KVC 是如何根据键或键路径来搜索匹配到属性的呢？</p>

<h4 id="valueforkey">valueForKey</h4>

<h5 id="getter">getter</h5>

<pre><code class="language-objectivec">@interface Computer : NSObject
@end

@implementation Computer

- (NSString *)getName {
    return [NSString stringWithFormat:@&quot;%s&quot;, __func__];
}

- (NSString *)name {
    return [NSString stringWithFormat:@&quot;%s&quot;, __func__];
}

- (NSString *)isName {
    return [NSString stringWithFormat:@&quot;%s&quot;, __func__];
}

- (NSString *)_name {
    return [NSString stringWithFormat:@&quot;%s&quot;, __func__];
}

@end

Computer *cpt = [[Computer alloc] init];
NSLog(@&quot;%@&quot;, [cpt valueForKey:@&quot;name&quot;]);

// 依次注释方法代码可得：
// OUTPUT:
// -[Computer getName]
// -[Computer name]
// -[Computer isName]
// -[Computer _name]
</code></pre>

<p>当调用 <code>valueForKey</code> 方法时，首先会通过传入的 Key 按顺序寻找调用 <code>get&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code>、<code>_&lt;key&gt;</code> getter <strong>方法</strong>，当前面的寻找到并返回后，即提前结束匹配，若该四个方法都没有实现，则进入下一阶段集合元素匹配。</p>

<h5 id="集合匹配">集合匹配</h5>

<pre><code class="language-objectivec">@interface Computer : NSObject {
    @public
    NSArray *_namesArray;
    NSSet *_namesSet;
}
@end

@implementation Computer

// 属性数量
- (NSUInteger)countOfNamesArray {
    NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%s&quot;, __func__]);
    return [_namesArray count];
}

// 数组指定下标的元素（与 namesArrayAtIndexes: 择一实现即可）
- (id)objectInNamesArrayAtIndex:(NSUInteger)index {
    NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%s&quot;, __func__]);
    return [_namesArray objectAtIndex:index];
}

// 数组下标集合的元素数组
- (NSArray *)namesArrayAtIndexes:(NSIndexSet *)indexes {
    NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%s&quot;, __func__]);
    return [_namesArray objectsAtIndexes:indexes];
}

//- (void)getNamesArray:(NSString *)namesArray range:(NSRange)range {
//    NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%s&quot;, __func__]);
//}

// ---

// 属性数量
- (NSUInteger)countOfNamesSet {
    NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%s&quot;, __func__]);
    return [_namesSet count];
}

// 集合枚举
- (NSEnumerator *)enumeratorOfNamesSet {
    NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%s&quot;, __func__]);
    return [_namesSet objectEnumerator];
}

// 集合成员
- (id)memberOfNamesSet:(NSSet *)namesSet {
    NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%s&quot;, __func__]);
    return [_namesSet member:namesSet];
}

@end

Computer *cpt = [[Computer alloc] init];
cpt-&gt;_namesArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;];
NSLog(@&quot;%@&quot;, [cpt valueForKey:@&quot;namesArray&quot;]);

// OUTPUT:
// -[Computer countOfNamesArray]
// -[Computer countOfNamesArray]
// -[Computer objectInNamesArrayAtIndex:] or -[Computer namesArrayAtIndexes:]
// -[Computer objectInNamesArrayAtIndex:] or -[Computer namesArrayAtIndexes:]
// -[Computer objectInNamesArrayAtIndex:] or -[Computer namesArrayAtIndexes:]
// (
//     a,
//     b,
//     c
// )

cpt-&gt;_namesSet = [NSSet setWithArray:@[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;]];
NSLog(@&quot;%@&quot;, [cpt valueForKey:@&quot;namesSet&quot;]);

// OUTPUT:
// -[Computer countOfNamesSet]
// -[Computer countOfNamesSet]
// -[Computer enumeratorOfNamesSet]
// {(
//     a,
//     b,
//     c
// )}
</code></pre>

<p>集合匹配主要是利用集合（Collection）类型的一些方法进行匹配：</p>

<ol>
<li>首先如果 <code>countOf&lt;Key&gt;</code> 方法（其内部本质为 NSArray 或 NSSet 的 <code>count</code>）已经被实现，跳入第 2 步，如果未被实现，则直接跳入成员变量匹配；</li>
<li>若 <code>objectIn&lt;Key&gt;AtIndex:</code>（其内部本质为 NSArray 的 <code>objectAtIndex:</code>）或 <code>&lt;key&gt;AtIndexes:</code>（其内部本质为 NSArray 的 <code>objectsAtIndexes:</code>）两个方法中至少有一个被实现，首先会调用（两次）<code>countOf&lt;Key&gt;</code> 方法；之后会调用两者中被实现的方法，如果均被实现时，只会调用一次前者，并结束匹配；若该两个方法均未实现，跳入第 3 步；</li>
<li>判断 <code>enumeratorOf&lt;Key&gt;</code>（其内部本质为 NSSet 的 <code>objectEnumerator</code>）和 <code>memberOf&lt;Key&gt;:</code>（其内部本质为 NSSet 的 <code>member:</code>）两个方法的实现，若两者都已实现，则会调用 <code>enumeratorOf&lt;Key&gt;</code> 并跳入下一步匹配；若有其中之一未实现，则直接跳入下一步匹配。</li>
</ol>

<ul>
<li>在 2 和 3 步骤中，当这些方法匹配到时，<code>valueForKey</code> 将返回一个集合代理对象。但对于空数组、空集合（Set）或非 NSArray/NSSet 类型的属性只会调用到 <code>countOf&lt;key&gt;</code>，当其返回 <code>0</code> 后续的方法便不会再调用了。</li>
</ul>

<blockquote>
<p>⚠️ 注意</p>

<p>官方文档中提到在上述第 2 步中，如果对象实现了 <code>get&lt;Key&gt;:range:</code> 方法，代理对象也会在合适的时机调用该方法以达到更好的性能。但我在尝试中，在 <code>objectIn&lt;Key&gt;AtIndex:</code> 或 <code>&lt;key&gt;AtIndexes:</code> 中有被实现的方法时，即会在 <code>countOf&lt;Key&gt;</code> 方法被调用后，调用 <code>get&lt;Key&gt;:range:</code> 方法，但会发生崩溃：「Thread 1: EXC_BAD_ACCESS」。具体的原因尚未查明，欢迎大家指教。</p>
</blockquote>

<h4 id="成员变量匹配">成员变量匹配</h4>

<pre><code class="language-objectivec">@interface Computer : NSObject {
    @public
    NSString *_name;
    NSString *_isName;
    NSString *name;
    NSString *isName;
}
@end

@implementation Computer
@end

Computer *cpt = [[Computer alloc] init];

cpt-&gt;_name = @&quot;a&quot;;
cpt-&gt;_isName = @&quot;b&quot;;
cpt-&gt;name = @&quot;c&quot;;
cpt-&gt;isName = @&quot;d&quot;;

NSLog(@&quot;%@&quot;, [cpt valueForKey:@&quot;name&quot;]);

// 依次注释方法和成员变量代码可得：
// OUTPUT:
// a
// b
// c
// d
</code></pre>

<p>在成员变量匹配阶段首先判断 <code>accessInstanceVariablesDirectly</code> 方法的返回，即是否允许直接访问成员变量，默认返回 <code>YES</code>；当为 <code>YES</code> 时，将按顺序尝试直接访问 <code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code> 成员变量。当为 <code>NO</code> 或没有匹配到相应的成员变量时，将调用 <code>valueForUndefinedKey:</code> 方法，该方法默认实现为抛出「NSUnknownKeyException」异常，但子类可以重写该方法以提供更灵活的行为。</p>

<pre><code class="language-objectivec">@interface Computer : NSObject
@end

@implementation Computer

- (id)valueForUndefinedKey:(NSString *)key {
    NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%s&quot;, __func__]);
    if ([key isEqualToString:@&quot;name&quot;]) {
        return nil;
    }
    
    return [super valueForUndefinedKey:key];
}

@end

Computer *cpt = [[Computer alloc] init];
NSLog(@&quot;%@&quot;, [cpt valueForKey:@&quot;name&quot;]);

// OUTPUT:
// -[Computer valueForUndefinedKey:]
// (null)
</code></pre>

<h5 id="总结">总结</h5>

<p>KVC <code>valueForKey:</code> 方法的调用确实深究起来比较复杂，画成图表更容易理解些：</p>

<p><img src="/img/2019/KVC_in_iOS/1.png" alt="" /></p>

<h4 id="setvalue-forkey">setValue:forKey:</h4>

<pre><code class="language-objectivec">@interface Computer : NSObject
@end

@implementation Computer

- (void)setName:(NSString *)name {
    NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%s&quot;, __func__]);
    _name = name;
}

- (void)_setName:(NSString *)name {
    NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%s&quot;, __func__]);
    _name = name;
}

@end

// 依次注释方法代码可得：
// OUTPUT:
// -[Computer setName:] or -[Computer _setName:]
// a
</code></pre>

<p>当调用 <code>setValue:forKey:</code> 方法时，会通过传入的 Key 按顺序寻找调用 <code>set&lt;Key&gt;</code>、<code>_set&lt;Key&gt;</code> 方法，当前面的寻找到并设置后，即提前返回。</p>

<pre><code class="language-objectivec">@interface Computer : NSObject {
    @public
    NSString *_name;
    NSString *_isName;
    NSString *name;
    NSString *isName;
}
@end

@implementation Computer

@end

// 依次注释成员变量代码可得：
// OUTPUT:
// a
// a
// a
// a
</code></pre>

<p>若这两个方法都没有实现，则会判断 <code>accessInstanceVariablesDirectly</code> 方法的返回，即是否允许直接访问成员变量，默认返回 YES；当为 YES 时，将按顺序尝试直接通过 <code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code> 成员变量设置值。当为 NO 或没有匹配到相应的成员变量时，将调用 <code>setValue:forUndefinedKey:</code> 方法，该方法默认实现为抛出「NSUnknownKeyException」异常，但子类可以重写该方法以提供更灵活的行为。</p>

<pre><code class="language-objectivec">@interface Computer : NSObject
@end

@implementation Computer

- (void)setValue:(id)value forUndefinedKey:(NSString *)key {
    NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%s&quot;, __func__]);
    if ([key isEqualToString:@&quot;name&quot;]) {
        return;
    }
    
    return [super setValue:value forUndefinedKey:key];
}

@end

Computer *cpt = [[Computer alloc] init];
[cpt setValue:@&quot;a&quot; forKey:@&quot;name&quot;];
NSLog(@&quot;%@&quot;, [cpt valueForKey:@&quot;name&quot;]);

// OUTPUT:
// -[Computer setValue:forUndefinedKey:]
// -[Computer valueForUndefinedKey:]
// (null)
</code></pre>

<h2 id="mutablevalueforkey">mutableValueForKey</h2>

<h3 id="how-1">How</h3>

<pre><code class="language-objectivec">Computer *cpt = [[Computer alloc] init];

Speaker *s1 = [[Speaker alloc] init];
s1.volume = @1;
Speaker *s2 = [[Speaker alloc] init];
s1.volume = @2;

cpt.speakers = @[s1, s2];

NSMutableArray *arr = [cpt mutableArrayValueForKeyPath:@&quot;speakers&quot;];

Speaker *s3 = [[Speaker alloc] init];
s3.volume = @20;

[arr addObject:s3];

NSLog(@&quot;%@&quot;, [cpt mutableArrayValueForKey:@&quot;speakers&quot;]);

// OUTPUT:
// (
//     &quot;&lt;Speaker: 0x100505220&gt;&quot;,
//     &quot;&lt;Speaker: 0x1005021a0&gt;&quot;,
//     &quot;&lt;Speaker: 0x100502180&gt;&quot;
// )
</code></pre>

<p>对于对象中的集合类型 <code>NSArray</code>、<code>NSSet</code>、<code>NSOrderedSet</code>，KVC 提供了比 <code>setValue:forKey:</code> 和 <code>valueForKey:</code> 更便捷高效的 <code>mutableArrayValueForKey:</code>、<code>mutableSetValueForKey</code>、<code>mutableOrderedSetValueForKey:</code> 以及对应的 <code>KeyPath</code> 方法。它们都会返回一个可变（Mutable）类型的代理对象，在该代理对象上的操作将影响真实的属性值。</p>

<h3 id="why-1">Why</h3>

<pre><code class="language-objectivec">@interface Computer : NSObject {
	@public
	NSMutableArray *_speakers;
}
@end

@implementation Computer
- (void)insertObject:(id)value inSpeakersAtIndex:(NSUInteger)index {
    NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%s&quot;, __func__]);
    [_speakers insertObject:value atIndex:index];
}

- (void)removeObjectFromSpeakersAtIndex:(NSUInteger)index {
    NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%s&quot;, __func__]);
    [_speakers removeObjectAtIndex:index];
}

- (void)insertSpeakers:(id)object atIndexes:(NSIndexSet *)indexes {
    NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%s&quot;, __func__]);
    [_speakers insertObjects:@[object] atIndexes:indexes];
}

- (void)removeSpeakersAtIndexes:(NSIndexSet *)indexes {
    NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%s&quot;, __func__]);
    [_speakers removeObjectsAtIndexes:indexes];
}
@end

Computer *cpt = [[Computer alloc] init];

Speaker *s1 = [[Speaker alloc] init];
s1.volume = @1;
Speaker *s2 = [[Speaker alloc] init];
s1.volume = @2;

cpt-&gt;_speakers = [@[s1, s2] mutableCopy];

NSMutableArray *arr = [cpt mutableArrayValueForKey:@&quot;speakers&quot;];

Speaker *s3 = [[Speaker alloc] init];
s3.volume = @20;

Speaker *s4 = [[Speaker alloc] init];
s4.volume = @30;

[arr addObjectsFromArray:@[s3, s4]];

NSLog(@&quot;%@&quot;, [cpt mutableArrayValueForKey:@&quot;speakers&quot;]);

// OUTPUT:
// -[Computer insertObject:inSpeakersAtIndex:]
// -[Computer insertObject:inSpeakersAtIndex:]
// (
//     &quot;&lt;Speaker: 0x10068cb00&gt;&quot;,
//     &quot;&lt;Speaker: 0x10067a880&gt;&quot;,
//     &quot;&lt;Speaker: 0x100705430&gt;&quot;,
//     &quot;&lt;Speaker: 0x100705020&gt;&quot;
// )
</code></pre>

<p>当调用 <code>mutableArrayValueForKey:</code> 会首先寻找 <code>insertObject:in&lt;key&gt;AtIndex:</code>（其内部本质为 NSMutableArray 的 <code>insertObject:atIndex:</code>）、<code>removeObjectFrom&lt;key&gt;AtIndex:</code>（其内部本质为 NSMutableArray 的 <code>removeObjectAtIndex:</code>）、<code>insertSpeakers:atIndexes:</code>（其内部本质为 NSMutableArray 的 <code>insertObjects:atIndexes:</code>）、<code>removeKeyAtIndexes:</code>（其内部本质为 NSMutableArray 的 <code>removeObjectsAtIndexes:</code>），判断这四个方法中是否有至少一个插入和一个移除方法被实现，如果有，将返回 NSMutableArray 类型的代理对象，并通过调用已实现的插入和移除方法对实际的数组进行操作。</p>

<pre><code class="language-objectivec">@implementation Computer

- (void)setSpeakers:(NSMutableArray *)speakers {
    NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%s&quot;, __func__]);
    _speakers = speakers;
}

@end

// OUTPUT:
// -[Computer setSpeakers:]
// -[Computer setSpeakers:]
// (
//     &quot;&lt;Speaker: 0x101808b90&gt;&quot;,
//     &quot;&lt;Speaker: 0x10180da20&gt;&quot;,
//     &quot;&lt;Speaker: 0x100613c00&gt;&quot;,
//     &quot;&lt;Speaker: 0x100613260&gt;&quot;
// )
</code></pre>

<p>如果上述四个方法不符合至少一个插入和一个移除方法被实现，将寻找 setter <code>setKey:</code> 方法实现，若存在该实现，代理对象将通过它设置值。但若这一阶段的效率将低于上一阶段，因为每次更新数据都需要创建新的一个数组对象。</p>

<pre><code class="language-objectivec">@interface Computer : NSObject {
    @public
    NSMutableArray *_speakers;
    NSMutableArray *speakers;
}
@end

@implementation Computer
@end

// 注释成员变量声明可得到同样的结果：
// OUTPUT:
// (
//     &quot;&lt;Speaker: 0x100601550&gt;&quot;,
//     &quot;&lt;Speaker: 0x100604800&gt;&quot;,
//     &quot;&lt;Speaker: 0x100606190&gt;&quot;,
//     &quot;&lt;Speaker: 0x100600bd0&gt;&quot;
// )
</code></pre>

<p>若 setter 也不存在，将会判断 <code>accessInstanceVariablesDirectly</code> 方法的返回，即是否允许直接访问成员变量，默认返回 YES；当为 YES 时，代理对象将按顺序尝试直接通过 <code>_&lt;key&gt;</code>、<code>&lt;key&gt;</code> 成员变量设置值。当为 NO 或没有匹配到相应的成员变量时，官方文档称将调用 <code>setValue:forUndefinedKey:</code> 方法，该方法默认实现为抛出「NSUnknownKeyException」异常，但子类可以重写该方法以提供更灵活的行为。</p>

<pre><code class="language-objectivec">@interface Computer : NSObject
@end

@implementation Computer
- (id)valueForUndefinedKey:(NSString *)key {
    NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%s&quot;, __func__]);
    return [super valueForUndefinedKey:key];
}

- (void)setValue:(id)value forUndefinedKey:(NSString *)key {
    NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;%s&quot;, __func__]);
    return [super setValue:value forUndefinedKey:key];
}
@end

Speaker *s3 = [[Speaker alloc] init];
s3.volume = @20;

[arr addObject:s3];

// OUTPUT:
// -[Computer valueForUndefinedKey:]
// *** Terminating app due to uncaught exception 'NSUnknownKeyException', reason: '[&lt;Computer 0x1005426d0&gt; valueForUndefinedKey:]: this class is not key value coding-compliant for the key speakers.'
</code></pre>

<p>但其实经过测试，对代理对象进行插入操作，将首先进入 <code>valueForUndefinedKey:</code>，若该 key 无法匹配，将抛出「NSUnknownKeyException」异常，若这一步骤未抛出异常，才将会进入到 <code>setValue:forUndefinedKey:</code>。原因我认为是当我们对代理对象进行插入操作时，首先要获得其中原本的元素，所以此时如果无法匹配，将抛出异常提前终止。</p>

<h2 id="集合操作符">集合操作符</h2>

<p>对于对象中的集合类型，KVC 提供了一些可以放置在键路径中的操作符，由 <code>@</code> 开头，整体结构为：<code>左键路径.@集合操作符.右键路径</code>，当然，左右键路径都可以根据需要选择是否忽略。集合操作符分为三种：聚合（Aggregation）操作符、数组操作符、嵌套（Nesting）操作符。</p>

<table>
    <tr>
        <th>类型</th>
        <th>操作符</th>
        <th>作用</th>
    </tr>
    <tr>
        <td rowspan="6" align="center">聚合操作符<br>（针对数组或集合类型，最终返回反应集合某个特性的单一值）</td>
    </tr>
    <tr>
        <td><code>@avg</code></td>
        <td>将数值转换为 <code>double</code> 类型求和并计算平均值（<code>nil</code> 值为 <code>0</code>），并返回 <code>NSNumber</code> 类型的实例</td>
    </tr>
    <tr>
        <td><code>@count</code></td>
        <td>计算集合类型中的对象数量，将忽略右键路径</td>
    </tr>
    <tr>
        <td><code>@max</code></td>
        <td>内部使用 <code>compare:</code> 方法比对出最大值（忽略 <code>nil</code> 值），并返回 <code>NSNumber</code> 类型的实例</td>
    </tr>
    <tr>
        <td><code>@min</code></td>
        <td>内部使用 <code>compare:</code> 方法比对出最小值（忽略 <code>nil</code> 值），并返回 <code>NSNumber</code> 类型的实例</td>
    </tr>
    <tr>
        <td><code>@sum</code></td>
        <td>将数值转换为 <code>double</code> 类型求和（<code>nil</code> 值为 <code>0</code>），并返回 <code>NSNumber</code> 类型的实例</td>
    </tr>
    <tr>
        <td rowspan="3" align="center">数组操作符<br>（返回特定的对象数组）</td>
    </tr>
    <tr>
        <td><code>@unionOfObjects</code></td>
        <td>返回包含右键路径指定属性的对象数组（即值为 <code>nil</code> 时不会被包含进来）</td>
    </tr>
    <tr>
        <td><code>@distinctUnionOfObjects</code></td>
        <td>返回包含右键路径指定属性的对象数组（即值为 <code>nil</code> 时不会被包含进来），并去重</td>
    </tr>
    <tr>
        <td rowspan="4" align="center">嵌套操作符<br>（嵌套意为包含集合的集合）</td>
    </tr>
    <tr>
        <td><code>@unionOfArrays</code></td>
        <td>返回调用数组中所有数组中包含右键路径指定属性的对象数组（当指定属性的值为 <code>nil</code> 时，对象将返回空）</td>
    </tr>
    <tr>
        <td><code>@distinctUnionOfArrays</code></td>
        <td>返回调用数组中所有数组中包含右键路径指定属性的对象数组（当指定属性的值为 <code>nil</code> 时，对象将返回空，多个空对象也会被去重），并去重</td>
    </tr>
    <tr>
        <td><code>@distinctUnionOfSets</code></td>
        <td>返回调用集合（Set）中所有集合（Set）中包含右键路径指定属性的对象数组（即值为 <code>nil</code> 时不会被包含进来，多个空对象也会被去重），并去重</td>
    </tr>
</table>

<pre><code class="language-objectivec">@interface Speaker : NSObject
// ⚠️ 注意：这里将 volume 改为 NSNumber * 类型，因为 int 时，属性将有默认值 0，不便于后续结果演示
@property (nonatomic) NSNumber *volume;
@end

@implementation Speaker
@end

// main()
Computer *cpt1 = [[Computer alloc] init];
Speaker *s1 = [[Speaker alloc] init];
s1.volume = @1;
Speaker *s2 = [[Speaker alloc] init];
s2.volume = @2;
Speaker *s3 = [[Speaker alloc] init];
s3.volume = @2;
Speaker *s4 = [[Speaker alloc] init];
// s4.volume = nil;
Speaker *s5 = [[Speaker alloc] init];
s5.volume = @5;

[cpt1 setValue:@[s1, s2, s3, s4, s5] forKey:@&quot;speakers&quot;];

// Aggregation Operators:
NSLog(@&quot;Aggregation Operators:&quot;);
NSLog(@&quot;Volumes at avg: %.2lf&quot;, [[cpt1 valueForKeyPath:@&quot;speakers.@avg.volume&quot;] doubleValue]);
NSLog(@&quot;Speakers at count: %d&quot;, [[cpt1 valueForKeyPath:@&quot;speakers.@count&quot;] intValue]);
NSLog(@&quot;Volumes at max: %.2lf&quot;, [[cpt1 valueForKeyPath:@&quot;speakers.@max.volume&quot;] doubleValue]);
NSLog(@&quot;Volumes at min: %.2lf&quot;, [[cpt1 valueForKeyPath:@&quot;speakers.@min.volume&quot;] doubleValue]);
NSLog(@&quot;Volumes at sum: %.2lf&quot;, [[cpt1 valueForKeyPath:@&quot;speakers.@sum.volume&quot;] doubleValue]);

// OUTPUT:
// Aggregation Operators:
// Volumes at avg: 2.00
// Speakers at count: 5
// Volumes at max: 5.00
// Volumes at min: 1.00
// Volumes at sum: 10.00

// Array Operators:
NSLog(@&quot;Array Operators:&quot;);
NSLog(@&quot;%@&quot;, [cpt1.speakers valueForKeyPath:@&quot;@unionOfObjects.volume&quot;]);
NSLog(@&quot;%@&quot;, [cpt1.speakers valueForKeyPath:@&quot;@distinctUnionOfObjects.volume&quot;]);

Computer *cpt2 = [[Computer alloc] init];
Speaker *s6 = [[Speaker alloc] init];
s6.volume = @5;
Speaker *s7 = [[Speaker alloc] init];
// s7.volume = nil;
Speaker *s8 = [[Speaker alloc] init];
s8.volume = @8;
cpt2.speakers = @[s6, s7, s8];

// OUTPUT:
// Array Operators:
// (
//     1,
//     2,
//     2,
//     5
// )
// (
//     2,
//     5,
//     1
// )

// Nesting Operators:
NSLog(@&quot;Nesting Operators:&quot;);
NSArray *arrayOfArrays = @[cpt1.speakers, cpt2.speakers];
NSLog(@&quot;%@&quot;, [arrayOfArrays valueForKeyPath:@&quot;@unionOfArrays.volume&quot;]);
NSLog(@&quot;%@&quot;, [arrayOfArrays valueForKeyPath:@&quot;@distinctUnionOfArrays.volume&quot;]);

NSSet *setOfSets = [NSSet setWithArray:@[[NSSet setWithArray:cpt1.speakers], [NSSet setWithArray:cpt2.speakers]]];
NSLog(@&quot;%@&quot;, [setOfSets valueForKeyPath:@&quot;@distinctUnionOfSets.volume&quot;]);

// OUTPUT:
// Nesting Operators:
// (
//     1,
//     2,
//     2,
//     &quot;&lt;null&gt;&quot;,
//     5,
//     5,
//     &quot;&lt;null&gt;&quot;,
//     8
// )
// (
//     5,
//     1,
//     2,
//     &quot;&lt;null&gt;&quot;,
//     8
// )
// {(
//     2,
//     5,
//     8,
//     1
// )}
</code></pre>

<h2 id="非对象属性">非对象属性</h2>

<p>当 KVC 中的 <code>valueForKey:</code> 或 <code>valueForKeyPath:</code> 获取到的值不是 Obj-C 对象时，将会以其值初始化     <code>NSNumber</code> 对象（针对标量（Scalar））或 <code>NSValue</code> 对象（针对结构体）并返回。</p>

<ul>
<li><p>标量值</p>

<pre><code class="language-objectivec">@interface Computer : NSObject {
@public
int _diskSize;
}
@end

@implementation Computer
@end

Computer *cpt = [[Computer alloc] init];
cpt-&gt;_diskSize = 512;
NSNumber *diskSizeNum = [cpt valueForKey:@&quot;diskSize&quot;];
NSLog(@&quot;Disk size: %d.&quot;, [diskSizeNum intValue]);

// LLDB:
// (lldb) po object_getClass([cpt valueForKey:@&quot;diskSize&quot;])
// __NSCFNumber

// OUTPUT:
// Disk size: 512.
</code></pre></li>

<li><p>结构体</p>

<pre><code class="language-objectivec">typedef struct {
NSSize size;
double inch;
} Screen;

@interface Computer : NSObject {
@public
Screen _screen;
}
@end

@implementation Computer
@end

Computer *cpt = [[Computer alloc] init];
cpt-&gt;_screen.size = NSMakeSize(1920, 1090);
cpt-&gt;_screen.inch = 15.6;

// ➡️ valueForKey
NSValue *value = [cpt valueForKey:@&quot;screen&quot;];

Screen screen;
[value getValue:&amp;screen];

NSLog(@&quot;Screen size: %.f * %.f\nScreen inch: %.1lf&quot;, screen.size.width, screen.size.height, screen.inch);

// OUTPUT:
// Screen size: 1920 * 1090
// Screen inch: 15.6

Screen retinaScreen;
retinaScreen.size = NSMakeSize(2560, 1600);
retinaScreen.inch = 13.3;

NSValue *retinaValue = [NSValue valueWithBytes:&amp;retinaScreen objCType:@encode(Screen)];

// ➡️ setValue:forKey
[cpt setValue:retinaValue forKey:@&quot;screen&quot;];

NSLog(@&quot;Screen size: %.f * %.f\nScreen inch: %.1lf&quot;, cpt-&gt;_screen.size.width, cpt-&gt;_screen.size.height, cpt-&gt;_screen.inch);

// OUTPUT:
// Screen size: 2560 * 1600
// Screen inch: 13.3
</code></pre></li>
</ul>

<h2 id="属性校验">属性校验</h2>

<pre><code class="language-objectivec">static NSString * const kKVCValidateErrorDomain = @&quot;kKVCValidateErrorDomain&quot;;

typedef NS_ENUM(NSUInteger, KVCValidateError) {
    KVCValidateErrorNilValue
};

@interface Computer : NSObject
@property (nonatomic) NSString *name;
@end

@implementation Computer

- (BOOL)validateValue:(inout id  _Nullable __autoreleasing *)ioValue
               forKey:(NSString *)inKey
                error:(out NSError * _Nullable __autoreleasing *)outError {
    if ([inKey isEqualToString:NSStringFromSelector(@selector(name))]) {
        if (*ioValue != nil) {
            return YES;
        } else {
            *outError = [NSError errorWithDomain:kKVCValidateErrorDomain
                                            code:KVCValidateErrorNilValue
                                        userInfo:nil];
            return NO;
        }
    }
    
    return [super validateValue:ioValue forKey:inKey error:outError];
}

@end

Computer *cpt = [[Computer alloc] init];

NSString *nilName = nil;
NSError *err;

if (![cpt validateValue:&amp;nilName forKey:@&quot;name&quot; error:&amp;err]) {
    NSLog(@&quot;Error domain: %@, code: %ld&quot;, err.domain, (long)err.code);
} else {
    [cpt setValue:nilName forKey:@&quot;name&quot;];
}

// OUTPUT:
// Error domain: kKVCValidateErrorDomain, code: 0
</code></pre>

<p>KVC 中的属性校验的方法可以让我们在设置值前先进行校验，即 <code>validateValue:forKey:error:</code>。该方法会调用被观察对象的 <code>validateValue:forKey:error:</code> 方法，NSObject 中的默认实现是返回 <code>YES</code> 即不作校验。所以当我们需要校验 <code>value</code> 是否为空，需要自己实现该方法。需要注意的是，<code>validateValue:forKey:error:</code> 和 <code>validateValue:forKey:error:</code> 方法中的 <code>value</code> 和 <code>error</code> 参数均是引用传递，外界调用时要传入相应的地址 <code>&amp;value</code> 和 <code>&amp;error</code>，而在方法内部我们只需要在方法中将其赋值到 <code>*value</code> 和 <code>*error</code> 即可。</p>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="/img/2019/KVC_in_iOS/https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html">Key-Value Coding Programming Guide</a></li>
<li><a href="/img/2019/KVC_in_iOS/https://github.com/kingcos/Perspective/tree/writing/Posts/Focus/KVO_in_iOS">Practice - iOS 中的 KVO</a></li>
</ul>

  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span
        class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      <span class="button previous">
        <a href="/posts/2019/ivar_access_control_in_obj-c/">
          <span class="button__icon">←</span>
          <span class="button__text">Obj-C 中实例变量和类的访问控制</span>
        </a>
      </span>
      
      
      <span class="button next">
        <a href="/posts/2019/override_and_overload_in_obj-c/">
          <span class="button__text">Obj-C 中的重载与重写</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo="kingcos/kingcos.github.io"
            issue-term="pathname"
            label="comments"
            theme="github-dark"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2019 · <a href="http://github.com/kingcos">kingcos</a></span>
      </div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>





  
</div>

</body>
</html>
