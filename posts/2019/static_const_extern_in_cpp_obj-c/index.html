<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>C/C&#43;&#43;/Obj-C/C&#43;&#43; 中的 static、const &amp; extern :: iBlog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Notes     2019-07-23 首次提交 clang&#43;&#43;    Preface 熟悉又陌生的 static、const &amp;amp; extern 关键词，是时候全部搞清楚啦。
基础类型 对于基础类型，其在内存中存储的即是该类型的变量本身，经过 const 修饰后，此处的变量不可变，即常量。const 的位置并不会影响其作用，更为推荐的写法应当是编译器提示的 const &amp;lt;TYPE&amp;gt;。
以下是在 C/C&#43;&#43; 中的用例，由于 Obj-C/C&#43;&#43; 分别是 C/C&#43;&#43; 的超集，对于 C/C&#43;&#43; 的基础类型，其在 Obj-C/C&#43;&#43; 的表现是一致的：
int a = 0; a = 10; const int b = 0; // error: cannot assign to variable &#39;b&#39; with const-qualified type &#39;const int&#39; // b = 10; int const c = 0; // c = 10;  对于 Obj-C 中特有的基本类型，const 也与修饰 C/C&#43;&#43; 中基础类型的行为一致："/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/static_const_extern_in_cpp_obj-c/" />


<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/green.css">



<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="/img/favicon/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="C/C&#43;&#43;/Obj-C/C&#43;&#43; 中的 static、const &amp; extern :: iBlog — " />
<meta name="twitter:description" content="Date Notes Notes     2019-07-23 首次提交 clang&#43;&#43;    Preface 熟悉又陌生的 static、const &amp;amp; extern 关键词，是时候全部搞清楚啦。
基础类型 对于基础类型，其在内存中存储的即是该类型的变量本身，经过 const 修饰后，此处的变量不可变，即常量。const 的位置并不会影响其作用，更为推荐的写法应当是编译器提示的 const &amp;lt;TYPE&amp;gt;。
以下是在 C/C&#43;&#43; 中的用例，由于 Obj-C/C&#43;&#43; 分别是 C/C&#43;&#43; 的超集，对于 C/C&#43;&#43; 的基础类型，其在 Obj-C/C&#43;&#43; 的表现是一致的：
int a = 0; a = 10; const int b = 0; // error: cannot assign to variable &#39;b&#39; with const-qualified type &#39;const int&#39; // b = 10; int const c = 0; // c = 10;  对于 Obj-C 中特有的基本类型，const 也与修饰 C/C&#43;&#43; 中基础类型的行为一致：" />
<meta name="twitter:site" content="/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="C/C&#43;&#43;/Obj-C/C&#43;&#43; 中的 static、const &amp; extern :: iBlog — ">
<meta property="og:description" content="Date Notes Notes     2019-07-23 首次提交 clang&#43;&#43;    Preface 熟悉又陌生的 static、const &amp;amp; extern 关键词，是时候全部搞清楚啦。
基础类型 对于基础类型，其在内存中存储的即是该类型的变量本身，经过 const 修饰后，此处的变量不可变，即常量。const 的位置并不会影响其作用，更为推荐的写法应当是编译器提示的 const &amp;lt;TYPE&amp;gt;。
以下是在 C/C&#43;&#43; 中的用例，由于 Obj-C/C&#43;&#43; 分别是 C/C&#43;&#43; 的超集，对于 C/C&#43;&#43; 的基础类型，其在 Obj-C/C&#43;&#43; 的表现是一致的：
int a = 0; a = 10; const int b = 0; // error: cannot assign to variable &#39;b&#39; with const-qualified type &#39;const int&#39; // b = 10; int const c = 0; // c = 10;  对于 Obj-C 中特有的基本类型，const 也与修饰 C/C&#43;&#43; 中基础类型的行为一致：" />
<meta property="og:url" content="/posts/2019/static_const_extern_in_cpp_obj-c/" />
<meta property="og:site_name" content="C/C&#43;&#43;/Obj-C/C&#43;&#43; 中的 static、const &amp; extern" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-07-23 00:00:00 &#43;0000 UTC" />











</head>
<body class="">


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    iBlog
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About &amp; AMA</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About &amp; AMA</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/2019/static_const_extern_in_cpp_obj-c/">C/C++/Obj-C/C++ 中的 static、const &amp; extern</a></h1>
  <div class="post-meta">
    <span class="post-date">
      2019-07-23
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/focus/">Focus</a>&nbsp;
    
    #<a href="/tags/ios/">iOS</a>&nbsp;
    
    #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
    
    #<a href="/tags/c/c&#43;&#43;/">C/C&#43;&#43;</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Notes</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2019-07-23</td>
<td align="center">首次提交</td>
<td align="center"><code>clang++</code></td>
</tr>
</tbody>
</table>

<h2 id="preface">Preface</h2>

<p>熟悉又陌生的 <code>static</code>、<code>const</code> &amp; <code>extern</code> 关键词，是时候全部搞清楚啦。</p>

<h2 id="基础类型">基础类型</h2>

<p>对于基础类型，其在内存中存储的即是该类型的变量本身，经过 <code>const</code> 修饰后，此处的变量不可变，即常量。<code>const</code> 的位置并不会影响其作用，更为推荐的写法应当是编译器提示的 <code>const &lt;TYPE&gt;</code>。</p>

<p>以下是在 C/C++ 中的用例，由于 Obj-C/C++ 分别是 C/C++ 的超集，对于 C/C++ 的基础类型，其在 Obj-C/C++ 的表现是一致的：</p>

<pre><code class="language-cpp">int a = 0;
a = 10;

const int b = 0;
// error: cannot assign to variable 'b' with const-qualified type 'const int'
// b = 10;

int const c = 0;
// c = 10;
</code></pre>

<p>对于 Obj-C 中特有的基本类型，<code>const</code> 也与修饰 C/C++ 中基础类型的行为一致：</p>

<pre><code class="language-objectivec">BOOL a = YES;
a = NO;

const BOOL b = YES;
// Cannot assign to variable 'b' with const-qualified type 'const BOOL' (aka 'const signed char')
// b = NO;

BOOL const c = YES;
// c = NO;
</code></pre>

<h3 id="数组类型">数组类型</h3>

<p>对于数组类型，即使用连续的一段内存来容纳同一类型元素的容器。当在 C/C++ 中使用 <code>const</code> 修饰基本类型的数组时，其中的内容将不能再改变：</p>

<pre><code class="language-cpp">int a[] = {1, 2, 3};
a[0] = 0;

int const b[] = {1, 2, 3};
// error: read-only variable is not assignable
// b[0] = 1;

const int c[] = {1, 2, 3};
// c[0] = 1;
</code></pre>

<p>对于 Obj-C，在 C 语言之上添加了面向对象的部分，其需要存储自身定义的对象类型的容器类，所以数组等集合（注：这里的集合并非特指 Set，而是指 Collection，下略）类型被单独拎出来独立为 <code>NSArray</code>、<code>NSSet</code> 等类型，且默认即作为不可变版本，并在使用时需结合指针。需要注意的是，这里的不可变仅针对内部元素（即变量内部地址指向的内存区域），对于指针本身（变量内部的地址）是可变的。可变版本 <code>NSMutableArray</code> 等则可以修改内部元素和指针本身。</p>

<p>由于 Obj-C 自身的可变和不可变集合类型，<code>const</code> 的作用其实就显得有些多余，这里的 <code>const</code> 将类似针对指针类型的行为。当 <code>const</code> 位于 <code>NSArray</code> 或 <code>NSMutableArray</code> 之前或之后时均没有作用；当 <code>const</code> 位于 <code>NSArray *</code> 或 <code>NSMutableArray *</code> 之后时，使得指针本身的值不可变时，它们就无法被指向新的 <code>NSArray</code> 或 <code>NSMutableArray</code> 了。</p>

<pre><code class="language-objectivec">NSArray *a = @[@1, @2, @3];
// Expected method to write array element not found on object of type 'NSArray *'
// a[0] = @0;
a = @[@3, @2, @1];

const NSArray *b = @[@1, @2, @3];
b = @[@3, @2, @1];

NSArray const *c = @[@1, @2, @3];
c = @[@3, @2, @1];

NSArray * const d = @[@1, @2, @3];
// Cannot assign to variable 'd' with const-qualified type 'NSArray *const __strong'
// d = @[@3, @2, @1];

NSMutableArray *e = [a mutableCopy];
e[0] = @0;
e = [a mutableCopy];

const NSMutableArray *f = [a mutableCopy];
f[0] = @0;
f = [a mutableCopy];

NSMutableArray const *g = [a mutableCopy];
g[0] = @0;
g = [a mutableCopy];

NSMutableArray * const h = [a mutableCopy];
h[0] = @0;
// Cannot assign to variable 'h' with const-qualified type 'NSMutableArray *const __strong'
// h = [a mutableCopy];
</code></pre>

<h3 id="指向基础类型的指针">指向基础类型的指针</h3>

<p>在上一节中，我们已经接触了 Obj-C 中的 <code>NSArray</code> 的指针，但为了更加清晰，我们将重新先从指向基础类型的指针开始。</p>

<p>指针，是指存储内存地址的一种数据类型，内存地址是由编译器来决定的，因此指针的大小由编译器决定。在 <code>clang++</code> 中，地址的长度为 8 个字节，因此无论 <code>int *</code>、<code>double *</code> 还是 <code>char *</code> 类型的指针其大小均为 8 个字节。</p>

<p><img src="/img/2019/static_const_extern_in_cpp_obj-c/1.png" alt="1" /></p>

<pre><code class="language-cpp">int foo = 0;
int bar = 10;

int *c = &amp;foo;
c = &amp;bar;
*c = foo;

const int *d = &amp;foo;
d = &amp;bar;
// error: read-only variable is not assignable
// *d = foo;

int const *e = &amp;foo;
e = &amp;bar;
// *e = foo;

int *const f = &amp;foo;
// error: cannot assign to variable 'f' with const-qualified type 'int *const'
// f = &amp;bar;
*f = foo;
</code></pre>

<h3 id="指向对象类型的指针">指向对象类型的指针</h3>

<pre><code class="language-cpp">class Foo
{
public:
    double bar;

    Foo(double _bar)
    {
        bar = _bar;
    }
};

Foo *foo1 = new Foo(0.0);
foo1-&gt;bar = 0.5;
cout &lt;&lt; foo1-&gt;bar &lt;&lt; endl;

foo1 = new Foo(1.5);
cout &lt;&lt; foo1-&gt;bar &lt;&lt; endl;

const Foo *foo2 = new Foo(0.0);
// error: cannot assign to variable 'foo2' with const-qualified type 'const Foo *'
// foo2-&gt;bar = 0.5;

foo2 = new Foo(1.5);

Foo const *foo3 = new Foo(0.0);
// foo3-&gt;bar = 0.5;

foo3 = new Foo(1.5);

Foo *const foo4 = new Foo(0.0);
foo4-&gt;bar = 0.5;

// error: cannot assign to variable 'foo4' with const-qualified type 'Foo *const'
// foo4 = new Foo(1.5);
</code></pre>

<h3 id="指向指针的指针">指向指针的指针</h3>

<pre><code class="language-cpp">int foo = 0;
int foo2 = 10;
int *bar = &amp;foo;
int *bar2 = &amp;foo2;
int **baz = &amp;bar;

cout &lt;&lt; **baz &lt;&lt; endl;
baz = &amp;bar2;
cout &lt;&lt; **baz &lt;&lt; endl;
*baz = &amp;foo2;
cout &lt;&lt; **baz &lt;&lt; endl;
**baz = foo2;
cout &lt;&lt; **baz &lt;&lt; endl;

cout &lt;&lt; &quot;---&quot; &lt;&lt; endl;

// error: cannot initialize a variable of type 'const int **' with an rvalue of type 'int **'
// const int **baz2 = &amp;bar;

// int const **baz2 = &amp;bar;

int *const *baz2 = &amp;bar;
cout &lt;&lt; **baz2 &lt;&lt; endl;
baz2 = &amp;bar2;
cout &lt;&lt; **baz2 &lt;&lt; endl;
// error: read-only variable is not assignable
// *baz2 = &amp;foo2;
**baz2 = foo2;
cout &lt;&lt; **baz2 &lt;&lt; endl;

cout &lt;&lt; &quot;---&quot; &lt;&lt; endl;

int **const baz3 = &amp;bar;
cout &lt;&lt; **baz3 &lt;&lt; endl;
// error: cannot assign to variable 'baz3' with const-qualified type 'int **const'
// baz3 = &amp;bar2;
*baz3 = &amp;foo2;
cout &lt;&lt; **baz3 &lt;&lt; endl;
**baz3 = foo2;
cout &lt;&lt; **baz3 &lt;&lt; endl;

// OUTPUT:
// 0
// 10
// 10
// 10
// ---
// 0
// 10
// 10
// ---
// 0
// 10
// 10
</code></pre>

<h2 id="reference">Reference</h2>

<pre><code>

//        PersonA *p = [[PersonA alloc] init];
//        [p doSomethingHiddly];

        ////    AAA = @&quot;BBB&quot;;
        //    BBB = @&quot;CCC&quot;;
        //    NSString *a = @&quot;CCC&quot;;
        //    BBB = a;
        ////    NSLog(@&quot;%@&quot;, BBB);
        ////    DDD = 333;
        ////    CCC = 333;

//        NSString * const D = @&quot;DD&quot;;
//        const NSString *E = @&quot;EE&quot;;
//
//        id DD = [D copy];
//        id EE = [E copy];
//
//        //    D = @&quot;D&quot;;
//        E = [[NSString alloc] init];
//
//        BBB = @&quot;&quot;;
//
//        // 指向的内存地址不能改，自己的地址能改
//        PersonA * const ppp1 = [[PersonA alloc] init];
//        // 指向的内存地址能改，自己的地址不能改
//        const PersonA * ppp2 = [[PersonA alloc] init];
//        const PersonA * const ppp3 = [[PersonA alloc] init];
//
//        PersonA const * ppp4 = [[PersonA alloc] init];
//        PersonA const * const ppp5 = [[PersonA alloc] init];


//        PersonA * ppp3 = ppp1;
//        &amp;ppp1 = &amp;ppp3;
//
//        ppp1.name = @&quot;111&quot;;
//
//        ppp1 = [[PersonA alloc] init];
//        ppp2 = [[PersonA alloc] init];



//        ppp4.name = @&quot;&quot;;



        // 一旦变量被声明，系统将为该变量分配内存空间，这块内存空间是不可更改的。

        // a/b 是 int 型，保存的数据是 int
        // 这个数据本身是不能更改的
        const int a = 5;
//        a = 10;
        // ---
        int const b = 5;
//        b = 10;
        // ---
        int cc = 5;
        int dd = 10;
        // c 是指针类型，保存的数据是内存地址，该内存地址指向的区域存储了 int 类型
        // const int * c 代表保存的内存地址可以改变，但其保存的内存地址所指向的 int 不可变
        // const int const * c == int const * c == const int * c
        int const * c = &amp;cc;
//        const int * c = &amp;cc;
//        const int const * c = &amp;cc;
//        *c = dd;
        c = &amp;dd;

        NSLog(@&quot;c - %d&quot;, *c);

        // d 是指针类型，保存的数据是内存地址，该内存地址指向的区域存储了 int 类型
        // int * const d 代表保存的内存地址不可变，但其保存的内存地址所指向的 int 可以变
        int * const d = &amp;dd;
//        d = &amp;cc;
        *d = cc;

        NSLog(@&quot;d - %d&quot;, *d);

        int ee = 5;
        int eee = 10;

        // e 是指针类型，保存的数据是内存地址，该内存地址指向的区域存储了 int 类型
        // const int * const e 代表保存的内存地址和其所指向的 int 都不可以变
        const int * const e = &amp;ee;
//        e = &amp;eee;
//        *e = eee;

        const NSString *str = @&quot;str&quot;;
        str = @&quot;string&quot;;


//        const Person * p = [[Person alloc] init];
//        const Person const * p = [[Person alloc] init];
//        PersonA const * p = [[PersonA alloc] init];
//        p-&gt;_height = 10;
//        p-&gt;_name = @&quot;&quot;;
//        p = [PersonA new];

//        PersonA * const pp = [[PersonA alloc] init];
//        pp-&gt;_height = 10;
//        pp-&gt;_name = @&quot;&quot;;
//        pp = [Person new];

        PersonA *pa = [[PersonA alloc] init];
//        pa-&gt;_name = @&quot;11&quot;;
//        NSLog(@&quot;%@&quot;, pa-&gt;_name);
        pa.name = @&quot;11&quot;;
        [pa test];





//        NSString *str1 = [[NSString alloc] initWithString:@&quot;The string&quot;];
//        NSString *str2 = [NSString stringWithString:@&quot;The string&quot;];
//        NSString *str3 = @&quot;The string&quot;;
//        NSString *str4 = [NSString stringWithFormat:@&quot;string&quot;];
//        NSString *str5 = str4;
//        Method method = class_getInstanceMethod([PersonA class], @selector(doSomethingHiddly));

        NSLog(@&quot;---&quot;);
        NSString *aaa = @&quot;1234567890-&quot;;
        NSString *bbb = @&quot;1234567890-&quot;;
        bbb = @&quot;&quot;;

        NSLog(@&quot;%d&quot;, aaa == bbb);
        NSLog(@&quot;%d&quot;, [aaa isEqual:bbb]);
        NSLog(@&quot;%d&quot;, [aaa isEqualToString:bbb]);
        NSLog(@&quot;%d&quot;, aaa == @&quot;1234567890-&quot;);
</code></pre>

  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span
        class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      
      <span class="button next">
        <a href="/posts/2019/objc_msgsend/">
          <span class="button__text">objc_msgSend</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo="kingcos/kingcos.github.io"
            issue-term="pathname"
            label="comments"
            theme="github-dark"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2019 · <a href="http://github.com/kingcos">kingcos</a></span>
      </div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>





  
</div>

</body>
</html>
