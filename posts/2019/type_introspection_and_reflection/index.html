<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Obj-C &amp; Swift 的类型内省与反射 :: iBlog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Swift Demo     2019-04-08 首次提交 4.2 Type Introspection and Reflection    Preface 许多编程语言中都有类型内省（又称自省，Introspection）和反射（Reflection）这两个概念，本文将探讨一下 Obj-C 和 Swift 中类型内省和反射的相关概念与具体使用。
What 维基百科中对于类型内省定义如下：
 In computing, type introspection is the ability of a program to examine the type or properties of an object at runtime. Some programming languages possess this capability.
Introspection should not be confused with reflection, which goes a step further and is the ability for a program to manipulate the values, meta-data, properties and/or functions of an object at runtime."/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/type_introspection_and_reflection/" />


<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/green.css">



<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="/img/favicon/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Obj-C &amp; Swift 的类型内省与反射 :: iBlog — " />
<meta name="twitter:description" content="Date Notes Swift Demo     2019-04-08 首次提交 4.2 Type Introspection and Reflection    Preface 许多编程语言中都有类型内省（又称自省，Introspection）和反射（Reflection）这两个概念，本文将探讨一下 Obj-C 和 Swift 中类型内省和反射的相关概念与具体使用。
What 维基百科中对于类型内省定义如下：
 In computing, type introspection is the ability of a program to examine the type or properties of an object at runtime. Some programming languages possess this capability.
Introspection should not be confused with reflection, which goes a step further and is the ability for a program to manipulate the values, meta-data, properties and/or functions of an object at runtime." />
<meta name="twitter:site" content="/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Obj-C &amp; Swift 的类型内省与反射 :: iBlog — ">
<meta property="og:description" content="Date Notes Swift Demo     2019-04-08 首次提交 4.2 Type Introspection and Reflection    Preface 许多编程语言中都有类型内省（又称自省，Introspection）和反射（Reflection）这两个概念，本文将探讨一下 Obj-C 和 Swift 中类型内省和反射的相关概念与具体使用。
What 维基百科中对于类型内省定义如下：
 In computing, type introspection is the ability of a program to examine the type or properties of an object at runtime. Some programming languages possess this capability.
Introspection should not be confused with reflection, which goes a step further and is the ability for a program to manipulate the values, meta-data, properties and/or functions of an object at runtime." />
<meta property="og:url" content="/posts/2019/type_introspection_and_reflection/" />
<meta property="og:site_name" content="Obj-C &amp; Swift 的类型内省与反射" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-04-08 00:00:00 &#43;0000 UTC" />











</head>
<body class="">


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    iBlog
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About &amp; AMA</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About &amp; AMA</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/2019/type_introspection_and_reflection/">Obj-C &amp; Swift 的类型内省与反射</a></h1>
  <div class="post-meta">
    <span class="post-date">
      2019-04-08
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/practice/">Practice</a>&nbsp;
    
    #<a href="/tags/ios/">iOS</a>&nbsp;
    
    #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
    
    #<a href="/tags/swift/">Swift</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Swift</th>
<th align="center">Demo</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2019-04-08</td>
<td align="center">首次提交</td>
<td align="center">4.2</td>
<td align="center"><a href="Type_Introspection_and_Reflection/">Type Introspection and Reflection</a></td>
</tr>
</tbody>
</table>

<h2 id="preface">Preface</h2>

<p>许多编程语言中都有类型内省（又称自省，Introspection）和反射（Reflection）这两个概念，本文将探讨一下 Obj-C 和 Swift 中类型内省和反射的相关概念与具体使用。</p>

<h3 id="what">What</h3>

<p>维基百科中对于类型内省定义如下：</p>

<blockquote>
<p>In computing, <em>type introspection</em> is the ability of a program to <strong>examine</strong> the type or properties of an object at runtime. Some programming languages possess this capability.</p>

<p>Introspection should not be confused with reflection, which goes a step further and is the ability for a program to manipulate the values, meta-data, properties and/or functions of an object at runtime. Some programming languages - e.g. Java, Python and Go - also possess that capability.</p>

<p>—— Type introspection, Wikipedia</p>

<p>译：</p>

<p>在计算机科学中，类型内省指程序在运行时<strong>检查</strong>类型或属性的能力。一些编程语言拥有该能力。</p>

<p>内省不应该和反射混淆，反射更深入一步，其是一种程序在运行时制造对象的值、元数据、属性、和/或方法的能力。一些编程语言——如 Java、Python 和 Go，同样拥有该能力。</p>

<p>—— 类型内省，维基百科</p>
</blockquote>

<p>维基百科中对于反射定义如下：</p>

<blockquote>
<p>In computer science, <strong>reflection</strong> is the ability of a computer program to examine, introspect, and modify its own structure and behavior at runtime.</p>

<p>—— Reflection (computer programming), Wikipedia</p>

<p>译：</p>

<p>在计算机科学中，<strong>反射</strong>是程序在运行时检查、内省并修改其自身结构和行为的能力。</p>

<p>—— 反射（计算机编程），维基百科</p>
</blockquote>

<p>从以上的定义中可以得知，类型内省和反射的共同点是程序在运行时的一种能力，不同点则是，内省只是一种检查机制，而反射广义上不仅包括检查，也拥有改变编译时刻原有结构的能力。对于具体的某种编程语言，可能根本不支持类型内省和反射，也可能仅支持内省，又或者同时支持内省和反射。</p>

<h2 id="obj-c">Obj-C</h2>

<h3 id="内省">内省</h3>

<p>Obj-C 中的 <code>id</code> 类型本质是指向 Obj-C 任意对象的指针。</p>

<pre><code class="language-objectivec">// objc.h
/// An opaque type that represents an Objective-C class.
typedef struct objc_class *Class;

/// Represents an instance of a class.
struct objc_object {
    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;
};

/// A pointer to an instance of a class.
typedef struct objc_object *id;
</code></pre>

<p>在 <code>Person</code> 类中定义一个参数为 <code>id</code> 类型的方法，并在运行时检查该参数的实际类型，以执行不同的方法。</p>

<pre><code class="language-objectivec">@implementation Person
- (void)eat:(id)fruit {
    // 检查是否是 Fruit 类或其子类
    if ([fruit isKindOfClass:Fruit.class]) {
        if ([fruit isMemberOfClass:Apple.class]) {
            // 检查是否是 Apple 类
            [(Apple *)fruit tasteApple];
        } else if ([fruit isMemberOfClass:Orange.class]) {
            // 检查是否是 Orange 类
            [(Orange *)fruit tasteOrange];
        } else {
            [fruit taste];
        }
    }
}

+ (void)introspectionDemo {
    Person *person = [[Person alloc] init];
    Apple *apple = [[Apple alloc] init];
    
    [person eat:apple];
}
@end

// OUTPUT:
// Apple - -[Apple tasteApple]
</code></pre>

<p>在 Obj-C 中进行运行时检查的方法主要是 <code>isKindOfClass:</code> 检查对象是否为本类或其子类的类型，以及 <code>isMemberOfClass:</code> 只检查对象是否为本类的类型。</p>

<h3 id="反射">反射</h3>

<pre><code class="language-objectivec">+ (void)reflectionDemo {
    id person = [[NSClassFromString(@&quot;Person&quot;) alloc] init];
    id orange = [[NSClassFromString(@&quot;Orange&quot;) alloc] init];
    [person performSelector:NSSelectorFromString(@&quot;eat:&quot;) withObject:orange];
}

// OUTPUT:
// Orange - -[Fruit tasteOrange]
</code></pre>

<p>由于 Obj-C 本身的运行时已经非常强大，反射的概念倒很少提及，但其实这些运行时的能力就可以被认为是反射。我们可以直接在运行时通过字符串得到类对象，进而创建实例对象，并执行方法。但这种灵活性也会带来一些风险，正如在 <code>performSelector:</code> 方法处，编译器会警告「PerformSelector may cause a leak because its selector is unknown」，所以 Apple 在设计 Swift 时，其实有意削减了类似 Obj-C 的动态特性。</p>

<h2 id="swift">Swift</h2>

<h3 id="内省-1">内省</h3>

<p>由于 Swift 和 Obj-C 能够互相桥接，Swift 中也可以访问到 Obj-C 中的类和方法等信息。Swift 中的 <code>AnyObject</code> 类型即是桥接了 Obj-C 中的 <code>id</code> 类型，代表任何 <code>class</code> 类型的对象实例。</p>

<pre><code class="language-swift">class Animal {
    func play(_ toy: AnyObject) {
        // 检查是否是 Toy 或其子类
        // Type.self 可以得到类型本身
        if toy.isKind(of: Toy.self) {
            if toy.isMember(of: Ball.self) {
                // 检查是否是 Ball 类
                (toy as! Ball).playWithBall()
            } else if toy.isMember(of: Doll.self) {
                // 检查是否是 Doll 类
                (toy as! Doll).playWithDoll()
            } else {
                (toy as! Toy).playWithToy()
            }
        }
    }
    
    class func introspectionDemo() {
        let ball = Ball()
        let dog = Animal()
        
        dog.play(ball)
    }
}

// OUTPUT:
// playWithBall()
</code></pre>

<p>仿照 Obj-C 中的方法，桥接过来的 <code>isKind(of: )</code> 和 <code>isMember(of: )</code> 也可以用于运行时检查 <code>class</code> 类型。但其实在 Swift 中使用更多的是结构体和枚举类型，所以 <code>Any</code> 类型应运而出。</p>

<pre><code class="language-swift">struct ToyCar {
    func playWithToyCar() {
        print(#function)
    }
}

class Animal {
    func play2(_ toy: Any) {
        // 检查是否是 Toy 或其子类
        if toy is Toy {
            (toy as! Toy).playWithToy()
        } else if (toy is ToyCar) {
            // 检查是否是 ToyCar 结构体类型
            (toy as! ToyCar).playWithToyCar()
        }
    }

    class func introspectionDemo2() {
        let car = ToyCar()
        let dog = Animal()
        
        dog.play2(car)
    }
}

// OUTPUT:
// playWithToyCar()
</code></pre>

<p>Swift 中的 <code>Any</code> 比 <code>AnyObject</code> 更加通用，可以代表任何类型的对象实例。Swift 中的 <code>is</code> 关键字，可以判断是否为某种结构体或枚举等类型；对于 <code>class</code> 类型，<code>is</code> 等同于 <code>isKind(of: )</code> 的作用，即判断是否为本类或子类的类型。</p>

<h3 id="反射-1">反射</h3>

<pre><code class="language-swift">/// A type that explicitly supplies its own mirror.
///
/// You can create a mirror for any type using the `Mirror(reflecting:)`
/// initializer, but if you are not satisfied with the mirror supplied for
/// your type by default, you can make it conform to `CustomReflectable` and
/// return a custom `Mirror` instance.
public protocol CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}
</code></pre>

<p>虽然 Swift 的运行时远不如 Obj-C 强大，但 Swift 中反射设计了专门的 API，默认情况下所有类型都支持创建镜像（Mirror），开发者也可以根据需要实现 <code>CustomReflectable</code> 协议来自定义镜像。</p>

<pre><code class="language-swift">struct Computer {
    var system: String
    var memorySize: Int
    
    let run = {
        print(#function)
    }
}

let cpt = Computer(system: &quot;macOS&quot;, memorySize: 16)
let mirror = Mirror(reflecting: cpt)

if let displayStyle = mirror.displayStyle {
    print(&quot;mirror's style: \(displayStyle).&quot;)
}

print(&quot;mirror's properties count: \(mirror.children.count)&quot;)

for (label, value) in mirror.children {
    switch value {
    case let function as () -&gt; Void:
        function()
    default:
        print(&quot;\(label ?? &quot;nil&quot;) - \(value)&quot;)
    }
}

// DEBUG OUTPUT:
// mirror's style: struct.
// mirror's properties count: 2
// system - macOS
// memorySize - 16
// Computer
// param: 
</code></pre>

<p>通过镜像类型，可以从任意实例（包括 <code>class</code>、<code>struct</code>、<code>enum</code> 的实例）中获取到属性等信息，<code>Mirro</code> 中的 <code>children</code> 属性是 <code>Mirror.Child</code> 集合类型，<code>Child</code> 是键值元组类型：<code>(label: String?, value: Any)</code>。在 Swift 中，函数也是一类公民（First class），完全可以当作一种属性，因此也可以作为 <code>children</code> 内的信息，尝试将 <code>value</code> 其转换为函数类型，即可以执行（如上 <code>function()</code>）。需要注意的是，这里的函数其实是闭包（Closure），即匿名函数，此时 <code>#function</code> 并不能得到函数名称。另外，含有参数的函数类型属性暂时还不能支持，在 Debug 模式下，程序没有崩溃，但参数无法打印；切换到 Release 模式下，程序将发生参数野指针错误导致崩溃「Thread 1: EXC_BAD_ACCESS」。</p>

<p>由此可见，反射在 Swift 中目前还比较弱，在类型安全还是运行时强大的自由选择题中，Swift 显然更加倾向于前者。</p>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Type_introspection">Type introspection - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)">Reflection (computer programming) - Wikipedia</a></li>
<li><a href="https://swifter.tips/reflect/">REFLECTION 和 MIRROR - onevcat</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33945268">Swift 中的 Reflection（反射） - 贾物体</a></li>
</ul>

  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span
        class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      <span class="button previous">
        <a href="/posts/2019/category_in_ios/">
          <span class="button__icon">←</span>
          <span class="button__text">iOS 中的 Category</span>
        </a>
      </span>
      
      
      <span class="button next">
        <a href="/posts/2019/ivar_access_control_in_obj-c/">
          <span class="button__text">Obj-C 中实例变量和类的访问控制</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo="kingcos/kingcos.github.io"
            issue-term="pathname"
            label="comments"
            theme="github-dark"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2019 · <a href="http://github.com/kingcos">kingcos</a></span>
      </div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>





  
</div>

</body>
</html>
