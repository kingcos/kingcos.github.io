<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>Obj-C &amp; Swift 的类型内省与反射 :: iBlog</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Swift Demo     2019-04-08 首次提交 4.2 Type Introspection and Reflection    Preface 许多编程语言中都有类型内省（又称自省，Introspection）和反射（Reflection）这两个概念，本文将探讨一下 Obj-C 和 Swift 中类型内省和反射的相关概念与具体使用。
What 维基百科中对于类型内省定义如下：
 In computing, type introspection is the ability of a program to examine the type or properties of an object at runtime. Some programming languages possess this capability.
Introspection should not be confused with reflection, which goes a step further and is the ability for a program to manipulate the values, meta-data, properties and/or functions of an object at runtime."/>
<meta name="keywords" content="kingcos.me,maimieng.comios,swift,objective-c,obj-c,objc,oc,geek,python,ruby,golang,go,apple,mac"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/type_introspection_and_reflection/" />





<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Obj-C &amp; Swift 的类型内省与反射"/>
<meta name="twitter:description" content="许多编程语言中都有类型内省（又称自省，Introspection）和反射（Reflection）这两个概念，本文将探讨一下 Obj-C 和 Swift 中类型内省和反射的相关概念与具体使用。"/>



<meta property="og:title" content="Obj-C &amp; Swift 的类型内省与反射" />
<meta property="og:description" content="许多编程语言中都有类型内省（又称自省，Introspection）和反射（Reflection）这两个概念，本文将探讨一下 Obj-C 和 Swift 中类型内省和反射的相关概念与具体使用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2019/type_introspection_and_reflection/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-08T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2019-04-08T00:00:00&#43;00:00" /><meta property="og:site_name" content="iBlog" />





<script data-ad-client="ca-pub-9925978992661955" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  </head>
  <body class="">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">kingcos.me</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/read">Read</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/read">Read</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="post">
    <h2 class="post-title"><a href="/posts/2019/type_introspection_and_reflection/">Obj-C &amp; Swift 的类型内省与反射</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            2019-04-08
        </span>
      
      
      
        <span class="post-read-time">— 4 min read</span>
      
    </div>

    
      <span class="post-tags">
        
          #<a href="/tags/practice/">Practice</a>&nbsp;
        
          #<a href="/tags/ios/">iOS</a>&nbsp;
        
          #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
        
          #<a href="/tags/swift/">Swift</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      <table>
<thead>
<tr>
<th style="text-align:center">Date</th>
<th style="text-align:center">Notes</th>
<th style="text-align:center">Swift</th>
<th style="text-align:center">Demo</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2019-04-08</td>
<td style="text-align:center">首次提交</td>
<td style="text-align:center">4.2</td>
<td style="text-align:center"><a href="https://github.com/kingcos/Perspective/tree/d77eec6c5c84ca161b0e128c41af6b6722021195/Posts/Practice/Type_Introspection_and_Reflection/Type_Introspection_and_Reflection/">Type Introspection and Reflection</a></td>
</tr>
</tbody>
</table>
<h2 id="preface">Preface</h2>
<p>许多编程语言中都有类型内省（又称自省，Introspection）和反射（Reflection）这两个概念，本文将探讨一下 Obj-C 和 Swift 中类型内省和反射的相关概念与具体使用。</p>
<h3 id="what">What</h3>
<p>维基百科中对于类型内省定义如下：</p>
<blockquote>
<p>In computing, <em>type introspection</em> is the ability of a program to <strong>examine</strong> the type or properties of an object at runtime. Some programming languages possess this capability.</p>
<p>Introspection should not be confused with reflection, which goes a step further and is the ability for a program to manipulate the values, meta-data, properties and/or functions of an object at runtime. Some programming languages - e.g. Java, Python and Go - also possess that capability.</p>
<p>—— Type introspection, Wikipedia</p>
<p>译：</p>
<p>在计算机科学中，类型内省指程序在运行时<strong>检查</strong>类型或属性的能力。一些编程语言拥有该能力。</p>
<p>内省不应该和反射混淆，反射更深入一步，其是一种程序在运行时制造对象的值、元数据、属性、和/或方法的能力。一些编程语言——如 Java、Python 和 Go，同样拥有该能力。</p>
<p>—— 类型内省，维基百科</p>
</blockquote>
<p>维基百科中对于反射定义如下：</p>
<blockquote>
<p>In computer science, <strong>reflection</strong> is the ability of a computer program to examine, introspect, and modify its own structure and behavior at runtime.</p>
<p>—— Reflection (computer programming), Wikipedia</p>
<p>译：</p>
<p>在计算机科学中，<strong>反射</strong>是程序在运行时检查、内省并修改其自身结构和行为的能力。</p>
<p>—— 反射（计算机编程），维基百科</p>
</blockquote>
<p>从以上的定义中可以得知，类型内省和反射的共同点是程序在运行时的一种能力，不同点则是，内省只是一种检查机制，而反射广义上不仅包括检查，也拥有改变编译时刻原有结构的能力。对于具体的某种编程语言，可能根本不支持类型内省和反射，也可能仅支持内省，又或者同时支持内省和反射。</p>
<h2 id="obj-c">Obj-C</h2>
<h3 id="内省">内省</h3>
<p>Obj-C 中的 <code>id</code> 类型本质是指向 Obj-C 任意对象的指针。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#75715e">// objc.h
</span><span style="color:#75715e">/// An opaque type that represents an Objective-C class.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> objc_class <span style="color:#f92672">*</span><span style="color:#66d9ef">Class</span>;

<span style="color:#75715e">/// Represents an instance of a class.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> objc_object {
    <span style="color:#66d9ef">Class</span> _Nonnull isa  OBJC_ISA_AVAILABILITY;
};

<span style="color:#75715e">/// A pointer to an instance of a class.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> objc_object <span style="color:#f92672">*</span><span style="color:#66d9ef">id</span>;
</code></pre></div><p>在 <code>Person</code> 类中定义一个参数为 <code>id</code> 类型的方法，并在运行时检查该参数的实际类型，以执行不同的方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="color:#66d9ef">@implementation</span> <span style="color:#a6e22e">Person</span>
- (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">eat:</span>(<span style="color:#66d9ef">id</span>)fruit {
    <span style="color:#75715e">// 检查是否是 Fruit 类或其子类
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ([fruit isKindOfClass:Fruit.<span style="color:#66d9ef">class</span>]) {
        <span style="color:#66d9ef">if</span> ([fruit isMemberOfClass:Apple.<span style="color:#66d9ef">class</span>]) {
            <span style="color:#75715e">// 检查是否是 Apple 类
</span><span style="color:#75715e"></span>            [(Apple <span style="color:#f92672">*</span>)fruit tasteApple];
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ([fruit isMemberOfClass:Orange.<span style="color:#66d9ef">class</span>]) {
            <span style="color:#75715e">// 检查是否是 Orange 类
</span><span style="color:#75715e"></span>            [(Orange <span style="color:#f92672">*</span>)fruit tasteOrange];
        } <span style="color:#66d9ef">else</span> {
            [fruit taste];
        }
    }
}

+ (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">introspectionDemo</span> {
    Person <span style="color:#f92672">*</span>person <span style="color:#f92672">=</span> [[Person alloc] init];
    Apple <span style="color:#f92672">*</span>apple <span style="color:#f92672">=</span> [[Apple alloc] init];

    [person eat:apple];
}
<span style="color:#66d9ef">@end</span>

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e">// Apple - -[Apple tasteApple]
</span></code></pre></div><p>在 Obj-C 中进行运行时检查的方法主要是 <code>isKindOfClass:</code> 检查对象是否为本类或其子类的类型，以及 <code>isMemberOfClass:</code> 只检查对象是否为本类的类型。</p>
<h3 id="反射">反射</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec">+ (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">reflectionDemo</span> {
    <span style="color:#66d9ef">id</span> person <span style="color:#f92672">=</span> [[NSClassFromString(<span style="color:#e6db74">@&#34;Person&#34;</span>) alloc] init];
    <span style="color:#66d9ef">id</span> orange <span style="color:#f92672">=</span> [[NSClassFromString(<span style="color:#e6db74">@&#34;Orange&#34;</span>) alloc] init];
    [person performSelector:NSSelectorFromString(<span style="color:#e6db74">@&#34;eat:&#34;</span>) withObject:orange];
}

<span style="color:#75715e">// OUTPUT:
</span><span style="color:#75715e">// Orange - -[Fruit tasteOrange]
</span></code></pre></div><p>由于 Obj-C 本身的运行时已经非常强大，反射的概念倒很少提及，但其实这些运行时的能力就可以被认为是反射。我们可以直接在运行时通过字符串得到类对象，进而创建实例对象，并执行方法。但这种灵活性也会带来一些风险，正如在 <code>performSelector:</code> 方法处，编译器会警告「PerformSelector may cause a leak because its selector is unknown」，所以 Apple 在设计 Swift 时，其实有意削减了类似 Obj-C 的动态特性。</p>
<h2 id="swift">Swift</h2>
<h3 id="内省-1">内省</h3>
<p>由于 Swift 和 Obj-C 能够互相桥接，Swift 中也可以访问到 Obj-C 中的类和方法等信息。Swift 中的 <code>AnyObject</code> 类型即是桥接了 Obj-C 中的 <code>id</code> 类型，代表任何 <code>class</code> 类型的对象实例。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Animal</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">play</span>(<span style="color:#66d9ef">_</span> toy: AnyObject) {
        <span style="color:#75715e">// 检查是否是 Toy 或其子类</span>
        <span style="color:#75715e">// Type.self 可以得到类型本身</span>
        <span style="color:#66d9ef">if</span> toy.isKind(of: Toy.<span style="color:#66d9ef">self</span>) {
            <span style="color:#66d9ef">if</span> toy.isMember(of: Ball.<span style="color:#66d9ef">self</span>) {
                <span style="color:#75715e">// 检查是否是 Ball 类</span>
                (toy <span style="color:#66d9ef">as</span>! Ball).playWithBall()
            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> toy.isMember(of: Doll.<span style="color:#66d9ef">self</span>) {
                <span style="color:#75715e">// 检查是否是 Doll 类</span>
                (toy <span style="color:#66d9ef">as</span>! Doll).playWithDoll()
            } <span style="color:#66d9ef">else</span> {
                (toy <span style="color:#66d9ef">as</span>! Toy).playWithToy()
            }
        }
    }

    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> introspectionDemo() {
        <span style="color:#66d9ef">let</span> ball = Ball()
        <span style="color:#66d9ef">let</span> dog = Animal()

        dog.play(ball)
    }
}

<span style="color:#75715e">// OUTPUT:</span>
<span style="color:#75715e">// playWithBall()</span>
</code></pre></div><p>仿照 Obj-C 中的方法，桥接过来的 <code>isKind(of: )</code> 和 <code>isMember(of: )</code> 也可以用于运行时检查 <code>class</code> 类型。但其实在 Swift 中使用更多的是结构体和枚举类型，所以 <code>Any</code> 类型应运而出。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ToyCar</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">playWithToyCar</span>() {
        print(<span style="color:#66d9ef">#function</span>)
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Animal</span> {
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">play2</span>(<span style="color:#66d9ef">_</span> toy: Any) {
        <span style="color:#75715e">// 检查是否是 Toy 或其子类</span>
        <span style="color:#66d9ef">if</span> toy <span style="color:#66d9ef">is</span> Toy {
            (toy <span style="color:#66d9ef">as</span>! Toy).playWithToy()
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (toy <span style="color:#66d9ef">is</span> ToyCar) {
            <span style="color:#75715e">// 检查是否是 ToyCar 结构体类型</span>
            (toy <span style="color:#66d9ef">as</span>! ToyCar).playWithToyCar()
        }
    }

    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">func</span> introspectionDemo2() {
        <span style="color:#66d9ef">let</span> car = ToyCar()
        <span style="color:#66d9ef">let</span> dog = Animal()

        dog.play2(car)
    }
}

<span style="color:#75715e">// OUTPUT:</span>
<span style="color:#75715e">// playWithToyCar()</span>
</code></pre></div><p>Swift 中的 <code>Any</code> 比 <code>AnyObject</code> 更加通用，可以代表任何类型的对象实例。Swift 中的 <code>is</code> 关键字，可以判断是否为某种结构体或枚举等类型；对于 <code>class</code> 类型，<code>is</code> 等同于 <code>isKind(of: )</code> 的作用，即判断是否为本类或子类的类型。</p>
<h3 id="反射-1">反射</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#75715e">/// A type that explicitly supplies its own mirror.</span>
<span style="color:#75715e">///</span>
<span style="color:#75715e">/// You can create a mirror for any type using the `Mirror(reflecting:)`</span>
<span style="color:#75715e">/// initializer, but if you are not satisfied with the mirror supplied for</span>
<span style="color:#75715e">/// your type by default, you can make it conform to `CustomReflectable` and</span>
<span style="color:#75715e">/// return a custom `Mirror` instance.</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">CustomReflectable</span> {

    <span style="color:#75715e">/// The custom mirror for this instance.</span>
    <span style="color:#75715e">///</span>
    <span style="color:#75715e">/// If this type has value semantics, the mirror should be unaffected by</span>
    <span style="color:#75715e">/// subsequent mutations of the instance.</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">var</span> customMirror: Mirror { <span style="color:#66d9ef">get</span> }
}
</code></pre></div><p>虽然 Swift 的运行时远不如 Obj-C 强大，但 Swift 中反射设计了专门的 API，默认情况下所有类型都支持创建镜像（Mirror），开发者也可以根据需要实现 <code>CustomReflectable</code> 协议来自定义镜像。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Computer</span> {
    <span style="color:#66d9ef">var</span> system: String
    <span style="color:#66d9ef">var</span> memorySize: Int

    <span style="color:#66d9ef">let</span> run = {
        print(<span style="color:#66d9ef">#function</span>)
    }
}

<span style="color:#66d9ef">let</span> cpt = Computer(system: <span style="color:#e6db74">&#34;macOS&#34;</span>, memorySize: <span style="color:#ae81ff">16</span>)
<span style="color:#66d9ef">let</span> mirror = Mirror(reflecting: cpt)

<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> displayStyle = mirror.displayStyle {
    print(<span style="color:#e6db74">&#34;mirror&#39;s style: </span><span style="color:#e6db74">\(</span>displayStyle<span style="color:#e6db74">)</span><span style="color:#e6db74">.&#34;</span>)
}

print(<span style="color:#e6db74">&#34;mirror&#39;s properties count: </span><span style="color:#e6db74">\(</span>mirror.children.count<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)

<span style="color:#66d9ef">for</span> (label, value) <span style="color:#66d9ef">in</span> mirror.children {
    <span style="color:#66d9ef">switch</span> value {
    <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">let</span> function <span style="color:#66d9ef">as</span> () -&gt; Void:
        function()
    <span style="color:#66d9ef">default</span>:
        print(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>label ?? <span style="color:#e6db74">&#34;nil&#34;</span><span style="color:#e6db74">)</span><span style="color:#e6db74"> - </span><span style="color:#e6db74">\(</span>value<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
    }
}

<span style="color:#75715e">// DEBUG OUTPUT:</span>
<span style="color:#75715e">// mirror&#39;s style: struct.</span>
<span style="color:#75715e">// mirror&#39;s properties count: 2</span>
<span style="color:#75715e">// system - macOS</span>
<span style="color:#75715e">// memorySize - 16</span>
<span style="color:#75715e">// Computer</span>
<span style="color:#75715e">// param:</span>
</code></pre></div><p>通过镜像类型，可以从任意实例（包括 <code>class</code>、<code>struct</code>、<code>enum</code> 的实例）中获取到属性等信息，<code>Mirro</code> 中的 <code>children</code> 属性是 <code>Mirror.Child</code> 集合类型，<code>Child</code> 是键值元组类型：<code>(label: String?, value: Any)</code>。在 Swift 中，函数也是一类公民（First class），完全可以当作一种属性，因此也可以作为 <code>children</code> 内的信息，尝试将 <code>value</code> 其转换为函数类型，即可以执行（如上 <code>function()</code>）。需要注意的是，这里的函数其实是闭包（Closure），即匿名函数，此时 <code>#function</code> 并不能得到函数名称。另外，含有参数的函数类型属性暂时还不能支持，在 Debug 模式下，程序没有崩溃，但参数无法打印；切换到 Release 模式下，程序将发生参数野指针错误导致崩溃「Thread 1: EXC_BAD_ACCESS」。</p>
<p>由此可见，反射在 Swift 中目前还比较弱，在类型安全还是运行时强大的自由选择题中，Swift 显然更加倾向于前者。</p>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Type_introspection">Type introspection - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)">Reflection (computer programming) - Wikipedia</a></li>
<li><a href="https://swifter.tips/reflect/">REFLECTION 和 MIRROR - onevcat</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33945268">Swift 中的 Reflection（反射） - 贾物体</a></li>
</ul>

    </div>
    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>
        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="/posts/2019/&#43;initialize_in_ios/">
                <span class="button__icon">←</span>
                <span class="button__text">iOS 中的 &#43;initialize 方法</span>
              </a>
            </span>
          
          
            <span class="button next">
              <a href="/posts/2019/kvc_in_ios/">
                <span class="button__text">iOS 中的 KVC</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    

    

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<table style="border: 0;">
  <tr>
  <td style="border: 0; width: 30%;">
    <img src='/img/about/1.jpg'>
  </td>
  <td style="border: 0;">
    <ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-9925978992661955"
     data-ad-slot="3213735320"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
  </td>
  </tr>
</table>



<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>


    
    
    <div>
      <div id="github-comment">
      </div>

      <script type="text/javascript">
        function getUtterances(isDark) {
          var utterances = document.createElement('script');
          utterances.type = 'text/javascript';
          utterances.async = true;
          utterances.setAttribute('issue-term', "pathname")
          utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
          utterances.setAttribute('label', "comments")
          isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
          utterances.crossorigin = 'anonymous';
          utterances.src = 'https://utteranc.es/client.js';

          return utterances
        }

        var themeToggle = document.querySelector(".theme-toggle")
        themeToggle.addEventListener("click", function () {
          var getTheme = window.localStorage && window.localStorage.getItem("theme")
          var divNode = document.getElementById('github-comment')
          while(divNode.hasChildNodes()) {
            divNode.removeChild(divNode.firstChild);
          }
          
          
          

          
          
          
          
          
          
          document.getElementById('github-comment').appendChild(getUtterances(getTheme !== "dark"))
        })

        var getTheme = window.localStorage && window.localStorage.getItem("theme")
        document.getElementById('github-comment').appendChild(getUtterances(getTheme === "dark"))
      </script>
    </div>
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">All rights reserved by kingcos.me</div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>



      
    </div>

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </body>
</html>
