<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>C/C&#43;&#43;/Obj-C/C&#43;&#43; 中的 const、static &amp; extern :: iBlog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Env     2019-07-23 首次提交 clang&#43;&#43;, macOS 10.14.6    Preface const、static &amp;amp; extern 是 C/C&#43;&#43; 中的关键字，然而在写 Obj-C/C&#43;&#43; 时却有不免会经常用到。虽然这几个关键字我都知道，但有时会将它们搞混或者用错，那么这次就简单总结下这几个关键字吧。
const 基础类型 int a = 0; a = 10;  对于基础类型，其在内存中存储的即是该类型的变量本身，经过 const 修饰后，此处的变量不可变，即常量。const 的位置并不会影响其作用，更为推荐的写法应当是编译器提示的 const &amp;lt;TYPE&amp;gt;。
以下是在 C/C&#43;&#43; 中的用例，由于 Obj-C/C&#43;&#43; 分别是 C/C&#43;&#43; 的超集，对于 C/C&#43;&#43; 的基础类型，其在 Obj-C/C&#43;&#43; 中的表现是一致的：
const int b = 0; // error: cannot assign to variable &#39;b&#39; with const-qualified type &#39;const int&#39; // b = 10; int const c = 0; // c = 10;  对于 Obj-C 中特有的基础类型，const 也与修饰 C/C&#43;&#43; 中基础类型的行为一致："/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/const_static_extern_in_cpp_obj-c/" />


<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/green.css">



<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="/img/favicon/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="C/C&#43;&#43;/Obj-C/C&#43;&#43; 中的 const、static &amp; extern :: iBlog — " />
<meta name="twitter:description" content="Date Notes Env     2019-07-23 首次提交 clang&#43;&#43;, macOS 10.14.6    Preface const、static &amp;amp; extern 是 C/C&#43;&#43; 中的关键字，然而在写 Obj-C/C&#43;&#43; 时却有不免会经常用到。虽然这几个关键字我都知道，但有时会将它们搞混或者用错，那么这次就简单总结下这几个关键字吧。
const 基础类型 int a = 0; a = 10;  对于基础类型，其在内存中存储的即是该类型的变量本身，经过 const 修饰后，此处的变量不可变，即常量。const 的位置并不会影响其作用，更为推荐的写法应当是编译器提示的 const &amp;lt;TYPE&amp;gt;。
以下是在 C/C&#43;&#43; 中的用例，由于 Obj-C/C&#43;&#43; 分别是 C/C&#43;&#43; 的超集，对于 C/C&#43;&#43; 的基础类型，其在 Obj-C/C&#43;&#43; 中的表现是一致的：
const int b = 0; // error: cannot assign to variable &#39;b&#39; with const-qualified type &#39;const int&#39; // b = 10; int const c = 0; // c = 10;  对于 Obj-C 中特有的基础类型，const 也与修饰 C/C&#43;&#43; 中基础类型的行为一致：" />
<meta name="twitter:site" content="/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="C/C&#43;&#43;/Obj-C/C&#43;&#43; 中的 const、static &amp; extern :: iBlog — ">
<meta property="og:description" content="Date Notes Env     2019-07-23 首次提交 clang&#43;&#43;, macOS 10.14.6    Preface const、static &amp;amp; extern 是 C/C&#43;&#43; 中的关键字，然而在写 Obj-C/C&#43;&#43; 时却有不免会经常用到。虽然这几个关键字我都知道，但有时会将它们搞混或者用错，那么这次就简单总结下这几个关键字吧。
const 基础类型 int a = 0; a = 10;  对于基础类型，其在内存中存储的即是该类型的变量本身，经过 const 修饰后，此处的变量不可变，即常量。const 的位置并不会影响其作用，更为推荐的写法应当是编译器提示的 const &amp;lt;TYPE&amp;gt;。
以下是在 C/C&#43;&#43; 中的用例，由于 Obj-C/C&#43;&#43; 分别是 C/C&#43;&#43; 的超集，对于 C/C&#43;&#43; 的基础类型，其在 Obj-C/C&#43;&#43; 中的表现是一致的：
const int b = 0; // error: cannot assign to variable &#39;b&#39; with const-qualified type &#39;const int&#39; // b = 10; int const c = 0; // c = 10;  对于 Obj-C 中特有的基础类型，const 也与修饰 C/C&#43;&#43; 中基础类型的行为一致：" />
<meta property="og:url" content="/posts/2019/const_static_extern_in_cpp_obj-c/" />
<meta property="og:site_name" content="C/C&#43;&#43;/Obj-C/C&#43;&#43; 中的 const、static &amp; extern" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-07-23 00:00:00 &#43;0000 UTC" />











</head>
<body class="">


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    iBlog
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
  
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About &amp; AMA</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About &amp; AMA</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/2019/const_static_extern_in_cpp_obj-c/">C/C++/Obj-C/C++ 中的 const、static &amp; extern</a></h1>
  <div class="post-meta">
    <span class="post-date">
      2019-07-23
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/focus/">Focus</a>&nbsp;
    
    #<a href="/tags/ios/">iOS</a>&nbsp;
    
    #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
    
    #<a href="/tags/c/c&#43;&#43;/">C/C&#43;&#43;</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Env</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2019-07-23</td>
<td align="center">首次提交</td>
<td align="center"><code>clang++</code>, macOS 10.14.6</td>
</tr>
</tbody>
</table>

<p><img src="/img/2019/const_static_extern_in_cpp_obj-c/0.png" alt="0" /></p>

<h2 id="preface">Preface</h2>

<p><code>const</code>、<code>static</code> &amp; <code>extern</code> 是 C/C++ 中的关键字，然而在写 Obj-C/C++ 时却有不免会经常用到。虽然这几个关键字我都知道，但有时会将它们搞混或者用错，那么这次就简单总结下这几个关键字吧。</p>

<h2 id="const"><code>const</code></h2>

<h3 id="基础类型">基础类型</h3>

<pre><code class="language-cpp">int a = 0;
a = 10;
</code></pre>

<p>对于基础类型，其在内存中存储的即是该类型的变量本身，经过 <code>const</code> 修饰后，此处的变量不可变，即常量。<code>const</code> 的位置并不会影响其作用，更为推荐的写法应当是编译器提示的 <code>const &lt;TYPE&gt;</code>。</p>

<p>以下是在 C/C++ 中的用例，由于 Obj-C/C++ 分别是 C/C++ 的超集，对于 C/C++ 的基础类型，其在 Obj-C/C++ 中的表现是一致的：</p>

<pre><code class="language-cpp">const int b = 0;
// error: cannot assign to variable 'b' with const-qualified type 'const int'
// b = 10;

int const c = 0;
// c = 10;
</code></pre>

<p>对于 Obj-C 中特有的基础类型，<code>const</code> 也与修饰 C/C++ 中基础类型的行为一致：</p>

<pre><code class="language-objectivec">BOOL a = YES;
a = NO;

const BOOL b = YES;
// Cannot assign to variable 'b' with const-qualified type 'const BOOL' (aka 'const signed char')
// b = NO;

BOOL const c = YES;
// c = NO;
</code></pre>

<h3 id="数组类型">数组类型</h3>

<pre><code class="language-cpp">int a[] = {1, 2, 3};
a[0] = 0;
</code></pre>

<p>对于数组类型，即使用连续的一段内存来容纳同一类型元素的容器。当在 C/C++ 中使用 <code>const</code> 修饰基础类型的数组时，其中的内容将不能再改变：</p>

<pre><code class="language-cpp">int const b[] = {1, 2, 3};
// error: read-only variable is not assignable
// b[0] = 1;

const int c[] = {1, 2, 3};
// c[0] = 1;
</code></pre>

<p>对于 Obj-C，在 C 语言之上添加了面向对象的部分，其需要存储自身定义的对象类型的容器类，所以数组等集合（注：这里的集合并非特指 Set，而是指 Collection，下略）类型被单独拎出来独立为 <code>NSArray</code>、<code>NSSet</code> 等类型，且默认即作为不可变版本，并在使用时需结合指针。需要注意的是，这里的不可变仅针对内部元素（即变量内部地址指向的值），对于指针本身（数组的首地址）是可变的。可变版本 <code>NSMutableArray</code> 等则可以修改内部元素和指针本身。</p>

<p>由于 Obj-C 自带可变和不可变版本的集合类型，<code>const</code> 的作用其实就显得有些多余，这里的 <code>const</code> 将类似针对指针类型的行为（关于指针详见下文）。当 <code>const</code> 位于 <code>NSArray</code> 或 <code>NSMutableArray</code> 之前或之后时均没有作用：</p>

<pre><code class="language-objectivec">NSArray *a = @[@1, @2, @3];
// Expected method to write array element not found on object of type 'NSArray *'
// a[0] = @0;
a = @[@3, @2, @1];

const NSArray *b = @[@1, @2, @3];
// b[0] = @0;
b = @[@3, @2, @1];

NSArray const *c = @[@1, @2, @3];
// c[0] = @0;
c = @[@3, @2, @1];

NSArray * const d = @[@1, @2, @3];
// d[0] = @0;
// Cannot assign to variable 'd' with const-qualified type 'NSArray *const __strong'
// d = @[@3, @2, @1];
</code></pre>

<p>当 <code>const</code> 位于 <code>NSArray *</code> 或 <code>NSMutableArray *</code> 之后时，将使得指针内部存储的内存地址不可被改变，它们也就无法被指向新的 <code>NSArray</code> 或 <code>NSMutableArray</code> 对象了。</p>

<pre><code class="language-objectivec">NSMutableArray *e = [a mutableCopy];
e[0] = @0;
e = [b mutableCopy];

const NSMutableArray *f = [a mutableCopy];
f[0] = @0;
f = [b mutableCopy];

NSMutableArray const *g = [a mutableCopy];
g[0] = @0;
g = [b mutableCopy];

NSMutableArray * const h = [a mutableCopy];
h[0] = @0;
// Cannot assign to variable 'h' with const-qualified type 'NSMutableArray *const __strong'
// h = [b mutableCopy];
</code></pre>

<h3 id="指向基础类型的指针">指向基础类型的指针</h3>

<p>在上一节中，我们已经接触了 Obj-C 中的 <code>NSArray</code> 的指针类型 <code>NSArray *</code>，但为了更加清晰，我们将重新先从指向基础类型的指针开始。</p>

<p>物理上的内存会被操作系统映射为一连串的内存地址，我们假设一段内存从 <code>0x0000</code> 开始，正如下图中一连串的小方格，每个小方格代表一个字节大小的内存。当我们声明一个基础类型的变量时，将为其分配一段内存空间来存储其中的值。比如 <code>int a = 10;</code>，会分配 4 个字节长度的内存，<code>10</code> 将以二进制的形式存储在这段内存中。需要注意的是 iOS 默认的小端（Little End）模式会在低地址存储高位字节，例如下图中的橙色部分，即 <code>10100000</code>。</p>

<p>指针，是指存储内存地址的一种数据类型，内存地址是由编译器来决定的，因此指针的大小由编译器决定。在 64 位 <code>clang++</code> 编译器中，内存地址的长度为 8 个字节，因此无论 <code>int *</code>、<code>double *</code> 还是 <code>char *</code> 类型的指针其大小均为 8 个字节。比如 <code>int *b = &amp;a;</code>，<code>&amp;</code> 在 C/C++ 中是取地址的符号，即我们将 <code>a</code> 变量的内存地址存储在 <code>b</code> 中，如下图绿色的部分。因此 <code>b</code> 的值就是 <code>0x00000000</code>，而 <code>*b</code> 取内容才为 <code>10</code>。这时我们就能发现，对于指针类型，其一共有两个部分，一个是变量本身直接存储的内存地址，另一个则是位于该内存地址处的值。</p>

<p><img src="/img/2019/const_static_extern_in_cpp_obj-c/1.png" alt="1" /></p>

<pre><code class="language-cpp">int foo = 0;
int bar = 10;

int *c = &amp;foo;
c = &amp;bar;
*c = foo;
</code></pre>

<p>那么，当指针遇上 <code>const</code>，哪一部分将不可变呢？当 <code>const</code> 修饰指针中内存地址对应变量的类型时，即在表达式最左边或在 <code>*</code> 左边时，其内部存储的内存地址所对应的值为常量，不可被改变，但我们仍能够通过直接改变指针存储的变量地址而间接改变其值：</p>

<pre><code class="language-cpp">const int *d = &amp;foo;
d = &amp;bar;
// error: read-only variable is not assignable
// *d = foo;

int const *e = &amp;foo;
e = &amp;bar;
// *e = foo;
</code></pre>

<p>当 <code>const</code> 位于表达式中 <code>*</code> 右边时，其内部存储的内存地址将无法被改变，但该内存地址所对应的值却可以被改变：</p>

<pre><code class="language-cpp">int *const f = &amp;foo;
// error: cannot assign to variable 'f' with const-qualified type 'int *const'
// f = &amp;bar;
*f = foo;
</code></pre>

<p>当我们既不希望改变指针中存储的内存地址，也不希望改变该内存地址所对应的值时，就需要同时限定两处，使用两个 <code>const</code> 来达到这种效果：</p>

<pre><code class="language-cpp">const int *const g = &amp;foo;
// error: cannot assign to variable 'g' with const-qualified type 'const int *const'
// g = &amp;bar;
// error: read-only variable is not assignable
// *g = foo;
</code></pre>

<p>由于 Obj-C/C++ 中的基础类型本质仍然是 C/C++ 中的基础类型，「指向基础类型的指针」将不针对 Obj-C/C++ 举例。</p>

<h3 id="指向对象类型的指针">指向对象类型的指针</h3>

<p>如果我们已经很好地理解了上一节「指向基础类型的指针」，那么对于指向对象类型的指针也将水到渠成。指向对象类型的指针的本质仍然是指针，因此其内部仍存储的是内存地址，大小也与 <code>int *</code> 一样都是 8 个字节。与指向基础类型的指针不同的是，其内部存储的内存地址对应值是对象类型。</p>

<pre><code class="language-cpp">class Foo
{
public:
    double bar;
    int *baz;

    Foo(double _bar, int *_baz)
    {
        bar = _bar;
        baz = _baz;
    }
};
</code></pre>

<p>当我们在 C++ 中创建对象时（C++ 中引入了 <code>class</code> 类与对象的概念），<code>new</code> 将申请内存空间，<code>SomeClass()</code> 构造方法将初始化，最终返回对象的首地址，保存在表达式左边的变量中，这也就是为什么这里我们不再需要 <code>&amp;</code> 来取地址。</p>

<pre><code class="language-cpp">int a = 1;
int b = 5;

Foo *foo1 = new Foo(0.0, &amp;a);
foo1-&gt;bar = 0.5;
cout &lt;&lt; foo1-&gt;bar &lt;&lt; endl;    // 0.5
cout &lt;&lt; *foo1-&gt;baz &lt;&lt; endl;  // 1

a = 10;
cout &lt;&lt; *foo1-&gt;baz &lt;&lt; endl;  // 10

foo1-&gt;baz = &amp;b;
cout &lt;&lt; *foo1-&gt;baz &lt;&lt; endl;  // 5

* foo1-&gt;baz = 100;
cout &lt;&lt; *foo1-&gt;baz &lt;&lt; endl;  // 100

foo1 = new Foo(1.5, &amp;a);
cout &lt;&lt; foo1-&gt;bar &lt;&lt; endl;    // 1.5
cout &lt;&lt; *foo1-&gt;baz &lt;&lt; endl;  // 10
</code></pre>

<p>而当指向对象类型的指针遇到 <code>const</code> 时，就和指向基础类型的指针很类似了。当 <code>const</code> 在表达式最左边或在 <code>*</code> 左边时，对象中的基础类型的值将不可改变，指针类型存储的地址值也将不可改变（类似于 <code>const int *baz</code>）。但此时我们仍可以通过 <code>new</code> 创建新的对象（首地址）或者将其它已创建好的对象（首地址）赋值给变量：</p>

<pre><code class="language-cpp">const Foo *foo2 = new Foo(0.0, &amp;a);
// error: cannot assign to variable 'foo2' with const-qualified type 'const Foo *'
// foo2-&gt;bar = 0.5;
cout &lt;&lt; *foo2-&gt;baz &lt;&lt; endl;  // 1
a = 10;
cout &lt;&lt; *foo2-&gt;baz &lt;&lt; endl;  // 10
// error: cannot assign to variable 'foo2' with const-qualified type 'const Foo *'
// foo2-&gt;baz = &amp;b;
* foo2-&gt;baz = 100;
cout &lt;&lt; *foo2-&gt;baz &lt;&lt; endl;  // 100

foo2 = new Foo(1.5, &amp;a);
cout &lt;&lt; foo2-&gt;bar &lt;&lt; endl;    // 1.5
cout &lt;&lt; *foo2-&gt;baz &lt;&lt; endl;  // 100

foo2 = foo1;
</code></pre>

<p>当 <code>const</code> 位于表达式中 <code>*</code> 右边时，其内部存储的内存地址将无法被改变，但该内存地址所对应的值却可以被改变：</p>

<pre><code class="language-cpp">Foo * const foo3 = new Foo(0.0, &amp;a);
foo3-&gt;bar = 0.5;
cout &lt;&lt; foo3-&gt;bar &lt;&lt; endl;    // 0.5
cout &lt;&lt; *foo3-&gt;baz &lt;&lt; endl;  // 1
a = 10;
cout &lt;&lt; *foo3-&gt;baz &lt;&lt; endl;  // 10
foo3-&gt;baz = &amp;b;
cout &lt;&lt; *foo3-&gt;baz &lt;&lt; endl;  // 5
* foo3-&gt;baz = 100;
cout &lt;&lt; *foo3-&gt;baz &lt;&lt; endl;  // 100

// error: cannot assign to variable 'foo3' with const-qualified type 'Foo *const'
// foo3 = new Foo(1.5, &amp;a);
// foo3 = foo1;
</code></pre>

<h3 id="指向指针的指针">指向指针的指针</h3>

<pre><code class="language-cpp">int foo = 0;
int foo2 = 10;
int *bar = &amp;foo;
int *bar2 = &amp;foo2;
int **baz = &amp;bar;

cout &lt;&lt; **baz &lt;&lt; endl; // 0
baz = &amp;bar2;
cout &lt;&lt; **baz &lt;&lt; endl; // 10
*baz = &amp;foo2;
cout &lt;&lt; **baz &lt;&lt; endl; // 10
**baz = foo2;
cout &lt;&lt; **baz &lt;&lt; endl; // 10
</code></pre>

<p>在了解了简单的指针之后，我们再进一步，了解一下「指向指针的指针（也称二维指针）」。指向指针的指针也是指针，因此其中保存的也是内存地址，需要注意的是该内存地址指向的内存空间存储的值仍然是一个内存地址，最终这个内存地址指向的是一个值。</p>

<p>当 <code>const</code> 位于表达式中的 <code>int</code> 之前或之后时，表示最终指向的 <code>int</code> 值不应被改变，需要注意的是 <code>int **</code> 将无法赋值给 <code>const int **</code>，因为后者的类型限定更加严格：</p>

<pre><code class="language-cpp">const int **baz2;
// error: assigning to 'const int **' from incompatible type 'int **'
// baz2 = &amp;bar;

const int foo3 = 100;
const int *bar3 = &amp;foo3;
const int **baz3 = &amp;bar3;
</code></pre>

<p>当 <code>const</code> 位于表达式第一个 <code>*</code> 之后时，表示第一维指针 <code>*baz4</code> 的值（即 <code>foo</code> 的地址）将无法改变，但我们仍然可以改变第二维指针 <code>baz4</code> 的值（即 <code>bar</code> 的地址）或者 <code>foo</code> 中的值：</p>

<pre><code class="language-cpp">int *const *baz4 = &amp;bar;

cout &lt;&lt; **baz4 &lt;&lt; endl; // 0
baz4 = &amp;bar2;
cout &lt;&lt; **baz4 &lt;&lt; endl; // 10
// error: read-only variable is not assignable
// *baz4 = &amp;foo2;
**baz4 = foo2;
cout &lt;&lt; **baz4 &lt;&lt; endl; // 10
</code></pre>

<p>当 <code>const</code> 位于表达式第二个 <code>*</code> 之后时，表示第二维指针 <code>baz5</code> 的值（即 <code>bar</code> 的地址）将无法改变，但我们仍然可以改变第一维指针 <code>*baz5</code> 的值（即 <code>foo</code> 的地址）或者 <code>foo</code> 中的值：</p>

<pre><code class="language-cpp">int **const baz5 = &amp;bar;

cout &lt;&lt; **baz5 &lt;&lt; endl; // 0
// error: cannot assign to variable 'baz5' with const-qualified type 'int **const'
// baz5 = &amp;bar2;
*baz5 = &amp;foo2;
cout &lt;&lt; **baz5 &lt;&lt; endl; // 0
**baz5 = foo2;
cout &lt;&lt; **baz5 &lt;&lt; endl; // 0
</code></pre>

<p>有了上面几个不同位置的 <code>const</code> 我们就可以组合多个 <code>const</code> 来满足我们的需求。</p>

<h2 id="static"><code>static</code></h2>

<p>与 <code>const</code> 约束变量是否可变不同，<code>static</code> 主要是对变量生命周期和作用域的控制，将存储在内存的静态区。</p>

<p>当我们定义一个全局变量，其默认将存储在全局区，作为一个全局符号暴露给外界；而此时如果使用 <code>static</code> 修饰，那么其将只能在当前文件内使用，且其生命周期将持续到程序结束：</p>

<pre><code class="language-cpp">int foo = 1;
static int bar = 1;

void baz()
{
    foo = 2;
    bar = 2;
}

int main()
{
    baz();
    printf(&quot;%d\n&quot;, foo); // 2
    printf(&quot;%d&quot;, bar);   // 2

    return 0;
}
</code></pre>

<p>如何可以证明呢？我们可以使用 <code>nm -gC &lt;OBJECT_FILE&gt;</code> 查看目标文件中的全局符号，其中只有 <code>foo</code> 而没有 <code>bar</code>：</p>

<pre><code class="language-shell">➜  ~ nm -gC a.out

0000000100000f20 T baz()
0000000100000000 T __mh_execute_header
0000000100001018 D _foo
0000000100000f40 T _main
                 U _printf
                 U dyld_stub_binder
</code></pre>

<p>在 Obj-C 中，我们通常将无需暴露给外界的全局变量使用 <code>static</code> 修饰并放置在相应的实现（.m）文件中，阻止了外界访问也避免了全局符号的冲突。</p>

<h2 id="extern"><code>extern</code></h2>

<p>在软件工程中，我们几乎很少会只使用到一个源文件，而编译通常是针对每个文件进行单独编译为目标文件，并在链接阶段进行链接，最终成为可执行文件。因此在一个文件中需要使用到其他文件中变量时，我们需要使用 <code>extern</code> 来告知编译器在全局符号表中存在该符号，允许编译通过。</p>

<pre><code class="language-objectivec">// A.m
NSString *const Foo = @&quot;Foo&quot;;

// main.m
extern NSString const * Foo;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSLog(@&quot;%@&quot;, Foo); // Foo
    }
}
</code></pre>

<p>而如果我们使用了实际不存在但 <code>extern</code> 的变量，将会在编译时出现错误：</p>

<pre><code>Undefined symbols for architecture x86_64:
  &quot;_Foo&quot;, referenced from:
      _main in main.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
</code></pre>

<p>在 Obj-C 中，我们通常将常量声明在实现（.m）文件中，在对应的头（.h）文件中 <code>extern</code>，其他文件需要访问这些常量时，即可通过引入该头文件即可。</p>

  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span
        class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      
      <span class="button next">
        <a href="/posts/2019/objc_msgsend/">
          <span class="button__text">objc_msgSend</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo="kingcos/kingcos.github.io"
            issue-term="pathname"
            label="comments"
            theme="github-dark"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2019 · <a href="http://github.com/kingcos">kingcos</a></span>
      </div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>





  
</div>

</body>
</html>
