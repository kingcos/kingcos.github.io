<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>iOS ä¸­çš„ Category :: iBlog</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Date Notes Source Code Demo     2019-04-16 ä¼˜åŒ–ç»“æ„ - -   2019-04-13 é¦–æ¬¡æäº¤ objc4-750ã€xnu-4903.221.2 Category in iOS   2019-10-23 æ·»åŠ é¦–å›¾ï¼Œç»†èŠ‚å¾®è°ƒ - -    Preface iOS ä¸­çš„ Category ä¸­æ–‡å¸¸è¯‘ä½œåˆ†ç±»ã€ç±»åˆ«ï¼ˆä¸ºè¡¨è¿°ç»Ÿä¸€ï¼Œæœ¬æ–‡å°†ä½¿ç”¨ Category ç‰¹æŒ‡è¯¥æŠ€æœ¯ï¼‰ã€‚æˆ‘ä»¬ç»å¸¸ä¼šä½¿ç”¨ Category æ¥å¯¹ä¸€ä¸ªç±»è¿›è¡Œæ‰©å±•ï¼Œä½¿å¾—åœ¨ä¸ç ´åä¸»ç±»ç»“æ„çš„åŒæ—¶å¯ä»¥å…·å¤‡æ›´å¤šçš„åŠŸèƒ½ï¼›ä¹Ÿå¯ä»¥ä½¿ç”¨ Category å¯¹ä¸€ä¸ªç±»è¿›è¡Œæ‹†åˆ†ï¼Œä½¿å¾—å…¶ç»“æ„æ›´åŠ æ¸…æ™°æ¡ç†ã€‚æœ¬æ–‡å°†ä» What - How - Why è°ˆè°ˆ iOS ä¸­ Categoryã€‚
What ä»€ä¹ˆæ˜¯ Category å‘¢ï¼Ÿ
Category æ˜¯ Obj-C è¯­è¨€ä¸­æ‰€æä¾›çš„ä¸€é¡¹åŠŸèƒ½ï¼Œå®ƒå¯ä»¥ä¸º Obj-C ç±»æ·»åŠ é¢å¤–çš„å±æ€§ã€æ–¹æ³•ï¼Œä¹Ÿå¯ä»¥éµå®ˆå…¶ä»–åè®®ã€‚
Xcode ä¸­å·²ç»ä¸º Category å·²ç»æä¾›äº†æ¨¡ç‰ˆæ¥å»ºç«‹ï¼Œåªéœ€è¦æŒ‡å®š Category çš„åç§°ä»¥åŠè¢«æ·»åŠ  Category ç±»åå³å¯ã€‚å½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æ‰‹åŠ¨æ¥è‡ªå·±å»ºç«‹ï¼ŒCategory çš„è¯­æ³•ä¸ç±»çš„å£°æ˜ä¸å®ç°æ¯”è¾ƒç±»ä¼¼ï¼š"/>
<meta name="keywords" content="kingcos.me,maimieng.comios,swift,objective-c,obj-c,objc,oc,geek,python,ruby,golang,go,apple,mac"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/2019/category_in_ios/" />





<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="iOS ä¸­çš„ Category"/>
<meta name="twitter:description" content="iOS ä¸­çš„ Category ä¸­æ–‡å¸¸è¯‘ä½œåˆ†ç±»ã€ç±»åˆ«ã€‚æˆ‘ä»¬ç»å¸¸ä¼šä½¿ç”¨ Category æ¥å¯¹ä¸€ä¸ªç±»è¿›è¡Œæ‰©å±•ï¼Œä½¿å¾—åœ¨ä¸ç ´åä¸»ç±»ç»“æ„çš„åŒæ—¶å¯ä»¥å…·å¤‡æ›´å¤šçš„åŠŸèƒ½ï¼›ä¹Ÿå¯ä»¥ä½¿ç”¨ Category å¯¹ä¸€ä¸ªç±»è¿›è¡Œæ‹†åˆ†ï¼Œä½¿å¾—å…¶ç»“æ„æ›´åŠ æ¸…æ™°æ¡ç†ã€‚æœ¬æ–‡å°†ä» What - How - Why è°ˆè°ˆ iOS ä¸­ Categoryã€‚"/>



<meta property="og:title" content="iOS ä¸­çš„ Category" />
<meta property="og:description" content="iOS ä¸­çš„ Category ä¸­æ–‡å¸¸è¯‘ä½œåˆ†ç±»ã€ç±»åˆ«ã€‚æˆ‘ä»¬ç»å¸¸ä¼šä½¿ç”¨ Category æ¥å¯¹ä¸€ä¸ªç±»è¿›è¡Œæ‰©å±•ï¼Œä½¿å¾—åœ¨ä¸ç ´åä¸»ç±»ç»“æ„çš„åŒæ—¶å¯ä»¥å…·å¤‡æ›´å¤šçš„åŠŸèƒ½ï¼›ä¹Ÿå¯ä»¥ä½¿ç”¨ Category å¯¹ä¸€ä¸ªç±»è¿›è¡Œæ‹†åˆ†ï¼Œä½¿å¾—å…¶ç»“æ„æ›´åŠ æ¸…æ™°æ¡ç†ã€‚æœ¬æ–‡å°†ä» What - How - Why è°ˆè°ˆ iOS ä¸­ Categoryã€‚" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/2019/category_in_ios/" />
<meta property="article:published_time" content="2019-10-23T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-10-23T00:00:00+00:00" /><meta property="og:site_name" content="iBlog" />






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">kingcos.me</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/perspective">Perspective</a></li>
        
      
        
          <li><a href="/words">Words</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/perspective">Perspective</a></li>
      
    
      
        <li><a href="/words">Words</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="post">
    <h2 class="post-title"><a href="/posts/2019/category_in_ios/">iOS ä¸­çš„ Category</a></h2>
    <div class="post-meta">
      
        <span class="post-date">
            2019-10-23
        </span>
      
      
      
        <span class="post-read-time">â€” 23 min read</span>
      
    </div>

    
      <span class="post-tags">
        
          #<a href="/tags/focus/">Focus</a>&nbsp;
        
          #<a href="/tags/ios/">iOS</a>&nbsp;
        
          #<a href="/tags/obj-c/">Obj-C</a>&nbsp;
        
          #<a href="/tags//">ğŸŒŸ</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      

<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Notes</th>
<th align="center">Source Code</th>
<th align="center">Demo</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">2019-04-16</td>
<td align="center">ä¼˜åŒ–ç»“æ„</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>

<tr>
<td align="center">2019-04-13</td>
<td align="center">é¦–æ¬¡æäº¤</td>
<td align="center"><a href="https://opensource.apple.com/tarballs/objc4/">objc4-750</a>ã€<a href="https://opensource.apple.com/tarballs/xnu/">xnu-4903.221.2</a></td>
<td align="center"><a href="https://github.com/kingcos/Perspective/tree/writing/Posts/Focus/Category_in_Obj-C/">Category in iOS</a></td>
</tr>

<tr>
<td align="center">2019-10-23</td>
<td align="center">æ·»åŠ é¦–å›¾ï¼Œç»†èŠ‚å¾®è°ƒ</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody>
</table>

<p><img src="/img/2019/category_in_ios/0.png" alt="0" /></p>

<h2 id="preface">Preface</h2>

<p>iOS ä¸­çš„ Category ä¸­æ–‡å¸¸è¯‘ä½œåˆ†ç±»ã€ç±»åˆ«ï¼ˆä¸ºè¡¨è¿°ç»Ÿä¸€ï¼Œæœ¬æ–‡å°†ä½¿ç”¨ Category ç‰¹æŒ‡è¯¥æŠ€æœ¯ï¼‰ã€‚æˆ‘ä»¬ç»å¸¸ä¼šä½¿ç”¨ Category æ¥å¯¹ä¸€ä¸ªç±»è¿›è¡Œæ‰©å±•ï¼Œä½¿å¾—åœ¨ä¸ç ´åä¸»ç±»ç»“æ„çš„åŒæ—¶å¯ä»¥å…·å¤‡æ›´å¤šçš„åŠŸèƒ½ï¼›ä¹Ÿå¯ä»¥ä½¿ç”¨ Category å¯¹ä¸€ä¸ªç±»è¿›è¡Œæ‹†åˆ†ï¼Œä½¿å¾—å…¶ç»“æ„æ›´åŠ æ¸…æ™°æ¡ç†ã€‚æœ¬æ–‡å°†ä» What - How - Why è°ˆè°ˆ iOS ä¸­ Categoryã€‚</p>

<h2 id="what">What</h2>

<p>ä»€ä¹ˆæ˜¯ Category å‘¢ï¼Ÿ</p>

<p>Category æ˜¯ Obj-C è¯­è¨€ä¸­æ‰€æä¾›çš„ä¸€é¡¹åŠŸèƒ½ï¼Œå®ƒå¯ä»¥ä¸º Obj-C ç±»æ·»åŠ é¢å¤–çš„å±æ€§ã€æ–¹æ³•ï¼Œä¹Ÿå¯ä»¥éµå®ˆå…¶ä»–åè®®ã€‚</p>

<p><img src="/img/2019/category_in_ios/1.png" alt="1" /></p>

<p>Xcode ä¸­å·²ç»ä¸º Category å·²ç»æä¾›äº†æ¨¡ç‰ˆæ¥å»ºç«‹ï¼Œåªéœ€è¦æŒ‡å®š Category çš„åç§°ä»¥åŠè¢«æ·»åŠ  Category ç±»åå³å¯ã€‚å½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æ‰‹åŠ¨æ¥è‡ªå·±å»ºç«‹ï¼ŒCategory çš„è¯­æ³•ä¸ç±»çš„å£°æ˜ä¸å®ç°æ¯”è¾ƒç±»ä¼¼ï¼š</p>

<pre><code class="language-objectivec">@interface Foo (Bar) &lt;SomeProtocol&gt;
- (void)foo;
@end

@implementation Foo (Bar)
- (void)foo {}

- (void)someMethodFromProtocol {}
@end
</code></pre>

<h2 id="how">How</h2>

<p>Category é€šå¸¸éƒ½æœ‰å“ªäº›ç”¨å¤„å‘¢ï¼Ÿ</p>

<h3 id="è§£è€¦">è§£è€¦</h3>

<p>å‡å¦‚æœ‰ä¸€ä¸ªäººï¼ˆPersonï¼‰ï¼Œä»–éœ€è¦å·¥ä½œï¼ˆWorkï¼‰å’Œç”Ÿæ´»ï¼ˆLifeï¼‰ï¼Œè€Œå·¥ä½œå’Œç”Ÿæ´»æ‰€åšçš„äº‹æƒ…æ˜¾ç„¶æ˜¯ä¸ä¸€æ ·çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ Category å°†äººçš„è¿™å®ƒä»¬è¿›è¡Œè§£è€¦ï¼š</p>

<pre><code class="language-objectivec">@interface Person
@property (nonatomic, copy) NSString *name;
@end

@implementation Person
@end

// ---

@interface Person (Life)
- (void)playWithPet;
@end

@implementation Person (Life)
- (void)playWithPet {}
@end

// ---

@interface Person (Work)
- (void)codeForWork;
@end

@implementation Person (Work)
- (void)codeForWork {}
@end
</code></pre>

<p>è¿™æ ·ï¼ŒPerson+Life ä¸­å¯ä»¥å®šä¹‰ä¸ç”Ÿæ´»ç›¸å…³çš„æ–¹æ³•ï¼Œè€Œ Person+Work ä¸­å°†ä¸“æ³¨äºå·¥ä½œã€‚å½“äººéœ€è¦è¿åŠ¨ï¼ˆSportsï¼‰æ—¶ï¼Œåªéœ€è¦å†ä¸º Person æ·»åŠ  Person+Sports çš„ Category å³å¯ï¼Œè¿™å¹¶ä¸éœ€è¦æ”¹åŠ¨ä¸»ç±»æœ¬èº«ä»è€Œå®ç°äº†è§£è€¦ã€‚</p>

<h3 id="ç§æœ‰åŒ–">ç§æœ‰åŒ–</h3>

<p>ä½¿ç”¨ Xcode æ¨¡ç‰ˆæ–°å»º Category åï¼Œå°†ä¼šè‡ªåŠ¨åˆ›å»ºä¸¤ä¸ªæ–‡ä»¶ï¼šClassName+CategoryName.h &amp; ClassName+CategoryName.mã€‚å½“æˆ‘ä»¬ä¸å¸Œæœ›æŸä¸ª Category å¯ä»¥åœ¨å¤–ç•Œè®¿é—®æ—¶ï¼Œåªéœ€è¦ä¸æŠŠå®ƒä½œä¸ºå…¬å…±å¤´æ–‡ä»¶ï¼ˆPublic Headerï¼‰æš´éœ²å‡ºå»å³å¯ï¼Œå³å®ç°äº†ç§æœ‰åŒ–ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒåŒæ ·å¯ä»¥å®ç°ç§æœ‰åŒ–çš„æ–¹æ¡ˆæ˜¯ä½¿ç”¨ç±»æ‰©å±•ï¼ˆClass Extensionï¼‰ï¼Œå…¶å› è¯­æ³•ç›¸ä¼¼ä½†æ²¡æœ‰å®šä¹‰åç§°è¢«å¾ˆå¤šäººç§°ä¸ºã€ŒåŒ¿ååˆ†ç±»ï¼ˆCategoryï¼‰ã€ã€‚ä¸è¿‡æœ¬è´¨ä¸Šè¯´ï¼ŒCategory å’Œç±»æ‰©å±•æ˜¯å®Œå…¨ä¸åŒçš„ï¼š</p>

<pre><code class="language-objectivec">// Class Extension
@interface Person ()
- (void)secret;
@end
</code></pre>

<p>ç±»æ‰©å±•æ˜¯å¯ä»¥å®šä¹‰åœ¨å•ç‹¬çš„ .h æˆ–è€… .m ä¸­ï¼Œå…¶ä¸»è¦å¯ä»¥ä½¿å¾—å¤–ç•Œæ— æ³•ç›´æ¥è®¿é—®åˆ°å®šä¹‰çš„æˆå‘˜å˜é‡ã€å±æ€§æˆ–æ–¹æ³•ã€‚å…³äºç±»æ‰©å±•ä¸è®¿é—®æ§åˆ¶ï¼Œå¯è¯¦è§ã€Š<a href="/posts/2019/ivar_access_control_in_obj-c/">Obj-C ä¸­æˆå‘˜å˜é‡å’Œç±»çš„è®¿é—®æ§åˆ¶</a>ã€‹ä¸€æ–‡ã€‚</p>

<h3 id="åç§æœ‰åŒ–">ã€Œåç§æœ‰åŒ–ã€</h3>

<p>Category ä¸ä»…å¯ä»¥ç§æœ‰åŒ–ï¼Œå…¶å®ä¹Ÿå¯ä»¥ã€Œåç§æœ‰åŒ–ã€ã€‚å¦‚æœæˆ‘ä»¬å¸Œæœ›è°ƒç”¨ä¸€ä¸ªæ²¡æœ‰å£°æ˜çš„æ–¹æ³•ï¼Œæ­¤æ—¶å°±å¯ä»¥åœ¨å…¶ Category æˆ–è€…ç±»æ‰©å±•ä¸­å£°æ˜è¯¥æ–¹æ³•ï¼Œå†è¿›è¡Œè°ƒç”¨ã€‚å½“ç„¶ï¼ŒObj-C ä¸­æ–¹æ³•è°ƒç”¨æœ¬è´¨æ˜¯æ¶ˆæ¯å‘é€ï¼Œåªè¦æˆ‘ä»¬çŸ¥é“äº†æ¶ˆæ¯çš„å‘é€è€…å’Œæ¥æ”¶è€…ï¼Œå³ä½¿æ²¡æœ‰å£°æ˜ä¹Ÿæ€»æœ‰æ–¹æ³•æ¥å‘é€æ¶ˆæ¯ã€‚</p>

<h3 id="å¤šç»§æ‰¿">ã€Œå¤šç»§æ‰¿ã€</h3>

<p>å› ä¸º Category æ˜¯æ”¯æŒéµå®ˆåè®®ï¼ˆProtocolï¼‰çš„ï¼Œé‚£ä¹ˆä¸åŒçš„ Category å°±å¯ä»¥éµå®ˆä¸åŒçš„åè®®ï¼Œå®ç°ç±»ä¼¼ã€Œå¤šç»§æ‰¿ã€çš„ç‰¹æ€§ã€‚ä½†ä¸ºä»€ä¹ˆæ˜¯åŠ å¼•å·çš„ã€Œå¤šç»§æ‰¿ã€å‘¢ï¼Ÿå› ä¸ºè¿™æ ·çš„åè®®éµå®ˆåªèƒ½è·å¾—æ–¹æ³•çš„å£°æ˜ï¼Œå´æ— æ³•è·å¾—çˆ¶ç±»çš„å…·ä½“å®ç°ã€‚</p>

<pre><code class="language-objectivec">@protocol LifeProtocol &lt;NSObject&gt;
- (void)playWithPet;
@end

@interface Person (Life) &lt;LifeProtocol&gt;
@end

@implementation Person (Life)
- (void)playWithPet {}
@end

// ---

@protocol WorkProtocol &lt;NSObject&gt;
- (void) workHard;
@end

@interface Person (Work) &lt;WorkProtocol&gt;
@end

@implementation Person (Work)
- (void)workHard {}
@end
</code></pre>

<h2 id="why">Why</h2>

<p>Obj-C ä¸­çš„ Category åº•å±‚æ˜¯å¦‚ä½•å®ç°çš„å‘¢ï¼Ÿ</p>

<h3 id="ç»“æ„">ç»“æ„</h3>

<pre><code class="language-objectivec">// Person+Life.h
/**
 LifeProtocol
 */
@protocol LifeProtocol &lt;NSObject&gt;
- (void)eat;
@end

/**
 Person+Life
 */
@interface Person (Life) &lt;LifeProtocol&gt;

@property (nonatomic, copy) NSString *name;

// Instance method
- (void)run;

// Class method
+ (void)foo;

// Protocol method
- (void)eat;

@end
</code></pre>

<p>å®šä¹‰ä¸€ä¸ªå®Œæ•´çš„ Person ç±»ï¼Œå®ƒéµå®ˆäº†åè®®ï¼Œå­˜å‚¨äº†å±æ€§ï¼Œå¹¶å®šä¹‰å®ç°äº†å¯¹è±¡æ–¹æ³•å’Œç±»æ–¹æ³•ã€‚ä¸ºäº†ä¾¿äºä¸‹é¢çš„åˆ†æï¼Œæˆ‘ä»¬ä½¿ç”¨ <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc Person+Life.m</code> å‘½ä»¤å°† Person+Life.m ç¿»è¯‘ä¸º C/C++ ä»£ç ï¼ˆPerson+Life.cppï¼‰ï¼Œå…³äºç¿»è¯‘ Obj-C ä»£ç çš„ç»†èŠ‚ï¼Œå¯è¯¦è§ã€Š<a href="../obj-c_to_c++/">å°† Obj-C ä»£ç ç¿»è¯‘ä¸º C++ ä»£ç </a>ã€‹ä¸€æ–‡ã€‚</p>

<pre><code class="language-cpp">// Person+Life.cpp
struct _category_t {
	const char *name;                               // ç±»å
	struct _class_t *cls;                           // ç±»æŒ‡é’ˆ
	const struct _method_list_t *instance_methods;  // å¯¹è±¡æ–¹æ³•åˆ—è¡¨æŒ‡é’ˆ
	const struct _method_list_t *class_methods;     // ç±»æ–¹æ³•åˆ—è¡¨æŒ‡é’ˆ
	const struct _protocol_list_t *protocols;       // åè®®åˆ—è¡¨æŒ‡é’ˆ
	const struct _prop_list_t *properties;          // å±æ€§åˆ—è¡¨æŒ‡é’ˆ
};

static struct _category_t _OBJC_$_CATEGORY_Person_$_Life __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) =
{
	&quot;Person&quot;,
	0, // &amp;OBJC_CLASS_$_Person,
	(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Life,
	(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_Person_$_Life,
	(const struct _protocol_list_t *)&amp;_OBJC_CATEGORY_PROTOCOLS_$_Person_$_Life,
	(const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_Person_$_Life,
};

// å¯¹è±¡æ–¹æ³•åˆ—è¡¨
static struct /*_method_list_t*/ {
	unsigned int entsize;  // sizeof(struct _objc_method)
	unsigned int method_count;
	struct _objc_method method_list[2];
} _OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Life __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = {
	sizeof(_objc_method),
	2,
	{{(struct objc_selector *)&quot;run&quot;, &quot;v16@0:8&quot;, (void *)_I_Person_Life_run},
	{(struct objc_selector *)&quot;eat&quot;, &quot;v16@0:8&quot;, (void *)_I_Person_Life_eat}}
};

// ç±»æ–¹æ³•åˆ—è¡¨
static struct /*_method_list_t*/ {
	unsigned int entsize;  // sizeof(struct _objc_method)
	unsigned int method_count;
	struct _objc_method method_list[1];
} _OBJC_$_CATEGORY_CLASS_METHODS_Person_$_Life __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = {
	sizeof(_objc_method),
	1,
	{{(struct objc_selector *)&quot;foo&quot;, &quot;v16@0:8&quot;, (void *)_C_Person_Life_foo}}
};

// åè®®åˆ—è¡¨
static struct /*_protocol_list_t*/ {
	long protocol_count;  // Note, this is 32/64 bit
	struct _protocol_t *super_protocols[1];
} _OBJC_CATEGORY_PROTOCOLS_$_Person_$_Life __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = {
	1,
	&amp;_OBJC_PROTOCOL_LifeProtocol
};

// å±æ€§åˆ—è¡¨
static struct /*_prop_list_t*/ {
	unsigned int entsize;  // sizeof(struct _prop_t)
	unsigned int count_of_properties;
	struct _prop_t prop_list[1];
} _OBJC_$_PROP_LIST_Person_$_Life __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = {
	sizeof(_prop_t),
	1,
	{{&quot;name&quot;,&quot;T@\&quot;NSString\&quot;,C,N&quot;}}
};
</code></pre>

<p>åœ¨ç¿»è¯‘åçš„ C++ æºä»£ç ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ä¸€ä¸ªåç§°å’Œ Category ç›¸å…³çš„ç»“æ„ä½“å®šä¹‰ï¼š<code>_category_t</code>ï¼Œè¯¥ç»“æ„ä½“è¡¨ç¤ºäº† Obj-C ä¸­ Category çš„å®é™…ç»“æ„ï¼›<code>_OBJC_$_CATEGORY_Person_$_Life</code> åˆ™å°±æ˜¯æˆ‘ä»¬å®šä¹‰çš„ Person+Life Categoryã€‚<code>_category_t</code> ç»“æ„ä½“ä¸­å­˜å‚¨äº†ç±»åã€ç±»æŒ‡é’ˆã€å¯¹è±¡æ–¹æ³•åˆ—è¡¨æŒ‡é’ˆã€ç±»æ–¹æ³•åˆ—è¡¨æŒ‡é’ˆã€åè®®åˆ—è¡¨æŒ‡é’ˆã€ä»¥åŠå±æ€§åˆ—è¡¨æŒ‡é’ˆï¼Œæ‰€ä»¥ Category ä¸­æ”¯æŒéµå®ˆåè®®ã€å£°æ˜å±æ€§ã€ä»¥åŠå®šä¹‰å®ç°å¯¹è±¡æ–¹æ³•å’Œç±»æ–¹æ³•ï¼ˆä¸æ”¯æŒå®šä¹‰æˆå‘˜å˜é‡ï¼‰ã€‚å½“ç„¶ï¼Œåœ¨ Apple å¼€æºçš„ objc4 ä¸­ï¼Œä¹Ÿå¯ä»¥æ‰¾åˆ° <code>category_t</code> ç»“æ„ä½“ï¼š</p>

<pre><code class="language-cpp">// objc-runtime-new.h
struct category_t {
    const char *name;
    classref_t cls;
    struct method_list_t *instanceMethods;
    struct method_list_t *classMethods;
    struct protocol_list_t *protocols;
    struct property_list_t *instanceProperties;
    // Fields below this point are not always present on disk.
    // ä»¥ä¸‹å†…å®¹å¹¶ä¸èƒ½ä¿è¯ä¼šåœ¨ç£ç›˜ä¸­å±•ç¤º
    struct property_list_t *_classProperties;

    method_list_t *methodsForMeta(bool isMeta) {
        if (isMeta) return classMethods;
        else return instanceMethods;
    }

    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);
};
</code></pre>

<h3 id="å®ç°åŸç†">å®ç°åŸç†</h3>

<p>å½“æˆ‘ä»¬çš„ä»£ç ç¼–è¯‘å®Œï¼ŒCategory ä¸­çš„ä¿¡æ¯å°±å°†è¢«å­˜å‚¨åœ¨ <code>category_t</code> çš„ç»“æ„ä½“ä¸­ï¼Œé‚£ä¹ˆè¿è¡Œæ—¶çš„ Category åˆä¼šå˜æˆä»€ä¹ˆæ ·å‘¢ï¼Ÿ</p>

<h4 id="what-1">What</h4>

<p>æˆ‘ä»¬å°è¯•åˆ†åˆ«åœ¨ <code>Person</code> ä¸»ç±»ã€Person+Life å’Œ Person+Work Category ä¸­å®šä¹‰å¹¶å®ç°å®Œå…¨ç›¸åŒçš„ <code>smile</code> æ–¹æ³•ã€‚æœ‰ä¸ªç»†èŠ‚æ˜¯ï¼Œæˆ‘ä»¬åœ¨ Category ä¸­å®ç°ä¸»ç±»ä¸­å·²ç»å®ç°çš„æ–¹æ³•æ—¶ï¼Œç¼–è¯‘å™¨ä¼šè­¦å‘Šã€ŒCategory is implementing a method which will also be implemented by its primary classã€ï¼Œè¿™åˆæ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ</p>

<pre><code class="language-objectivec">// Person.h
@interface Person : NSObject
- (void)smile;
@end

// Person+Life.h
@interface Person (Life) &lt;LifeProtocol&gt;
// ...

- (void)smile;
@end

// Person+Work.h
@interface Person (Work)
- (void)smile;
@end

// main.m
Person *p = [[Person alloc] init];
[p smile];

// OUTPUT:
// Person (Work) - -[Person(Work) smile]
</code></pre>

<p>å½“æˆ‘ä»¬è¿è¡Œç¨‹åºï¼Œå‘ç°æœ€ç»ˆåªè¾“å‡ºäº†ä¸€å¥ï¼Œå¹¶ä¸”æ˜¯è°ƒç”¨åˆ°äº† Person+Work Category ä¸­çš„æ–¹æ³•ã€‚é‚£ä¹ˆå…ˆè¯´ç»“è®ºï¼š<strong>å½“ Category ä¸­å®ç°äº†ä¸»ç±»ä¸­åŒä¸€ä¸ªæ–¹æ³•æ—¶ï¼Œå°†æ€»æ˜¯è°ƒç”¨ Category ä¸­çš„æ–¹æ³•ï¼ˆè¿™ä¹Ÿæ˜¯ä¸ºä½•ç¼–è¯‘å™¨è­¦å‘Šçš„åŸå› ï¼‰ï¼›å½“å­˜åœ¨å¤šä¸ª Category å®ç°åŒä¸€ä¸ªæ–¹æ³•æ—¶ï¼Œå°†æ€»æ˜¯è°ƒç”¨æœ€åè¢«ç¼–è¯‘çš„ Category ä¸­çš„æ–¹æ³•</strong>ã€‚å¦‚ä½•æŸ¥çœ‹æ–‡ä»¶çš„ç¼–è¯‘é¡ºåºå‘¢ï¼Ÿåœ¨ Xcode -ã€ŒBuild Phasesã€-ã€ŒCompile Sourcesã€ä¸­ï¼Œé å‰çš„å³æ˜¯æœ€å…ˆè¢«ç¼–è¯‘çš„ï¼š</p>

<p><img src="/img/2019/category_in_ios/2.png" alt="2" /></p>

<h4 id="why-1">Why</h4>

<p>ä¸ºäº†è¯æ˜ä¸Šè¿°ç»“è®ºï¼Œæˆ‘ä»¬éœ€è¦åœ¨ objc4 çš„æºç ä¸­ï¼Œä» Obj-C è¿è¡Œæ—¶åˆå§‹åŒ–çš„å…¥å£ç€æ‰‹ï¼Œå³ <code>_objc_init</code>ï¼š</p>

<pre><code class="language-objectivec">// objc-os.mm
/***********************************************************************
* _objc_init
* Bootstrap initialization. Registers our image notifier with dyld.
* å¼•å¯¼åˆå§‹åŒ–ã€‚ä½¿ç”¨ dyld æ³¨å†Œé•œåƒé€šçŸ¥å™¨ã€‚
* Called by libSystem BEFORE library initialization time
* åœ¨åº“åˆå§‹åŒ–æ—¶é—´ä¹‹å‰ç”± libSystem è°ƒç”¨
**********************************************************************/

void _objc_init(void)
{
    static bool initialized = false;
    if (initialized) return;
    initialized = true;

    // fixme defer initialization until an objc-using image is found?
    environ_init();
    tls_init();
    static_init();
    lock_init();
    exception_init();

    // â¡ï¸ dyld æ³¨å†Œé€šçŸ¥ï¼›map_imagesï¼šæ˜ å°„é•œåƒï¼Œload_imagesï¼šåŠ è½½é•œåƒï¼Œunmap_imageï¼šåæ˜ å°„é•œåƒ
    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);
}

// objc-runtime-new.mm
/***********************************************************************
* map_images
* Process the given images which are being mapped in by dyld.
* ç”± dyld å¤„ç†ç»™å®šå°†è¦æ˜ å°„çš„é•œåƒã€‚
* Calls ABI-agnostic code after taking ABI-specific locks.
* åŠ ä¸ŠæŒ‡å®š ABI é”åè°ƒç”¨ ABI æ— å…³ï¼ˆagnosticï¼‰çš„ä»£ç ã€‚
*
* Locking: write-locks runtimeLock
* é”ï¼šå†™é” runtimeLock
**********************************************************************/
void
map_images(unsigned count, const char * const paths[],
           const struct mach_header * const mhdrs[])
{
    // äº’æ–¥é”
    mutex_locker_t lock(runtimeLock);
    // â¡ï¸ map_images_nolockï¼šæ˜ å°„é•œåƒï¼ˆæ— é”ï¼‰
    return map_images_nolock(count, paths, mhdrs);
}

// objc-os.mm
void
map_images_nolock(unsigned mhCount, const char * const mhPaths[],
                  const struct mach_header * const mhdrs[])
{
    static bool firstTime = YES;
    header_info *hList[mhCount];
    uint32_t hCount;
    size_t selrefCount = 0;

    // Perform first-time initialization if necessary.
    // å¿…è¦æ—¶æ‰§è¡Œé¦–æ¬¡åˆå§‹åŒ–ã€‚
    // This function is called before ordinary library initializers.
    // åœ¨æ™®é€šåº“æ„é€ æ–¹æ³•ä¹‹å‰è°ƒç”¨è¯¥å‡½æ•°ã€‚
    // fixme defer initialization until an objc-using image is found?
    if (firstTime) {
        preopt_init();
    }

    // Xcode ä¸­ OBJC_PRINT_IMAGES ç¯å¢ƒå˜é‡å€¼ä¸º YES æ—¶ï¼Œå°†å¯åœ¨æ§åˆ¶å°æ‰“å°è¯¥ä¿¡æ¯
    // OPTION(PrintImages, OBJC_PRINT_IMAGES, &quot;log image and library names as they are loaded&quot;)
    if (PrintImages) {
        _objc_inform(&quot;IMAGES: processing %u newly-mapped images...\n&quot;, mhCount);
    }


    // Find all images with Objective-C metadata.
    // ä½¿ç”¨ Obj-C å…ƒæ•°æ®æŸ¥æ‰¾æ‰€æœ‰é•œåƒã€‚
    hCount = 0;

    // Count classes. Size various table based on the total.
    // è®¡ç®—ç±»ã€‚æ ¹æ®æ€»æ•°è®¡ç®—ä¸åŒçš„è¡¨ã€‚
    int totalClasses = 0;
    int unoptimizedTotalClasses = 0;
    {
        uint32_t i = mhCount;
        // éå† mach-o header
        while (i--) {
            const headerType *mhdr = (const headerType *)mhdrs[i];

            // â¡ï¸ addHeaderï¼šæ·»åŠ å¤´éƒ¨ä¿¡æ¯ï¼ˆè®¡ç®—ç±»çš„æ€»æ•°ã€æœªä¼˜åŒ–çš„ç±»æ€»æ•°ï¼‰
            auto hi = addHeader(mhdr, mhPaths[i], totalClasses, unoptimizedTotalClasses);
            if (!hi) {
                // no objc data in this entry
                // è‹¥ hi ä¸ºç©ºï¼Œåˆ™è¯¥æ¡ç›®æ²¡æœ‰ Obj-C æ•°æ®
                continue;
            }

            // åˆ¤æ–­æ–‡ä»¶ç±»å‹æ˜¯å¦æ˜¯å¯æ‰§è¡Œæ–‡ä»¶
            // #define	MH_EXECUTE	0x2		/* demand paged executable file */
            if (mhdr-&gt;filetype == MH_EXECUTE) {
                // Size some data structures based on main executable's size
                // æ ¹æ®ä¸»å¯æ‰§è¡Œæ–‡ä»¶çš„å¤§å°è°ƒæ•´ä¸€äº›æ•°æ®ç»“æ„çš„å¤§å°
#if __OBJC2__
                size_t count;

                // åœ¨ __objc_selrefs èŠ‚è·å– SEL å¼•ç”¨ï¼ˆæ­¤å¤„å¯å‚è€ƒ Mach-O æˆ– Link Map æ–‡ä»¶ä¸­ Sections éƒ¨åˆ†ï¼‰
                // GETSECT(_getObjc2SelectorRefs,        SEL,             &quot;__objc_selrefs&quot;);
                _getObjc2SelectorRefs(hi, &amp;count);
                selrefCount += count;
                // åœ¨ __objc_msgrefs èŠ‚è·å–æ¶ˆæ¯å¼•ç”¨
                // GETSECT(_getObjc2MessageRefs,         message_ref_t,   &quot;__objc_msgrefs&quot;);
                _getObjc2MessageRefs(hi, &amp;count);
                selrefCount += count;
#else
                _getObjcSelectorRefs(hi, &amp;selrefCount);
#endif

#if SUPPORT_GC_COMPAT
                // Halt if this is a GC app.
                if (shouldRejectGCApp(hi)) {
                    _objc_fatal_with_reason
                        (OBJC_EXIT_REASON_GC_NOT_SUPPORTED,
                         OS_REASON_FLAG_CONSISTENT_FAILURE,
                         &quot;Objective-C garbage collection &quot;
                         &quot;is no longer supported.&quot;);
                }
#endif
            }

            // hList ä¿å­˜ hi å¹¶ hCount è‡ªå¢
            hList[hCount++] = hi;

            if (PrintImages) {
                _objc_inform(&quot;IMAGES: loading image for %s%s%s%s%s\n&quot;,
                             hi-&gt;fname(),
                             mhdr-&gt;filetype == MH_BUNDLE ? &quot; (bundle)&quot; : &quot;&quot;,
                             hi-&gt;info()-&gt;isReplacement() ? &quot; (replacement)&quot; : &quot;&quot;,
                             hi-&gt;info()-&gt;hasCategoryClassProperties() ? &quot; (has class properties)&quot; : &quot;&quot;,
                             hi-&gt;info()-&gt;optimizedByDyld()?&quot; (preoptimized)&quot;:&quot;&quot;);
            }
        }
    }

    // Perform one-time runtime initialization that must be deferred until
    // the executable itself is found. This needs to be done before
    // further initialization.
    // (The executable may not be present in this infoList if the
    // executable does not contain Objective-C code but Objective-C
    // is dynamically loaded later.
    // åœ¨æ‰¾åˆ°å¯æ‰§è¡Œæ–‡ä»¶æœ¬èº«ä¹‹å‰å¿…é¡»å»¶è¿Ÿæ‰§è¡Œä¸€æ¬¡æ€§è¿è¡Œæ—¶åˆå§‹åŒ–ã€‚
    // è¿™éœ€è¦åœ¨è¿›ä¸€æ­¥åˆå§‹åŒ–ä¹‹å‰å®Œæˆã€‚
    // ï¼ˆå¦‚æœå¯æ‰§è¡Œæ–‡ä»¶ä¸åŒ…å« Obj-C ä»£ç ä½† Obj-C åœ¨ä¹‹ååŠ¨æ€åŠ è½½ï¼Œåˆ™ infoList ä¸­å¯èƒ½ä¸åŒ…å«è¯¥å¯æ‰§è¡Œæ–‡ä»¶ã€‚ï¼‰
    if (firstTime) {
        sel_init(selrefCount);
        arr_init();

#if SUPPORT_GC_COMPAT
        // Reject any GC images linked to the main executable.
        // We already rejected the app itself above.
        // Images loaded after launch will be rejected by dyld.

        for (uint32_t i = 0; i &lt; hCount; i++) {
            auto hi = hList[i];
            auto mh = hi-&gt;mhdr();
            if (mh-&gt;filetype != MH_EXECUTE  &amp;&amp;  shouldRejectGCImage(mh)) {
                _objc_fatal_with_reason
                    (OBJC_EXIT_REASON_GC_NOT_SUPPORTED,
                     OS_REASON_FLAG_CONSISTENT_FAILURE,
                     &quot;%s requires Objective-C garbage collection &quot;
                     &quot;which is no longer supported.&quot;, hi-&gt;fname());
            }
        }
#endif

#if TARGET_OS_OSX
        // Disable +initialize fork safety if the app is too old (&lt; 10.13).
        // Disable +initialize fork safety if the app has a
        //   __DATA,__objc_fork_ok section.

        if (dyld_get_program_sdk_version() &lt; DYLD_MACOSX_VERSION_10_13) {
            DisableInitializeForkSafety = true;
            if (PrintInitializing) {
                _objc_inform(&quot;INITIALIZE: disabling +initialize fork &quot;
                             &quot;safety enforcement because the app is &quot;
                             &quot;too old (SDK version &quot; SDK_FORMAT &quot;)&quot;,
                             FORMAT_SDK(dyld_get_program_sdk_version()));
            }
        }

        for (uint32_t i = 0; i &lt; hCount; i++) {
            auto hi = hList[i];
            auto mh = hi-&gt;mhdr();
            if (mh-&gt;filetype != MH_EXECUTE) continue;
            unsigned long size;
            if (getsectiondata(hi-&gt;mhdr(), &quot;__DATA&quot;, &quot;__objc_fork_ok&quot;, &amp;size)) {
                DisableInitializeForkSafety = true;
                if (PrintInitializing) {
                    _objc_inform(&quot;INITIALIZE: disabling +initialize fork &quot;
                                 &quot;safety enforcement because the app has &quot;
                                 &quot;a __DATA,__objc_fork_ok section&quot;);
                }
            }
            break;  // assume only one MH_EXECUTE image
        }
#endif

    }

    if (hCount &gt; 0) {
        // â¡ï¸ è¯»å–é•œåƒï¼ˆä¼ å…¥ header_info åˆ—è¡¨ï¼Œæ•°é‡ï¼Œç±»çš„æ€»æ•°ï¼Œæœªä¼˜åŒ–çš„ç±»çš„æ€»æ•°ï¼‰
        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);
    }

    // ç¬¬ä¸€æ¬¡æ‰§è¡Œå®Œæ¯•åï¼Œç½®ä¸º NO
    firstTime = NO;
}

// objc-os.mm
static header_info * addHeader(const headerType *mhdr, const char *path, int &amp;totalClasses, int &amp;unoptimizedTotalClasses)
{
    header_info *hi;

    if (bad_magic(mhdr)) return NULL;

    bool inSharedCache = false;

    // Look for hinfo from the dyld shared cache.
    // åœ¨ dyld å…±äº«ç¼“å­˜ä¸­å¯»æ‰¾ hinfoï¼ˆå…³äº dyld å…±äº«ç¼“å­˜å¯å‚è€ƒæ–‡æœ«ã€Œè°ˆè°ˆ iOS ä¸­çš„ dyld_shared_cacheã€ä¸€æ–‡ï¼‰ã€‚
    // ä¸ºå¤´éƒ¨é¢„ä¼˜åŒ– hinfo
    hi = preoptimizedHinfoForHeader(mhdr);
    if (hi) {
        // Found an hinfo in the dyld shared cache.
        // åœ¨ dyld å…±äº«ç¼“å­˜ä¸­æ‰¾åˆ° hinfo

        // Weed out duplicates.
        // å»é™¤é‡å¤ï¼ˆè‹¥è¯¥ hi å·²è¢«åŠ è½½ï¼Œåˆ™è¿”å›ç©ºï¼‰ã€‚
        if (hi-&gt;isLoaded()) {
            return NULL;
        }

        inSharedCache = true;

        // Initialize fields not set by the shared cache
        // åˆå§‹åŒ–æœªç”±å…±äº«ç¼“å­˜è®¾ç½®çš„åŸŸ
        // hi-&gt;next is set by appendHeader
        // hi-&gt;next ç”± appendHeader è®¾ç½®
        // è®¾ç½®å·²åŠ è½½ä¸º true
        hi-&gt;setLoaded(true);

        // Xcode ä¸­ OBJC_PRINT_PREOPTIMIZATION ç¯å¢ƒå˜é‡å€¼ä¸º YES æ—¶ï¼Œå°†å¯åœ¨æ§åˆ¶å°æ‰“å°è¯¥ä¿¡æ¯
        // OPTION(PrintPreopt, OBJC_PRINT_PREOPTIMIZATION, &quot;log preoptimization courtesy of dyld shared cache&quot;)
        if (PrintPreopt) {
            _objc_inform(&quot;PREOPTIMIZATION: honoring preoptimized header info at %p for %s&quot;, hi, hi-&gt;fname());
        }

#if !__OBJC2__
        _objc_fatal(&quot;shouldn't be here&quot;);
#endif
#if DEBUG
        // Verify image_info
        // DEBUG æ¨¡å¼æ ¡éªŒ image_info
        size_t info_size = 0;
        const objc_image_info *image_info = _getObjcImageInfo(mhdr,&amp;info_size);
        assert(image_info == hi-&gt;info());
#endif
    }
    else
    {
        // Didn't find an hinfo in the dyld shared cache.
        // åœ¨ dyld å…±äº«ç¼“å­˜ä¸­æœªæ‰¾åˆ° hinfoã€‚

        // Weed out duplicates
        // å»é™¤é‡å¤
        for (hi = FirstHeader; hi; hi = hi-&gt;getNext()) {
            if (mhdr == hi-&gt;mhdr()) return NULL;
        }

        // Locate the __OBJC segment
        // å®šä½ __OBJC æ®µï¼ˆSegmentï¼‰
        size_t info_size = 0;
        unsigned long seg_size;
        // _getObjcImageInfoï¼šå†…éƒ¨å®é™…æ˜¯è·å– __objc_imageinfo æ•°æ®ï¼ˆ__DATA æˆ– __DATA_CONST æˆ– __DATA_DIRTYï¼‰èŠ‚ï¼ˆSectionï¼‰ä¿¡æ¯
        const objc_image_info *image_info = _getObjcImageInfo(mhdr,&amp;info_size);
        // getsegmentdataï¼šè·å– __OBJC æ®µæ•°æ®
        // #define	SEG_OBJC	&quot;__OBJC&quot;	/* objective-C runtime segment */
        const uint8_t *objc_segment = getsegmentdata(mhdr,SEG_OBJC,&amp;seg_size);
        // è‹¥éƒ½æ²¡æœ‰è·å–åˆ°ï¼Œè¿”å›ç©º
        if (!objc_segment  &amp;&amp;  !image_info) return NULL;

        // Allocate a header_info entry.
        // åˆ†é…ä¸€ä¸ª header_infoã€‚
        // Note we also allocate space for a single header_info_rw in the
        // rw_data[] inside header_info.
        // æ³¨æ„æˆ‘ä»¬åœ¨ header_info å†…éƒ¨çš„ rw_data[] ä¹Ÿä¸ºå•ä¸ª header_info_rw åˆ†é…äº†ç©ºé—´ã€‚
        hi = (header_info *)calloc(sizeof(header_info) + sizeof(header_info_rw), 1);

        // Set up the new header_info entry.
        // è®¾ç½®æ–°çš„ header_infoã€‚
        hi-&gt;setmhdr(mhdr);
#if !__OBJC2__
        // mhdr must already be set
        hi-&gt;mod_count = 0;
        hi-&gt;mod_ptr = _getObjcModules(hi, &amp;hi-&gt;mod_count);
#endif
        // Install a placeholder image_info if absent to simplify code elsewhere
        // å¦‚æœæ²¡æœ‰åœ¨å…¶ä»–åœ°æ–¹ç®€åŒ–ä»£ç åˆ™å®‰è£…å ä½ç¬¦ image_info
        static const objc_image_info emptyInfo = {0, 0};
        hi-&gt;setinfo(image_info ?: &amp;emptyInfo);

        // è®¾ç½®å·²åŠ è½½ä¸º true
        hi-&gt;setLoaded(true);
        hi-&gt;setAllClassesRealized(NO);
    }

#if __OBJC2__
    {
        size_t count = 0;
        // åœ¨ __objc_classlist èŠ‚è·å–ç±»åˆ—è¡¨
        // GETSECT(_getObjc2ClassList,           classref_t,      &quot;__objc_classlist&quot;);
        if (_getObjc2ClassList(hi, &amp;count)) {
            // totalClasses è®¾ç½®ä¸ºè·å–åˆ°çš„ç±»æ•°é‡
            totalClasses += (int)count;
            // è‹¥è·å–çš„ header_info ä¸åœ¨å…±äº«ç¼“å­˜ä¸­ï¼Œåˆ™è§†ä¸ºæœªä¼˜åŒ–ç±»ï¼Œæ›´æ–° unoptimizedTotalClasses
            if (!inSharedCache) unoptimizedTotalClasses += count;
        }
    }
#endif

    appendHeader(hi);

    return hi;
}

// objc-runtime-new.mm
/***********************************************************************
* _read_images
* Perform initial processing of the headers in the linked
* list beginning with headerList.
* ä» headerList å¼€å§‹ä¸ºé“¾è¡¨ä¸­çš„å¤´éƒ¨æ‰§è¡Œåˆå§‹å¤„ç†ã€‚
*
* Called by: map_images_nolock
* ç”± map_images_nolock è°ƒç”¨
*
* Locking: runtimeLock acquired by map_images
* é”ï¼šç”± map_images è·å¾—çš„ runtimeLock
**********************************************************************/
void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)
{
    header_info *hi;
    uint32_t hIndex;
    size_t count;
    size_t i;
    Class *resolvedFutureClasses = nil;
    size_t resolvedFutureClassCount = 0;
    static bool doneOnce;
    TimeLogger ts(PrintImageTimes);

    runtimeLock.assertLocked();

#define EACH_HEADER \
    hIndex = 0;         \
    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \
    hIndex++

    if (!doneOnce) {
        doneOnce = YES;

#if SUPPORT_NONPOINTER_ISA
        // Disable non-pointer isa under some conditions.

# if SUPPORT_INDEXED_ISA
        // Disable nonpointer isa if any image contains old Swift code
        for (EACH_HEADER) {
            if (hi-&gt;info()-&gt;containsSwift()  &amp;&amp;
                hi-&gt;info()-&gt;swiftVersion() &lt; objc_image_info::SwiftVersion3)
            {
                DisableNonpointerIsa = true;
                if (PrintRawIsa) {
                    _objc_inform(&quot;RAW ISA: disabling non-pointer isa because &quot;
                                 &quot;the app or a framework contains Swift code &quot;
                                 &quot;older than Swift 3.0&quot;);
                }
                break;
            }
        }
# endif

# if TARGET_OS_OSX
        // Disable non-pointer isa if the app is too old
        // (linked before OS X 10.11)
        if (dyld_get_program_sdk_version() &lt; DYLD_MACOSX_VERSION_10_11) {
            DisableNonpointerIsa = true;
            if (PrintRawIsa) {
                _objc_inform(&quot;RAW ISA: disabling non-pointer isa because &quot;
                             &quot;the app is too old (SDK version &quot; SDK_FORMAT &quot;)&quot;,
                             FORMAT_SDK(dyld_get_program_sdk_version()));
            }
        }

        // Disable non-pointer isa if the app has a __DATA,__objc_rawisa section
        // New apps that load old extensions may need this.
        for (EACH_HEADER) {
            if (hi-&gt;mhdr()-&gt;filetype != MH_EXECUTE) continue;
            unsigned long size;
            if (getsectiondata(hi-&gt;mhdr(), &quot;__DATA&quot;, &quot;__objc_rawisa&quot;, &amp;size)) {
                DisableNonpointerIsa = true;
                if (PrintRawIsa) {
                    _objc_inform(&quot;RAW ISA: disabling non-pointer isa because &quot;
                                 &quot;the app has a __DATA,__objc_rawisa section&quot;);
                }
            }
            break;  // assume only one MH_EXECUTE image
        }
# endif

#endif

        if (DisableTaggedPointers) {
            disableTaggedPointers();
        }

        initializeTaggedPointerObfuscator();

        if (PrintConnecting) {
            _objc_inform(&quot;CLASS: found %d classes during launch&quot;, totalClasses);
        }

        // namedClasses
        // Preoptimized classes don't go in this table.
        // 4/3 is NXMapTable's load factor
        int namedClassesSize =
            (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * 4 / 3;
        gdb_objc_realized_classes =
            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);

        allocatedClasses = NXCreateHashTable(NXPtrPrototype, 0, nil);

        ts.log(&quot;IMAGE TIMES: first time tasks&quot;);
    }


    // Discover classes. Fix up unresolved future classes. Mark bundle classes.

    for (EACH_HEADER) {
        classref_t *classlist = _getObjc2ClassList(hi, &amp;count);

        if (! mustReadClasses(hi)) {
            // Image is sufficiently optimized that we need not call readClass()
            continue;
        }

        bool headerIsBundle = hi-&gt;isBundle();
        bool headerIsPreoptimized = hi-&gt;isPreoptimized();

        for (i = 0; i &lt; count; i++) {
            Class cls = (Class)classlist[i];
            Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);

            if (newCls != cls  &amp;&amp;  newCls) {
                // Class was moved but not deleted. Currently this occurs
                // only when the new class resolved a future class.
                // Non-lazily realize the class below.
                resolvedFutureClasses = (Class *)
                    realloc(resolvedFutureClasses,
                            (resolvedFutureClassCount+1) * sizeof(Class));
                resolvedFutureClasses[resolvedFutureClassCount++] = newCls;
            }
        }
    }

    ts.log(&quot;IMAGE TIMES: discover classes&quot;);

    // Fix up remapped classes
    // Class list and nonlazy class list remain unremapped.
    // Class refs and super refs are remapped for message dispatching.

    if (!noClassesRemapped()) {
        for (EACH_HEADER) {
            Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);
            for (i = 0; i &lt; count; i++) {
                remapClassRef(&amp;classrefs[i]);
            }
            // fixme why doesn't test future1 catch the absence of this?
            classrefs = _getObjc2SuperRefs(hi, &amp;count);
            for (i = 0; i &lt; count; i++) {
                remapClassRef(&amp;classrefs[i]);
            }
        }
    }

    ts.log(&quot;IMAGE TIMES: remap classes&quot;);

    // Fix up @selector references
    static size_t UnfixedSelectors;
    {
        mutex_locker_t lock(selLock);
        for (EACH_HEADER) {
            if (hi-&gt;isPreoptimized()) continue;

            bool isBundle = hi-&gt;isBundle();
            SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);
            UnfixedSelectors += count;
            for (i = 0; i &lt; count; i++) {
                const char *name = sel_cname(sels[i]);
                sels[i] = sel_registerNameNoLock(name, isBundle);
            }
        }
    }

    ts.log(&quot;IMAGE TIMES: fix up selector references&quot;);

#if SUPPORT_FIXUP
    // Fix up old objc_msgSend_fixup call sites
    for (EACH_HEADER) {
        message_ref_t *refs = _getObjc2MessageRefs(hi, &amp;count);
        if (count == 0) continue;

        if (PrintVtables) {
            _objc_inform(&quot;VTABLES: repairing %zu unsupported vtable dispatch &quot;
                         &quot;call sites in %s&quot;, count, hi-&gt;fname());
        }
        for (i = 0; i &lt; count; i++) {
            fixupMessageRef(refs+i);
        }
    }

    ts.log(&quot;IMAGE TIMES: fix up objc_msgSend_fixup&quot;);
#endif

    // Discover protocols. Fix up protocol refs.
    for (EACH_HEADER) {
        extern objc_class OBJC_CLASS_$_Protocol;
        Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;
        assert(cls);
        NXMapTable *protocol_map = protocols();
        bool isPreoptimized = hi-&gt;isPreoptimized();
        bool isBundle = hi-&gt;isBundle();

        protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;count);
        for (i = 0; i &lt; count; i++) {
            readProtocol(protolist[i], cls, protocol_map,
                         isPreoptimized, isBundle);
        }
    }

    ts.log(&quot;IMAGE TIMES: discover protocols&quot;);

    // Fix up @protocol references
    // Preoptimized images may have the right
    // answer already but we don't know for sure.
    for (EACH_HEADER) {
        protocol_t **protolist = _getObjc2ProtocolRefs(hi, &amp;count);
        for (i = 0; i &lt; count; i++) {
            remapProtocolRef(&amp;protolist[i]);
        }
    }

    ts.log(&quot;IMAGE TIMES: fix up @protocol references&quot;);

    // Realize non-lazy classes (for +load methods and static instances)
    for (EACH_HEADER) {
        classref_t *classlist =
            _getObjc2NonlazyClassList(hi, &amp;count);
        for (i = 0; i &lt; count; i++) {
            Class cls = remapClass(classlist[i]);
            if (!cls) continue;

            // hack for class __ARCLite__, which didn't get this above
#if TARGET_OS_SIMULATOR
            if (cls-&gt;cache._buckets == (void*)&amp;_objc_empty_cache  &amp;&amp;
                (cls-&gt;cache._mask  ||  cls-&gt;cache._occupied))
            {
                cls-&gt;cache._mask = 0;
                cls-&gt;cache._occupied = 0;
            }
            if (cls-&gt;ISA()-&gt;cache._buckets == (void*)&amp;_objc_empty_cache  &amp;&amp;
                (cls-&gt;ISA()-&gt;cache._mask  ||  cls-&gt;ISA()-&gt;cache._occupied))
            {
                cls-&gt;ISA()-&gt;cache._mask = 0;
                cls-&gt;ISA()-&gt;cache._occupied = 0;
            }
#endif

            addClassTableEntry(cls);
            realizeClass(cls);
        }
    }

    ts.log(&quot;IMAGE TIMES: realize non-lazy classes&quot;);

    // Realize newly-resolved future classes, in case CF manipulates them
    if (resolvedFutureClasses) {
        for (i = 0; i &lt; resolvedFutureClassCount; i++) {
            realizeClass(resolvedFutureClasses[i]);
            resolvedFutureClasses[i]-&gt;setInstancesRequireRawIsa(false/*inherited*/);
        }
        free(resolvedFutureClasses);
    }

    ts.log(&quot;IMAGE TIMES: realize future classes&quot;);

    // â¡ï¸ Category
    // Discover categories.
    // å‘ç° Categoryã€‚
    // éå† hList ä¸­çš„ header_info
    for (EACH_HEADER) {
        // åœ¨ __objc_catlist èŠ‚è·å– Category åˆ—è¡¨
        // GETSECT(_getObjc2CategoryList,        category_t *,    &quot;__objc_catlist&quot;);
        category_t **catlist =
            _getObjc2CategoryList(hi, &amp;count);
        bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();

        // éå† Category
        for (i = 0; i &lt; count; i++) {
            // è·å–ç¬¬ i ä¸ª Categoryï¼Œç±»å‹ä¸º category_t
            category_t *cat = catlist[i];
            // æ ¹æ® Category çš„ cls é‡æ–°æ˜ å°„ç±»
            Class cls = remapClass(cat-&gt;cls);

            // ç±»ä¸ºç©ºæ—¶
            if (!cls) {
                // Category's target class is missing (probably weak-linked).
                // Category çš„ç›®æ ‡ç±»ä¸¢å¤±ï¼ˆå¯èƒ½ä¸ºå¼±é“¾æ¥ï¼‰ã€‚
                // Disavow any knowledge of this category.
                // å¦è®¤å¯¹æ­¤ Category çš„ä»»ä½•äº†è§£ã€‚
                // å°† Category ç½®ä¸º nil
                catlist[i] = nil;
                if (PrintConnecting) {
                    _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;
                                 &quot;missing weak-linked target class&quot;,
                                 cat-&gt;name, cat);
                }
                continue;
            }

            // ç±»éç©ºæ—¶

            // Process this category.
            // First, register the category with its target class.
            // Then, rebuild the class's method lists (etc) if
            // the class is realized.
            // å¤„ç†è¯¥ Categoryã€‚
            // é¦–å…ˆï¼Œä½¿ç”¨ç›®æ ‡ç±»æ³¨å†Œ Categoryã€‚
            // ç„¶åï¼Œå¦‚æœå®ç°äº†ç±»ï¼Œåˆ™é‡å»ºç±»çš„æ–¹æ³•åˆ—è¡¨ï¼ˆç­‰ï¼‰ã€‚
            bool classExists = NO;
            // åˆ¤æ–­ Category ä¸­å­˜åœ¨å¯¹è±¡æ–¹æ³•ã€åè®®ã€æˆ–å±æ€§
            if (cat-&gt;instanceMethods ||  cat-&gt;protocols
                ||  cat-&gt;instanceProperties)
            {
                // è®°å½•æœªé™„åŠ ä¸Šçš„ Category
                addUnattachedCategoryForClass(cat, cls, hi);
                if (cls-&gt;isRealized()) {
                    // â¡ï¸ å¦‚æœå®ç°äº†ç±»ï¼Œé‡å»ºç±»
                    remethodizeClass(cls);
                    classExists = YES;
                }
                if (PrintConnecting) {
                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,
                                 cls-&gt;nameForLogging(), cat-&gt;name,
                                 classExists ? &quot;on existing class&quot; : &quot;&quot;);
                }
            }

            // åˆ¤æ–­ Category ä¸­å­˜åœ¨ç±»æ–¹æ³•ã€åè®®ã€æˆ–ç±»å±æ€§
            if (cat-&gt;classMethods  ||  cat-&gt;protocols
                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))
            {
                // è®°å½•æœªé™„åŠ ä¸Šçš„ Category
                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);
                if (cls-&gt;ISA()-&gt;isRealized()) {
                    // â¡ï¸  å¦‚æœå®ç°äº†å…ƒç±»ï¼Œé‡å»ºå…ƒç±»
                    remethodizeClass(cls-&gt;ISA());
                }
                if (PrintConnecting) {
                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;,
                                 cls-&gt;nameForLogging(), cat-&gt;name);
                }
            }
        }
    }

    ts.log(&quot;IMAGE TIMES: discover categories&quot;);

    // Category discovery MUST BE LAST to avoid potential races
    // when other threads call the new category code before
    // this thread finishes its fixups.

    // +load handled by prepare_load_methods()

    if (DebugNonFragileIvars) {
        realizeAllClasses();
    }


    // Print preoptimization statistics
    if (PrintPreopt) {
        static unsigned int PreoptTotalMethodLists;
        static unsigned int PreoptOptimizedMethodLists;
        static unsigned int PreoptTotalClasses;
        static unsigned int PreoptOptimizedClasses;

        for (EACH_HEADER) {
            if (hi-&gt;isPreoptimized()) {
                _objc_inform(&quot;PREOPTIMIZATION: honoring preoptimized selectors &quot;
                             &quot;in %s&quot;, hi-&gt;fname());
            }
            else if (hi-&gt;info()-&gt;optimizedByDyld()) {
                _objc_inform(&quot;PREOPTIMIZATION: IGNORING preoptimized selectors &quot;
                             &quot;in %s&quot;, hi-&gt;fname());
            }

            classref_t *classlist = _getObjc2ClassList(hi, &amp;count);
            for (i = 0; i &lt; count; i++) {
                Class cls = remapClass(classlist[i]);
                if (!cls) continue;

                PreoptTotalClasses++;
                if (hi-&gt;isPreoptimized()) {
                    PreoptOptimizedClasses++;
                }

                const method_list_t *mlist;
                if ((mlist = ((class_ro_t *)cls-&gt;data())-&gt;baseMethods())) {
                    PreoptTotalMethodLists++;
                    if (mlist-&gt;isFixedUp()) {
                        PreoptOptimizedMethodLists++;
                    }
                }
                if ((mlist=((class_ro_t *)cls-&gt;ISA()-&gt;data())-&gt;baseMethods())) {
                    PreoptTotalMethodLists++;
                    if (mlist-&gt;isFixedUp()) {
                        PreoptOptimizedMethodLists++;
                    }
                }
            }
        }

        _objc_inform(&quot;PREOPTIMIZATION: %zu selector references not &quot;
                     &quot;pre-optimized&quot;, UnfixedSelectors);
        _objc_inform(&quot;PREOPTIMIZATION: %u/%u (%.3g%%) method lists pre-sorted&quot;,
                     PreoptOptimizedMethodLists, PreoptTotalMethodLists,
                     PreoptTotalMethodLists
                     ? 100.0*PreoptOptimizedMethodLists/PreoptTotalMethodLists
                     : 0.0);
        _objc_inform(&quot;PREOPTIMIZATION: %u/%u (%.3g%%) classes pre-registered&quot;,
                     PreoptOptimizedClasses, PreoptTotalClasses,
                     PreoptTotalClasses
                     ? 100.0*PreoptOptimizedClasses/PreoptTotalClasses
                     : 0.0);
        _objc_inform(&quot;PREOPTIMIZATION: %zu protocol references not &quot;
                     &quot;pre-optimized&quot;, UnfixedProtocolReferences);
    }

#undef EACH_HEADER
}

// objc-runtime-new.mm
/***********************************************************************
* remethodizeClass
* Attach outstanding categories to an existing class.
* å°†æœªå®Œæˆçš„ Category é™„åŠ åˆ°ç°æœ‰ç±»ã€‚
* Fixes up cls's method list, protocol list, and property list.
* ä¿®å¤ cls çš„æ–¹æ³•åˆ—è¡¨ã€åè®®åˆ—è¡¨ã€ä»¥åŠå±æ€§åˆ—è¡¨ã€‚
* Updates method caches for cls and its subclasses.
* æ›´æ–° cls ä»¥åŠå…¶å­ç±»çš„æ–¹æ³•ç¼“å­˜ã€‚
* Locking: runtimeLock must be held by the caller
* é”ï¼šè°ƒç”¨è€…å¿…é¡»æŒæœ‰ runtimeLock
**********************************************************************/
static void remethodizeClass(Class cls)
{
    // Category åˆ—è¡¨
    category_list *cats;
    bool isMeta;

    runtimeLock.assertLocked();

    // æ˜¯å¦ä¸ºå…ƒç±»
    isMeta = cls-&gt;isMetaClass();

    // Re-methodizing: check for more categories
    // é‡æ–°æ–¹æ³•åŒ–ï¼šæ£€æŸ¥æ›´å¤šçš„ Category
    if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) {
        if (PrintConnecting) {
            _objc_inform(&quot;CLASS: attaching categories to class '%s' %s&quot;,
                         cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);
        }

        // â¡ï¸ é™„åŠ  Categoryï¼ˆç±»/å…ƒç±»ï¼ŒCategoryï¼Œæ˜¯å¦åˆ·æ–°ç¼“å­˜ï¼‰
        attachCategories(cls, cats, true /*flush caches*/);
        free(cats);
    }
}

// objc-runtime-new.mm
// Attach method lists and properties and protocols from categories to a class.
// å°†æ‰€æœ‰ Category çš„æ–¹æ³•åˆ—è¡¨ã€å±æ€§åˆ—è¡¨ã€åè®®åˆ—è¡¨é™„åŠ åˆ°ç±»ä¸Šã€‚
// Assumes the categories in cats are all loaded and sorted by load order,
// oldest categories first.
// å‡è®¾ cats ä¸­çš„ Category éƒ½å·²åŠ è½½å¹¶ç”±åŠ è½½é¡ºåºæ’åºï¼Œåˆ™æœ€åï¼ˆç¼–è¯‘ï¼‰çš„ Category æ’åœ¨æœ€å…ˆã€‚
static void
attachCategories(Class cls, category_list *cats, bool flush_caches)
{
    if (!cats) return;
    // â¡ï¸ Xcode ä¸­ OBJC_PRINT_REPLACED_METHODS ç¯å¢ƒå˜é‡å€¼ä¸º YES æ—¶ï¼Œå°†å¯åœ¨æ§åˆ¶å°æ‰“å°è¯¥ä¿¡æ¯
    // OPTION(PrintReplacedMethods, OBJC_PRINT_REPLACED_METHODS, &quot;log methods replaced by category implementations&quot;)
    if (PrintReplacedMethods) printReplacements(cls, cats);

    // æ˜¯å¦æ˜¯å…ƒç±»
    bool isMeta = cls-&gt;isMetaClass();

    // fixme rearrange to remove these intermediate allocations
    // æ–¹æ³•åˆ—è¡¨ï¼ˆæŒ‡å‘æŒ‡é’ˆçš„æŒ‡é’ˆï¼Œå­˜å‚¨äº†ä¸¤ç»´ï¼šeg. [[cat_1-&gt;method_a, cat_1-&gt;method_b], [cat_2-&gt;method_c, cat_2-&gt;method_d]]ï¼‰
    method_list_t **mlists = (method_list_t **)
        malloc(cats-&gt;count * sizeof(*mlists));
    // å±æ€§åˆ—è¡¨
    property_list_t **proplists = (property_list_t **)
        malloc(cats-&gt;count * sizeof(*proplists));
    // åè®®åˆ—è¡¨
    protocol_list_t **protolists = (protocol_list_t **)
        malloc(cats-&gt;count * sizeof(*protolists));

    // Count backwards through cats to get newest categories first
    int mcount = 0;
    int propcount = 0;
    int protocount = 0;
    // i = Category çš„ä¸ªæ•°
    int i = cats-&gt;count;
    bool fromBundle = NO;
    // â¡ï¸ å°†æ‰€æœ‰ Category ä¸­çš„æ–¹æ³•ã€å±æ€§ã€åè®®æå–å‡º
    // å€’æ•° i
    while (i--) {
        // entry = ä¸€ä¸ª Category
        auto&amp; entry = cats-&gt;list[i];

        // mlist = Category ä¸­çš„æ–¹æ³•åˆ—è¡¨
        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);
        if (mlist) {
            mlists[mcount++] = mlist;
            fromBundle |= entry.hi-&gt;isBundle();
        }

        // proplist = Category ä¸­çš„å±æ€§åˆ—è¡¨
        property_list_t *proplist =
            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);
        if (proplist) {
            proplists[propcount++] = proplist;
        }

        // protolist = Category ä¸­çš„åè®®åˆ—è¡¨
        protocol_list_t *protolist = entry.cat-&gt;protocols;
        if (protolist) {
            protolists[protocount++] = protolist;
        }
    }

    // rw = ç±»/å…ƒç±»å¯¹è±¡çš„ class_rw_t *data()
    auto rw = cls-&gt;data();

    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);
    // â¡ï¸ Category æ–¹æ³•åˆ—è¡¨ -&gt; ç±»/å…ƒç±»æ–¹æ³•åˆ—è¡¨ï¼Œæ–¹æ³•åˆ—è¡¨æ•°é‡ï¼ˆä¸Šè¿°äºŒç»´ä¸­ç¬¬ä¸€ç»´çš„å¤§å°ï¼‰
    rw-&gt;methods.attachLists(mlists, mcount);
    free(mlists);
    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);

    // â¡ï¸ Category å±æ€§åˆ—è¡¨ -&gt; ç±»/å…ƒç±»å±æ€§åˆ—è¡¨ï¼Œå±æ€§åˆ—è¡¨æ•°é‡ï¼ˆä¸Šè¿°äºŒç»´ä¸­ç¬¬ä¸€ç»´çš„å¤§å°ï¼‰
    rw-&gt;properties.attachLists(proplists, propcount);
    free(proplists);

    // â¡ï¸ Category åè®®åˆ—è¡¨ -&gt; ç±»/å…ƒç±»åè®®åˆ—è¡¨ï¼Œåè®®åˆ—è¡¨æ•°é‡ï¼ˆä¸Šè¿°äºŒç»´ä¸­ç¬¬ä¸€ç»´çš„å¤§å°ï¼‰
    rw-&gt;protocols.attachLists(protolists, protocount);
    free(protolists);
}

// objc-runtime-new.h
class list_array_tt {
 public:
    void attachLists(List* const * addedLists, uint32_t addedCount) {
        if (addedCount == 0) return;

        if (hasArray()) {
            // many lists -&gt; many lists
            // oldCount = åŸæœ‰çš„å¤§å°
            uint32_t oldCount = array()-&gt;count;
            // newCount = åŸæœ‰ + æ–°å¢
            uint32_t newCount = oldCount + addedCount;
            // realloc é‡æ–°åˆ†é…å†…å­˜ç©ºé—´ï¼ˆæ‰©å®¹ï¼‰
            setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));
            // è®¾ç½®ä¸ºæ–°å¤§å°
            array()-&gt;count = newCount;
            // array()-&gt;lists ä¸ºåŸæœ‰åˆ—è¡¨çš„æŒ‡é’ˆ
            // å°†æŒ‡é’ˆæŒ‡å‘çš„å†…å­˜å†…å®¹å‘ååç§» addedCount
            // void    *memmove(void *__dst, const void *__src, size_t __len);
            memmove(array()-&gt;lists + addedCount, array()-&gt;lists,
                    oldCount * sizeof(array()-&gt;lists[0]));
            // addedLists ä¸ºæ‰€æœ‰ Category ä¸­ç›¸åº”åˆ—è¡¨ï¼ˆå¦‚æ–¹æ³•åˆ—è¡¨ç­‰ï¼‰çš„æŒ‡é’ˆ
            // å°†æŒ‡é’ˆæŒ‡å‘çš„å†…å­˜å†…å®¹æ‹·è´åˆ°åŸæœ‰åˆ—è¡¨çš„æŒ‡é’ˆåœ°å€å¤„
            // void    *memcpy(void *__dst, const void *__src, size_t __n);
            memcpy(array()-&gt;lists, addedLists,
                   addedCount * sizeof(array()-&gt;lists[0]));
        }
        else if (!list  &amp;&amp;  addedCount == 1) {
            // 0 lists -&gt; 1 list
            list = addedLists[0];
        }
        else {
            // 1 list -&gt; many lists
            List* oldList = list;
            uint32_t oldCount = oldList ? 1 : 0;
            uint32_t newCount = oldCount + addedCount;
            setArray((array_t *)malloc(array_t::byteSize(newCount)));
            array()-&gt;count = newCount;
            if (oldList) array()-&gt;lists[addedCount] = oldList;
            memcpy(array()-&gt;lists, addedLists,
                   addedCount * sizeof(array()-&gt;lists[0]));
        }
    }
};
</code></pre>

<p>ä» <code>realloc</code> åˆ° <code>memmove</code> å’Œ <code>memcpy</code> éƒ¨åˆ†å¯ä»¥å‚è€ƒä¸‹å›¾ï¼š</p>

<p><img src="/img/2019/category_in_ios/3.png" alt="3" /></p>

<p>å› æ­¤ï¼Œå¯¹äº Category åœ¨è¿è¡Œæ—¶å°†å…¶ä¸­çš„æ–¹æ³•ã€å±æ€§ã€åè®®åŠ è½½åˆ°ä¸»ç±»çš„è¿‡ç¨‹ææ˜ç™½åï¼Œä¹‹å‰çš„ç»“è®ºå°±æ°´è½çŸ³å‡ºã€‚è¶Šé åç¼–è¯‘çš„ Categoryï¼Œå…¶æ–¹æ³•åˆ—è¡¨æœ€ç»ˆå°±è¶Šé å‰ã€‚å› æ­¤åœ¨è°ƒç”¨æ—¶ï¼Œè™½ç„¶ä¸»ç±»å’Œå…¶ä»– Category ä¸­çš„æ–¹æ³•å¹¶æ²¡æœ‰è¢«è¦†ç›–ï¼Œä½†ä¼šå› ä¸ºåœ¨å‰é¢å·²ç»è¢«æ‰¾åˆ°å¹¶è°ƒç”¨è€Œæ— æ³•è°ƒç”¨åˆ°ã€‚ä¹Ÿæ˜¯å› ä¸ºæ–¹æ³•å¹¶æ²¡æœ‰è¢«è¦†ç›–ï¼Œå¦‚æœæˆ‘ä»¬åœ¨ Category ä¸­ä»…å£°æ˜å´ä¸å®ç°ï¼Œè¿è¡Œæ—¶ä»å°†æ‰¾åˆ°ä¸»ç±»ä¸­çš„å®ç°ã€‚ä»ä¸Šé¢æºç åˆ†æä¸­æˆ‘ä»¬ä¹Ÿå¯ä»¥å‘ç°ï¼Œåœ¨ Xcode è®¾ç½® <code>OBJC_PRINT_REPLACED_METHODS</code> ç¯å¢ƒå˜é‡ä¸º <code>YES</code> åï¼Œå°±å¯ä»¥åœ¨è¿è¡Œæ—¶è¾“å‡ºæ‰€æœ‰è¢«æ›¿æ¢çš„æ–¹æ³•ï¼ˆè‹¥æ·»åŠ åä»æœªè¾“å‡ºæˆ‘ä»¬è‡ªå®šä¹‰ç±»çš„æ›¿æ¢ä¿¡æ¯ï¼Œå¯ä»¥åœ¨å°è¯•ä¸»ç±»å’Œæ‰€æœ‰ Category ä¸­æ·»åŠ  <code>+ (void)load</code> æ–¹æ³•å®ç°åé‡è¯•ï¼‰ï¼š</p>

<pre><code>objc[17895]: REPLACED: -[Person smile]  by category Life  (IMP was 0x100001b90 (/Users/kingcos/Library/Developer/Xcode/DerivedData/Category_in_Obj-C-cgesibqaizbvgnckrzeofmpfkmmy/Build/Products/Debug/Category_in_Obj-C), now 0x100001b00 (/Users/kingcos/Library/Developer/Xcode/DerivedData/Category_in_Obj-C-cgesibqaizbvgnckrzeofmpfkmmy/Build/Products/Debug/Category_in_Obj-C))
objc[17895]: REPLACED: -[Person smile]  by category Work  (IMP was 0x100001b00 (/Users/kingcos/Library/Developer/Xcode/DerivedData/Category_in_Obj-C-cgesibqaizbvgnckrzeofmpfkmmy/Build/Products/Debug/Category_in_Obj-C), now 0x100001b40 (/Users/kingcos/Library/Developer/Xcode/DerivedData/Category_in_Obj-C-cgesibqaizbvgnckrzeofmpfkmmy/Build/Products/Debug/Category_in_Obj-C))
</code></pre>

<p>ç¬¬ä¸€æ¡çš„æ›¿æ¢ï¼Œæ˜¯æŒ‡ Person+Life æ›¿æ¢äº† Person ä¸­çš„ <code>smile</code> æ–¹æ³•ï¼Œè€Œç¬¬äºŒæ¡æŒ‡ Person+Work å†æ¬¡æ›¿æ¢äº† Person+Life ä¸­çš„ <code>smile</code> æ–¹æ³•ï¼Œå› æ­¤æœ€ç»ˆä¹Ÿç”± Person+Work ä¸­çš„æ–¹æ³•è¢«è°ƒç”¨ï¼Œæœ€ç»ˆä¹Ÿä¸æˆ‘ä»¬çš„ç»“è®ºä¸€è‡´ã€‚</p>

<h3 id="memmove-memcpy"><code>memmove</code> &amp; <code>memcpy</code></h3>

<p>ä¸Šä¸€èŠ‚ä¸­ï¼ŒCategory ä¸­å†…å®¹åˆ—è¡¨ä¸ä¸»ç±»èåˆæ—¶ï¼Œè°ƒç”¨äº† <code>memmove</code> å’Œ <code>memcpy</code> å‡½æ•°ï¼Œå®ƒä»¬å…¶å®æ˜¯ C è¯­è¨€æ ‡å‡†åº“ä¸­çš„å‡½æ•°ï¼Œç›®çš„éƒ½æ˜¯å°†ä¸€å®šé•¿åº¦çš„æºå†…å­˜åœ°å€çš„å†…å®¹æ‹·è´åˆ°ç›®æ ‡å†…å­˜åœ°å€ä¸­ã€‚åœ¨ Apple å¼€æºçš„ XNU - libsyscall ä¸­ï¼Œ<code>memmove</code> å’Œ <code>memcpy</code> æœ¬è´¨å…¶å®æ˜¯ä¸€è‡´çš„ï¼š</p>

<pre><code class="language-c">// _libc_funcptr.c
__attribute__((visibility(&quot;hidden&quot;)))
void *
memmove(void *dst, const void *src, size_t n)
{
	return _libkernel_string_functions-&gt;memmove(dst, src, n);
}

__attribute__((visibility(&quot;hidden&quot;)))
void *
memcpy(void *dst, const void *src, size_t n)
{
	return _libkernel_string_functions-&gt;memmove(dst, src, n);
}

// _libc_funcptr.c
/*
 * Upcalls to optimized libplatform string functions
 */

static const struct _libkernel_string_functions
		_libkernel_generic_string_functions = {
	.bzero = _libkernel_bzero,
	.memmove = _libkernel_memmove,
	.memset = _libkernel_memset,
	.strchr = _libkernel_strchr,
	.strcmp = _libkernel_strcmp,
	.strcpy = _libkernel_strcpy,
	.strlcpy = _libkernel_strlcpy,
	.strlen = _libkernel_strlen,
};
static _libkernel_string_functions_t _libkernel_string_functions =
		&amp;_libkernel_generic_string_functions;

// memcpy.c
/*
 * sizeof(word) MUST BE A POWER OF TWO
 * SO THAT wmask BELOW IS ALL ONES
 */
typedef    int word;        /* &quot;word&quot; used for optimal copy speed &quot;å­—&quot;ç”¨ä½œä¼˜åŒ–æ‹·è´é€Ÿåº¦ */

#define    wsize    sizeof(word)
#define    wmask    (wsize - 1)

/*
 * Copy a block of memory, handling overlap.
 * æ‹·è´ä¸€å—å†…å­˜ï¼Œå¹¶å¤„ç†é‡å éƒ¨åˆ†ã€‚
 * This is the routine that actually implements
 * (the portable versions of) bcopy, memcpy, and memmove.
 * è¿™æ˜¯ä¸ªå®é™…å®ç°äº†ï¼ˆå¯ç§»æ¤ç‰ˆæœ¬çš„ï¼‰bcopyã€memcpyã€ä»¥åŠ memmove çš„ä¾‹è¡Œç¨‹åºã€‚
 */

// visibility(&quot;hidden&quot;)ï¼šéšè—å‡½æ•°ç¬¦å·
__attribute__((visibility(&quot;hidden&quot;)))
void * _libkernel_memmove(void *dst0, const void *src0, size_t length)
{
    // ä¿å­˜ä¸€ä»½ç›®æ ‡ã€æºï¼Œä½†æºæ˜¯å¸¸é‡ï¼Œè€Œç›®æ ‡æ˜¯å¯å˜çš„
    char *dst = dst0;
    const char *src = src0;
    size_t t;

    // é•¿åº¦ä¸º 0 æˆ–ç›®æ ‡ç­‰äºæºæ—¶ï¼Œæ— éœ€ç§»åŠ¨
    if (length == 0 || dst == src)        /* nothing to do */
        goto done;

    /*
     * Macros: loop-t-times; and loop-t-times, t&gt;0
     * å®šä¹‰å¾ªç¯å®ï¼Œt å¤§äº 0 æ—¶ï¼Œå¾ªç¯ t æ¬¡
     */
#define    TLOOP(s) if (t) TLOOP1(s)
#define    TLOOP1(s) do { s; } while (--t)

    // å¦‚æœæº &gt; ç›®æ ‡ï¼ˆé«˜åœ°å€ -&gt; ä½åœ°å€ï¼Œå°ç«¯å°±æ˜¯å‘å‰ï¼‰
    printf(&quot;(unsigned long)dst: %lu; (unsigned long)src: %lu\n&quot;, (unsigned long)dst, (unsigned long)src);
    if ((unsigned long)dst &lt; (unsigned long)src) {
        /*
         * Copy forward.
         * æ­£å‘æ‹·è´ã€‚
         */
        // typedef unsigned long           uintptr_t;
        t = (uintptr_t)src;    /* only need low bits åªéœ€è¦ä½ä½ */
        printf(&quot;(t | (uintptr_t)dst) &amp; wmask: %lu\n&quot;, (t | (uintptr_t)dst) &amp; wmask);
        if ((t | (uintptr_t)dst) &amp; wmask) {
            /*
             * Try to align operands.  This cannot be done
             * unless the low bits match.
             * å°è¯•å¯¹é½æ“ä½œæ•°ã€‚é™¤éä½ä½åŒ¹é…ï¼Œå¦åˆ™ä¸å¯è¿™æ ·åšã€‚
             */
            if ((t ^ (uintptr_t)dst) &amp; wmask || length &lt; wsize)
                t = length;
            else
                t = wsize - (t &amp; wmask);
            length -= t;
            //
//            TLOOP1(*dst++ = *src++);
            do {
                *dst++ = *src++;
            } while (--t);
        }
        /*
         * Copy whole words, then mop up any trailing bytes.
         * æ‹·è´æ•´ä¸ªå­—ï¼Œç„¶ååˆ é™¤æ‰€æœ‰å°¾å­—èŠ‚ã€‚
         */
        t = length / wsize;
        printf(&quot;t: %zu\n&quot;, t);
//        TLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);
        if (t) {
            do {
                // æ›´æ”¹æŒ‡é’ˆæŒ‡å‘çš„ä¸€ä¸ªå­—é•¿çš„å†…å®¹ï¼ˆsrc -&gt; dstï¼‰
                *(word *)dst = *(word *)src;
                // dst &amp; src å‘å‰ç§»åŠ¨ä¸€ä¸ªå­—é•¿
                src += wsize;
                dst += wsize;
            } while (--t);
        }
        printf(&quot;(unsigned long)dst: %lu; (unsigned long)src: %lu\n&quot;, (unsigned long)dst, (unsigned long)src);

        t = length &amp; wmask;
        printf(&quot;t: %zu\n&quot;, t);
//        TLOOP(*dst++ = *src++);
        if (t) {
            do {
                *dst++ = *src++;
            } while (--t);
        }
    } else {
        /*
         * Copy backwards.  Otherwise essentially the same.
         * Alignment works as before, except that it takes
         * (t&amp;wmask) bytes to align, not wsize-(t&amp;wmask).
         * åå‘æ‹·è´ã€‚å¦åˆ™åŸºæœ¬ä¸€è‡´ã€‚
         * ä¸ä¹‹å‰ä¸€æ ·å¯¹é½ï¼Œé™¤äº†å®ƒæ˜¯ä»¥ (t&amp;wmask) å­—èŠ‚å¯¹é½ï¼Œè€Œé wsize-(t&amp;wmask)ã€‚
         */
        src += length;
        dst += length;
        t = (uintptr_t)src;
        printf(&quot;(t | (uintptr_t)dst) &amp; wmask: %lu\n&quot;, (t | (uintptr_t)dst) &amp; wmask);
        if ((t | (uintptr_t)dst) &amp; wmask) {
            if ((t ^ (uintptr_t)dst) &amp; wmask || length &lt;= wsize)
                t = length;
            else
                t &amp;= wmask;
            length -= t;
//            TLOOP1(*--dst = *--src);
            do {
                *--dst = *--src;
            } while (--t);
        }
        t = length / wsize;
//        TLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);
        if (t) {
            do {
                src -= wsize;
                dst -= wsize;
                *(word *)dst = *(word *)src;
            } while (--t);
        }

        t = length &amp; wmask;
//        TLOOP(*--dst = *--src);
        if (t) {
            do {
                *--dst = *--src;
            } while (--t);
        }
    }
done:
    printf(&quot;(unsigned long)dst: %lu; (unsigned long)src: %lu\n&quot;, (unsigned long)dst, (unsigned long)src);
    return (dst0);
}
</code></pre>

<p>æˆ‘å·²ç»å°†è¯¥å‡½æ•°ç§»æ¤åˆ° Demo ä¸­ï¼Œå¯ä»¥å°è¯•ä½åœ°å€æ‹·è´åˆ°é«˜åœ°å€ï¼Œä¹Ÿå¯ä»¥å°†é«˜åœ°å€æ‹·è´åˆ°ä½åœ°å€ï¼š</p>

<pre><code class="language-objectivec">// b -&gt; a
int a = 10;
int b = 20;
NSLog(@&quot;Before: a: %d, b: %d&quot;, a, b);
_libkernel_memmove(&amp;a, &amp;b, sizeof(int));
// memmove(&amp;a, &amp;b, sizeof(int));
// memcpy(&amp;a, &amp;b, sizeof(int));
NSLog(@&quot;After: a: %d, b: %d&quot;, a, b);

// OUTPUT:
// Before: a: 10, b: 20
// After: a: 20, b: 20

// c -&gt; d
int c = 30;
int d = 40;
NSLog(@&quot;Before: c: %d, d: %d&quot;, c, d);
// _libkernel_memmove2 æ˜¯ä¸ªç®€åŒ–ç‰ˆæœ¬çš„ _libkernel_memmove
_libkernel_memmove2(&amp;d, &amp;c, sizeof(int));
NSLog(@&quot;After: c: %d, d: %d&quot;, c, d);

// OUTPUT:
// Before: c: 30, d: 40
// After: c: 30, d: 30
</code></pre>

<p>ä½†åœ¨æœ‰äº›ç¼–è¯‘å™¨ä¸­ï¼Œç”±äºä¸åŒçš„æ ‡å‡†åº“å…·ä½“å®ç°å¯èƒ½ä¼šæœ‰æ‰€ä¸åŒã€‚å…¶ä¸­æœ€ä¸»è¦çš„å·®åˆ«ä¾¿æ˜¯ <code>memcpy</code> çš„å®ç°é€šå¸¸å¹¶éä¸€å®šæ˜¯å®‰å…¨çš„ï¼Œå½“æºå†…å­˜å’Œç›®æ ‡å†…å­˜å­˜åœ¨é‡å æ—¶ï¼Œ<code>memcpy</code> å°†å‘ç”Ÿé”™è¯¯ï¼š</p>

<pre><code class="language-c">#include &lt;stddef.h&gt; /* size_t */
void *c_memcpy(void *dest, const void *src, size_t n)
{
    char *dp = dest;
    const char *sp = src;
    while (n--)
        *dp++ = *sp++;
    return dest;
}
</code></pre>

<p>ä¸Šé¢æ˜¯ C99 æ ‡å‡†åº“ä¸­çš„å®ç°ã€‚ä¸‹é¢å°è¯•ä¸‹ï¼Œå°†ä¸€ä¸ªæ•°ç»„çš„å‰åŠæˆªæ‹·è´åˆ°å…¶ä¸­é—´çš„åœ°å€ï¼Œè¿™æ ·æºåœ°å€ä¸ç›®æ ‡åœ°å€å°±å‡ºç°äº†é‡å éƒ¨åˆ†ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¼€å‘è€…è¦ä¿è¯å†…å­˜æ˜¯å·²ç»åˆ†é…å¥½çš„ï¼Œå¦‚æœç›®æ ‡åœ°å€æ— æ³•å®¹çº³è¶³å¤Ÿé•¿çš„æºåœ°å€å†…å®¹é•¿åº¦ï¼Œåˆ™ä»å°†æº¢å‡ºï¼Œå‘ç”Ÿå´©æºƒã€‚</p>

<pre><code class="language-objectivec">// e[0, 1] -&gt; e[1, 2]
int e[5] = {1, 2, 3};
NSLog(@&quot;Before: e[0]: %d, e[1]: %d, e[2]: %d, e[3]: %d, e[4]: %d&quot;, e[0], e[1], e[2], e[3], e[4]);
_libkernel_memmove3(&amp;e[2], &amp;e[0], sizeof(int) * 3);
NSLog(@&quot;After: e[0]: %d, e[1]: %d, e[2]: %d, e[3]: %d, e[4]: %d&quot;, e[0], e[1], e[2], e[3], e[4]);

/ OUTPUT:
// Before: e[0]: 1, e[1]: 2, e[2]: 3, e[3]: 0, e[4]: 0
// After: e[0]: 1, e[1]: 2, e[2]: 1, e[3]: 2, e[4]: 3

// f[0, 1] -&gt; f[1, 2]
int f[5] = {1, 2, 3};
NSLog(@&quot;Before: f[0]: %d, f[1]: %d, f[2]: %d, f[3]: %d, f[4]: %d&quot;, f[0], f[1], f[2], f[3], f[4]);
v_memcpy(&amp;f[2], &amp;f[0], sizeof(int) * 3);
NSLog(@&quot;After: f[0]: %d, f[1]: %d, f[2]: %d, f[3]: %d, f[4]: %d&quot;, f[0], f[1], f[2], f[3], f[4]);

// OUTPUT:
// Before: f[0]: 1, f[1]: 2, f[2]: 3, f[3]: 0, f[4]: 0
// After: f[0]: 1, f[1]: 2, f[2]: 1, f[3]: 2, f[4]: 1
</code></pre>

<p>ç»“æœå¾ˆæ˜æ˜¾ï¼Œ<code>c_memcpy</code>ï¼ˆC99 æ ‡å‡†åº“å®ç°çš„ <code>memcpy</code>ï¼‰åœ¨é‡å éƒ¨åˆ†å‡ºç°äº†å·®é”™ï¼Œè€Œ <code>memmove</code> å´èƒ½å¤Ÿæ­£ç¡®çš„å¤„ç†ã€‚è¿™æ˜¯å› ä¸ºåœ¨ <code>memmove</code> å†…éƒ¨ä¼šåˆ¤æ–­æºåœ°å€å’Œç›®æ ‡åœ°å€çš„å¤§å°ï¼Œè¿›è€Œè¿›è¡Œæ­£å‘æˆ–åå‘æ‹·è´ï¼Œä»è€Œé¿å…äº†ä¸¢å¼ƒæ•°æ®ã€‚</p>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="../obj-c_to_c++/">å°† Obj-C ä»£ç ç¿»è¯‘ä¸º C++ ä»£ç  - kingcos</a></li>
<li><a href="/posts/2018/dyld_shared_cache/">è°ˆè°ˆ iOS ä¸­çš„ dyld_shared_cache - kingcos</a></li>
<li><a href="/posts/2019/link_map_file_in_xcode/">Xcode ä¸­çš„ Link Map æ–‡ä»¶ - kingcos</a></li>
<li><a href="/posts/2019/ivar_access_control_in_obj-c/">Obj-C ä¸­æˆå‘˜å˜é‡å’Œç±»çš„è®¿é—®æ§åˆ¶ - kingcos</a></li>
<li><a href="https://stackoverflow.com/questions/1201319/what-is-the-difference-between-memmove-and-memcpy">What is the difference between memmove and memcpy? - StackOverflow</a></li>
<li><a href="https://clc-wiki.net/wiki/memcpy">memcpy - clc-wiki</a></li>
<li><a href="https://tech.meituan.com/2018/11/08/ios-category-module-communicate.html">Category ç‰¹æ€§åœ¨ iOS ç»„ä»¶åŒ–ä¸­çš„åº”ç”¨ä¸ç®¡æ§ - ç¾å›¢æŠ€æœ¯å›¢é˜Ÿ</a></li>
</ul>

    </div>
    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>
        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="/posts/2019/libraries_in_ios/">
                <span class="button__icon">â†</span>
                <span class="button__text">iOS ä¸­çš„åº“ä¸æ¡†æ¶</span>
              </a>
            </span>
          
          
            <span class="button next">
              <a href="/posts/2019/objc_msgsend/">
                <span class="button__text">æµ…å° objc_msgSend</span>
                <span class="button__icon">â†’</span>
              </a>
            </span>
          
        </div>
      </div>
    

    

    
    
    <div>
      <div id="github-comment">
      </div>

      <script type="text/javascript">
        function getUtterances(isDark) {
          var utterances = document.createElement('script');
          utterances.type = 'text/javascript';
          utterances.async = true;
          utterances.setAttribute('issue-term', "pathname")
          utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
          utterances.setAttribute('label', "comments")
          isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
          utterances.crossorigin = 'anonymous';
          utterances.src = 'https://utteranc.es/client.js';

          return utterances
        }

        var themeToggle = document.querySelector(".theme-toggle")
        themeToggle.addEventListener("click", function () {
          var getTheme = window.localStorage && window.localStorage.getItem("theme")
          var divNode = document.getElementById('github-comment')
          while(divNode.hasChildNodes()) {
            divNode.removeChild(divNode.firstChild);
          }
          
          
          

          
          
          
          
          
          
          document.getElementById('github-comment').appendChild(getUtterances(getTheme !== "dark"))
        })

        var getTheme = window.localStorage && window.localStorage.getItem("theme")
        document.getElementById('github-comment').appendChild(getUtterances(getTheme === "dark"))
      </script>
    </div>
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">All rights reserved by kingcos.me</div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </body>
</html>
