<!DOCTYPE html>
<html lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="kingcos" />
	
	
	
	<title>iOS 中的 Category ｜ kingcos</title>
	
    
    
    <meta name="description" content="iOS 中的 Category 中文常译作分类、类别。我们经常会使用 Category 来对一个类进行扩展，使得在不破坏主类结构的同时可以具备更多的功能；也可以使用 Category 对一个类进行拆分，使得其结构更加清晰条理。本文将从 What - How - Why 谈谈 iOS 中 Category。" />
    

    
    
    <meta name="keywords" content="Hugo, theme, zozo" />
    

	
    
    <link rel="shortcut icon" href="https://kingcos.me/images/favicon.png" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://kingcos.me/css/highlight.css" />

    
    
</head>

<script data-ad-client="ca-pub-9925978992661955" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<body>
    <div class="main animate__animated animate__fadeInDown">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/posts/">Archive</a>
            </li>
            
            <li>
                <a href="/tags/">Tags</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>


<link rel="stylesheet" href="https://kingcos.me/scss/main.min.75b49085bfb07b1bf150a1d59b4773d857e0452a747e37243805218b528a4045.css" integrity="sha256-dbSQhb&#43;wexvxUKHVm0dz2FfgRSp0fjckOAUhi1KKQEU=" media="screen">

<style>
.nav_container {
  height: 1rem;
}
 
table {
    width: 100%;
    table-layout: fixed;
}

 
.markdown code {
    white-space: normal;
    word-wrap: break-word;
    word-break: break-word;
    line-height: 1.5em;
    font-size: 0.85em;
    font-weight: bold;
    display: inline-block;
     
}

 
.menu_icon a {
    font-size: 16px;
}

 
body {
    font-family: 'Hiragino Sans GB', 'SFMono', 'Lato', '-apple-system';
    -webkit-font-smoothing: 'antialiased';
}

 
.markdown strong, .markdown b, .markdown em {
    font-weight: bold;
}

.post .post_content p {
     

    line-height: 1.75em;
}

 
.markdown img {
    max-width: 100%;
    margin: 0 auto;
    display: block;
    border-radius: 0.25rem;
}

 
.ri-stack-line {
    vertical-align: middle;
}

 
.ri-map-pin-time-line {
    vertical-align: middle;
}

 
.chroma .lntd:nth-child(2) {
    width: 100%;
}

 

 
.markdown .book-hint::before {
    content: none;
}

.markdown .book-hint {
    margin: 1rem 0;
    padding: 0.5rem 1rem 0.5rem 0.75rem;

    border-inline-start: 0.25rem solid #e9ecef;
    border-radius: 0.25rem;

    font-style: normal;
     
}

.book-hint strong {
    background-color: transparent;
}

.markdown .book-hint.info {
    border-left-color:#6bf;
    background-color:rgba(102,187,255,.1);
}

.markdown .book-hint.warning {
    border-left-color:#fd6;
    background-color:rgba(255,221,102,.1);
}

.markdown .book-hint.danger {
    border-left-color:#f66;
    background-color:rgba(255,102,102,.1);
}

</style>

        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            
                <a href="https://kingcos.me/">
                    
                    <img class="kingcos" style="margin-top: -20px; margin-left: -10px;" src="/title.svg" width="150px">
                </a>
            
        </div>
        <div class="description">
            <p class="sub_title">专注、坚持</p>
            <div class="my_socials">
                
                
                <a href="https://github.com/kingcos" title="github" target="_blank"><i class="ri-github-fill"></i></a>
                
                
                
                <a href="https://www.instagram.com/kingcos_v/" title="instagram" target="_blank"><i class="ri-instagram-fill"></i></a>
                
                
                
                <a href="https://twitter.com/kingcos_v" title="twitter" target="_blank"><i class="ri-twitter-fill"></i></a>
                
                
                
                <a href="https://weibo.com/u/1798410923" title="weibo" target="_blank"><i class="ri-weibo-fill"></i></a>
                
                
                
            </div>
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/posts/2019/category_in_ios/'>iOS 中的 Category</a></h2>
                        <span class="date">2019.10.23</span>
                        <span>by kingcos</span>
                        
                        
                        
                        
                    </div>
                    <div class="post_content markdown"><table>
<thead>
<tr>
<th style="text-align:center">Date</th>
<th style="text-align:center">Notes</th>
<th style="text-align:center">Source Code</th>
<th style="text-align:center">Demo</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2019-04-16</td>
<td style="text-align:center">优化结构</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">2019-04-13</td>
<td style="text-align:center">首次提交</td>
<td style="text-align:center"><a href="https://opensource.apple.com/tarballs/objc4/">objc4-750</a>、<a href="https://opensource.apple.com/tarballs/xnu/">xnu-4903.221.2</a></td>
<td style="text-align:center"><a href="https://github.com/kingcos/Perspective/tree/writing/Posts/Focus/Category_in_Obj-C/">Category in iOS</a></td>
</tr>
<tr>
<td style="text-align:center">2019-10-23</td>
<td style="text-align:center">添加首图，细节微调</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p><img src="/img/2019/category_in_ios/0.png" alt="0"></p>
<h2 id="preface">Preface</h2>
<p>iOS 中的 Category 中文常译作分类、类别（为表述统一，本文将使用 Category 特指该技术）。我们经常会使用 Category 来对一个类进行扩展，使得在不破坏主类结构的同时可以具备更多的功能；也可以使用 Category 对一个类进行拆分，使得其结构更加清晰条理。本文将从 What - How - Why 谈谈 iOS 中 Category。</p>
<h2 id="what">What</h2>
<p>什么是 Category 呢？</p>
<p>Category 是 Obj-C 语言中所提供的一项功能，它可以为 Obj-C 类添加额外的属性、方法，也可以遵守其他协议。</p>
<p><img src="/img/2019/category_in_ios/1.png" alt="1"></p>
<p>Xcode 中已经为 Category 已经提供了模版来建立，只需要指定 Category 的名称以及被添加 Category 类名即可。当然，我们也可以手动来自己建立，Category 的语法与类的声明与实现比较类似：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@interface</span> <span class="nc">Foo</span> <span class="nl">(Bar)</span> <span class="o">&lt;</span><span class="n">SomeProtocol</span><span class="o">&gt;</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">foo</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo</span> <span class="nl">(Bar)</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">foo</span> <span class="p">{}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">someMethodFromProtocol</span> <span class="p">{}</span>
<span class="k">@end</span>
</code></pre></div><h2 id="how">How</h2>
<p>Category 通常都有哪些用处呢？</p>
<h3 id="解耦">解耦</h3>
<p>假如有一个人（Person），他需要工作（Work）和生活（Life），而工作和生活所做的事情显然是不一样的，那么我们就可以使用 Category 将人的这它们进行解耦：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@interface</span> <span class="nc">Person</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Person</span>
<span class="k">@end</span>

<span class="c1">// ---
</span><span class="c1"></span>
<span class="k">@interface</span> <span class="nc">Person</span> <span class="nl">(Life)</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">playWithPet</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Person</span> <span class="nl">(Life)</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">playWithPet</span> <span class="p">{}</span>
<span class="k">@end</span>

<span class="c1">// ---
</span><span class="c1"></span>
<span class="k">@interface</span> <span class="nc">Person</span> <span class="nl">(Work)</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">codeForWork</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Person</span> <span class="nl">(Work)</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">codeForWork</span> <span class="p">{}</span>
<span class="k">@end</span>
</code></pre></div><p>这样，Person+Life 中可以定义与生活相关的方法，而 Person+Work 中将专注于工作。当人需要运动（Sports）时，只需要再为 Person 添加 Person+Sports 的 Category 即可，这并不需要改动主类本身从而实现了解耦。</p>
<h3 id="私有化">私有化</h3>
<p>使用 Xcode 模版新建 Category 后，将会自动创建两个文件：ClassName+CategoryName.h &amp; ClassName+CategoryName.m。当我们不希望某个 Category 可以在外界访问时，只需要不把它作为公共头文件（Public Header）暴露出去即可，即实现了私有化。需要注意的是，同样可以实现私有化的方案是使用类扩展（Class Extension），其因语法相似但没有定义名称被很多人称为「匿名分类（Category）」。不过本质上说，Category 和类扩展是完全不同的：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// Class Extension
</span><span class="c1"></span><span class="k">@interface</span> <span class="nc">Person</span> <span class="p">()</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">secret</span><span class="p">;</span>
<span class="k">@end</span>
</code></pre></div><p>类扩展是可以定义在单独的 .h 或者 .m 中，其主要可以使得外界无法直接访问到定义的成员变量、属性或方法。关于类扩展与访问控制，可详见《<a href="/posts/2019/ivar_access_control_in_obj-c/">Obj-C 中成员变量和类的访问控制</a>》一文。</p>
<h3 id="反私有化">「反私有化」</h3>
<p>Category 不仅可以私有化，其实也可以「反私有化」。如果我们希望调用一个没有声明的方法，此时就可以在其 Category 或者类扩展中声明该方法，再进行调用。当然，Obj-C 中方法调用本质是消息发送，只要我们知道了消息的发送者和接收者，即使没有声明也总有方法来发送消息。</p>
<h3 id="多继承">「多继承」</h3>
<p>因为 Category 是支持遵守协议（Protocol）的，那么不同的 Category 就可以遵守不同的协议，实现类似「多继承」的特性。但为什么是加引号的「多继承」呢？因为这样的协议遵守只能获得方法的声明，却无法获得父类的具体实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">@protocol</span> <span class="nc">LifeProtocol</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">playWithPet</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@interface</span> <span class="nc">Person</span> <span class="nl">(Life)</span> <span class="o">&lt;</span><span class="n">LifeProtocol</span><span class="o">&gt;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Person</span> <span class="nl">(Life)</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">playWithPet</span> <span class="p">{}</span>
<span class="k">@end</span>

<span class="c1">// ---
</span><span class="c1"></span>
<span class="k">@protocol</span> <span class="nc">WorkProtocol</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">workHard</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@interface</span> <span class="nc">Person</span> <span class="nl">(Work)</span> <span class="o">&lt;</span><span class="n">WorkProtocol</span><span class="o">&gt;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Person</span> <span class="nl">(Work)</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">workHard</span> <span class="p">{}</span>
<span class="k">@end</span>
</code></pre></div><h2 id="why">Why</h2>
<p>Obj-C 中的 Category 底层是如何实现的呢？</p>
<h3 id="结构">结构</h3>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// Person+Life.h
</span><span class="c1"></span><span class="cm">/**
</span><span class="cm"> LifeProtocol
</span><span class="cm"> */</span>
<span class="k">@protocol</span> <span class="nc">LifeProtocol</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">eat</span><span class="p">;</span>
<span class="k">@end</span>

<span class="cm">/**
</span><span class="cm"> Person+Life
</span><span class="cm"> */</span>
<span class="k">@interface</span> <span class="nc">Person</span> <span class="nl">(Life)</span> <span class="o">&lt;</span><span class="n">LifeProtocol</span><span class="o">&gt;</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

<span class="c1">// Instance method
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">run</span><span class="p">;</span>

<span class="c1">// Class method
</span><span class="c1"></span><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">foo</span><span class="p">;</span>

<span class="c1">// Protocol method
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">eat</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre></div><p>定义一个完整的 Person 类，它遵守了协议，存储了属性，并定义实现了对象方法和类方法。为了便于下面的分析，我们使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc Person+Life.m</code> 命令将 Person+Life.m 翻译为 C/C++ 代码（Person+Life.cpp），关于翻译 Obj-C 代码的细节，可详见《<a href="../obj-c_to_c++/">将 Obj-C 代码翻译为 C++ 代码</a>》一文。</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Person+Life.cpp
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">_category_t</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>                               <span class="c1">// 类名
</span><span class="c1"></span>	<span class="k">struct</span> <span class="nc">_class_t</span> <span class="o">*</span><span class="n">cls</span><span class="p">;</span>                           <span class="c1">// 类指针
</span><span class="c1"></span>	<span class="k">const</span> <span class="k">struct</span> <span class="nc">_method_list_t</span> <span class="o">*</span><span class="n">instance_methods</span><span class="p">;</span>  <span class="c1">// 对象方法列表指针
</span><span class="c1"></span>	<span class="k">const</span> <span class="k">struct</span> <span class="nc">_method_list_t</span> <span class="o">*</span><span class="n">class_methods</span><span class="p">;</span>     <span class="c1">// 类方法列表指针
</span><span class="c1"></span>	<span class="k">const</span> <span class="k">struct</span> <span class="nc">_protocol_list_t</span> <span class="o">*</span><span class="n">protocols</span><span class="p">;</span>       <span class="c1">// 协议列表指针
</span><span class="c1"></span>	<span class="k">const</span> <span class="k">struct</span> <span class="nc">_prop_list_t</span> <span class="o">*</span><span class="n">properties</span><span class="p">;</span>          <span class="c1">// 属性列表指针
</span><span class="c1"></span><span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="nc">_category_t</span> <span class="n">_OBJC_</span><span class="err">$</span><span class="n">_CATEGORY_Person_</span><span class="err">$</span><span class="n">_Life</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">used</span><span class="p">,</span> <span class="n">section</span> <span class="p">(</span><span class="s">&#34;__DATA,__objc_const&#34;</span><span class="p">)))</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="s">&#34;Person&#34;</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span> <span class="c1">// &amp;OBJC_CLASS_$_Person,
</span><span class="c1"></span>	<span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">_method_list_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_OBJC_</span><span class="err">$</span><span class="n">_CATEGORY_INSTANCE_METHODS_Person_</span><span class="err">$</span><span class="n">_Life</span><span class="p">,</span>
	<span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">_method_list_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_OBJC_</span><span class="err">$</span><span class="n">_CATEGORY_CLASS_METHODS_Person_</span><span class="err">$</span><span class="n">_Life</span><span class="p">,</span>
	<span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">_protocol_list_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_OBJC_CATEGORY_PROTOCOLS_</span><span class="err">$</span><span class="n">_Person_</span><span class="err">$</span><span class="n">_Life</span><span class="p">,</span>
	<span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">_prop_list_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_OBJC_</span><span class="err">$</span><span class="n">_PROP_LIST_Person_</span><span class="err">$</span><span class="n">_Life</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// 对象方法列表
</span><span class="c1"></span><span class="k">static</span> <span class="k">struct</span> <span class="err">/*</span><span class="nc">_method_list_t</span><span class="err">*/</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">entsize</span><span class="p">;</span>  <span class="c1">// sizeof(struct _objc_method)
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">method_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">_objc_method</span> <span class="n">method_list</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span> <span class="n">_OBJC_</span><span class="err">$</span><span class="n">_CATEGORY_INSTANCE_METHODS_Person_</span><span class="err">$</span><span class="n">_Life</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">used</span><span class="p">,</span> <span class="n">section</span> <span class="p">(</span><span class="s">&#34;__DATA,__objc_const&#34;</span><span class="p">)))</span> <span class="o">=</span> <span class="p">{</span>
	<span class="k">sizeof</span><span class="p">(</span><span class="n">_objc_method</span><span class="p">),</span>
	<span class="mi">2</span><span class="p">,</span>
	<span class="p">{{(</span><span class="k">struct</span> <span class="nc">objc_selector</span> <span class="o">*</span><span class="p">)</span><span class="s">&#34;run&#34;</span><span class="p">,</span> <span class="s">&#34;v16@0:8&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">_I_Person_Life_run</span><span class="p">},</span>
	<span class="p">{(</span><span class="k">struct</span> <span class="nc">objc_selector</span> <span class="o">*</span><span class="p">)</span><span class="s">&#34;eat&#34;</span><span class="p">,</span> <span class="s">&#34;v16@0:8&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">_I_Person_Life_eat</span><span class="p">}}</span>
<span class="p">};</span>

<span class="c1">// 类方法列表
</span><span class="c1"></span><span class="k">static</span> <span class="k">struct</span> <span class="err">/*</span><span class="nc">_method_list_t</span><span class="err">*/</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">entsize</span><span class="p">;</span>  <span class="c1">// sizeof(struct _objc_method)
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">method_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">_objc_method</span> <span class="n">method_list</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">_OBJC_</span><span class="err">$</span><span class="n">_CATEGORY_CLASS_METHODS_Person_</span><span class="err">$</span><span class="n">_Life</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">used</span><span class="p">,</span> <span class="n">section</span> <span class="p">(</span><span class="s">&#34;__DATA,__objc_const&#34;</span><span class="p">)))</span> <span class="o">=</span> <span class="p">{</span>
	<span class="k">sizeof</span><span class="p">(</span><span class="n">_objc_method</span><span class="p">),</span>
	<span class="mi">1</span><span class="p">,</span>
	<span class="p">{{(</span><span class="k">struct</span> <span class="nc">objc_selector</span> <span class="o">*</span><span class="p">)</span><span class="s">&#34;foo&#34;</span><span class="p">,</span> <span class="s">&#34;v16@0:8&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">_C_Person_Life_foo</span><span class="p">}}</span>
<span class="p">};</span>

<span class="c1">// 协议列表
</span><span class="c1"></span><span class="k">static</span> <span class="k">struct</span> <span class="err">/*</span><span class="nc">_protocol_list_t</span><span class="err">*/</span> <span class="p">{</span>
	<span class="kt">long</span> <span class="n">protocol_count</span><span class="p">;</span>  <span class="c1">// Note, this is 32/64 bit
</span><span class="c1"></span>	<span class="k">struct</span> <span class="nc">_protocol_t</span> <span class="o">*</span><span class="n">super_protocols</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">_OBJC_CATEGORY_PROTOCOLS_</span><span class="err">$</span><span class="n">_Person_</span><span class="err">$</span><span class="n">_Life</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">used</span><span class="p">,</span> <span class="n">section</span> <span class="p">(</span><span class="s">&#34;__DATA,__objc_const&#34;</span><span class="p">)))</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">1</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">_OBJC_PROTOCOL_LifeProtocol</span>
<span class="p">};</span>

<span class="c1">// 属性列表
</span><span class="c1"></span><span class="k">static</span> <span class="k">struct</span> <span class="err">/*</span><span class="nc">_prop_list_t</span><span class="err">*/</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">entsize</span><span class="p">;</span>  <span class="c1">// sizeof(struct _prop_t)
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count_of_properties</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">_prop_t</span> <span class="n">prop_list</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">_OBJC_</span><span class="err">$</span><span class="n">_PROP_LIST_Person_</span><span class="err">$</span><span class="n">_Life</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">used</span><span class="p">,</span> <span class="n">section</span> <span class="p">(</span><span class="s">&#34;__DATA,__objc_const&#34;</span><span class="p">)))</span> <span class="o">=</span> <span class="p">{</span>
	<span class="k">sizeof</span><span class="p">(</span><span class="n">_prop_t</span><span class="p">),</span>
	<span class="mi">1</span><span class="p">,</span>
	<span class="p">{{</span><span class="s">&#34;name&#34;</span><span class="p">,</span><span class="s">&#34;T@</span><span class="se">\&#34;</span><span class="s">NSString</span><span class="se">\&#34;</span><span class="s">,C,N&#34;</span><span class="p">}}</span>
<span class="p">};</span>
</code></pre></div><p>在翻译后的 C++ 源代码中，我们可以发现一个名称和 Category 相关的结构体定义：<code>_category_t</code>，该结构体表示了 Obj-C 中 Category 的实际结构；<code>_OBJC_$_CATEGORY_Person_$_Life</code> 则就是我们定义的 Person+Life Category。<code>_category_t</code> 结构体中存储了类名、类指针、对象方法列表指针、类方法列表指针、协议列表指针、以及属性列表指针，所以 Category 中支持遵守协议、声明属性、以及定义实现对象方法和类方法（不支持定义成员变量）。当然，在 Apple 开源的 objc4 中，也可以找到 <code>category_t</code> 结构体：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// objc-runtime-new.h
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">category_t</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="n">classref_t</span> <span class="n">cls</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">method_list_t</span> <span class="o">*</span><span class="n">instanceMethods</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">method_list_t</span> <span class="o">*</span><span class="n">classMethods</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">protocol_list_t</span> <span class="o">*</span><span class="n">protocols</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">property_list_t</span> <span class="o">*</span><span class="n">instanceProperties</span><span class="p">;</span>
    <span class="c1">// Fields below this point are not always present on disk.
</span><span class="c1"></span>    <span class="c1">// 以下内容并不能保证会在磁盘中展示
</span><span class="c1"></span>    <span class="k">struct</span> <span class="nc">property_list_t</span> <span class="o">*</span><span class="n">_classProperties</span><span class="p">;</span>

    <span class="n">method_list_t</span> <span class="o">*</span><span class="nf">methodsForMeta</span><span class="p">(</span><span class="kt">bool</span> <span class="n">isMeta</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isMeta</span><span class="p">)</span> <span class="k">return</span> <span class="n">classMethods</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">instanceMethods</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">property_list_t</span> <span class="o">*</span><span class="nf">propertiesForMeta</span><span class="p">(</span><span class="kt">bool</span> <span class="n">isMeta</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">header_info</span> <span class="o">*</span><span class="n">hi</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div><h3 id="实现原理">实现原理</h3>
<p>当我们的代码编译完，Category 中的信息就将被存储在 <code>category_t</code> 的结构体中，那么运行时的 Category 又会变成什么样呢？</p>
<h4 id="what-1">What</h4>
<p>我们尝试分别在 <code>Person</code> 主类、Person+Life 和 Person+Work Category 中定义并实现完全相同的 <code>smile</code> 方法。有个细节是，我们在 Category 中实现主类中已经实现的方法时，编译器会警告「Category is implementing a method which will also be implemented by its primary class」，这又是为什么呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// Person.h
</span><span class="c1"></span><span class="k">@interface</span> <span class="nc">Person</span> : <span class="nc">NSObject</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">smile</span><span class="p">;</span>
<span class="k">@end</span>

<span class="c1">// Person+Life.h
</span><span class="c1"></span><span class="k">@interface</span> <span class="nc">Person</span> <span class="nl">(Life)</span> <span class="o">&lt;</span><span class="n">LifeProtocol</span><span class="o">&gt;</span>
<span class="c1">// ...
</span><span class="c1"></span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">smile</span><span class="p">;</span>
<span class="k">@end</span>

<span class="c1">// Person+Work.h
</span><span class="c1"></span><span class="k">@interface</span> <span class="nc">Person</span> <span class="nl">(Work)</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">smile</span><span class="p">;</span>
<span class="k">@end</span>

<span class="c1">// main.m
</span><span class="c1"></span><span class="n">Person</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Person</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
<span class="p">[</span><span class="n">p</span> <span class="n">smile</span><span class="p">];</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// Person (Work) - -[Person(Work) smile]
</span></code></pre></div><p>当我们运行程序，发现最终只输出了一句，并且是调用到了 Person+Work Category 中的方法。那么先说结论：<strong>当 Category 中实现了主类中同一个方法时，将总是调用 Category 中的方法（这也是为何编译器警告的原因）；当存在多个 Category 实现同一个方法时，将总是调用最后被编译的 Category 中的方法</strong>。如何查看文件的编译顺序呢？在 Xcode -「Build Phases」-「Compile Sources」中，靠前的即是最先被编译的：</p>
<p><img src="/img/2019/category_in_ios/2.png" alt="2"></p>
<h4 id="why-1">Why</h4>
<p>为了证明上述结论，我们需要在 objc4 的源码中，从 Obj-C 运行时初始化的入口着手，即 <code>_objc_init</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// objc-os.mm
</span><span class="c1"></span><span class="cm">/***********************************************************************
</span><span class="cm">* _objc_init
</span><span class="cm">* Bootstrap initialization. Registers our image notifier with dyld.
</span><span class="cm">* 引导初始化。使用 dyld 注册镜像通知器。
</span><span class="cm">* Called by libSystem BEFORE library initialization time
</span><span class="cm">* 在库初始化时间之前由 libSystem 调用
</span><span class="cm">**********************************************************************/</span>

<span class="kt">void</span> <span class="nf">_objc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">initialized</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">initialized</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">initialized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="c1">// fixme defer initialization until an objc-using image is found?
</span><span class="c1"></span>    <span class="n">environ_init</span><span class="p">();</span>
    <span class="n">tls_init</span><span class="p">();</span>
    <span class="n">static_init</span><span class="p">();</span>
    <span class="n">lock_init</span><span class="p">();</span>
    <span class="n">exception_init</span><span class="p">();</span>

    <span class="c1">// ➡️ dyld 注册通知；map_images：映射镜像，load_images：加载镜像，unmap_image：反映射镜像
</span><span class="c1"></span>    <span class="n">_dyld_objc_notify_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_images</span><span class="p">,</span> <span class="n">load_images</span><span class="p">,</span> <span class="n">unmap_image</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// objc-runtime-new.mm
</span><span class="c1"></span><span class="cm">/***********************************************************************
</span><span class="cm">* map_images
</span><span class="cm">* Process the given images which are being mapped in by dyld.
</span><span class="cm">* 由 dyld 处理给定将要映射的镜像。
</span><span class="cm">* Calls ABI-agnostic code after taking ABI-specific locks.
</span><span class="cm">* 加上指定 ABI 锁后调用 ABI 无关（agnostic）的代码。
</span><span class="cm">*
</span><span class="cm">* Locking: write-locks runtimeLock
</span><span class="cm">* 锁：写锁 runtimeLock
</span><span class="cm">**********************************************************************/</span>
<span class="kt">void</span>
<span class="nf">map_images</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">paths</span><span class="p">[],</span>
           <span class="k">const</span> <span class="k">struct</span> <span class="n">mach_header</span> <span class="o">*</span> <span class="k">const</span> <span class="n">mhdrs</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="c1">// 互斥锁
</span><span class="c1"></span>    <span class="n">mutex_locker_t</span> <span class="n">lock</span><span class="p">(</span><span class="n">runtimeLock</span><span class="p">);</span>
    <span class="c1">// ➡️ map_images_nolock：映射镜像（无锁）
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">map_images_nolock</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">mhdrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// objc-os.mm
</span><span class="c1"></span><span class="kt">void</span>
<span class="nf">map_images_nolock</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">mhCount</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">mhPaths</span><span class="p">[],</span>
                  <span class="k">const</span> <span class="k">struct</span> <span class="n">mach_header</span> <span class="o">*</span> <span class="k">const</span> <span class="n">mhdrs</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">firstTime</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
    <span class="n">header_info</span> <span class="o">*</span><span class="n">hList</span><span class="p">[</span><span class="n">mhCount</span><span class="p">];</span>
    <span class="n">uint32_t</span> <span class="n">hCount</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">selrefCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Perform first-time initialization if necessary.
</span><span class="c1"></span>    <span class="c1">// 必要时执行首次初始化。
</span><span class="c1"></span>    <span class="c1">// This function is called before ordinary library initializers.
</span><span class="c1"></span>    <span class="c1">// 在普通库构造方法之前调用该函数。
</span><span class="c1"></span>    <span class="c1">// fixme defer initialization until an objc-using image is found?
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">firstTime</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">preopt_init</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Xcode 中 OBJC_PRINT_IMAGES 环境变量值为 YES 时，将可在控制台打印该信息
</span><span class="c1"></span>    <span class="c1">// OPTION(PrintImages, OBJC_PRINT_IMAGES, &#34;log image and library names as they are loaded&#34;)
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">PrintImages</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;IMAGES: processing %u newly-mapped images...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">mhCount</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="c1">// Find all images with Objective-C metadata.
</span><span class="c1"></span>    <span class="c1">// 使用 Obj-C 元数据查找所有镜像。
</span><span class="c1"></span>    <span class="n">hCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Count classes. Size various table based on the total.
</span><span class="c1"></span>    <span class="c1">// 计算类。根据总数计算不同的表。
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">totalClasses</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">unoptimizedTotalClasses</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="n">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">mhCount</span><span class="p">;</span>
        <span class="c1">// 遍历 mach-o header
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">const</span> <span class="n">headerType</span> <span class="o">*</span><span class="n">mhdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">headerType</span> <span class="o">*</span><span class="p">)</span><span class="n">mhdrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

            <span class="c1">// ➡️ addHeader：添加头部信息（计算类的总数、未优化的类总数）
</span><span class="c1"></span>            <span class="k">auto</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">addHeader</span><span class="p">(</span><span class="n">mhdr</span><span class="p">,</span> <span class="n">mhPaths</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">totalClasses</span><span class="p">,</span> <span class="n">unoptimizedTotalClasses</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// no objc data in this entry
</span><span class="c1"></span>                <span class="c1">// 若 hi 为空，则该条目没有 Obj-C 数据
</span><span class="c1"></span>                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 判断文件类型是否是可执行文件
</span><span class="c1"></span>            <span class="c1">// #define	MH_EXECUTE	0x2		/* demand paged executable file */
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">mhdr</span><span class="o">-&gt;</span><span class="n">filetype</span> <span class="o">==</span> <span class="n">MH_EXECUTE</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Size some data structures based on main executable&#39;s size
</span><span class="c1"></span>                <span class="c1">// 根据主可执行文件的大小调整一些数据结构的大小
</span><span class="c1"></span><span class="cp">#if __OBJC2__
</span><span class="cp"></span>                <span class="n">size_t</span> <span class="n">count</span><span class="p">;</span>

                <span class="c1">// 在 __objc_selrefs 节获取 SEL 引用（此处可参考 Mach-O 或 Link Map 文件中 Sections 部分）
</span><span class="c1"></span>                <span class="c1">// GETSECT(_getObjc2SelectorRefs,        SEL,             &#34;__objc_selrefs&#34;);
</span><span class="c1"></span>                <span class="n">_getObjc2SelectorRefs</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
                <span class="n">selrefCount</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
                <span class="c1">// 在 __objc_msgrefs 节获取消息引用
</span><span class="c1"></span>                <span class="c1">// GETSECT(_getObjc2MessageRefs,         message_ref_t,   &#34;__objc_msgrefs&#34;);
</span><span class="c1"></span>                <span class="n">_getObjc2MessageRefs</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
                <span class="n">selrefCount</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
<span class="cp">#else
</span><span class="cp"></span>                <span class="n">_getObjcSelectorRefs</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">selrefCount</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="cp"></span>
<span class="cp">#if SUPPORT_GC_COMPAT
</span><span class="cp"></span>                <span class="c1">// Halt if this is a GC app.
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">shouldRejectGCApp</span><span class="p">(</span><span class="n">hi</span><span class="p">))</span> <span class="p">{</span>
                    <span class="n">_objc_fatal_with_reason</span>
                        <span class="p">(</span><span class="n">OBJC_EXIT_REASON_GC_NOT_SUPPORTED</span><span class="p">,</span>
                         <span class="n">OS_REASON_FLAG_CONSISTENT_FAILURE</span><span class="p">,</span>
                         <span class="s">&#34;Objective-C garbage collection &#34;</span>
                         <span class="s">&#34;is no longer supported.&#34;</span><span class="p">);</span>
                <span class="p">}</span>
<span class="cp">#endif
</span><span class="cp"></span>            <span class="p">}</span>

            <span class="c1">// hList 保存 hi 并 hCount 自增
</span><span class="c1"></span>            <span class="n">hList</span><span class="p">[</span><span class="n">hCount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">hi</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">PrintImages</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;IMAGES: loading image for %s%s%s%s%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
                             <span class="n">hi</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">(),</span>
                             <span class="n">mhdr</span><span class="o">-&gt;</span><span class="n">filetype</span> <span class="o">==</span> <span class="n">MH_BUNDLE</span> <span class="o">?</span> <span class="s">&#34; (bundle)&#34;</span> <span class="o">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>
                             <span class="n">hi</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isReplacement</span><span class="p">()</span> <span class="o">?</span> <span class="s">&#34; (replacement)&#34;</span> <span class="o">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>
                             <span class="n">hi</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasCategoryClassProperties</span><span class="p">()</span> <span class="o">?</span> <span class="s">&#34; (has class properties)&#34;</span> <span class="o">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>
                             <span class="n">hi</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">optimizedByDyld</span><span class="p">()</span><span class="o">?</span><span class="s">&#34; (preoptimized)&#34;</span><span class="o">:</span><span class="s">&#34;&#34;</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Perform one-time runtime initialization that must be deferred until
</span><span class="c1"></span>    <span class="c1">// the executable itself is found. This needs to be done before
</span><span class="c1"></span>    <span class="c1">// further initialization.
</span><span class="c1"></span>    <span class="c1">// (The executable may not be present in this infoList if the
</span><span class="c1"></span>    <span class="c1">// executable does not contain Objective-C code but Objective-C
</span><span class="c1"></span>    <span class="c1">// is dynamically loaded later.
</span><span class="c1"></span>    <span class="c1">// 在找到可执行文件本身之前必须延迟执行一次性运行时初始化。
</span><span class="c1"></span>    <span class="c1">// 这需要在进一步初始化之前完成。
</span><span class="c1"></span>    <span class="c1">// （如果可执行文件不包含 Obj-C 代码但 Obj-C 在之后动态加载，则 infoList 中可能不包含该可执行文件。）
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">firstTime</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sel_init</span><span class="p">(</span><span class="n">selrefCount</span><span class="p">);</span>
        <span class="n">arr_init</span><span class="p">();</span>

<span class="cp">#if SUPPORT_GC_COMPAT
</span><span class="cp"></span>        <span class="c1">// Reject any GC images linked to the main executable.
</span><span class="c1"></span>        <span class="c1">// We already rejected the app itself above.
</span><span class="c1"></span>        <span class="c1">// Images loaded after launch will be rejected by dyld.
</span><span class="c1"></span>
        <span class="k">for</span> <span class="p">(</span><span class="n">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">hList</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">auto</span> <span class="n">mh</span> <span class="o">=</span> <span class="n">hi</span><span class="o">-&gt;</span><span class="n">mhdr</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">filetype</span> <span class="o">!=</span> <span class="n">MH_EXECUTE</span>  <span class="o">&amp;&amp;</span>  <span class="n">shouldRejectGCImage</span><span class="p">(</span><span class="n">mh</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">_objc_fatal_with_reason</span>
                    <span class="p">(</span><span class="n">OBJC_EXIT_REASON_GC_NOT_SUPPORTED</span><span class="p">,</span>
                     <span class="n">OS_REASON_FLAG_CONSISTENT_FAILURE</span><span class="p">,</span>
                     <span class="s">&#34;%s requires Objective-C garbage collection &#34;</span>
                     <span class="s">&#34;which is no longer supported.&#34;</span><span class="p">,</span> <span class="n">hi</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
<span class="cp">#endif
</span><span class="cp"></span>
<span class="cp">#if TARGET_OS_OSX
</span><span class="cp"></span>        <span class="c1">// Disable +initialize fork safety if the app is too old (&lt; 10.13).
</span><span class="c1"></span>        <span class="c1">// Disable +initialize fork safety if the app has a
</span><span class="c1"></span>        <span class="c1">//   __DATA,__objc_fork_ok section.
</span><span class="c1"></span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dyld_get_program_sdk_version</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">DYLD_MACOSX_VERSION_10_13</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">DisableInitializeForkSafety</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">PrintInitializing</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;INITIALIZE: disabling +initialize fork &#34;</span>
                             <span class="s">&#34;safety enforcement because the app is &#34;</span>
                             <span class="s">&#34;too old (SDK version &#34;</span> <span class="n">SDK_FORMAT</span> <span class="s">&#34;)&#34;</span><span class="p">,</span>
                             <span class="n">FORMAT_SDK</span><span class="p">(</span><span class="n">dyld_get_program_sdk_version</span><span class="p">()));</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">hList</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">auto</span> <span class="n">mh</span> <span class="o">=</span> <span class="n">hi</span><span class="o">-&gt;</span><span class="n">mhdr</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">filetype</span> <span class="o">!=</span> <span class="n">MH_EXECUTE</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">getsectiondata</span><span class="p">(</span><span class="n">hi</span><span class="o">-&gt;</span><span class="n">mhdr</span><span class="p">(),</span> <span class="s">&#34;__DATA&#34;</span><span class="p">,</span> <span class="s">&#34;__objc_fork_ok&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">DisableInitializeForkSafety</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">PrintInitializing</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;INITIALIZE: disabling +initialize fork &#34;</span>
                                 <span class="s">&#34;safety enforcement because the app has &#34;</span>
                                 <span class="s">&#34;a __DATA,__objc_fork_ok section&#34;</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>  <span class="c1">// assume only one MH_EXECUTE image
</span><span class="c1"></span>        <span class="p">}</span>
<span class="cp">#endif
</span><span class="cp"></span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">hCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ➡️ 读取镜像（传入 header_info 列表，数量，类的总数，未优化的类的总数）
</span><span class="c1"></span>        <span class="n">_read_images</span><span class="p">(</span><span class="n">hList</span><span class="p">,</span> <span class="n">hCount</span><span class="p">,</span> <span class="n">totalClasses</span><span class="p">,</span> <span class="n">unoptimizedTotalClasses</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 第一次执行完毕后，置为 NO
</span><span class="c1"></span>    <span class="n">firstTime</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// objc-os.mm
</span><span class="c1"></span><span class="k">static</span> <span class="n">header_info</span> <span class="o">*</span> <span class="nf">addHeader</span><span class="p">(</span><span class="k">const</span> <span class="n">headerType</span> <span class="o">*</span><span class="n">mhdr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">totalClasses</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">unoptimizedTotalClasses</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">header_info</span> <span class="o">*</span><span class="n">hi</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">bad_magic</span><span class="p">(</span><span class="n">mhdr</span><span class="p">))</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">inSharedCache</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="c1">// Look for hinfo from the dyld shared cache.
</span><span class="c1"></span>    <span class="c1">// 在 dyld 共享缓存中寻找 hinfo（关于 dyld 共享缓存可参考文末「谈谈 iOS 中的 dyld_shared_cache」一文）。
</span><span class="c1"></span>    <span class="c1">// 为头部预优化 hinfo
</span><span class="c1"></span>    <span class="n">hi</span> <span class="o">=</span> <span class="n">preoptimizedHinfoForHeader</span><span class="p">(</span><span class="n">mhdr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Found an hinfo in the dyld shared cache.
</span><span class="c1"></span>        <span class="c1">// 在 dyld 共享缓存中找到 hinfo
</span><span class="c1"></span>
        <span class="c1">// Weed out duplicates.
</span><span class="c1"></span>        <span class="c1">// 去除重复（若该 hi 已被加载，则返回空）。
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">hi</span><span class="o">-&gt;</span><span class="n">isLoaded</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">inSharedCache</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="c1">// Initialize fields not set by the shared cache
</span><span class="c1"></span>        <span class="c1">// 初始化未由共享缓存设置的域
</span><span class="c1"></span>        <span class="c1">// hi-&gt;next is set by appendHeader
</span><span class="c1"></span>        <span class="c1">// hi-&gt;next 由 appendHeader 设置
</span><span class="c1"></span>        <span class="c1">// 设置已加载为 true
</span><span class="c1"></span>        <span class="n">hi</span><span class="o">-&gt;</span><span class="n">setLoaded</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

        <span class="c1">// Xcode 中 OBJC_PRINT_PREOPTIMIZATION 环境变量值为 YES 时，将可在控制台打印该信息
</span><span class="c1"></span>        <span class="c1">// OPTION(PrintPreopt, OBJC_PRINT_PREOPTIMIZATION, &#34;log preoptimization courtesy of dyld shared cache&#34;)
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">PrintPreopt</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;PREOPTIMIZATION: honoring preoptimized header info at %p for %s&#34;</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">hi</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">());</span>
        <span class="p">}</span>

<span class="cp">#if !__OBJC2__
</span><span class="cp"></span>        <span class="n">_objc_fatal</span><span class="p">(</span><span class="s">&#34;shouldn&#39;t be here&#34;</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="cp">#if DEBUG
</span><span class="cp"></span>        <span class="c1">// Verify image_info
</span><span class="c1"></span>        <span class="c1">// DEBUG 模式校验 image_info
</span><span class="c1"></span>        <span class="n">size_t</span> <span class="n">info_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">const</span> <span class="n">objc_image_info</span> <span class="o">*</span><span class="n">image_info</span> <span class="o">=</span> <span class="n">_getObjcImageInfo</span><span class="p">(</span><span class="n">mhdr</span><span class="p">,</span><span class="o">&amp;</span><span class="n">info_size</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">image_info</span> <span class="o">==</span> <span class="n">hi</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">());</span>
<span class="cp">#endif
</span><span class="cp"></span>    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">// Didn&#39;t find an hinfo in the dyld shared cache.
</span><span class="c1"></span>        <span class="c1">// 在 dyld 共享缓存中未找到 hinfo。
</span><span class="c1"></span>
        <span class="c1">// Weed out duplicates
</span><span class="c1"></span>        <span class="c1">// 去除重复
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="n">hi</span> <span class="o">=</span> <span class="n">FirstHeader</span><span class="p">;</span> <span class="n">hi</span><span class="p">;</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">hi</span><span class="o">-&gt;</span><span class="n">getNext</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mhdr</span> <span class="o">==</span> <span class="n">hi</span><span class="o">-&gt;</span><span class="n">mhdr</span><span class="p">())</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Locate the __OBJC segment
</span><span class="c1"></span>        <span class="c1">// 定位 __OBJC 段（Segment）
</span><span class="c1"></span>        <span class="n">size_t</span> <span class="n">info_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seg_size</span><span class="p">;</span>
        <span class="c1">// _getObjcImageInfo：内部实际是获取 __objc_imageinfo 数据（__DATA 或 __DATA_CONST 或 __DATA_DIRTY）节（Section）信息
</span><span class="c1"></span>        <span class="k">const</span> <span class="n">objc_image_info</span> <span class="o">*</span><span class="n">image_info</span> <span class="o">=</span> <span class="n">_getObjcImageInfo</span><span class="p">(</span><span class="n">mhdr</span><span class="p">,</span><span class="o">&amp;</span><span class="n">info_size</span><span class="p">);</span>
        <span class="c1">// getsegmentdata：获取 __OBJC 段数据
</span><span class="c1"></span>        <span class="c1">// #define	SEG_OBJC	&#34;__OBJC&#34;	/* objective-C runtime segment */
</span><span class="c1"></span>        <span class="k">const</span> <span class="n">uint8_t</span> <span class="o">*</span><span class="n">objc_segment</span> <span class="o">=</span> <span class="n">getsegmentdata</span><span class="p">(</span><span class="n">mhdr</span><span class="p">,</span><span class="n">SEG_OBJC</span><span class="p">,</span><span class="o">&amp;</span><span class="n">seg_size</span><span class="p">);</span>
        <span class="c1">// 若都没有获取到，返回空
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">objc_segment</span>  <span class="o">&amp;&amp;</span>  <span class="o">!</span><span class="n">image_info</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="c1">// Allocate a header_info entry.
</span><span class="c1"></span>        <span class="c1">// 分配一个 header_info。
</span><span class="c1"></span>        <span class="c1">// Note we also allocate space for a single header_info_rw in the
</span><span class="c1"></span>        <span class="c1">// rw_data[] inside header_info.
</span><span class="c1"></span>        <span class="c1">// 注意我们在 header_info 内部的 rw_data[] 也为单个 header_info_rw 分配了空间。
</span><span class="c1"></span>        <span class="n">hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">header_info</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">header_info</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">header_info_rw</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>

        <span class="c1">// Set up the new header_info entry.
</span><span class="c1"></span>        <span class="c1">// 设置新的 header_info。
</span><span class="c1"></span>        <span class="n">hi</span><span class="o">-&gt;</span><span class="n">setmhdr</span><span class="p">(</span><span class="n">mhdr</span><span class="p">);</span>
<span class="cp">#if !__OBJC2__
</span><span class="cp"></span>        <span class="c1">// mhdr must already be set
</span><span class="c1"></span>        <span class="n">hi</span><span class="o">-&gt;</span><span class="n">mod_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">hi</span><span class="o">-&gt;</span><span class="n">mod_ptr</span> <span class="o">=</span> <span class="n">_getObjcModules</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hi</span><span class="o">-&gt;</span><span class="n">mod_count</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="cp"></span>        <span class="c1">// Install a placeholder image_info if absent to simplify code elsewhere
</span><span class="c1"></span>        <span class="c1">// 如果没有在其他地方简化代码则安装占位符 image_info
</span><span class="c1"></span>        <span class="k">static</span> <span class="k">const</span> <span class="n">objc_image_info</span> <span class="n">emptyInfo</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
        <span class="n">hi</span><span class="o">-&gt;</span><span class="n">setinfo</span><span class="p">(</span><span class="n">image_info</span> <span class="o">?:</span> <span class="o">&amp;</span><span class="n">emptyInfo</span><span class="p">);</span>

        <span class="c1">// 设置已加载为 true
</span><span class="c1"></span>        <span class="n">hi</span><span class="o">-&gt;</span><span class="n">setLoaded</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
        <span class="n">hi</span><span class="o">-&gt;</span><span class="n">setAllClassesRealized</span><span class="p">(</span><span class="nb">NO</span><span class="p">);</span>
    <span class="p">}</span>

<span class="cp">#if __OBJC2__
</span><span class="cp"></span>    <span class="p">{</span>
        <span class="n">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// 在 __objc_classlist 节获取类列表
</span><span class="c1"></span>        <span class="c1">// GETSECT(_getObjc2ClassList,           classref_t,      &#34;__objc_classlist&#34;);
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">_getObjc2ClassList</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// totalClasses 设置为获取到的类数量
</span><span class="c1"></span>            <span class="n">totalClasses</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">count</span><span class="p">;</span>
            <span class="c1">// 若获取的 header_info 不在共享缓存中，则视为未优化类，更新 unoptimizedTotalClasses
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inSharedCache</span><span class="p">)</span> <span class="n">unoptimizedTotalClasses</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="cp">#endif
</span><span class="cp"></span>
    <span class="n">appendHeader</span><span class="p">(</span><span class="n">hi</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">hi</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// objc-runtime-new.mm
</span><span class="c1"></span><span class="cm">/***********************************************************************
</span><span class="cm">* _read_images
</span><span class="cm">* Perform initial processing of the headers in the linked
</span><span class="cm">* list beginning with headerList.
</span><span class="cm">* 从 headerList 开始为链表中的头部执行初始处理。
</span><span class="cm">*
</span><span class="cm">* Called by: map_images_nolock
</span><span class="cm">* 由 map_images_nolock 调用
</span><span class="cm">*
</span><span class="cm">* Locking: runtimeLock acquired by map_images
</span><span class="cm">* 锁：由 map_images 获得的 runtimeLock
</span><span class="cm">**********************************************************************/</span>
<span class="kt">void</span> <span class="nf">_read_images</span><span class="p">(</span><span class="n">header_info</span> <span class="o">**</span><span class="n">hList</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">hCount</span><span class="p">,</span> <span class="kt">int</span> <span class="n">totalClasses</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unoptimizedTotalClasses</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">header_info</span> <span class="o">*</span><span class="n">hi</span><span class="p">;</span>
    <span class="n">uint32_t</span> <span class="n">hIndex</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">count</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">Class</span> <span class="o">*</span><span class="n">resolvedFutureClasses</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">resolvedFutureClassCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">doneOnce</span><span class="p">;</span>
    <span class="n">TimeLogger</span> <span class="n">ts</span><span class="p">(</span><span class="n">PrintImageTimes</span><span class="p">);</span>

    <span class="n">runtimeLock</span><span class="p">.</span><span class="n">assertLocked</span><span class="p">();</span>

<span class="cp">#define EACH_HEADER \
</span><span class="cp">    hIndex = 0;         \
</span><span class="cp">    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \
</span><span class="cp">    hIndex++
</span><span class="cp"></span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">doneOnce</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">doneOnce</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>

<span class="cp">#if SUPPORT_NONPOINTER_ISA
</span><span class="cp"></span>        <span class="c1">// Disable non-pointer isa under some conditions.
</span><span class="c1"></span>
<span class="cp"># if SUPPORT_INDEXED_ISA
</span><span class="cp"></span>        <span class="c1">// Disable nonpointer isa if any image contains old Swift code
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">hi</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">containsSwift</span><span class="p">()</span>  <span class="o">&amp;&amp;</span>
                <span class="n">hi</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">swiftVersion</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">objc_image_info</span><span class="o">::</span><span class="n">SwiftVersion3</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">DisableNonpointerIsa</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">PrintRawIsa</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;RAW ISA: disabling non-pointer isa because &#34;</span>
                                 <span class="s">&#34;the app or a framework contains Swift code &#34;</span>
                                 <span class="s">&#34;older than Swift 3.0&#34;</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
<span class="cp"># endif
</span><span class="cp"></span>
<span class="cp"># if TARGET_OS_OSX
</span><span class="cp"></span>        <span class="c1">// Disable non-pointer isa if the app is too old
</span><span class="c1"></span>        <span class="c1">// (linked before OS X 10.11)
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">dyld_get_program_sdk_version</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">DYLD_MACOSX_VERSION_10_11</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">DisableNonpointerIsa</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">PrintRawIsa</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;RAW ISA: disabling non-pointer isa because &#34;</span>
                             <span class="s">&#34;the app is too old (SDK version &#34;</span> <span class="n">SDK_FORMAT</span> <span class="s">&#34;)&#34;</span><span class="p">,</span>
                             <span class="n">FORMAT_SDK</span><span class="p">(</span><span class="n">dyld_get_program_sdk_version</span><span class="p">()));</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// Disable non-pointer isa if the app has a __DATA,__objc_rawisa section
</span><span class="c1"></span>        <span class="c1">// New apps that load old extensions may need this.
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">hi</span><span class="o">-&gt;</span><span class="n">mhdr</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">filetype</span> <span class="o">!=</span> <span class="n">MH_EXECUTE</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">getsectiondata</span><span class="p">(</span><span class="n">hi</span><span class="o">-&gt;</span><span class="n">mhdr</span><span class="p">(),</span> <span class="s">&#34;__DATA&#34;</span><span class="p">,</span> <span class="s">&#34;__objc_rawisa&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">DisableNonpointerIsa</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">PrintRawIsa</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;RAW ISA: disabling non-pointer isa because &#34;</span>
                                 <span class="s">&#34;the app has a __DATA,__objc_rawisa section&#34;</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>  <span class="c1">// assume only one MH_EXECUTE image
</span><span class="c1"></span>        <span class="p">}</span>
<span class="cp"># endif
</span><span class="cp"></span>
<span class="cp">#endif
</span><span class="cp"></span>
        <span class="k">if</span> <span class="p">(</span><span class="n">DisableTaggedPointers</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">disableTaggedPointers</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">initializeTaggedPointerObfuscator</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">PrintConnecting</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;CLASS: found %d classes during launch&#34;</span><span class="p">,</span> <span class="n">totalClasses</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// namedClasses
</span><span class="c1"></span>        <span class="c1">// Preoptimized classes don&#39;t go in this table.
</span><span class="c1"></span>        <span class="c1">// 4/3 is NXMapTable&#39;s load factor
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">namedClassesSize</span> <span class="o">=</span>
            <span class="p">(</span><span class="n">isPreoptimized</span><span class="p">()</span> <span class="o">?</span> <span class="nl">unoptimizedTotalClasses</span> <span class="p">:</span> <span class="n">totalClasses</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">gdb_objc_realized_classes</span> <span class="o">=</span>
            <span class="n">NXCreateMapTable</span><span class="p">(</span><span class="n">NXStrValueMapPrototype</span><span class="p">,</span> <span class="n">namedClassesSize</span><span class="p">);</span>

        <span class="n">allocatedClasses</span> <span class="o">=</span> <span class="n">NXCreateHashTable</span><span class="p">(</span><span class="n">NXPtrPrototype</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">nil</span><span class="p">);</span>

        <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="s">&#34;IMAGE TIMES: first time tasks&#34;</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="c1">// Discover classes. Fix up unresolved future classes. Mark bundle classes.
</span><span class="c1"></span>
    <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">classref_t</span> <span class="o">*</span><span class="n">classlist</span> <span class="o">=</span> <span class="n">_getObjc2ClassList</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">mustReadClasses</span><span class="p">(</span><span class="n">hi</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// Image is sufficiently optimized that we need not call readClass()
</span><span class="c1"></span>            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="n">headerIsBundle</span> <span class="o">=</span> <span class="n">hi</span><span class="o">-&gt;</span><span class="n">isBundle</span><span class="p">();</span>
        <span class="kt">bool</span> <span class="n">headerIsPreoptimized</span> <span class="o">=</span> <span class="n">hi</span><span class="o">-&gt;</span><span class="n">isPreoptimized</span><span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="p">(</span><span class="kt">Class</span><span class="p">)</span><span class="n">classlist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="kt">Class</span> <span class="n">newCls</span> <span class="o">=</span> <span class="n">readClass</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">headerIsBundle</span><span class="p">,</span> <span class="n">headerIsPreoptimized</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">newCls</span> <span class="o">!=</span> <span class="n">cls</span>  <span class="o">&amp;&amp;</span>  <span class="n">newCls</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Class was moved but not deleted. Currently this occurs
</span><span class="c1"></span>                <span class="c1">// only when the new class resolved a future class.
</span><span class="c1"></span>                <span class="c1">// Non-lazily realize the class below.
</span><span class="c1"></span>                <span class="n">resolvedFutureClasses</span> <span class="o">=</span> <span class="p">(</span><span class="kt">Class</span> <span class="o">*</span><span class="p">)</span>
                    <span class="n">realloc</span><span class="p">(</span><span class="n">resolvedFutureClasses</span><span class="p">,</span>
                            <span class="p">(</span><span class="n">resolvedFutureClassCount</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">Class</span><span class="p">));</span>
                <span class="n">resolvedFutureClasses</span><span class="p">[</span><span class="n">resolvedFutureClassCount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">newCls</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="s">&#34;IMAGE TIMES: discover classes&#34;</span><span class="p">);</span>

    <span class="c1">// Fix up remapped classes
</span><span class="c1"></span>    <span class="c1">// Class list and nonlazy class list remain unremapped.
</span><span class="c1"></span>    <span class="c1">// Class refs and super refs are remapped for message dispatching.
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">noClassesRemapped</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">Class</span> <span class="o">*</span><span class="n">classrefs</span> <span class="o">=</span> <span class="n">_getObjc2ClassRefs</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">remapClassRef</span><span class="p">(</span><span class="o">&amp;</span><span class="n">classrefs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="c1">// fixme why doesn&#39;t test future1 catch the absence of this?
</span><span class="c1"></span>            <span class="n">classrefs</span> <span class="o">=</span> <span class="n">_getObjc2SuperRefs</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">remapClassRef</span><span class="p">(</span><span class="o">&amp;</span><span class="n">classrefs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="s">&#34;IMAGE TIMES: remap classes&#34;</span><span class="p">);</span>

    <span class="c1">// Fix up @selector references
</span><span class="c1"></span>    <span class="k">static</span> <span class="n">size_t</span> <span class="n">UnfixedSelectors</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="n">mutex_locker_t</span> <span class="n">lock</span><span class="p">(</span><span class="n">selLock</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">hi</span><span class="o">-&gt;</span><span class="n">isPreoptimized</span><span class="p">())</span> <span class="k">continue</span><span class="p">;</span>

            <span class="kt">bool</span> <span class="n">isBundle</span> <span class="o">=</span> <span class="n">hi</span><span class="o">-&gt;</span><span class="n">isBundle</span><span class="p">();</span>
            <span class="kt">SEL</span> <span class="o">*</span><span class="n">sels</span> <span class="o">=</span> <span class="n">_getObjc2SelectorRefs</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
            <span class="n">UnfixedSelectors</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">sel_cname</span><span class="p">(</span><span class="n">sels</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="n">sels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sel_registerNameNoLock</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">isBundle</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="s">&#34;IMAGE TIMES: fix up selector references&#34;</span><span class="p">);</span>

<span class="cp">#if SUPPORT_FIXUP
</span><span class="cp"></span>    <span class="c1">// Fix up old objc_msgSend_fixup call sites
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">message_ref_t</span> <span class="o">*</span><span class="n">refs</span> <span class="o">=</span> <span class="n">_getObjc2MessageRefs</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">PrintVtables</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;VTABLES: repairing %zu unsupported vtable dispatch &#34;</span>
                         <span class="s">&#34;call sites in %s&#34;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">hi</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fixupMessageRef</span><span class="p">(</span><span class="n">refs</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="s">&#34;IMAGE TIMES: fix up objc_msgSend_fixup&#34;</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="cp"></span>
    <span class="c1">// Discover protocols. Fix up protocol refs.
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">extern</span> <span class="n">objc_class</span> <span class="n">OBJC_CLASS_</span><span class="err">$</span><span class="n">_Protocol</span><span class="p">;</span>
        <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="p">(</span><span class="kt">Class</span><span class="p">)</span><span class="o">&amp;</span><span class="n">OBJC_CLASS_</span><span class="err">$</span><span class="n">_Protocol</span><span class="p">;</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
        <span class="n">NXMapTable</span> <span class="o">*</span><span class="n">protocol_map</span> <span class="o">=</span> <span class="n">protocols</span><span class="p">();</span>
        <span class="kt">bool</span> <span class="n">isPreoptimized</span> <span class="o">=</span> <span class="n">hi</span><span class="o">-&gt;</span><span class="n">isPreoptimized</span><span class="p">();</span>
        <span class="kt">bool</span> <span class="n">isBundle</span> <span class="o">=</span> <span class="n">hi</span><span class="o">-&gt;</span><span class="n">isBundle</span><span class="p">();</span>

        <span class="n">protocol_t</span> <span class="o">**</span><span class="n">protolist</span> <span class="o">=</span> <span class="n">_getObjc2ProtocolList</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">readProtocol</span><span class="p">(</span><span class="n">protolist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cls</span><span class="p">,</span> <span class="n">protocol_map</span><span class="p">,</span>
                         <span class="n">isPreoptimized</span><span class="p">,</span> <span class="n">isBundle</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="s">&#34;IMAGE TIMES: discover protocols&#34;</span><span class="p">);</span>

    <span class="c1">// Fix up @protocol references
</span><span class="c1"></span>    <span class="c1">// Preoptimized images may have the right
</span><span class="c1"></span>    <span class="c1">// answer already but we don&#39;t know for sure.
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">protocol_t</span> <span class="o">**</span><span class="n">protolist</span> <span class="o">=</span> <span class="n">_getObjc2ProtocolRefs</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">remapProtocolRef</span><span class="p">(</span><span class="o">&amp;</span><span class="n">protolist</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="s">&#34;IMAGE TIMES: fix up @protocol references&#34;</span><span class="p">);</span>

    <span class="c1">// Realize non-lazy classes (for +load methods and static instances)
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">classref_t</span> <span class="o">*</span><span class="n">classlist</span> <span class="o">=</span>
            <span class="n">_getObjc2NonlazyClassList</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">remapClass</span><span class="p">(</span><span class="n">classlist</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

            <span class="c1">// hack for class __ARCLite__, which didn&#39;t get this above
</span><span class="c1"></span><span class="cp">#if TARGET_OS_SIMULATOR
</span><span class="cp"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">_buckets</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_objc_empty_cache</span>  <span class="o">&amp;&amp;</span>
                <span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">_mask</span>  <span class="o">||</span>  <span class="n">cls</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">_occupied</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">cls</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">cls</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">_occupied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">ISA</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">_buckets</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_objc_empty_cache</span>  <span class="o">&amp;&amp;</span>
                <span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">ISA</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">_mask</span>  <span class="o">||</span>  <span class="n">cls</span><span class="o">-&gt;</span><span class="n">ISA</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">_occupied</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">cls</span><span class="o">-&gt;</span><span class="n">ISA</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">cls</span><span class="o">-&gt;</span><span class="n">ISA</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">.</span><span class="n">_occupied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
<span class="cp">#endif
</span><span class="cp"></span>
            <span class="n">addClassTableEntry</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
            <span class="n">realizeClass</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="s">&#34;IMAGE TIMES: realize non-lazy classes&#34;</span><span class="p">);</span>

    <span class="c1">// Realize newly-resolved future classes, in case CF manipulates them
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">resolvedFutureClasses</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">resolvedFutureClassCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">realizeClass</span><span class="p">(</span><span class="n">resolvedFutureClasses</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">resolvedFutureClasses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setInstancesRequireRawIsa</span><span class="p">(</span><span class="nb">false</span><span class="cm">/*inherited*/</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">free</span><span class="p">(</span><span class="n">resolvedFutureClasses</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="s">&#34;IMAGE TIMES: realize future classes&#34;</span><span class="p">);</span>

    <span class="c1">// ➡️ Category
</span><span class="c1"></span>    <span class="c1">// Discover categories.
</span><span class="c1"></span>    <span class="c1">// 发现 Category。
</span><span class="c1"></span>    <span class="c1">// 遍历 hList 中的 header_info
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 在 __objc_catlist 节获取 Category 列表
</span><span class="c1"></span>        <span class="c1">// GETSECT(_getObjc2CategoryList,        category_t *,    &#34;__objc_catlist&#34;);
</span><span class="c1"></span>        <span class="n">category_t</span> <span class="o">**</span><span class="n">catlist</span> <span class="o">=</span>
            <span class="n">_getObjc2CategoryList</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
        <span class="kt">bool</span> <span class="n">hasClassProperties</span> <span class="o">=</span> <span class="n">hi</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasCategoryClassProperties</span><span class="p">();</span>

        <span class="c1">// 遍历 Category
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 获取第 i 个 Category，类型为 category_t
</span><span class="c1"></span>            <span class="n">category_t</span> <span class="o">*</span><span class="n">cat</span> <span class="o">=</span> <span class="n">catlist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="c1">// 根据 Category 的 cls 重新映射类
</span><span class="c1"></span>            <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">remapClass</span><span class="p">(</span><span class="n">cat</span><span class="o">-&gt;</span><span class="n">cls</span><span class="p">);</span>

            <span class="c1">// 类为空时
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Category&#39;s target class is missing (probably weak-linked).
</span><span class="c1"></span>                <span class="c1">// Category 的目标类丢失（可能为弱链接）。
</span><span class="c1"></span>                <span class="c1">// Disavow any knowledge of this category.
</span><span class="c1"></span>                <span class="c1">// 否认对此 Category 的任何了解。
</span><span class="c1"></span>                <span class="c1">// 将 Category 置为 nil
</span><span class="c1"></span>                <span class="n">catlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">PrintConnecting</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;CLASS: IGNORING category \?\?\?(%s) %p with &#34;</span>
                                 <span class="s">&#34;missing weak-linked target class&#34;</span><span class="p">,</span>
                                 <span class="n">cat</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cat</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 类非空时
</span><span class="c1"></span>
            <span class="c1">// Process this category.
</span><span class="c1"></span>            <span class="c1">// First, register the category with its target class.
</span><span class="c1"></span>            <span class="c1">// Then, rebuild the class&#39;s method lists (etc) if
</span><span class="c1"></span>            <span class="c1">// the class is realized.
</span><span class="c1"></span>            <span class="c1">// 处理该 Category。
</span><span class="c1"></span>            <span class="c1">// 首先，使用目标类注册 Category。
</span><span class="c1"></span>            <span class="c1">// 然后，如果实现了类，则重建类的方法列表（等）。
</span><span class="c1"></span>            <span class="kt">bool</span> <span class="n">classExists</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
            <span class="c1">// 判断 Category 中存在对象方法、协议、或属性
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">cat</span><span class="o">-&gt;</span><span class="n">instanceMethods</span> <span class="o">||</span>  <span class="n">cat</span><span class="o">-&gt;</span><span class="n">protocols</span>
                <span class="o">||</span>  <span class="n">cat</span><span class="o">-&gt;</span><span class="n">instanceProperties</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// 记录未附加上的 Category
</span><span class="c1"></span>                <span class="n">addUnattachedCategoryForClass</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">isRealized</span><span class="p">())</span> <span class="p">{</span>
                    <span class="c1">// ➡️ 如果实现了类，重建类
</span><span class="c1"></span>                    <span class="n">remethodizeClass</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
                    <span class="n">classExists</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">PrintConnecting</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;CLASS: found category -%s(%s) %s&#34;</span><span class="p">,</span>
                                 <span class="n">cls</span><span class="o">-&gt;</span><span class="n">nameForLogging</span><span class="p">(),</span> <span class="n">cat</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
                                 <span class="n">classExists</span> <span class="o">?</span> <span class="s">&#34;on existing class&#34;</span> <span class="o">:</span> <span class="s">&#34;&#34;</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// 判断 Category 中存在类方法、协议、或类属性
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">cat</span><span class="o">-&gt;</span><span class="n">classMethods</span>  <span class="o">||</span>  <span class="n">cat</span><span class="o">-&gt;</span><span class="n">protocols</span>
                <span class="o">||</span>  <span class="p">(</span><span class="n">hasClassProperties</span> <span class="o">&amp;&amp;</span> <span class="n">cat</span><span class="o">-&gt;</span><span class="n">_classProperties</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="c1">// 记录未附加上的 Category
</span><span class="c1"></span>                <span class="n">addUnattachedCategoryForClass</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">ISA</span><span class="p">(),</span> <span class="n">hi</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">ISA</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isRealized</span><span class="p">())</span> <span class="p">{</span>
                    <span class="c1">// ➡️  如果实现了元类，重建元类
</span><span class="c1"></span>                    <span class="n">remethodizeClass</span><span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">ISA</span><span class="p">());</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">PrintConnecting</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;CLASS: found category +%s(%s)&#34;</span><span class="p">,</span>
                                 <span class="n">cls</span><span class="o">-&gt;</span><span class="n">nameForLogging</span><span class="p">(),</span> <span class="n">cat</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ts</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="s">&#34;IMAGE TIMES: discover categories&#34;</span><span class="p">);</span>

    <span class="c1">// Category discovery MUST BE LAST to avoid potential races
</span><span class="c1"></span>    <span class="c1">// when other threads call the new category code before
</span><span class="c1"></span>    <span class="c1">// this thread finishes its fixups.
</span><span class="c1"></span>
    <span class="c1">// +load handled by prepare_load_methods()
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="n">DebugNonFragileIvars</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">realizeAllClasses</span><span class="p">();</span>
    <span class="p">}</span>


    <span class="c1">// Print preoptimization statistics
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">PrintPreopt</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">PreoptTotalMethodLists</span><span class="p">;</span>
        <span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">PreoptOptimizedMethodLists</span><span class="p">;</span>
        <span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">PreoptTotalClasses</span><span class="p">;</span>
        <span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">PreoptOptimizedClasses</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">hi</span><span class="o">-&gt;</span><span class="n">isPreoptimized</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;PREOPTIMIZATION: honoring preoptimized selectors &#34;</span>
                             <span class="s">&#34;in %s&#34;</span><span class="p">,</span> <span class="n">hi</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hi</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">optimizedByDyld</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;PREOPTIMIZATION: IGNORING preoptimized selectors &#34;</span>
                             <span class="s">&#34;in %s&#34;</span><span class="p">,</span> <span class="n">hi</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="n">classref_t</span> <span class="o">*</span><span class="n">classlist</span> <span class="o">=</span> <span class="n">_getObjc2ClassList</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">remapClass</span><span class="p">(</span><span class="n">classlist</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

                <span class="n">PreoptTotalClasses</span><span class="o">++</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">hi</span><span class="o">-&gt;</span><span class="n">isPreoptimized</span><span class="p">())</span> <span class="p">{</span>
                    <span class="n">PreoptOptimizedClasses</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">const</span> <span class="n">method_list_t</span> <span class="o">*</span><span class="n">mlist</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">mlist</span> <span class="o">=</span> <span class="p">((</span><span class="n">class_ro_t</span> <span class="o">*</span><span class="p">)</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">())</span><span class="o">-&gt;</span><span class="n">baseMethods</span><span class="p">()))</span> <span class="p">{</span>
                    <span class="n">PreoptTotalMethodLists</span><span class="o">++</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">mlist</span><span class="o">-&gt;</span><span class="n">isFixedUp</span><span class="p">())</span> <span class="p">{</span>
                        <span class="n">PreoptOptimizedMethodLists</span><span class="o">++</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">mlist</span><span class="o">=</span><span class="p">((</span><span class="n">class_ro_t</span> <span class="o">*</span><span class="p">)</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">ISA</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">())</span><span class="o">-&gt;</span><span class="n">baseMethods</span><span class="p">()))</span> <span class="p">{</span>
                    <span class="n">PreoptTotalMethodLists</span><span class="o">++</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">mlist</span><span class="o">-&gt;</span><span class="n">isFixedUp</span><span class="p">())</span> <span class="p">{</span>
                        <span class="n">PreoptOptimizedMethodLists</span><span class="o">++</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;PREOPTIMIZATION: %zu selector references not &#34;</span>
                     <span class="s">&#34;pre-optimized&#34;</span><span class="p">,</span> <span class="n">UnfixedSelectors</span><span class="p">);</span>
        <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;PREOPTIMIZATION: %u/%u (%.3g%%) method lists pre-sorted&#34;</span><span class="p">,</span>
                     <span class="n">PreoptOptimizedMethodLists</span><span class="p">,</span> <span class="n">PreoptTotalMethodLists</span><span class="p">,</span>
                     <span class="n">PreoptTotalMethodLists</span>
                     <span class="o">?</span> <span class="mf">100.0</span><span class="o">*</span><span class="n">PreoptOptimizedMethodLists</span><span class="o">/</span><span class="nl">PreoptTotalMethodLists</span>
                     <span class="p">:</span> <span class="mf">0.0</span><span class="p">);</span>
        <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;PREOPTIMIZATION: %u/%u (%.3g%%) classes pre-registered&#34;</span><span class="p">,</span>
                     <span class="n">PreoptOptimizedClasses</span><span class="p">,</span> <span class="n">PreoptTotalClasses</span><span class="p">,</span>
                     <span class="n">PreoptTotalClasses</span>
                     <span class="o">?</span> <span class="mf">100.0</span><span class="o">*</span><span class="n">PreoptOptimizedClasses</span><span class="o">/</span><span class="nl">PreoptTotalClasses</span>
                     <span class="p">:</span> <span class="mf">0.0</span><span class="p">);</span>
        <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;PREOPTIMIZATION: %zu protocol references not &#34;</span>
                     <span class="s">&#34;pre-optimized&#34;</span><span class="p">,</span> <span class="n">UnfixedProtocolReferences</span><span class="p">);</span>
    <span class="p">}</span>

<span class="cp">#undef EACH_HEADER
</span><span class="cp"></span><span class="p">}</span>

<span class="c1">// objc-runtime-new.mm
</span><span class="c1"></span><span class="cm">/***********************************************************************
</span><span class="cm">* remethodizeClass
</span><span class="cm">* Attach outstanding categories to an existing class.
</span><span class="cm">* 将未完成的 Category 附加到现有类。
</span><span class="cm">* Fixes up cls&#39;s method list, protocol list, and property list.
</span><span class="cm">* 修复 cls 的方法列表、协议列表、以及属性列表。
</span><span class="cm">* Updates method caches for cls and its subclasses.
</span><span class="cm">* 更新 cls 以及其子类的方法缓存。
</span><span class="cm">* Locking: runtimeLock must be held by the caller
</span><span class="cm">* 锁：调用者必须持有 runtimeLock
</span><span class="cm">**********************************************************************/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">remethodizeClass</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Category 列表
</span><span class="c1"></span>    <span class="n">category_list</span> <span class="o">*</span><span class="n">cats</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">isMeta</span><span class="p">;</span>

    <span class="n">runtimeLock</span><span class="p">.</span><span class="n">assertLocked</span><span class="p">();</span>

    <span class="c1">// 是否为元类
</span><span class="c1"></span>    <span class="n">isMeta</span> <span class="o">=</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">isMetaClass</span><span class="p">();</span>

    <span class="c1">// Re-methodizing: check for more categories
</span><span class="c1"></span>    <span class="c1">// 重新方法化：检查更多的 Category
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">cats</span> <span class="o">=</span> <span class="n">unattachedCategoriesForClass</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="nb">false</span><span class="cm">/*not realizing*/</span><span class="p">)))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PrintConnecting</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&#34;CLASS: attaching categories to class &#39;%s&#39; %s&#34;</span><span class="p">,</span>
                         <span class="n">cls</span><span class="o">-&gt;</span><span class="n">nameForLogging</span><span class="p">(),</span> <span class="n">isMeta</span> <span class="o">?</span> <span class="s">&#34;(meta)&#34;</span> <span class="o">:</span> <span class="s">&#34;&#34;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// ➡️ 附加 Category（类/元类，Category，是否刷新缓存）
</span><span class="c1"></span>        <span class="n">attachCategories</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">cats</span><span class="p">,</span> <span class="nb">true</span> <span class="cm">/*flush caches*/</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">cats</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// objc-runtime-new.mm
</span><span class="c1">// Attach method lists and properties and protocols from categories to a class.
</span><span class="c1">// 将所有 Category 的方法列表、属性列表、协议列表附加到类上。
</span><span class="c1">// Assumes the categories in cats are all loaded and sorted by load order,
</span><span class="c1">// oldest categories first.
</span><span class="c1">// 假设 cats 中的 Category 都已加载并由加载顺序排序，则最后（编译）的 Category 排在最先。
</span><span class="c1"></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">attachCategories</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="n">category_list</span> <span class="o">*</span><span class="n">cats</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flush_caches</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cats</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="c1">// ➡️ Xcode 中 OBJC_PRINT_REPLACED_METHODS 环境变量值为 YES 时，将可在控制台打印该信息
</span><span class="c1"></span>    <span class="c1">// OPTION(PrintReplacedMethods, OBJC_PRINT_REPLACED_METHODS, &#34;log methods replaced by category implementations&#34;)
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">PrintReplacedMethods</span><span class="p">)</span> <span class="n">printReplacements</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">cats</span><span class="p">);</span>

    <span class="c1">// 是否是元类
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="n">isMeta</span> <span class="o">=</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">isMetaClass</span><span class="p">();</span>

    <span class="c1">// fixme rearrange to remove these intermediate allocations
</span><span class="c1"></span>    <span class="c1">// 方法列表（指向指针的指针，存储了两维：eg. [[cat_1-&gt;method_a, cat_1-&gt;method_b], [cat_2-&gt;method_c, cat_2-&gt;method_d]]）
</span><span class="c1"></span>    <span class="n">method_list_t</span> <span class="o">**</span><span class="n">mlists</span> <span class="o">=</span> <span class="p">(</span><span class="n">method_list_t</span> <span class="o">**</span><span class="p">)</span>
        <span class="n">malloc</span><span class="p">(</span><span class="n">cats</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mlists</span><span class="p">));</span>
    <span class="c1">// 属性列表
</span><span class="c1"></span>    <span class="n">property_list_t</span> <span class="o">**</span><span class="n">proplists</span> <span class="o">=</span> <span class="p">(</span><span class="n">property_list_t</span> <span class="o">**</span><span class="p">)</span>
        <span class="n">malloc</span><span class="p">(</span><span class="n">cats</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">proplists</span><span class="p">));</span>
    <span class="c1">// 协议列表
</span><span class="c1"></span>    <span class="n">protocol_list_t</span> <span class="o">**</span><span class="n">protolists</span> <span class="o">=</span> <span class="p">(</span><span class="n">protocol_list_t</span> <span class="o">**</span><span class="p">)</span>
        <span class="n">malloc</span><span class="p">(</span><span class="n">cats</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">protolists</span><span class="p">));</span>

    <span class="c1">// Count backwards through cats to get newest categories first
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">mcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">propcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">protocount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// i = Category 的个数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cats</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">fromBundle</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
    <span class="c1">// ➡️ 将所有 Category 中的方法、属性、协议提取出
</span><span class="c1"></span>    <span class="c1">// 倒数 i
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// entry = 一个 Category
</span><span class="c1"></span>        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">cats</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="c1">// mlist = Category 中的方法列表
</span><span class="c1"></span>        <span class="n">method_list_t</span> <span class="o">*</span><span class="n">mlist</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">cat</span><span class="o">-&gt;</span><span class="n">methodsForMeta</span><span class="p">(</span><span class="n">isMeta</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mlist</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">mlists</span><span class="p">[</span><span class="n">mcount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">mlist</span><span class="p">;</span>
            <span class="n">fromBundle</span> <span class="o">|=</span> <span class="n">entry</span><span class="p">.</span><span class="n">hi</span><span class="o">-&gt;</span><span class="n">isBundle</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c1">// proplist = Category 中的属性列表
</span><span class="c1"></span>        <span class="n">property_list_t</span> <span class="o">*</span><span class="n">proplist</span> <span class="o">=</span>
            <span class="n">entry</span><span class="p">.</span><span class="n">cat</span><span class="o">-&gt;</span><span class="n">propertiesForMeta</span><span class="p">(</span><span class="n">isMeta</span><span class="p">,</span> <span class="n">entry</span><span class="p">.</span><span class="n">hi</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">proplist</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">proplists</span><span class="p">[</span><span class="n">propcount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">proplist</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// protolist = Category 中的协议列表
</span><span class="c1"></span>        <span class="n">protocol_list_t</span> <span class="o">*</span><span class="n">protolist</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">cat</span><span class="o">-&gt;</span><span class="n">protocols</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">protolist</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">protolists</span><span class="p">[</span><span class="n">protocount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">protolist</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// rw = 类/元类对象的 class_rw_t *data()
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">rw</span> <span class="o">=</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">();</span>

    <span class="n">prepareMethodLists</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">mlists</span><span class="p">,</span> <span class="n">mcount</span><span class="p">,</span> <span class="nb">NO</span><span class="p">,</span> <span class="n">fromBundle</span><span class="p">);</span>
    <span class="c1">// ➡️ Category 方法列表 -&gt; 类/元类方法列表，方法列表数量（上述二维中第一维的大小）
</span><span class="c1"></span>    <span class="n">rw</span><span class="o">-&gt;</span><span class="n">methods</span><span class="p">.</span><span class="n">attachLists</span><span class="p">(</span><span class="n">mlists</span><span class="p">,</span> <span class="n">mcount</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">mlists</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flush_caches</span>  <span class="o">&amp;&amp;</span>  <span class="n">mcount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">flushCaches</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>

    <span class="c1">// ➡️ Category 属性列表 -&gt; 类/元类属性列表，属性列表数量（上述二维中第一维的大小）
</span><span class="c1"></span>    <span class="n">rw</span><span class="o">-&gt;</span><span class="n">properties</span><span class="p">.</span><span class="n">attachLists</span><span class="p">(</span><span class="n">proplists</span><span class="p">,</span> <span class="n">propcount</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">proplists</span><span class="p">);</span>

    <span class="c1">// ➡️ Category 协议列表 -&gt; 类/元类协议列表，协议列表数量（上述二维中第一维的大小）
</span><span class="c1"></span>    <span class="n">rw</span><span class="o">-&gt;</span><span class="n">protocols</span><span class="p">.</span><span class="n">attachLists</span><span class="p">(</span><span class="n">protolists</span><span class="p">,</span> <span class="n">protocount</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">protolists</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// objc-runtime-new.h
</span><span class="c1"></span><span class="k">class</span> <span class="n">list_array_tt</span> <span class="p">{</span>
 <span class="nl">public</span><span class="p">:</span>
    <span class="kt">void</span> <span class="n">attachLists</span><span class="p">(</span><span class="n">List</span><span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">addedLists</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">addedCount</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">addedCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">hasArray</span><span class="p">())</span> <span class="p">{</span>
            <span class="c1">// many lists -&gt; many lists
</span><span class="c1"></span>            <span class="c1">// oldCount = 原有的大小
</span><span class="c1"></span>            <span class="n">uint32_t</span> <span class="n">oldCount</span> <span class="o">=</span> <span class="n">array</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
            <span class="c1">// newCount = 原有 + 新增
</span><span class="c1"></span>            <span class="n">uint32_t</span> <span class="n">newCount</span> <span class="o">=</span> <span class="n">oldCount</span> <span class="o">+</span> <span class="n">addedCount</span><span class="p">;</span>
            <span class="c1">// realloc 重新分配内存空间（扩容）
</span><span class="c1"></span>            <span class="n">setArray</span><span class="p">((</span><span class="n">array_t</span> <span class="o">*</span><span class="p">)</span><span class="n">realloc</span><span class="p">(</span><span class="n">array</span><span class="p">(),</span> <span class="n">array_t</span><span class="o">::</span><span class="n">byteSize</span><span class="p">(</span><span class="n">newCount</span><span class="p">)));</span>
            <span class="c1">// 设置为新大小
</span><span class="c1"></span>            <span class="n">array</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">newCount</span><span class="p">;</span>
            <span class="c1">// array()-&gt;lists 为原有列表的指针
</span><span class="c1"></span>            <span class="c1">// 将指针指向的内存内容向后偏移 addedCount
</span><span class="c1"></span>            <span class="c1">// void    *memmove(void *__dst, const void *__src, size_t __len);
</span><span class="c1"></span>            <span class="n">memmove</span><span class="p">(</span><span class="n">array</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">lists</span> <span class="o">+</span> <span class="n">addedCount</span><span class="p">,</span> <span class="n">array</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">,</span>
                    <span class="n">oldCount</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">array</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
            <span class="c1">// addedLists 为所有 Category 中相应列表（如方法列表等）的指针
</span><span class="c1"></span>            <span class="c1">// 将指针指向的内存内容拷贝到原有列表的指针地址处
</span><span class="c1"></span>            <span class="c1">// void    *memcpy(void *__dst, const void *__src, size_t __n);
</span><span class="c1"></span>            <span class="n">memcpy</span><span class="p">(</span><span class="n">array</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">,</span> <span class="n">addedLists</span><span class="p">,</span>
                   <span class="n">addedCount</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">array</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list</span>  <span class="o">&amp;&amp;</span>  <span class="n">addedCount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 0 lists -&gt; 1 list
</span><span class="c1"></span>            <span class="n">list</span> <span class="o">=</span> <span class="n">addedLists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 1 list -&gt; many lists
</span><span class="c1"></span>            <span class="n">List</span><span class="o">*</span> <span class="n">oldList</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
            <span class="n">uint32_t</span> <span class="n">oldCount</span> <span class="o">=</span> <span class="n">oldList</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">uint32_t</span> <span class="n">newCount</span> <span class="o">=</span> <span class="n">oldCount</span> <span class="o">+</span> <span class="n">addedCount</span><span class="p">;</span>
            <span class="n">setArray</span><span class="p">((</span><span class="n">array_t</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">array_t</span><span class="o">::</span><span class="n">byteSize</span><span class="p">(</span><span class="n">newCount</span><span class="p">)));</span>
            <span class="n">array</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">newCount</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">oldList</span><span class="p">)</span> <span class="n">array</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">[</span><span class="n">addedCount</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldList</span><span class="p">;</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">array</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">,</span> <span class="n">addedLists</span><span class="p">,</span>
                   <span class="n">addedCount</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">array</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><p>从 <code>realloc</code> 到 <code>memmove</code> 和 <code>memcpy</code> 部分可以参考下图：</p>
<p><img src="/img/2019/category_in_ios/3.png" alt="3"></p>
<p>因此，对于 Category 在运行时将其中的方法、属性、协议加载到主类的过程搞明白后，之前的结论就水落石出。越靠后编译的 Category，其方法列表最终就越靠前。因此在调用时，虽然主类和其他 Category 中的方法并没有被覆盖，但会因为在前面已经被找到并调用而无法调用到。也是因为方法并没有被覆盖，如果我们在 Category 中仅声明却不实现，运行时仍将找到主类中的实现。从上面源码分析中我们也可以发现，在 Xcode 设置 <code>OBJC_PRINT_REPLACED_METHODS</code> 环境变量为 <code>YES</code> 后，就可以在运行时输出所有被替换的方法（若添加后仍未输出我们自定义类的替换信息，可以在尝试主类和所有 Category 中添加 <code>+ (void)load</code> 方法实现后重试）：</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">objc[17895]: REPLACED: -[Person smile]  by category Life  (IMP was 0x100001b90 (/Users/kingcos/Library/Developer/Xcode/DerivedData/Category_in_Obj-C-cgesibqaizbvgnckrzeofmpfkmmy/Build/Products/Debug/Category_in_Obj-C), now 0x100001b00 (/Users/kingcos/Library/Developer/Xcode/DerivedData/Category_in_Obj-C-cgesibqaizbvgnckrzeofmpfkmmy/Build/Products/Debug/Category_in_Obj-C))
objc[17895]: REPLACED: -[Person smile]  by category Work  (IMP was 0x100001b00 (/Users/kingcos/Library/Developer/Xcode/DerivedData/Category_in_Obj-C-cgesibqaizbvgnckrzeofmpfkmmy/Build/Products/Debug/Category_in_Obj-C), now 0x100001b40 (/Users/kingcos/Library/Developer/Xcode/DerivedData/Category_in_Obj-C-cgesibqaizbvgnckrzeofmpfkmmy/Build/Products/Debug/Category_in_Obj-C))
</code></pre></div><p>第一条的替换，是指 Person+Life 替换了 Person 中的 <code>smile</code> 方法，而第二条指 Person+Work 再次替换了 Person+Life 中的 <code>smile</code> 方法，因此最终也由 Person+Work 中的方法被调用，最终也与我们的结论一致。</p>
<h3 id="memmove--memcpy">memmove &amp; memcpy</h3>
<p>上一节中，Category 中内容列表与主类融合时，调用了 <code>memmove</code> 和 <code>memcpy</code> 函数，它们其实是 C 语言标准库中的函数，目的都是将一定长度的源内存地址的内容拷贝到目标内存地址中。在 Apple 开源的 XNU - libsyscall 中，<code>memmove</code> 和 <code>memcpy</code> 本质其实是一致的：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// _libc_funcptr.c
</span><span class="c1"></span><span class="n">__attribute__</span><span class="p">((</span><span class="n">visibility</span><span class="p">(</span><span class="s">&#34;hidden&#34;</span><span class="p">)))</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="n">memmove</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_libkernel_string_functions</span><span class="o">-&gt;</span><span class="n">memmove</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">__attribute__</span><span class="p">((</span><span class="n">visibility</span><span class="p">(</span><span class="s">&#34;hidden&#34;</span><span class="p">)))</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="n">memcpy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_libkernel_string_functions</span><span class="o">-&gt;</span><span class="n">memmove</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// _libc_funcptr.c
</span><span class="c1"></span><span class="cm">/*
</span><span class="cm"> * Upcalls to optimized libplatform string functions
</span><span class="cm"> */</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">_libkernel_string_functions</span>
		<span class="n">_libkernel_generic_string_functions</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">bzero</span> <span class="o">=</span> <span class="n">_libkernel_bzero</span><span class="p">,</span>
	<span class="p">.</span><span class="n">memmove</span> <span class="o">=</span> <span class="n">_libkernel_memmove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">memset</span> <span class="o">=</span> <span class="n">_libkernel_memset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">strchr</span> <span class="o">=</span> <span class="n">_libkernel_strchr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">strcmp</span> <span class="o">=</span> <span class="n">_libkernel_strcmp</span><span class="p">,</span>
	<span class="p">.</span><span class="n">strcpy</span> <span class="o">=</span> <span class="n">_libkernel_strcpy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">strlcpy</span> <span class="o">=</span> <span class="n">_libkernel_strlcpy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">strlen</span> <span class="o">=</span> <span class="n">_libkernel_strlen</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">_libkernel_string_functions_t</span> <span class="n">_libkernel_string_functions</span> <span class="o">=</span>
		<span class="o">&amp;</span><span class="n">_libkernel_generic_string_functions</span><span class="p">;</span>

<span class="c1">// memcpy.c
</span><span class="c1"></span><span class="cm">/*
</span><span class="cm"> * sizeof(word) MUST BE A POWER OF TWO
</span><span class="cm"> * SO THAT wmask BELOW IS ALL ONES
</span><span class="cm"> */</span>
<span class="k">typedef</span>    <span class="kt">int</span> <span class="n">word</span><span class="p">;</span>        <span class="cm">/* &#34;word&#34; used for optimal copy speed &#34;字&#34;用作优化拷贝速度 */</span>

<span class="cp">#define    wsize    sizeof(word)
</span><span class="cp">#define    wmask    (wsize - 1)
</span><span class="cp"></span>
<span class="cm">/*
</span><span class="cm"> * Copy a block of memory, handling overlap.
</span><span class="cm"> * 拷贝一块内存，并处理重叠部分。
</span><span class="cm"> * This is the routine that actually implements
</span><span class="cm"> * (the portable versions of) bcopy, memcpy, and memmove.
</span><span class="cm"> * 这是个实际实现了（可移植版本的）bcopy、memcpy、以及 memmove 的例行程序。
</span><span class="cm"> */</span>

<span class="c1">// visibility(&#34;hidden&#34;)：隐藏函数符号
</span><span class="c1"></span><span class="n">__attribute__</span><span class="p">((</span><span class="n">visibility</span><span class="p">(</span><span class="s">&#34;hidden&#34;</span><span class="p">)))</span>
<span class="kt">void</span> <span class="o">*</span> <span class="n">_libkernel_memmove</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst0</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src0</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 保存一份目标、源，但源是常量，而目标是可变的
</span><span class="c1"></span>    <span class="kt">char</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">dst0</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="n">src0</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">t</span><span class="p">;</span>

    <span class="c1">// 长度为 0 或目标等于源时，无需移动
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">dst</span> <span class="o">==</span> <span class="n">src</span><span class="p">)</span>        <span class="cm">/* nothing to do */</span>
        <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

    <span class="cm">/*
</span><span class="cm">     * Macros: loop-t-times; and loop-t-times, t&gt;0
</span><span class="cm">     * 定义循环宏，t 大于 0 时，循环 t 次
</span><span class="cm">     */</span>
<span class="cp">#define    TLOOP(s) if (t) TLOOP1(s)
</span><span class="cp">#define    TLOOP1(s) do { s; } while (--t)
</span><span class="cp"></span>
    <span class="c1">// 如果源 &gt; 目标（高地址 -&gt; 低地址，小端就是向前）
</span><span class="c1"></span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;(unsigned long)dst: %lu; (unsigned long)src: %lu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dst</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">src</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dst</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/*
</span><span class="cm">         * Copy forward.
</span><span class="cm">         * 正向拷贝。
</span><span class="cm">         */</span>
        <span class="c1">// typedef unsigned long           uintptr_t;
</span><span class="c1"></span>        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">uintptr_t</span><span class="p">)</span><span class="n">src</span><span class="p">;</span>    <span class="cm">/* only need low bits 只需要低位 */</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;(t | (uintptr_t)dst) &amp; wmask: %lu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span> <span class="o">|</span> <span class="p">(</span><span class="n">uintptr_t</span><span class="p">)</span><span class="n">dst</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">wmask</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">t</span> <span class="o">|</span> <span class="p">(</span><span class="n">uintptr_t</span><span class="p">)</span><span class="n">dst</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">wmask</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/*
</span><span class="cm">             * Try to align operands.  This cannot be done
</span><span class="cm">             * unless the low bits match.
</span><span class="cm">             * 尝试对齐操作数。除非低位匹配，否则不可这样做。
</span><span class="cm">             */</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">t</span> <span class="o">^</span> <span class="p">(</span><span class="n">uintptr_t</span><span class="p">)</span><span class="n">dst</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">wmask</span> <span class="o">||</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="n">wsize</span><span class="p">)</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">wsize</span> <span class="o">-</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;</span> <span class="n">wmask</span><span class="p">);</span>
            <span class="n">length</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
            <span class="c1">//
</span><span class="c1">//            TLOOP1(*dst++ = *src++);
</span><span class="c1"></span>            <span class="k">do</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">t</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/*
</span><span class="cm">         * Copy whole words, then mop up any trailing bytes.
</span><span class="cm">         * 拷贝整个字，然后删除所有尾字节。
</span><span class="cm">         */</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">wsize</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;t: %zu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="c1">//        TLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">do</span> <span class="p">{</span>
                <span class="c1">// 更改指针指向的一个字长的内容（src -&gt; dst）
</span><span class="c1"></span>                <span class="o">*</span><span class="p">(</span><span class="n">word</span> <span class="o">*</span><span class="p">)</span><span class="n">dst</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">word</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="p">;</span>
                <span class="c1">// dst &amp; src 向前移动一个字长
</span><span class="c1"></span>                <span class="n">src</span> <span class="o">+=</span> <span class="n">wsize</span><span class="p">;</span>
                <span class="n">dst</span> <span class="o">+=</span> <span class="n">wsize</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">t</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;(unsigned long)dst: %lu; (unsigned long)src: %lu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dst</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">src</span><span class="p">);</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">length</span> <span class="o">&amp;</span> <span class="n">wmask</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;t: %zu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="c1">//        TLOOP(*dst++ = *src++);
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">do</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">t</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/*
</span><span class="cm">         * Copy backwards.  Otherwise essentially the same.
</span><span class="cm">         * Alignment works as before, except that it takes
</span><span class="cm">         * (t&amp;wmask) bytes to align, not wsize-(t&amp;wmask).
</span><span class="cm">         * 反向拷贝。否则基本一致。
</span><span class="cm">         * 与之前一样对齐，除了它是以 (t&amp;wmask) 字节对齐，而非 wsize-(t&amp;wmask)。
</span><span class="cm">         */</span>
        <span class="n">src</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
        <span class="n">dst</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">uintptr_t</span><span class="p">)</span><span class="n">src</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;(t | (uintptr_t)dst) &amp; wmask: %lu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span> <span class="o">|</span> <span class="p">(</span><span class="n">uintptr_t</span><span class="p">)</span><span class="n">dst</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">wmask</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">t</span> <span class="o">|</span> <span class="p">(</span><span class="n">uintptr_t</span><span class="p">)</span><span class="n">dst</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">wmask</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">t</span> <span class="o">^</span> <span class="p">(</span><span class="n">uintptr_t</span><span class="p">)</span><span class="n">dst</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">wmask</span> <span class="o">||</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">wsize</span><span class="p">)</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">t</span> <span class="o">&amp;=</span> <span class="n">wmask</span><span class="p">;</span>
            <span class="n">length</span> <span class="o">-=</span> <span class="n">t</span><span class="p">;</span>
<span class="c1">//            TLOOP1(*--dst = *--src);
</span><span class="c1"></span>            <span class="k">do</span> <span class="p">{</span>
                <span class="o">*--</span><span class="n">dst</span> <span class="o">=</span> <span class="o">*--</span><span class="n">src</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">t</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">wsize</span><span class="p">;</span>
<span class="c1">//        TLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">do</span> <span class="p">{</span>
                <span class="n">src</span> <span class="o">-=</span> <span class="n">wsize</span><span class="p">;</span>
                <span class="n">dst</span> <span class="o">-=</span> <span class="n">wsize</span><span class="p">;</span>
                <span class="o">*</span><span class="p">(</span><span class="n">word</span> <span class="o">*</span><span class="p">)</span><span class="n">dst</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">word</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">t</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">length</span> <span class="o">&amp;</span> <span class="n">wmask</span><span class="p">;</span>
<span class="c1">//        TLOOP(*--dst = *--src);
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">do</span> <span class="p">{</span>
                <span class="o">*--</span><span class="n">dst</span> <span class="o">=</span> <span class="o">*--</span><span class="n">src</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">t</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="nl">done</span><span class="p">:</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;(unsigned long)dst: %lu; (unsigned long)src: %lu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dst</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">src</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">dst0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>我已经将该函数移植到 Demo 中，可以尝试低地址拷贝到高地址，也可以将高地址拷贝到低地址：</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// b -&gt; a
</span><span class="c1"></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;Before: a: %d, b: %d&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="n">_libkernel_memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="c1">// memmove(&amp;a, &amp;b, sizeof(int));
</span><span class="c1">// memcpy(&amp;a, &amp;b, sizeof(int));
</span><span class="c1"></span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;After: a: %d, b: %d&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// Before: a: 10, b: 20
</span><span class="c1">// After: a: 20, b: 20
</span><span class="c1"></span>
<span class="c1">// c -&gt; d
</span><span class="c1"></span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>
<span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;Before: c: %d, d: %d&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
<span class="c1">// _libkernel_memmove2 是个简化版本的 _libkernel_memmove
</span><span class="c1"></span><span class="n">_libkernel_memmove2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;After: c: %d, d: %d&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// Before: c: 30, d: 40
</span><span class="c1">// After: c: 30, d: 30
</span></code></pre></div><p>但在有些编译器中，由于不同的标准库具体实现可能会有所不同。其中最主要的差别便是 <code>memcpy</code> 的实现通常并非一定是安全的，当源内存和目标内存存在重叠时，<code>memcpy</code> 将发生错误：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stddef.h&gt; /* size_t */</span><span class="cp">
</span><span class="cp"></span><span class="kt">void</span> <span class="o">*</span><span class="nf">c_memcpy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span>
        <span class="o">*</span><span class="n">dp</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">sp</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">dest</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>上面是 C99 标准库中的实现。下面尝试下，将一个数组的前半截拷贝到其中间的地址，这样源地址与目标地址就出现了重叠部分。需要注意的是，开发者要保证内存是已经分配好的，如果目标地址无法容纳足够长的源地址内容长度，则仍将溢出，发生崩溃。</p>
<div class="highlight"><pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="c1">// e[0, 1] -&gt; e[1, 2]
</span><span class="c1"></span><span class="kt">int</span> <span class="n">e</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;Before: e[0]: %d, e[1]: %d, e[2]: %d, e[3]: %d, e[4]: %d&#34;</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
<span class="n">_libkernel_memmove3</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;After: e[0]: %d, e[1]: %d, e[2]: %d, e[3]: %d, e[4]: %d&#34;</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>

<span class="o">/</span> <span class="nl">OUTPUT</span><span class="p">:</span>
<span class="c1">// Before: e[0]: 1, e[1]: 2, e[2]: 3, e[3]: 0, e[4]: 0
</span><span class="c1">// After: e[0]: 1, e[1]: 2, e[2]: 1, e[3]: 2, e[4]: 3
</span><span class="c1"></span>
<span class="c1">// f[0, 1] -&gt; f[1, 2]
</span><span class="c1"></span><span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;Before: f[0]: %d, f[1]: %d, f[2]: %d, f[3]: %d, f[4]: %d&#34;</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
<span class="n">v_memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;After: f[0]: %d, f[1]: %d, f[2]: %d, f[3]: %d, f[4]: %d&#34;</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>

<span class="c1">// OUTPUT:
</span><span class="c1">// Before: f[0]: 1, f[1]: 2, f[2]: 3, f[3]: 0, f[4]: 0
</span><span class="c1">// After: f[0]: 1, f[1]: 2, f[2]: 1, f[3]: 2, f[4]: 1
</span></code></pre></div><p>结果很明显，<code>c_memcpy</code>（C99 标准库实现的 <code>memcpy</code>）在重叠部分出现了差错，而 <code>memmove</code> 却能够正确的处理。这是因为在 <code>memmove</code> 内部会判断源地址和目标地址的大小，进而进行正向或反向拷贝，从而避免了丢弃数据。</p>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="../obj-c_to_c++/">将 Obj-C 代码翻译为 C++ 代码 - kingcos</a></li>
<li><a href="/posts/2018/dyld_shared_cache/">谈谈 iOS 中的 dyld_shared_cache - kingcos</a></li>
<li><a href="/posts/2019/link_map_file_in_xcode/">Xcode 中的 Link Map 文件 - kingcos</a></li>
<li><a href="/posts/2019/ivar_access_control_in_obj-c/">Obj-C 中成员变量和类的访问控制 - kingcos</a></li>
<li><a href="https://stackoverflow.com/questions/1201319/what-is-the-difference-between-memmove-and-memcpy">What is the difference between memmove and memcpy? - StackOverflow</a></li>
<li><a href="https://clc-wiki.net/wiki/memcpy">memcpy - clc-wiki</a></li>
<li><a href="https://tech.meituan.com/2018/11/08/ios-category-module-communicate.html">Category 特性在 iOS 组件化中的应用与管控 - 美团技术团队</a></li>
</ul>
</div>
                    <div class="post_footer">
                        
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    <a href="https://kingcos.me/tags/focus/">Focus</a>
                                    
                                    <a href="https://kingcos.me/tags/ios/">iOS</a>
                                    
                                    <a href="https://kingcos.me/tags/obj-c/">Obj-C</a>
                                    
                                    <a href="https://kingcos.me/tags//">★</a>
                                    
                                </span>
                            </div>
                        </div>
                        
                    </div>
                </div>
                <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<table style="border: 0;">
  <tr>
  <td style="border: 0; width: 30%;">
    <img width='100%' src='/img/about/1.jpg'>
  </td>
  <td style="border: 0; width: 50%;">
    <ins class="adsbygoogle"
     style="display:block;width:100%;"
     data-ad-client="ca-pub-9925978992661955"
     data-ad-slot="3213735320"
     data-ad-format="rectangle"
     data-full-width-responsive="false"></ins>
  </td>
  </tr>
</table>

<hr>

<script>
    (adsbygoogle = window.adsbygoogle || []).push({});
</script>
                
                
                







    
    
    
    <div>
        <div id="github-comment">
        </div>

        <script type="text/javascript">
        function getUtterances(isDark) {
            var utterances = document.createElement('script');
            utterances.type = 'text/javascript';
            utterances.async = true;
            utterances.setAttribute('issue-term', "pathname")
            utterances.setAttribute('repo', "kingcos\/kingcos.github.io")
            utterances.setAttribute('label', "comments")
            isDark ? utterances.setAttribute('theme', "github-dark") : utterances.setAttribute('theme', "github-light")
            utterances.crossorigin = 'anonymous';
            utterances.src = 'https://utteranc.es/client.js';

            return utterances
        }
        document.getElementById('github-comment').appendChild(getUtterances(false))
        </script>
    </div>
    




                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://kingcos.me">Powered by kingcos with love.</a>
    </div>

    <div class="footer_slogan">
        <span>❤️</span>
    </div>
</footer>
    <script src="https://kingcos.me/js/jquery-3.5.1.min.js"></script>
<link href="https://kingcos.me/css/fancybox.min.css" rel="stylesheet">
<script src="https://kingcos.me/js/fancybox.min.js"></script>
<script src="https://kingcos.me/js/zozo.js"></script>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-138311951-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</body>

</html>