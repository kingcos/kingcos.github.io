<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Swift 中的 struct & class & enum]]></title>
      <url>2016%2F37%2F</url>
      <content type="text"><![CDATA[知己知彼，百战不殆 Info: macOS 10.12.2 Beta Xcode 8.2 Beta Swift 3.0 前言最近在看《大话设计模式》一书，深感设计模式的重要性，于是决定做个 Swift 3.0 版的设计模式实现。我会将代码与文章同步更新，代码放在 kingcos/Swift-3-Design-Patterns，文章将近日同步更新于简书和博客，并会投稿掘金，期待与大家的交流。 由于 Swift 是一门比较新的语言，且更新迅速，也实属本人能力有限。所以在这一系列文章的完成过程中可能会存在各种各样的问题。我会尽力把遇到的问题，查阅资料，写出 Demo，进行总结。设计模式重在思想，而 Swift 也异常灵活，因此有些答案需要在实际的项目需求中确定，而非有唯一的答案。如果您有不同见解，或是文章有所纰漏，还请您多多指教，谢谢！ struct &amp; class &amp; enumstruct，即结构体，class，即类，enum，即枚举。在 C 语言中，有结构体和枚举，因为其是面向过程的语言，没有类和对象的概念。而在 Java 中，只有类，而没有结构体。因为 Java 是一门完全面向对象的语言，类已经可以足以包容结构体的功能，在 JDK 1.5 后，Java 也拥有了枚举。 而 Swift 也是一门面向对象的语言，却保留了结构体，甚至可以在结构体里定义方法。我在用 Swift 3.0 实现设计模式时，struct， class，以及 enum 有时甚至可以直接替换，而不用修改任何其他代码即可运行。所以这次来研究一下 struct， class，以及 enum 各是什么，它们之间有什么区别，以及什么时候该采用。 由于 struct， class，以及 enum 之间的异同比较多，本文采取先分别介绍各个类型，再进行比较异同。 structstruct 是 Swift 中定义结构体的关键字。在 Swift 中，结构体内可以定义变量，函数。 12345678struct CoordinateStruct &#123; var x = 0.0 var y: Double func getCoordinateTuple() -&gt; (Double, Double) &#123; return (x, y) &#125;&#125; 构造方法Swift 为 struct 添加了默认的成员逐一构造的方法。 当 struct 有成员变量（常量）仅声明类型，无初始值，那么 Swift 会为该结构体提供一个成员逐一构造的方法。在实例化该结构体类型的变量时，必须使用该构造方法。 1234567891011121314struct CoordinateStructDemoA &#123; let x: Double var y: Double func getCoordinateTuple() -&gt; (Double, Double) &#123; return (x, y) &#125;&#125;// var coordA = CoordinateStructDemoA() // WRONGvar coordA = CoordinateStructDemoA(x: 10, y: 10)print(coordA.getCoordinateTuple())// (10.0, 10.0) 当所有成员变量声明时均带有初始值时，那么 Swift 也会为该结构体提供一个带有默认值的变量成员逐一构造的方法。在实例化该结构体类型的变量时，可以任选其一。 1234567891011121314151617struct CoordinateStructDemoB &#123; let x = 0.0 var y = 0.0 func getCoordinateTuple() -&gt; (Double, Double) &#123; return (x, y) &#125;&#125;var coordBOne = CoordinateStructDemoB()print(coordBOne.getCoordinateTuple())var coordBTwo = CoordinateStructDemoB(y: 5)print(coordBTwo.getCoordinateTuple())// (0.0, 0.0)// (0.0, 5.0) 虽然 Swift 可以自动为我们生成构造方法，但我们也可以在结构体内部定义构造方法，需要在构造之后所有的成员均有初始值。当我们自己定义构造方法时，Swift 将不再为我们生成。 12345678910111213141516171819struct CoordinateStructDemoC &#123; var x = 0.0 var y = 0.0 init(_ tuple: (Double, Double)) &#123; x = tuple.0 y = tuple.1 &#125; func getCoordinateTuple() -&gt; (Double, Double) &#123; return (x, y) &#125;&#125;// var coorC = CoordinateStructDemoC()// var coorC = CoordinateStructDemoC(x: 20, y: 20)var coorC = CoordinateStructDemoC((20, 20))print(coorC.getCoordinateTuple()) 拷贝类型内部存储structclassenuminit 方法structclassenum值类型 &amp; 引用类型structclassenum相同点不同点总结 struct class enum 类型 值类型 引用类型 值类型 构造方法 提供默认的构造方法 java.util.Date - - java.sql.Timestamp java.sql.Date 参考资料]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift 中的值类型与引用类型]]></title>
      <url>2016%2F36%2F</url>
      <content type="text"><![CDATA[Value Type &amp; Reference Type Info: macOS 10.12.2 Beta Xcode 8.2 Beta Swift 3.0 Update: 更新了行文顺序，并增加了一部分图文。 前言最近在学设计模式中，发现 Swift 中的 struct，class 以及 enum 在一般的使用中能够做到互相替换，因此探究其背后的逻辑就十分有必要。而这一问题又引出了 Swift 中的值类型和引用类型的区别。在网上搜寻一番，虽然也找到很多很棒的资料，不过有的有些过时，或是比较分散，因此总结一篇，以便自己加深印象，也方便与大家交流。 由于 Swift 中的 struct 为值类型，class 为引用类型，因此文中以这两种类型为代表来具体阐述。 stack &amp; heap内存（RAM）中有两个区域，栈区（stack）和堆区（heap）。在 Swift 中，值类型，存放在栈区；引用类型，存放在堆区。 123456789101112class RectClass &#123; var height = 0.0 var width = 0.0&#125;struct RectStruct &#123; var height = 0.0 var width = 0.0&#125;var rectCls = RectClass()var rectStrct = RectStruct() 值类型 &amp; 引用类型值类型（Value Type）值类型，即每个实例保持一份数据拷贝。 在 Swift 中，典型的有 struct，enum，以及 tuple 都是值类型。而平时使用的 Int， Double，Float，String，Array，Dictionary，Set 其实都是用结构体实现的，也是值类型。 Swift 中，值类型的赋值为深拷贝（Deep Copy），即新对象和源对象是独立的，当改变新对象的属性，源对象不会受到影响，反之同理。 1234567891011121314struct CoordinateStruct &#123; var x: Double var y: Double&#125;var coordA = CoordinateStruct(x: 0, y: 0)var coordB = coordAcoordA.x = 100.0print("coordA.x -&gt; \(coordA.x)")print("coordB.x -&gt; \(coordB.x)")// coordA.x -&gt; 100.0// coordB.x -&gt; 0.0 如果声明一个值类型的常量，那么就意味着该常量是不可变的（无论内部数据为 var/let）。 12let coordC = CoordinateStruct(x: 0, y: 0)// WRONG: coordC.x = 100.0 在 Swift 3.0 中，可以使用 withUnsafePointer(to:_:) 函数来打印值类型变量的内存地址，这样就能看出两个变量的内存地址并不相同。 12345withUnsafePointer(to: &amp;coordA) &#123; print("\($0)") &#125;withUnsafePointer(to: &amp;coordB) &#123; print("\($0)") &#125;// 0x000000011df6ec10// 0x000000011df6ec20 在 Swift 中，双等号（== &amp; !=）可以用来比较变量存储的内容是否一致，如果要让我们的 struct 类型支持该符号，则必须遵守 Equatable 协议。 1234567891011extension CoordinateStruct: Equatable &#123; static func ==(left: CoordinateStruct, right: CoordinateStruct) -&gt; Bool &#123; return (left.x == right.x &amp;&amp; left.y == right.y) &#125;&#125;if coordA != coordB &#123; print("coordA != coordB")&#125;// coordA != coordB 引用类型（Reference Type）引用类型，即所有实例共享一份数据拷贝。 在 Swift 中，class 和闭包是引用类型。引用类型的赋值是浅拷贝（Shallow Copy），即新对象和源对象的变量名不同，但其引用（指向的内存空间）是一样的，因此当使用新对象操作其内部数据时，源对象的内部数据也会受到影响。 1234567891011121314class Dog &#123; var height = 0.0 var weight = 0.0&#125;var dogA = Dog()var dogB = dogAdogA.height = 50.0print("dogA.height -&gt; \(dogA.height)")print("dogB.height -&gt; \(dogB.height)")// dogA.height -&gt; 50.0// dogB.height -&gt; 50.0 如果声明一个引用类型的常量，那么就意味着该常量的引用不能改变（即不能被同类型变量赋值），但指向的内存中所存储的变量是可以改变的。 1234let dogC = Dog()dogC.height = 50// WRONG: dogC = dogA 在 Swift 3.0 中，可以使用以下方法来打印引用类型变量指向的内存地址。从中即可发现，两个变量指向的是同一块内存空间。 12345print(Unmanaged.passUnretained(dogA).toOpaque())print(Unmanaged.passUnretained(dogB).toOpaque())// 0x0000600000031380// 0x0000600000031380 在 Swift 中，三等号（=== &amp; !==）可以用来比较引用类型的引用（即指向的内存地址）是否一致。也可以在遵守 Equatable 协议后，使用双等号（== &amp; !=）用来比较变量的内容是否一致。 1234567891011121314151617181920if (dogA === dogB) &#123; print("dogA === dogB")&#125;// dogA === dogBif dogC !== dogA &#123; print("dogC !== dogA")&#125;// dogC !== dogAextension Animal: Equatable &#123; static func ==(left: Animal, right: Animal) -&gt; Bool &#123; return (left.height == right.height &amp;&amp; left.weight == right.weight) &#125;&#125;if dogC == dogA &#123; print("dogC == dogA")&#125;// dogC == dogA 参数 与 inout这里定义一个 ResolutionStruct 结构体，以及一个 ResolutionClass 类。这里为了方便打印对象，ResolutionClass 类遵从了 CustomStringConvertible 协议。 12345678910111213struct ResolutionStruct &#123; var height = 0.0 var width = 0.0&#125;class ResolutionClass: CustomStringConvertible &#123; var height = 0.0 var width = 0.0 var description: String &#123; return "ResolutionClass(height: \(height), width: \(width))" &#125;&#125; 在谈及 inout 关键字之前，先简述一下 Swift 中的函数传参。在 Swift 中，函数的参数默认为常量，即在函数体内只能访问参数，而不能修改参数值。具体来说： 值类型作为参数传入时，函数体内部不能修改其值； 引用类型作为参数传入时，函数体内部不能修改其指向的内存地址，但是可以修改其内部的变量。 123456789101112131415func test(sct: ResolutionStruct) &#123;// WRONG: sct.height = 1080 var sct = sct sct.height = 1080&#125;func test(clss: ResolutionClass) &#123;// WRONG: clss = ResolutionClass() clss.height = 1080 var clss = clss clss = ResolutionClass() clss.height = 1440&#125; 但是如果的确想直接改动传入的参数，可以在函数体内部直接声明同名变量，并把原有变量赋值于新变量，那么这个新的变量就可以更改其值或引用（但一般来说，引用类型很少使用该特性，毕竟内部变量是可以改变的）。那么这就引出了另一个问题，在函数体内部对参数的修改，是否会影响到函数体外部的变量呢？我们来测试一下，定义两个函数，作用为交换内部的 height 和 width。 1234567891011121314151617181920212223242526272829303132333435func swap(resSct: ResolutionStruct) -&gt; ResolutionStruct &#123; var resSct = resSct let temp = resSct.height resSct.height = resSct.width resSct.width = temp return resSct&#125;func swap(resCls: ResolutionClass) &#123; let temp = resCls.height resCls.height = resCls.width resCls.width = temp&#125;let iPhone4ResoStruct = ResolutionStruct(height: 960, width: 640)print(iPhone4ResoStruct)print(swap(resSct: iPhone4ResoStruct))print(iPhone4ResoStruct)// ResolutionStruct(height: 960.0, width: 640.0)// ResolutionStruct(height: 640.0, width: 960.0)// ResolutionStruct(height: 960.0, width: 640.0)let iPhone5ResoClss = ResolutionClass()iPhone5ResoClss.height = 1136iPhone5ResoClss.width = 640print(iPhone5ResoClss)swap(resCls: iPhone5ResoClss)print(iPhone5ResoClss)// ResolutionClass(height: 1136.0, width: 640.0)// ResolutionClass(height: 640.0, width: 1136.0) 通过以上代码，我们可以得出： 值类型的变量作为参数被传入函数时，相当于将变量内容赋值给参数。因为在调用函数前后，变量的值并没有因为调用函数而发生变化。即该参数的生命周期仅存在于函数体内 引用类型的变量作为参数被传入函数中，当函数内部对参数进行修改，外面的变量也会随之修改。即传入的参数是引用，与外部指向同一块内存空间 那么 inout 是什么呢，又有什么用呢？inout 是 Swift 中的关键字，可以放置于参数类型前，冒号之后。使用 inout 之后，函数体内部可以直接更改参数值，而且改变会保留。 12345678910111213func swap(resSct: inout ResolutionStruct) &#123; let temp = resSct.height resSct.height = resSct.width resSct.width = temp&#125;var iPhone6ResoStruct = ResolutionStruct(height: 1334, width: 750)print(iPhone6ResoStruct)swap(resSct: &amp;iPhone6ResoStruct)print(iPhone6ResoStruct)// ResolutionStruct(height: 1334.0, width: 750.0)// ResolutionStruct(height: 750.0, width: 1334.0) 通过以上代码，可以看出值类型作为参数传入函数，更改得到了保留。但是需要注意的是： 使用 inout 关键字的函数，在调用时需要在该参数前加上 &amp; 符号 inout 参数在传入时必须为变量，不能为常量 inout 参数不能有默认值，不能为可变参数 inout 参数不等同于函数返回值，是一种使参数的作用域超出函数体的方式 多个 inout 参数不能同时传入同一个变量，因为拷入拷出的顺序不定，那么最终值也不能确定 inout 参数的传递过程： 当函数被调用时，参数值被拷贝 在函数体内，被拷贝的参数修改 函数返回时，被拷贝的参数值被赋值给原有的变量 官方称这个行为为：copy-in copy-out 或 call by value result。我们可以使用 KVO 或计算属性来跟踪这一过程，这里以计算属性为例。我们可以排除在调用函数之前与之后的 center GETTER call。从中可以发现：参数值先被获取到（setter 被调用），接着被设值（setter 被调用）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct Point &#123; var x = 0.0 var y = 0.0&#125;struct Rectangle &#123; var width = 0.0 var height = 0.0 var origin = Point() var center: Point &#123; get &#123; print("center GETTER call") return Point(x: origin.x + width / 2, y: origin.y + height / 2) &#125; set &#123; print("center SETTER call") origin.x = newValue.x - width / 2 origin.y = newValue.y - height / 2 &#125; &#125; func reset(center: inout Point) &#123; center.x = 0.0 center.y = 0.0 &#125; &#125;var rect = Rectangle(width: 100, height: 100, origin: Point(x: -100, y: -100))print(rect.center)rect.reset(center: &amp;rect.center)print(rect.center)// center GETTER call// Point(x: -50.0, y: -50.0)// center GETTER call// center SETTER call// center GETTER call// Point(x: 0.0, y: 0.0) 引用类型也可以使用 inout 参数。 123456789101112131415161718192021222324class ResolutionClass: CustomStringConvertible &#123; var height = 0.0 var width = 0.0 var description: String &#123; return "ResolutionClass(height: \(height), width: \(width))" &#125;&#125;func swap(clss: inout ResolutionClass) &#123; let temp = clss.height clss.height = clss.width clss.width = temp&#125;var iPhone7PlusResClss = ResolutionClass()iPhone7PlusResClss.height = 1080iPhone7PlusResClss.width = 1920print(iPhone7PlusResClss)swap(clss: &amp;iPhone7PlusResClss)print(iPhone7PlusResClss)// ResolutionClass(height: 1080.0, width: 1920.0)// ResolutionClass(height: 1920.0, width: 1080.0) 那么现在又出现一个问题，call by reference（通过引用调用）和copy-in copy-out（或 call by value result）有什么区别和联系？苹果官方是如此解释的： As an optimization, when the argument is a value stored at a physical address in memory, the same memory location is used both inside and outside the function body. The optimized behavior is known as call by reference; it satisfies all of the requirements of the copy-in copy-out model while removing the overhead of copying. Write your code using the model given by copy-in copy-out, without depending on the call-by-reference optimization, so that it behaves correctly with or without the optimization. 作为一种优化，当参数是一个存储于内存中实际地址的值时，函数体内外共用相同的一块内存地址。即通过引用调用；其满足 copy-in copy-out 模型的所有必需条件，同时消除了拷贝时的开销。使用 copy-in copy-out 提供的模型来写代码，而不依赖于通过引用调用的优化，以便在进行或不进行优化时正确运行。 Do not access the value that was passed as an in-out argument, even if the original argument is available in the current scope. When the function returns, your changes to the original are overwritten with the value of the copy. Do not depend on the implementation of the call-by-reference optimization to try to keep the changes from being overwritten. 不要访问作为 inout 参数传递的值，尽管原始参数在当前范围可以获得。当函数返回时，你对原始参数所作出的改变会被拷贝的值重写。不要依赖通过引用调用的优化实现来尝试在重写中保持改变。 总结这篇文章是我在着手写 Swift 中的 struct &amp; class &amp; enum 一文时抽离出来的一篇。主要还是围绕了值类型中的 struct 和引用类型中的 class。在本文 stack &amp; heap 一节中，此前一直对此部分内容感到迷惑，也查阅很多资料，希望最近可以总结出来一篇，与大家分享。 When 值类型 Value Type 引用类型 Reference Type 1 == 有意义时 === 有意义时 2 独立 共享，可变 3 在多线程使用的数据 - 在本文的叙述中，可能有许多说法与您平时所用的术语略有差池，例如变量指向的内存空间，其实也等价于变量指向的内存地址。在行文过程中，查阅了很多国外的资料，也尽力将语言规范，以免产生歧义，如果有任何错误或建议，您都可以在评论中直接提出，我会研究学习，虚心接受，并作出相应整改。 参考资料Value and Reference TypesIn-Out ParametersIn-Out ParametersReference vs Value Types in Swift: Part 1/2 延伸阅读Reference vs Value Types in Swift: Part 2/2Swift 3 必看：foundation 中数据引用类型改为值类型Mutability and Foundation Value Types]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[腾讯云 Ubuntu 安装并远程访问 MySQL]]></title>
      <url>2016%2F35%2F</url>
      <content type="text"><![CDATA[道理都懂，但还是连不上的话你就应该来看看… Info: Ubuntu Server 14.04.01 LTS 64 位 DataGrip 2016.2 前言为了完成作业，不让服务器闲置，决定把数据库放在远程。免去本地配置的麻烦，这次的配置是基于腾讯的学生云，系统选择的是 Ubuntu Server 14.04.01 LTS 64 位，顺便学习下命令行操作。 步骤安装和配置的步骤比较详细，如果你已经安装过 MySQL 可以跳过相应章节。 配置服务器安全组服务器的安全组可以在腾讯云上修改、配置。因为 MySQL 默认远程访问端口为 3306，因此，我们至少要开放该端口。这里由于我的服务器仅供折腾，所以开放了所有端口，实际使用的服务器应当考虑到相应的安全问题。 设置服务器 root 账户密码在后面的使用中，我们需要 root 账户的权限，因此需要设置 root 账户的密码。腾讯云默认会提供一个 ubuntu 账户，在装系统时可以设置密码。 使用 ubuntu 账户登录服务器（0.0.0.0 替换为你的服务器 IP）。 1ssh ubuntu@0.0.0.0 登录成功后，设置 root 账户密码。 1sudo passwd 你需要先输入 ubuntu 账户密码，之后设置 root 账户密码。 安装 MySQL安装时，若提示 Do you want to continue? [Y/n] 输入 Y 即可。在 MySQL 快安装完毕时，会跳出设置 root 密码的界面。该 root 为数据库的用户，而非服务器账户。注意区分和记忆密码。 123sudo apt-get install mysql-serverapt-get isntall mysql-clientsudo apt-get install libmysqlclient-dev 安装完成后，尝试连接 MySQL，使用 root 用户验证是否安装成功。 1mysql -u root –p 配置 MySQL 远程访问查看 3306 端口状态，在 MySQL 安装成功，但没有配置远程访问时，会显示 127.0.0.1:3306。 1netstat -an|grep 3306 为保证安全，首先停止 MySQL。 1service mysql stop 切换为 root 账户。 1su root 使用 vim 打开 my.cnf。 1vim /etc/mysql/my.cnf 将 bind-address = 127.0.0.1 注释。 1# bind-address = 127.0.0.1 保存并退出后，启动 MySQL。 1service mysql start 查看 3306 端口状态，现在应当显示 0.0.0.0:3306。 1netstat -an|grep 3306 新建用户并授权12345678910# 创建 kingcos 用户，设置密码为 123456CREATE USER kingcos IDENTIFIED BY '123456';# 授权GRANT ALL PRIVILEGES ON *.* TO 'kingcos'@'%'IDENTIFIED BY '123456'WITH GRANT OPTION;# 更新权限FLUSH PRIVILEGES; 尝试远程访问这里以 JetBrains 的 DataGrip 2016.2 为例。 如图，即连接成功。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[计组实验 - Cache]]></title>
      <url>2016%2F34%2F</url>
      <content type="text"><![CDATA[Analysis of L1 Cache Info: L1 Cache Cache Simulator by jiangxincode 花了近乎一周时间，本是想用 Java 或 JavaScript 写一个 Cache 模拟器，但由于时间和精力有限，暂放弃。 不过为了实验效果，将老师所提供的 CacheSim 程序进行了微调（源程序未提供 License），并将结果数据绘成图表（使用 ECharts）。 虽然最后实验部分分数得了满分，但由于该程序可能存在一些问题，导致某些结果并非完全正确，实验结果仅供参考。 实验结果及相应分析可在下方网站中获取，相应的参考资料也在其中，这里不再赘述。 https://maimieng.com/skipsrc/CacheSimulator 以上的实验结果出自 jiangxincode/CacheSim 程序，向开源致敬！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初探 iOS 中自定义 UIView 的初始化过程]]></title>
      <url>2016%2F33%2F</url>
      <content type="text"><![CDATA[awakeFromNib()init(frame:)init(coder:) Info: macOS 10.12.1 Xcode 8.2 Beta 1 Swift 3.0 前言在 StoryBoard 和 Xib 出现之后，iOS UI 开发出现了三足鼎立之势。本文不涉及 StoryBoard、Xib、纯代码的优劣之分。仅仅涉及几个初始化方法：awakeFromNib() &amp; init(frame:) &amp; init(coder:)，探讨他们何时调用，为何调用。 Xib &amp; Nibib 是 Interface Builder 的缩写，即界面构造器。这里简要说下，Xib 和 Nib 各是什么，有什么区别。 Xib 实际是一个 XML 文件，而 Nib 是二进制文件。当应用编译时，Xib 文件被翻译为 Nib。所以在 Xcode 中，我们可以自己新建 Xib 文件来构造 UI，而当编译时，Xcode 会自动生成相应的 Nib 文件，而不需我们额外关注。关于其详细介绍，您可以参考文末的资料。 OK! Talk is cheap, show me the code! Demo在下面的 Demo 中，统一将自定义 UIView 命名为 MyView。 MyView.swift 12345import UIKitclass MyView: UIView &#123; // methods&#125; Interface Builder如果使用 Interface Builder 拖控件，那么其默认属于 UIView 类型。为将其改为自定义控件，需要将 Utilities 中 Identity inspector 的 Custom Class 改为 MyView。 为了方便看出调用顺序，将 MyView.swift 改为如下： 1234567891011121314151617181920212223import UIKitclass MyView: UIView &#123; override init(frame: CGRect) &#123; super.init(frame: frame) print("init(frame:)") &#125; required init?(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder) print("init(coder:)") // fatalError("init(coder:) has not been implemented") &#125; override func awakeFromNib() &#123; super.awakeFromNib() print("awakeFromNib()") &#125;&#125; 之后运行即可在屏幕上看到该自定义 UIView，控制台输出： 12init(coder:)awakeFromNib() 小结通过打印的输出，可以看出使用 Interface Builder 载入 View 不会调用 init(frame:) 方法，而是调用了 init(coder:)。init(coder:) 是 NSCoding 协议中的方法，NSCoding 是负责编码解码，归档处理的协议。 1required init?(coder aDecoder: NSCoder) 代码中的 init(coder:) 与平时见到的其他初始化方法有点不同：required 是指其为必要构造器，即子类「必须」重写该构造器，但当父类的构造器可以完全满足初始化时，也可不重写。init? 是指其为可失败构造器，即其可以 return nil 告知外界构造失败。若想详细了解 Swift 中的构造器，可以参考苹果官方文档。 init(coder:) 的调用处于 Nib 载入时，而 awakeFromNib() 的调用处于 Nib 载入后。Nib 的载入过程如下： Nib 文件内容和引用的资源文件加载到内存； 反归档存储于 Nib 文件的图像数据对象并初始化； 遵从 NSCoding 的对象（UIView &amp; UIViewController）调用 init(coder:) 其他对象调用其他构造器方法 建立对象间连接：Outlet &amp; Action 实现 awakeFromNib() 的对象调用该方法 需要注意的是，awakeFromNib() 中需要调用父类的该方法以保证父类的进行额外初始化。而在本例中重写的 init(coder:) 目的主要是查看调用顺序，并没有加入特别的操作。因此在实际使用中，如果使用 Interface Builder，可以不重写该方法。 CodeMyView.swift 1234567891011121314151617181920import UIKitclass MyView: UIView &#123; override init(frame: CGRect) &#123; super.init(frame: frame) print("init(frame:)") &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError("init(coder:) has not been implemented") &#125; override func awakeFromNib() &#123; super.awakeFromNib() print("awakeFromNib") &#125;&#125; ViewController.swift 12345678910111213import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let myView = MyView(frame: CGRect(x: 100, y: 100, width: 50, height: 50)) myView.backgroundColor = .black view.addSubview(myView) &#125; &#125; 之后运行即可在屏幕上看到该自定义 UIView，控制台输出： 1init(frame:) 小结通过纯代码创建自定义 UIView，便只调用 init(frame:) 方法，不涉及 Nib 的方法，因此不会调用 awakeFromNib() 和 init(coder:) 方法。而由于 init(coder:) 为必要构造器，因此重写 init(frame:) 时，必须实现该方法。 有时，为了便于从 Interface Builder 和纯代码都能创建自定义 UIView 对象，可以将 init(coder:) 方法改为： 1234required init?(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder) // fatalError("init(coder:) has not been implemented")&#125; 若保留 fatalError()，则从 Nib 初始化时会无条件输出语句并停止运行。 后记可能是强迫症作祟，学习中每遇到一个知识点，都想要查看官方文档或者 Google 出为什么，然后自己敲代码验证，再总结出一篇文章，投稿给简书、掘金。一篇文章有时要耗费一两天，因为查阅的资料都是略有过时且几乎全为英文，但自己挺享受这样的学习状态，也很享受分享给大家之后获得的收藏所带来的鼓励。最近也看了很多实习生的招聘，现在深感基础的重要，未来可能会倾向一些基础，例如数据结构、算法、网络等知识。也希望自己在寒假或下学期能找一份 iOS 实习，虽然自己也有所涉猎 Android 等其他的一些技术栈，但还是对 iOS 最感兴趣。Come on! 参考资料Nib FilesInitialization]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小窥 iOS 中的 Target-Action 设计模式]]></title>
      <url>2016%2F32%2F</url>
      <content type="text"><![CDATA[Design Pattern in iOS Info: macOS 10.12.1 Xcode 8.2 Beta 1 Swift 3.0 前言在前两天学习 iOS 中的 UISlider 控件时，看到官方文档提到，Slider 使用了 Target-Action 设计模式。即当用户移动滑块，将通知应用。同理，UIButton 也使用了该设计模式。那么，我们能从这个设计模式中学到什么呢？ Target-ActionTarget-Action，意为 目标-行为，行为即要调用的方法，目标即消息的接收对象（Objective-C 语言使用消息机制，类似但不同于方法调用，该两种概念可能未来会进行探讨）。整个过程为：用户点击按钮，触发某事件发生，该消息由按钮传到另外的接收对象，接收对象再做相应处理。接收对象可以为任何对象，但通常为控制器（Controller）。 Responder Chain在有关于 Target-Action 的官方文档章节中，提到了通过设置 Target 为 nil 来使用响应链。这样可以使得在运行时（Runtime）决定 Target 对象。关于此的探讨可以参照 Dominik Hauser 的 Utilize The Responder Chain For Target-Action 一文。 但是鉴于个人能力有限，而且在其原文中，作者新加了这么一句话： 显然，作者虽然了解响应链的存在，但不会去使用。 DemoInterface Builder通过 Interface Builder 可以拖线来实现（注意 Connection 选择 Action）。 之后便可以在其内部进行其他操作。 123@IBAction func buttonClick(_ sender: Any) &#123; // do something...&#125; 当然，也可以先定义方法，再拖线，这样也是允许的。 Code通过代码进行绑定 Target，可以先采用将控件拖线至代码中，这时 Connection 选择 Outlet。纯代码可以无视拖线。 之后便可以通过 addTarget(_:action:for:) 来绑定 Target 和 Action。 1234567891011override func viewDidLoad() &#123; super.viewDidLoad() demoButton.addTarget(self, action: #selector(demoFunc), for: .touchUpInside)&#125;func demoFunc() &#123; // do something...&#125; #selector()据考证，#selector() 是 Swift 2.2 中新增的写法。使得选择方法更加安全，因为 IDE 可以自动提示自动补全，即可在编译时刻检查。 #selector() 在 Swift 中为 Selector 结构体类型，但其本质是 Objective-C 的运行时概念。如果有方法为 private，则需要在方法前加上 @objc 才能运行正常。 123456789101112override func viewDidLoad() &#123; super.viewDidLoad() let selectorStruct = #selector(demoFunc) demoButton.addTarget(self, action: selectorStruct, for: .touchUpInside)&#125;@objc private func demoFunc() &#123; // do something...&#125; 关于 Selector 也可以参考喵神的文章，所有本文提及的文章均在参考资料中列出。 参考资料Target-ActionTarget-ActionUtilize The Responder Chain For Target-Action在 Target-Action 中使用响应链SELECTOR]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UITableViewCell 的简单优化]]></title>
      <url>2016%2F31%2F</url>
      <content type="text"><![CDATA[UITableView in iOS by Swift Info: macOS 10.12.1 Xcode 8.1 Swift 3.0 前言UITableView 是 iOS 开发中极其重要且经常使用的视图，有时候也直接使用 UITableViewController。和 Android 中的 ListView 一样，列表视图总是和内存分不开，因为他们可以承载很多条不同的信息，而随着用户手指滑动，需要即时呈现，不卡顿，不拖沓。因此对其的优化便与生俱来。 Demo首先，使用一个 static 常量存储复用 ID。之后在 viewDidLoad 中为自定义 Cell 注册该 ID（使用自定义 Cell 可以更加方便，自由的自定义表格 Cell 中的内容）。然后在 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) 方法中使用静态常量作为复用 ID，若 Cell 已存在于缓存池则取出，反之创建。 123456789101112131415161718192021222324252627282930313233343536import UIKitclass TableViewController: UITableViewController &#123; static let id = "reuseIdentifier" override func viewDidLoad() &#123; super.viewDidLoad() tableView.register(CustomCell.self, forCellReuseIdentifier: TableViewController.id) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1 &#125; override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 200 &#125; override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: TableViewController.id, for: indexPath) cell.textLabel?.text = "\(indexPath.row)" return cell &#125;&#125;class CustomCell: UITableViewCell &#123;&#125; 分析Swift 中的 staticregister1func register(_ cellClass: AnyClass?, forCellReuseIdentifier identifier: String) dequeueReusableCell1func dequeueReusableCell(withIdentifier identifier: String) -&gt; UITableViewCell?]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单使用 UIColor 生成 UIImage]]></title>
      <url>2016%2F30%2F</url>
      <content type="text"><![CDATA[UIColor &lt;-&gt; UIImage Info: macOS 10.12.1 Xcode 8.1 Swift 3.0 前言在平时的练习中，经常需要使用 UIImage，但图片又不好找。为了解决这个问题，我想到了使用 UIColor 生成 UIImage。该部分的具体知识涉及到 Core Graphics，也是一个新的知识点。在网上寻找一番，只有 Objective-C 版本，这次使用 Swift 3.0 进行重写。 Code123456789101112131415161718func generateImageWith(_ color: UIColor, andFrame frame: CGRect) -&gt; UIImage? &#123; // 开始绘图 UIGraphicsBeginImageContext(frame.size) // 获取绘图上下文 let context = UIGraphicsGetCurrentContext() // 设置填充颜色 context?.setFillColor(color.cgColor) // 使用填充颜色填充区域 context?.fill(frame) // 获取绘制的图像 let image = UIGraphicsGetImageFromCurrentImageContext() // 结束绘图 UIGraphicsEndImageContext() return image&#125; 使用时直接调用该方法，并传入相应参数即可，那么反过来呢？ 1let color = UIColor(patternImage: image!) 这样就可以从图片获取颜色。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初探 Swift 中的 KVC 之补充]]></title>
      <url>2016%2F29%2F</url>
      <content type="text"><![CDATA[Updated for Swift 3.0.1 Swift 3.0.1 中的 KVC按照官网，其实在 Swift 3.0 中已经为如下写法，但我是根据 10 月 24 日更新的 KVC 编程指南中的链接才发现该更新的。#keyPath 表达式使得键（路径）更加安全，因为其可以在编译时检查，极大程度避免传入 undefinedkey。但在测试中，也发现了其中的问题，如果该属性在外界无法访问，那么 #keyPath 也无能为力，但仍传入字符串可以做到动态设置。Demo 包含在下面的 Demo 中。 使用 KVC 设置访问控制属性在前面，我已经大致总结了 Swift 中的访问控制以及 KVC，其实很不全面，而且漏掉了 KVC 可以突破访问控制修饰的限制。似乎这样做会破坏封装，但这也是 Cocoa 的一个特性，使得我们可以在运行时进行更加灵活的设置。这次结合两者谈谈简单说下。 Demo在 Demo 中，将各个访问控制修饰符均列出，但他们都能通过 KVC 设值。 Person.swift 1234567891011open class Person: NSObject &#123; dynamic open var openProp = "" dynamic public var publicProp = "" dynamic internal var internalProp = "" dynamic fileprivate var fileprivateProp = "" dynamic private var privateProp = "" override open var description: String &#123; return "[\(openProp), \(publicProp), \(internalProp), \(fileprivateProp), \(privateProp)]" &#125;&#125; main.swift 1234567891011var p = Person()p.setValue("open", forKey: #keyPath(Person.openProp))p.setValue("public", forKey: #keyPath(Person.publicProp))p.setValue("internal", forKey: #keyPath(Person.internalProp))p.setValue("fileprivate", forKey: "fileprivateProp")p.setValue("private", forKey: "privateProp")print(p)// [open, public, internal, fileprivate, private] 浅谈集合属性的 KVC漫谈 KVC 与 KVO，这篇文章在写上篇 KVC 时已经看过，但没有注意末尾提到的集合属性的 KVC，感谢木杉同学的提问，才让我注意到这个细节。 关于这点，我查了很多资料，尤其是关心苹果的官方 KVC 指南，官方的 KVC 编程指南的最新更新日期是 2016 年 10 月 24 日，我特意查了更新历史，上一次更新要追溯的 2012 年。但指南仅仅更新了部分的 Swift 内容，而对于集合属性部分，仍为 Objective-C。 Demo-1如果按照漫谈 KVC 与 KVO所提到的，Swift 中的写法应当为下，但通过运行发现，并不走 countOfArr() 方法，而是直接输出 arr.count，即 0。 12345678910111213141516171819202122class CollectionDemo: NSObject &#123; var arr = NSMutableArray() func countOfArr() -&gt; Int &#123; print("countOfArr") return 100 &#125; // 该方法虽然未调用，但不能缺少 func objectInArrAt(index: Int) -&gt; Any? &#123; print("objectInArrAt") return arr.object(at: index) &#125;&#125;var obj = CollectionDemo()print(obj.mutableArrayValue(forKeyPath: "arr").count)print(obj.mutableArrayValue(forKeyPath: #keyPath(CollectionDemo.arr)).count)// 0// 0 Demo-2mutableArrayValue: 的默认实现为传入键，返回该键对应的可变代理数组。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class CollectionDemo: NSObject &#123; dynamic var Arr = NSMutableArray() func countOfArr() -&gt; Int &#123; print("countOfArr") return Arr.count &#125; func objectInArrAt(index: Int) -&gt; Any? &#123; print("objectInArrAt") return Arr[index] &#125; func insertObject(_ obj: Any, inArrAtIndex index: Int) &#123; print("insertObject") Arr[index] = obj &#125;&#125;var obj = CollectionDemo()let arrayProxy = obj.mutableArrayValue(forKeyPath: "arr")arrayProxy.add("Test1")// countOfArr// countOfArr// countOfArrarrayProxy.add("Test2")// countOfArr// countOfArr// countOfArr// objectInArrAtarrayProxy.add("Test3")// countOfArr// countOfArr// countOfArr// objectInArrAt// objectInArrAtprint(arrayProxy.count)// countOfArr// 3print(arrayProxy[0])// objectInArrAt// Test1 参考资料mutableArrayValueForKey: countOf not being called, countOfSongsKey-Value Coding Programming Guide漫谈 KVC 与 KVO初探 Swift 中的 KVC浅谈 Swift 3 中的访问控制]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈 Swift 中的属性（Property）]]></title>
      <url>2016%2F28%2F</url>
      <content type="text"><![CDATA[Stored PropertiesComputed PropertiesProperty Observers Info: macOS 10.12.1 Xcode 8.1 Beta 3 Swift 3.0 前言Swift 中的属性分为存储属性与计算属性，存储属性即为我们平时常用的属性，可以直接赋值使用，而计算属性不直接存储值，而是根据其他（存储）属性计算得来的值。 在其他面向对象的编程语言中，例如 Java 和 Objective-C 中，get 和 set 方法提供了统一、规范的接口，可以使得外部访问或设置对象的私有属性，而不破坏封装性，也可以很好的控制权限（选择性实现 get 或 set 方法）。而 Swift 中似乎并没有见到类似的 get 和 set 方法，而 Swift 使用了一种名为属性观察器的概念来解决该问题。 本文简单介绍下 Swift 中的这两种属性，以及属性观察器。 延迟存储属性存储属性使用广泛，即是类或结构体中的变量或常量，可以直接赋初始值，也可以修改其初始值（仅指变量）。延迟存储属性是指第一次使用到该变量再进行运算（这里的运算不能依赖其他属性）。延迟存储属性必须声明为 var 变量，因为其属性值在对象实例化前可能无法得到，而常量必须在初始化完成前拥有初始值。 在 Swift 中，可以将消耗性能才能得到的值的初始化放在延迟存储属性中，即懒加载。 Demo这里假定在 ViewController.swift 有一个属性，需要从 plist 文件读取内容，将其中的字典转为模型。如果 plist 文件内容很多，那么就十分消耗性能。如果用户不触发相应事件，也没有必要加载这些数据。那么这里就很适合使用懒加载，即延迟存储属性。 ViewController.swift 12345678910111213141516171819202122class ViewController: UIViewController &#123; lazy var goods: NSArray? = &#123; var goodsArray: NSMutableArray = [] if let path = Bundle.main.path(forResource: "Goods", ofType: "plist") &#123; if let array = NSArray(contentsOfFile: path) &#123; for goodsDict in array &#123; goodsArray.add(Goods(goodsDict as! NSDictionary)) &#125; return goodsArray &#125; &#125; return nil &#125;() // 这样也是允许的 lazy var testLazy = Person()&#125;class Person &#123;&#125; 可以在延迟存储属性运算的代码中加入 print()，即可验证其何时初始化。 计算属性举个例子，一个矩形结构体（类同理），拥有宽度和高度两个存储属性，以及一个只读面积的计算属性，因为通过设置矩形的宽度和高度即可计算出矩形的面积，而无需直接设置其值。当宽度或高度改变，面积也应当可以跟随其变化（反之不能推算，因此为只读）。为说明 setter 以及便捷 setter 说明，另外添加了原点（矩形左下角）存储属性，以及中心计算属性。 Demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct Point &#123; var x = 0.0 var y = 0.0&#125;struct Rectangle &#123; var width = 0.0 var height = 0.0 var origin = Point() // 只读计算属性 var size: Double &#123; get &#123; return width * height &#125; &#125; // 只读计算属性简写为// var size: Double &#123;// return width * height// &#125; var center: Point &#123; get &#123; return Point(x: origin.x + width / 2, y: origin.y + height / 2) &#125; set(newCenter) &#123; origin.x = newCenter.x - width / 2 origin.y = newCenter.y - height / 2 &#125; // 便捷 setter 声明// set &#123;// origin.x = newValue.x - width / 2// origin.y = newValue.y - height / 2// &#125; &#125; &#125;var rect = Rectangle()rect.width = 100rect.height = 50print(rect.size)rect.origin = Point(x: 0, y: 0)print(rect.center)rect.center = Point(x: 100, y: 100)print(rect.origin)// 5000.0// Point(x: 50.0, y: 25.0)// Point(x: 50.0, y: 75.0) 综上，getter 可以根据存储属性推算计算属性的值，setter 可以在被赋值时根据新值倒推存储属性，但它们与我们在其他语言中的 get/set 方法却不一样。 属性观察器属性观察器算是 Swift 中的一个 feature，变量在设值前会先进入 willSet，这时默认 newValue 等于即将要赋值的值，而变量本身尚未改变。变量在设值后会先进入 didSet，这时默认 oldValue 等于赋值前变量的值，而变量变为新值。 这样，开发者即可在 willSet 和 didSet 中进行相应的操作，如果只是取值和设值而不进行额外操作，那么直接使用点语法即可。但是有时候一个变量只需要被访问，而不能在外界赋值，那么可以使用访问控制修饰符加上 (set) 即可私有化 set 方法。例如 fileprivate(set)，private(set)，以及 internal(set)。值得注意的是，这里的访问控制修饰符修饰的是 set 方法，访问权限（即 get）是另外设置的。例如 public fileprivate(set) var prop = 0，该变量全局可以访问，但只有同文件内可以使用 set 方法。 Demo12345678910111213141516171819202122232425262728293031323334struct Animal &#123; // internal 为默认权限，可不加 internal private(set) var privateSetProp = 0 var hungryValue = 0 &#123; // 设置前调用 willSet &#123; print("willSet \(hungryValue) newValue: \(newValue)") &#125; // 设置后调用 didSet &#123; print("didSet \(hungryValue) oldValue: \(oldValue)") &#125; // 也可以自己命名默认的 newValue/oldValue // willSet(new) &#123;&#125; // didSet(old) &#123;&#125; &#125;&#125;var cat = Animal()// private(set) 即只读// cat.privateSetProp = 10print(cat.privateSetProp)cat.hungryValue += 10print(cat.hungryValue)// 0// willSet 0 newValue: 10// didSet 10 oldValue: 0// 10 总结Swift 的这几个 feature 我未曾在其他语言中见过，对于初学者确实容易凌乱。特别是 getter/setter 以及属性观察器中均没有代码提示，容易造成手误，代码似乎也变得臃肿。但是熟悉之后，这些也都能完成之前的功能，甚至更加细分。保持每一部分可控，便使得整个程序更加严谨，更加安全。 参考资料浅谈 Swift 3 中的访问控制Access ControlProperties]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初探 Swift 中的 KVC]]></title>
      <url>2016%2F27%2F</url>
      <content type="text"><![CDATA[Key-Value Coding Info: macOS 10.12.1 Beta 4 Xcode 8.1 Beta 3 Swift 3 前言这两天（2016-10-27），苹果一言不合更新了官网的文档，有些文档上次的更新日期甚至为 2012 年，说明这次的更新十分重要且稳定，并且将 Swift 版本更新到 3.0.1，本文中的一些写法随能运行，但已经过时，并非最佳实践，为此以及一些本文未涉及的内容，可以参照另一文——初探 Swift 中的 KVC 之补充。 Key-Value Coding 中文译为「键值编码」，简称 KVC。是 iOS 开发中极其重要且基础的概念。苹果官网对于 KVC 有详细的编程指南，但均是基于 Objective-C 语言。Swift 也继承了该特性，KVC 常用于从网络获取请求进行处理，这次只是简单探究下 Swift 中的 KVC。 在 Swift 中想要兼容 KVC，需要该类继承 NSObject。下面是 KVC 中常用的几个方法： 根据传入的 key，设置 value： func setValue(_ value: Any?, forKey key: String) 根据传入的 keyPath，设置 value，keyPath 即键路径可利用 . 遍历至键： func setValue(_ value: Any?, forKeyPath keyPath: String) 根据传入的字典，设值，如果字典中有对象不存在的属性，则会抛出异常： func setValuesForKeys(_ keyedValues: [String : Any]) 当为不存在的某个键设值时，默认调用该方法抛出 NSUndefinedKeyException 异常，子类可重写该方法： func setValue(_ value: Any?, forUndefinedKey key: String) 设置特定键的值为 nil 时，默认调用该方法抛出 NSInvalidArgumentException，子类可重写该方法（注：官方称该方法针对标量值（scalar value），例如整型和浮点型）对于其他类型没有提到，在 Demo 中有详细的列出是否支持）： func setNilValueForKey(_ key: String) 返回传入指定键的对应值： func value(forKey key: String) -&gt; Any? 返回传入指定键路径的对应值： func value(forKeyPath keyPath: String) -&gt; Any? 返回传入未定义的键路径的对应值： func value(forUndefinedKey key: String) -&gt; Any? DemoKVC 兼容的类，需要继承自 NSObject。在学习 KVC 的过程中，发现并不是所有的数据类型都支持通过 KVC 设值。KVC 设值的方便之处在于可以动态的设值，即使封装在内部的细节也可以设值，而且可以自动将类型转换（注意：有些类型是不可行的）。这种特性使得从网络获取的数据可以轻松设置到模型中。以下的 Demo，选取了几个常用的 Swift 中的数据类型，测试一下是否支持 KVC 以及是否在设置 nil 值时调用 setNilValueForKey 方法。 DataType.swift 123456789101112131415161718192021222324252627class DataType: NSObject &#123; var aInt: Int = 0 var bUInt: UInt = 0 var cFloat: Float = 0.0 var dDouble: Double = 0.0 var eBool: Bool = false var fCharacter: Character = "f" var gString: String = "" var hArray: [Any] = [0] var iDictionary: [String: Any] = ["0": 0] var jTuple: (Int, Int) = (0, 0) var kOptional: Int? var lObject: Type = Type() var mNSDictionary: NSDictionary = ["0": 0] var nNSArray: NSArray = [0, "0"] var oArrayAny: Array&lt;Any&gt; = [0, "0"] override func setNilValueForKey(_ key: String) &#123; print("You set nil for \(key)") &#125;&#125;class Type: NSObject &#123; var prop = 0&#125; main.swift 1let o = DataType() Intmain.swift 123456o.setValue("1", forKeyPath: "aInt")print("aInt: \(o.aInt)")o.setValue(nil, forKeyPath: "aInt")// aInt: 1// You set nil for aInt Int 支持 setValue 自动转换设值，且支持设值为 nil 时调用 setNilValueForKey 方法。 UIntmain.swift 123456789// 不支持通过自动转换// Error: -[Swift._NSContiguousString unsignedLongLongValue]: unrecognized selector sent to instance// o.setValue("1", forKeyPath: "bUInt")o.setValue(1, forKeyPath: "bUInt")print(o.bUInt)o.setValue(nil, forKeyPath: "bUInt")// 1// You set nil for bUInt UInt 支持 setValue 设值，但不支持自动转换，且支持设值为 nil 时调用 setNilValueForKey 方法。 Floatmain.swift 123456o.setValue("1", forKeyPath: "cFloat")print(o.cFloat)o.setValue(nil, forKeyPath: "cFloat")// 1.0// You set nil for cFloat Float 支持 setValue 自动转换设值，且支持设值为 nil 时调用 setNilValueForKey 方法。 Doublemain.swift 123456o.setValue("1", forKeyPath: "dDouble")print(o.dDouble)o.setValue(nil, forKeyPath: "dDouble")// 1.0// You set nil for dDouble Double 支持 setValue 自动转换设值，且支持设值为 nil 时调用 setNilValueForKey 方法。 Boolmain.swift 123456789// 不支持通过自动转换// Error: -[Swift._NSContiguousString charValue]: unrecognized selector sent to instance// o.setValue("true", forKeyPath: "eBool")o.setValue(true, forKeyPath: "eBool")print(o.eBool)o.setValue(nil, forKeyPath: "eBool")// true// You set nil for eBool Bool 支持 setValue 设值，但不支持自动转换，且支持设值为 nil 时调用 setNilValueForKey 方法。 Charactermain.swift 12345// 不支持 setValue// Error: [&lt;DataType&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key fCharacter.// let b: Character = "b"// o.setValue(b, forKeyPath: "fCharacter")// o.setValue(nil, forKeyPath: "fCharacter") Character 不支持 setValue。 Stringmain.swift 1234567o.setValue("gString", forKeyPath: "gString")print(o.gString)o.setValue(nil, forKeyPath: "gString")print(o.gString)// gString// String 支持 setValue 设值，设值为 nil 时不调用 setNilValueForKey 方法，但可以清空。 Array&lt;Int&gt;main.swift 12345678910// 不支持自动转换// Error: -[Swift._NSContiguousString count]: unrecognized selector sent to instance// o.setValue("1", forKeyPath: "hArray")o.setValue([1], forKeyPath: "hArray")print(o.hArray)o.setValue(nil, forKeyPath: "hArray")print(o.hArray)// [1]// [] Array&lt;Int&gt; 支持 setValue 设值，但不支持自动转换，设值为 nil 时不调用 setNilValueForKey 方法，但可以清空。 Dictionarymain.swift 12345678910// 不支持自动转换// Error: -[Swift._NSContiguousString count]: unrecognized selector sent to instance// o.setValue("[\"2\": 2]", forKeyPath: "iDictionary")o.setValue(["2": 2], forKeyPath: "iDictionary")print(o.iDictionary)o.setValue(nil, forKeyPath: "iDictionary")print(o.iDictionary)// ["2": 2]// [:] Dictionary 支持 setValue 设值，但不支持自动转换，设值为 nil 时不调用 setNilValueForKey 方法，但可以清空。 Tuplemain.swift 12345// 不支持 setValue// Error: [&lt;DataType&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key jTuple.// let t = (1, 1)// o.setValue(t, forKeyPath: "jTuple")// o.setValue(nil, forKeyPath: "jTuple") Tuple 不支持 setValue。 Optionalmain.swift 1234// 不支持 setValue// Error: [&lt;DataType&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key kOptional.// o.setValue(1, forKeyPath: "kOptional")// o.setValue(nil, forKeyPath: "kOptional") Optional 不支持 setValue。 自定义类main.swift 1234567o.setValue("1", forKeyPath: "lObject.prop")print(o.lObject.prop)// 不支持设值 nil// Error: [&lt;Type&gt; setNilValueForKey]: could not set nil as the value for the key prop.//o.setValue(nil, forKeyPath: "lObject.prop")// 1 自定义类的对象的属性支持 setValue 自动转换设值，但不支持设值为 nil。 NSDictionarymain.swift 1234567891011121314let nsDict: NSDictionary = ["1": 1]o.setValue(nsDict, forKeyPath: "mNSDictionary")print(o.mNSDictionary["1"])let swiftDict = ["2": 2]o.setValue(swiftDict, forKeyPath: "mNSDictionary")print(o.mNSDictionary["2"])o.setValue(nil, forKeyPath: "mNSDictionary")print(o.mNSDictionary["2"])// Optional(1)// Optional(2)// nil NSDictionary 支持 setValue 设值（支持 Swift 中的 Dictionary 以及 NSDictionary），但不支持自动转换，设值为 nil 时不调用 setNilValueForKey 方法，但可以清空。 NSArraymain.swift 1234567o.setValue("a", forKeyPath: "nNSArray")print(o.nNSArray)o.setValue(nil, forKeyPath: "nNSArray")print(o.nNSArray == nil)// a// true NSArray 支持 setValue 设值（NSArray 存储 Any 类型，因此不存在自动转换），设值为 nil 时不调用 setNilValueForKey 方法，但会设值为 nil。 后记这次将 Swift 中的一些数据类型拿出来单独测试了 KVC，结果来看有部分类型对此支持并不完全，所以在往后从网络获取数据一定要进行相应的处理再 setValue。也最好重写 func setValue(_ value: Any?, forUndefinedKey key: String)，必要时重写 func setNilValueForKey(_ key: String)。Swift 是一门强类型语言，就要求程序员多加注意类型转换等其他问题，以减少或避免程序崩溃，带来不好的用户体验。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈 Swift 3 中的访问控制]]></title>
      <url>2016%2F25%2F</url>
      <content type="text"><![CDATA[Access Control in Swift 3.0 Info: macOS 10.12.1 Beta 4 Xcode 8.1 Beta 3 Swift 3.0 前言学习过 Java 等面向对象语言的同学对访问控制一定不陌生，Swift 3 相较于之前的版本，新加了两个关于访问控制修饰符，open 和 fileprivate。因此，是时候总结一下这四个关键字的基本用法，因为暂未涉及到复杂的访问控制，故为浅谈。 另外，由于 Apple.com 的所有文档均无权翻译，所以取消之前的翻译，转为自己的理解和代码，权当给自己做个笔记。 Demo访问控制修饰符的限制性 高-&gt;低 排序为下： open &gt; public &gt; internal(默认) &gt; fileprivate &gt; private 访问控制的使用原则：不允许将实体定义在限制性更强的实体内。所以，以下代码均为错误用法，并注明了错误信息： 12345678910111213141516171819class Cat: NSObject &#123; var name: String?&#125;public var cat = Cat()// Error: Variable cannot be declared public because its type 'Cat' uses an internal type// public 变量不能为 internal，fileprivate，private 类型public func testAccessControl(_ cat: Cat) &#123; return cat&#125;// Error: Function cannot be declared public because its parameter uses an internal type// 函数或方法的访问限制级别不能高于其参数类型public func testAccessControl() -&gt; Cat &#123; return Cat()&#125;// Error: Function cannot be declared public because its result uses an internal type// 函数或方法的访问限制级别不能高于其返回值类型 open &amp; publicopen 是 Swift 3 新增的访问控制符，相较于 public 更加开放。open 和 public 都是可以跨 Module 访问的，但 open 修饰的类可以继承，修饰的方法可以重写（此时，open 需同时修饰该方法以及所在类），而 public 不可以。 至于 public final 与 public，前者在任何地方均不可重写，而后者可在本 Module 内重写。 DemoModuleA: Person.swift 12345678910111213141516171819202122// open 修饰的类可以为其他 Module 所访问和继承open class Person: NSObject &#123; // 属性： // 子类可访问，不可重写 public var note = "maimieng.com" // 方法： // 子类可访问，可重写 open func work() &#123; print("Work") &#125; // 子类可访问，不可重写 public func eat() &#123; print("Eat it") &#125; // 子类可访问，不可重写 public final func walk() &#123; print("Take a walk") &#125;&#125; ModuleB: Programmer.swift 123456789101112import ModuleAclass Programmer: Person &#123; // 只可重写 open 方法 override func work() &#123; // 可访问父类 public 和 public final 方法 eat() walk() print("Writing \(note)") &#125;&#125; 错误信息汇总重写父类 public 方法ModuleA: Person.swift 12345open class Person: NSObject &#123; public func eat() &#123; print("Eat it") &#125;&#125; ModuleB: Programmer.swift 1234567import ModuleAclass Programmer: Person &#123; override func eat() &#123; print("Hamburger!!") &#125;&#125; Overriding non-open instance method outside of its defining module 重写父类 public 属性ModuleA: Person.swift 123open class Person: NSObject &#123; public var note = "maimieng.com"&#125; ModuleB: Programmer.swift 1234567import ModuleAclass Programmer: Person &#123; override var note: String &#123; return "v1024.cn" &#125;&#125; Overriding non-open var outside of its defining module 重写 public 父类ModuleA: Animal.swift 1public class Animal: NSObject &#123;&#125; ModuleB: Programmer.swift 123import ModuleAclass Dog: Animal &#123;&#125; Cannot inherit from non-open class ‘Animal’ outside of its defining module internalinternal 是 Swift 中默认／缺省的访问控制级别。网上对于其他修饰符的解释有很多，而 internal 却很少。internal 对自身 Module 开放所有源文件，而对外界源代码屏蔽。 DemoModuleA: Person.swift 123class Person: NSObject &#123; var name = "Person Name"&#125; ModuleA: Designer.swift 12345class Designer: Person &#123; func test() &#123; print("test internal") &#125;&#125; 错误信息汇总在 ModuleB 访问 ModuleA ModuleA: Person.swift 123class Person: NSObject &#123; var name = "Person Name"&#125; ModuleB: Programmer.swift 123import ModuleAclass Programmer: Person &#123;&#125; Use of undeclared type ‘Person’ fileprivate &amp; privateSwift 3 新增的另一个访问修饰符是 fileprivate。 Demomain.swift 123456789101112131415161718192021class Animal: NSObject &#123; // 默认／缺省 internal var name: String? // private 仅可在本类中访问 private var privateProp = "Private Property" private func privateMethod() &#123;&#125; // fileprivate 可在当前文件内所有类访问 fileprivate var filePrivateProp = "File Private Property" fileprivate func filePrivateMethod() &#123;&#125;&#125;class Cat: Animal &#123; func test() &#123; filePrivateMethod() print("\(filePrivateProp)") &#125; fileprivate override func filePrivateMethod() &#123;&#125;&#125; 错误信息汇总子类访问父类 private 成员123456789class Animal: NSObject &#123; private func privateMethod() &#123;&#125;&#125;class Cat: Animal &#123; func test() &#123; privateMethod() &#125;&#125; ‘privateMethod’ is inaccessible due to ‘private’ protection level 其他文件的子类访问 fileprivate 成员main.swift 123class Animal: NSObject &#123; fileprivate var filePrivateProp = "File Private Property"&#125; Cat.swift 12345class Cat: Animal &#123; func test() &#123; print("\(filePrivateProp)") &#125;&#125; ‘filePrivateProp’ is inaccessible due to ‘fileprivate’ protection level 总结在 Swift 3 中新增的访问控制修饰符，使得 Swift 的访问控制更加灵活。使用不同的访问修饰符，可以使得程序耦合性降低，对外界屏蔽内部的实现细节。但是，Objective-C 是一门允许动态处理的语言，private 只是所谓的私有，而不是真正的私有，通过 KVC 还是可以获取到内部的细节，而 Swift 由于性能的考虑，默认关闭了动态处理，下一篇谈谈 Swift 中的 KVC &amp; KVO。 参考资料 Access Control 在 iOS 项目中新建 Module]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[生日记]]></title>
      <url>2016%2F26%2F</url>
      <content type="text"><![CDATA[生命不息，向死而生。内容有些凌乱，暂不修改在 QQ 空间里朋友送的礼物提醒下，似乎快要过生日了。虽然在今天之前也知道自己快要过生日了，但是到了这一天也似乎没什么分别。可能是最近有些忙碌，可能其实生日也算不了什么吧。也好久没有什么理由写点什么了，这里总是冷冰冰的技术文也不太好，所以还是写点什么，记录下吧。 很遗憾，大学似乎在知乎大神口中是绚丽多彩的，在小时代中也是很精彩的。而我这几年的重心只放在了学习上，虽说可能比不上 985／211 的学霸们，但也算是没有太大的愧疚吧。 来到大学已两年有余，大一刚进来的时候，一心想要进入卓越班，也想拿到国家奖学金。毕竟这所大学不怎么样，没有什么能够证明自己。结果，卓越班迟迟未开始，拿着专业第一的成绩才发现国家奖学金仅仅属于大三，结果连国家励志也没有拿到。说实话，那时候心里很不服，但我只是想，不就再努力一年嘛，有什么大不了的。 大一的暑假似乎是完全浪费的，由于在家里我的惰性很强，可能是习惯竞争的环境。虽然我不玩游戏，但也没有去学习，只是在暑假的最后一段时间，学了学 Java 基础，很欣慰，当时的笔记得到了浙大翁凯老师的微博推荐。 大一就那样过去了，迎来了大二。大二，进入了卓越班，考过了四级，六级。虽然这样看来算是有点成绩，而且大二的杂事少多了，我也退出了社团，但现在看来，大二这一年所学习的有些杂乱，虽然对于计算机的热情仍在，但缺少方向。由于大四就可以出去实习，最近也看了一些招聘帖，所以也是感觉时间紧迫，要学有所长，而不是蜻蜓点水。 从大一到现在，我的学习环境几乎都是在宿舍，虽然在大二时有去过汇森学习，也去过图书馆，但最久的还是宿舍。虽然有时候觉得在宿舍效率低，但是似乎我已经习惯了这个嘈杂的环境。至少我认为，虽然我身在宿舍，但我所做的事是学习， 今年最好的生日礼物，算是获得了国家奖学金吧。金钱固然重要，但这张奖状算是对我这两年的一个肯定吧。毕竟没有多少人知道我所做的，没有多少人肯定我所做的，没有正面的反馈，想要单单靠热情来驱动，的确是挺难的。老罗曾经说过，具体原话是否如此不太记得:“通过干干净净地赚钱来证明，在中国是可以做到干干净净地赚钱”。我不清楚也不关心老罗是否干净的赚钱。我只是觉得，通过自己的努力，在没有出身也可以尽力做到最好。 今天呢，Apple 宣布 2016 年 10 月 27 日召开发布会，360 云盘宣布即将关闭。每天，都有不同的事情发生，最近在听一档关于日本的播客，很有深度，引人思考。人的一生不过几十年，多去尝试，多去思考，虽然荆棘遍地，人心叵测，但我仍愿意相信美好。生命不息，向死而生。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在 iOS 项目中新建 Module]]></title>
      <url>2016%2F24%2F</url>
      <content type="text"><![CDATA[Access Control Prerequisite Article Info: macOS 10.12.1 Beta 4 Xcode 8.1 Beta 3 前言Module，中文译为「标准部件；模块」。iOS 中的 Module 类似于 Java 中的 Jar 包，也可以称作第三方库，或者框架（Framework)。Swift 中的访问控制就涉及到了不同 Module 下的情况，因此简单记录下如何在 iOS 项目中新建 Module。 Demo首先建立一个 iOS Single View Application。 选择 File-New-Target。 选择 Cocoa Touch Framework。 如图，即为建立的 Module（此处建立两个方便后续测试访问控制修饰符）。 使用时，import ModuleA 即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Intellij IDEA 配置 Code Style]]></title>
      <url>2016%2F23%2F</url>
      <content type="text"><![CDATA[IDE 已经如此完备了，为什么还是懒得用？ 前言昨天自说自话，闲扯了界面设计和代码规范。设计确实需要一些经验，也不一定能取悦所有人。而代码规范却是程序员所起码应当做到的，多人协作中，杂乱的代码就好像批阅潦草的作文，可读性极差。 然而这是个懒人驱动的世界，IDE 其实已经为你准备好了各种工具，等着你去使用。但是由于这些软件基本都是国外开发，汉化不全，新手往往望着密密麻麻的按钮不知所措。 但没办法，英文是程序员所不得不克服的一个「障碍」，障碍我打了引号，因为语言并能算是障碍。语言是共同不同种族的桥梁，然而却阻碍了很多人的前进。 这次，就简单介绍下 Intellij IDEA 如何配置 Code Style 文件，之后便可以通过快捷键规整代码。当然，Code Style 能力有限，更高级的开发者也许早已烂熟于胸。 这里以 Google 的 Java Code Style 为例。 intellij-java-google-style.xmlGoogle 在 GitHub 上有一个专门放置编码规范的仓库，地址在：https://github.com/google/styleguide。 可以随时在该网站获得最新的代码规范（但大部分规范几乎很少改动）。 找到其中文件名为 intellij-java-google-style.xml 的文件，点击打开。或者直接点击https://github.com/google/styleguide/blob/gh-pages/intellij-java-google-style.xml。 这里需要将其中的内容保存到本地，当然也可以选择下载整个仓库，只提取所需要的文件。 导入 Code Style切换到 Intellij IDEA，这里我用的是 Android Studio，同理。Android Studio-Preferences… 侧栏 Editor-Java，点击 Manage。 打开后的界面如下图，点击 Import，之后点击 OK。 选中刚刚保存的 xml 文件，点击 OK，之后再次点击 OK。 如下图，即导入成功。 回到 Preferences 界面，也可看到当前 Code Style 切换到 Google Style 了。 使用之后的使用 IDE 会保证格式的符合，为了确保文件格式的符合，也可以手动格式化代码。 选择菜单栏-Code-Reformat Code，也可以使用相应的快捷键。 参考资料Configuring Code Style by JetBrainsGoogle Java Style Guide]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[瞎扯界面设计与代码规范]]></title>
      <url>2016%2F22%2F</url>
      <content type="text"><![CDATA[而我说的都是错的。 前言身处软件学院，周围是数不胜数的「程序员」。也有看过他们所做的 App，网站，等等项目。具体功能的实现我不清楚是否合格，但几乎都有一个共同点，「mess」。我需要说明的是，杂乱并不等于丑，因为审美各有不同，而杂乱的界面与糟糕的代码却往往被忽视。当然，程序员又不是产品经理，也不是设计师，所以我说的都是错的。 What题中的「设计」，我想分为两个截然不同的意义。一是软件的整体设计，即规划，二是软件的界面设计。软件的整体设计可能需要经验的积累，才能做到考虑周到，尽可能不遗漏某些要点，暂且不论。而界面设计则是设计师对流行设计的认知结合特定软件的思考的产物。 私以为会用 Photoshop 等工具则根本不等同于会设计，就好像会用钢笔但不一定写得出庞中华的硬笔书法（注：我不喜欢庞中华的字体，但其能力还是有的）。 题中的「规范」，主要说的是代码规范。暑假时接了一个 Android Project，没有文档，且是 2012 年的代码，资金与精力有限，不可能完全重写。而代码也是十分糟糕的，拼音命名的变量名随处可见，到处充斥的打印日志（个人认为这些用于测试的临时代码应当及时删除），代码风格极差。加上由于是临时组织的团队，我没有主导权。首先尝试了 SVN 管理代码，结果无法连接 SVN 服务器，最后的协作竟然是通过 QQ，Copy-Paste。团队中的成员对代码规范似乎也没有听说过，我无法想象如果未来公司中这样的代码管理会给后期维护造成多大的难度。。。 所以身边也许有会用 Photoshop 切图的人，但没见过几个能设计的；身边都会敲代码，但没过几个代码做到起码的规范。当然，我连 Photoshop 都不会用，也没做过几个项目，所以我说的都是错的。 How暑假培训无聊，草草翻看之前借阅的《写给大家看的设计书》，里面的一些原则也都忘记的差不多了。如果想要做一名专业的设计师，那么掌握工具是基本功，也可能需要看一些理论的书籍，甚至用户心理学的书籍。 说句实话，闲扯这篇，其中一个原因是这次的 Android Project。身为学生，且和计院的不熟悉，不清楚他们平时的写代码是否会多加考虑。上次的 Project 原定 1 周完成，结果到现在也无法交付。这次的 Project 是从头做起，所以我希望可以制定一些代码规范，遵照一些设计规则，这也是我假期这几天所考虑的。 此次的 Project 是基于 Android，所以我希望设计是趋于 Material Design，而不是模仿 iOS。虽然 Apple 的产品我拥有一部分，它们也的确好用，但是一个基于 Android 开发的软件就应当遵照其规范。 但，这里有个悖论。Material Design 在国内其实名存实亡。第三方 ROM 已经把 Android 改的面目全非，当然本地化还是值得称赞的。这也导致现今国内的 Android 手机都神似 iPhone。加上 Android 的碎片化，需要考虑到适配较早的 SDK 版本，导致一些设计无法使用，这也是我最近在考虑是否可以建议有一些 Android 的特有设计。 当然，我又不是决策者，这么做于我来说似乎并没有什么益处，所以我说的都是错的。 Why界面设计是为了更好的用户体验，让用户乐于打开你的应用。而代码规范也是为了更好的用户体验，只是这里的用户指的是程序员。 功能的实现也许已经不是关键，App Store 和 Google Play 中有无数的天气预报应用，或是无数的浏览器。但是为什么还是有人不断的开发呢？也许解决了一个用户的痛点，也许只是易用性更好，界面更加美观，运行更加高效。 当然，我站在看热闹不嫌事大的角度，所以我说的都是错的。 参考资料本来重点是准备整理一些 Material Design 的相关资料，工具，没想到瞎扯这么多，一气呵成，也不再去纠正什么了，当作随笔吧。 希望有人可以懂点设计，有点规范，也希望未来进入的公司可以如此。 MaterialUpMaterial PaletteCallToIdea]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用 Gradle 构建 Struts 2 Web 应用]]></title>
      <url>2016%2F21%2F</url>
      <content type="text"><![CDATA[Ant -&gt; Maven -&gt; Gradle Info JDK 1.8 Tomcat 8.5.5 Intellij IDEA 2016.2.3 macOS 10.12.1 beta 前言熟悉 Android 开发的程序员都知道，Android Studio 是基于 Intellij IDEA 社区版所开发的。其默认使用 Gradle 构建项目。 与 Maven 不同，Gradle 的配置更为简单，两者的优劣这里略过，。这次就体验一下使用 Gradle 构建最基本的 Struts 2 Web 应用。记录于此，便于往后查阅。 安装 Tomcat下载并解压 Tomcat，将其置于 /usr/local 文件夹内，这里以 Tomcat 8.5.5 为例，因为其支持 Servlet 3.1 标准。 新建 Gradle Web 项目菜单栏：File - New - Project… 选择左侧的 Gradle，勾选 Web 选项，因为要建立的是跑在服务器上的应用。点击 Next。 输入 Group ID 以及 Artifact ID，建议输入真实，唯一的 ID。良好的习惯将减小未来发生错误的概率。继续点击 Next。 勾选必要的选项，Next。 设置项目的放置目录，Finish。 等待 Gradle 构建项目，可以在窗口下部看到当前状态，构建完毕时，则会消失。和 Maven 类似，Gradle 的构建过程也需要联网下载所需的依赖。 导入 Struts 2Gradle 项目建立基本完毕，需要配置 Struts 2 的依赖。和 Maven 类似，可以搜索 Maven Repository，虽然名字是 Maven 仓库，但却提供了多种依赖的部署方式。 搜索 struts，我们能得到很多结果，我们需要选择 Struts 2 Core。 打开之后可以看到 Struts 2 的不同版本，Maven 和 Gradle 的方便之处在于，可以很简单的切换不同版本，而不用手动下载相关 JAR 包。对于版本的选择，首先可以优先选择 release 版。测试版（即 Beta 版）在网页上也有清晰的标注。另外通过阅览 Struts 官网我们得知，Struts 3 将基于 2.5 或更新版本，较大版本更迭会有较大不同，甚至是兼容性的差异。所以我们选择当前 2.3 的最高子版本 2.3.30。当然你也可以选择参考书等资料中的版本，但个人偏向较新的版本，不要沉溺于太过时的东西，限制你的思想。 切换到 Gradle 标签，拷贝其中的内容。 回到 IDEA，打开 build.gradle，将其粘贴到 dependencies 中。由于之前勾选过 auto-import，即可自动导入。 如果忘记勾选，也可在此手动刷新，让其导入。 至此，Struts 2 已经导入该项目，但距离使用还差一点距离。 配置 Tomcat虽然我们安装了 Tomcat，也选择了 Web 应用，但并没有部署项目，所以无法运行。点击图中菜单的下三角，选择 Edit Configurations…。 点击左上角加号。 选择 Tomcate Server - Local。 根据下图即可配置 Tomcat。 如果 IDEA Application server 为空，那么需要首先添加 Tomcat 服务器，点击 Configure…，点击新窗口的左上角的加号添加新的服务器，选择 Tomcat 的路径即可（图上已经拥有配置好的两个不同版本的 Tomcat 服务器）。 回到配置 Tomcat，切换到 Deployment 标签，点击图中的加号，选择 Aritifacts。 这里选择 exploded 结尾的 war 包，这是展开的 war，便于重载资源，在开发阶段建议选择此。 配置完成，点击 OK。 添加 web.xml &amp; struts.xml点击菜单栏的 Project Structure。 选择左侧 Modules，当前 Web Gradle，点击加号。 选择创建 web.xml 的路径，注意在最后不要忘记 web.xml，否则并不会创建。 配置 web.xml 完成，点击 OK。 struts.xml 可以直接在 resources 目录右键 - New - XML Configuration File - Struts Config，即可生成。 新建完成，IDEA 会检测到 struts.xml，提示配置，选择 Configure，勾选刚刚创建的 struts.xml 以及下面的 struts-default（图中漏掉了），点击 OK。（注意：如果 IDEA 没有提示，那么可在选择 Web Gradle 界面，选择左侧的 Facets，点击加号，添加 Struts 2 并勾选上述文件） 配置完成，点击 OK。 添加完成这两个 xml 文件，但并没有进行内部的配置，web.xml 是必须配置的，可以按照如下配置 Struts 2 过滤器。 web.xml 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 测试至此，Struts 2 基本配置已经完成，可以简单的在 index.jsp 中测试 Struts 2 的标签即可验证是否成功。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[几种数据结构的多种语言实现]]></title>
      <url>2016%2F20%2F</url>
      <content type="text"><![CDATA[Learning data structures by coding inC/C++/Obj-C/Java/Swift. Info Xcode 8.0 Intellij IDEA 2016.2 前言数据结构是一门相对抽象，枯燥的课。 这次算是我第五次学数据结构了吧，之前的几次都没跟上，希望这次至少多敲敲代码，熟悉熟悉。代码全部公开，欢迎指出错误。 注意本来准备把代码段粘贴到博客中，但是由于文件较多，不好组织，更不便于阅读。因此我在 GitLab 上建立了一个 Group，将所有项目放置于此。 每种数据结构均使用了 5 种编程语言实现，目的是为了巩固基本的语法，也印证了数据结构与具体的编程语言无关。 由于不同语言的特性不同，C 和 Obj-C 均使用特定的整型数据类型（即 int），而 C++ 使用模版来达到泛型的目的，Swift 和 Java 也原生支持泛型，使得数据结构与数据类型解耦。 Loop QueueChttps://gitlab.com/data-structure-learning/Loop-Queue-in-C C++https://gitlab.com/data-structure-learning/Loop-Queue-in-Cpp Objective-Chttps://gitlab.com/data-structure-learning/Loop-Queue-in-ObjC Swifthttps://gitlab.com/data-structure-learning/Loop-Queue-in-Swift Javahttps://gitlab.com/data-structure-learning/Loop-Queue-in-Java StackChttps://gitlab.com/data-structure-learning/Stack-in-C C++https://gitlab.com/data-structure-learning/Stack-in-Cpp Objective-Chttps://gitlab.com/data-structure-learning/Stack-in-ObjC Swifthttps://gitlab.com/data-structure-learning/Stack-in-Swift Javahttps://gitlab.com/data-structure-learning/Stack-in-Java Sequence ListChttps://gitlab.com/data-structure-learning/Sequence-List-in-C C++https://gitlab.com/data-structure-learning/Sequence-List-in-Cpp Objective-Chttps://gitlab.com/data-structure-learning/Sequence-List-in-ObjC Swifthttps://gitlab.com/data-structure-learning/Sequence-List-in-Swift Javahttps://gitlab.com/data-structure-learning/Sequence-List-in-Java Link ListChttps://gitlab.com/data-structure-learning/Link-List-in-C C++https://gitlab.com/data-structure-learning/Link-List-in-Cpp Objective-Chttps://gitlab.com/data-structure-learning/Link-List-in-ObjC Swifthttps://gitlab.com/data-structure-learning/Link-List-in-Swift Javahttps://gitlab.com/data-structure-learning/Link-List-in-Java 参考资料Daily Interview数据结构探险—队列篇数据结构探险—栈篇]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小试爬虫]]></title>
      <url>2016%2F19%2F</url>
      <content type="text"><![CDATA[Crawler… Info: macOS 10.12 beta Python 2.7.10 PyCharm 2016.2 安装 PythonmacOS 自带了 2.7 版本的 Python，因此无需安装。 注意：在 PyCharm 中开发，有时候会默认为 2.6.9 的 Python，在 Preferences-Project: xxx-Project Interpreter 中，将 Python 版本切换为 2.7.10。（我仅在本文的 Demo Pro 中采用了 PyCharm IDE 开发） Terminal 输入 python，即可查看 Python 版本。 123Python 2.7.10 (default, Aug 1 2016, 20:48:38) [GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.34)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. 众所周知，Python 分为两大版本，2.7.x &amp; 3.x，两者是不兼容的，暂时这里以 2.7.x 版本为例。稍后可能更新 3.x 版甚至 Java 版的爬虫 Demo。 安装 pippip 即 Python 的包管理工具，我们需要包管理工具来下载所需要的第三方包。 macOS 虽然有 Python 环境，但是没有 pip 插件。 Terminal 输入 sudo easy_install pip，再输入用户密码即可安装。 Terminal 输入 pip，即可验证安装成功。 1234Usage: pip &lt;command&gt; [options]... 使用 pip 安装 Beautiful Soup 4Beautiful Soup 是 Python 的一个第三方包，用于从 HTML 或 XML 文档中提取数据。安装 BS4 的方法有很多，这里使用 pip 安装。 在 Terminal 输入 sudo pip install beautifulsoup4，再输入用户密码即可安装。 Demo以下 Demo 均可以爬取到相关网页的内容，但由于各种原因，以下网站的链接均删去，参考时请根据具体网站具体分析。有些网站的反爬虫机制比较健全，导致返回错误码，可以查阅相关模拟浏览器或模拟登陆的资料。 爬取学校的某个网站的照片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# coding: utf8import urllib, urllib2, os, os.pathfrom bs4 import BeautifulSoupdef getSoup(url): if url is None: return None response = urllib2.urlopen(url) if response.getcode() != 200: return None soup = BeautifulSoup(response, 'html.parser') return soupdef getImage(url, prefix): soup = getSoup(url) images = soup.find(name='div', attrs=&#123;'class':'six alpha'&#125;).find_all('img') i = 0 for img in images: image = 'http://www.ngsying.cn' + images[i]['src'] i += 1 urllib.urlretrieve(image, prefix + ' %d.jpg' % i)def downloadImages(urls, marks): i = 0 for url in urls: if not os.path.exists(marks[i]): os.mkdir(marks[i]) prefix = os.path.join(marks[i], marks[i]) getImage(url, prefix) i += 1if __name__ == '__main__': print 'Welcome to kingcos\' PicDownloader!' urls = set() marks = [] marks.append('20160910') marks.append('20160911') marks.append('20160912') marks.append('20160913') marks.append('20160914') marks.append('20160915') marks.append('20160916') urls.add('http://www.***.cn/show.asp?id=67') urls.add('http://www.***.cn/show.asp?id=60') urls.add('http://www.***.cn/show.asp?id=61') urls.add('http://www.***.cn/show.asp?id=62') urls.add('http://www.***.cn/show.asp?id=63') urls.add('http://www.***.cn/show.asp?id=64') urls.add('http://www.***.cn/show.asp?id=65') downloadImages(urls, marks) print 'Downloading has been finished.' 爬取某图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# coding: utf8import urllib, urllib2, os, os.path, randomfrom bs4 import BeautifulSoupglobal nn = 1def getSoup(url): if url is None: return None response = urllib2.urlopen(url) if response.getcode() != 200: return None soup = BeautifulSoup(response, 'html.parser') return soupdef getImage(url, prefix): soup = getSoup(url) images = soup.find(name='div', attrs=&#123;'id':'srcPic'&#125;).find_all('img') i = 0 for img in images: image = images[i]['src'] i += 1 global n urllib.urlretrieve(image, prefix + ' %d.jpg' % n) n += 1def downloadImages(urls, marks): i = 0 for url in urls: if not os.path.exists(marks[i]): os.mkdir(marks[i]) prefix = os.path.join(marks[i], marks[i]) getImage(url, prefix) # i += 1if __name__ == '__main__': print 'Welcome to kingcos\' PicDownloader!' urls = set() marks = [] marks.append('24974') for i in range(1, 10): url = 'http://www.***.com/meimei/24974-' + str(i) + '.html' urls.add(url) downloadImages(urls, marks) print 'Downloading has been finished.' 爬取某站图片该网站有一定的反爬机制，通过设置 header 绕过。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# coding: utf8import urllib, urllib2, os, os.path, randomfrom bs4 import BeautifulSoupdef getSoup(url): if url is None: return None header = &#123; "User-Agent": 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36' &#125; req = urllib2.Request(url, headers=header) response = urllib2.urlopen(req) if response.getcode() != 200: return None soup = BeautifulSoup(response, 'html.parser') return soupdef getImage(url, prefix): soup = getSoup(url) images = soup.find(name='div', attrs=&#123;'class':'main-body'&#125;).find_all('a') i = 0 for img in images: image = img['href'] i += 1 urllib.urlretrieve(image, prefix + ' %d.jpg' % i)def downloadImages(urls, marks): i = 0 for url in urls: if not os.path.exists(marks[i]): os.mkdir(marks[i]) prefix = os.path.join(marks[i], marks[i]) getImage(url, prefix) i += 1if __name__ == '__main__': print 'Welcome to kingcos\' PicDownloader!' urls = set() marks = ['14007', '13998', '13987'] for m in marks: url = 'http://www.***.***/' + m + '/' urls.add(url) downloadImages(urls, marks) print 'Downloading has been finished.' Demo Pro上面的 Demo 仅仅是爬去某个单独的网页，下面是可以爬取相关链接指定图片的 Demo。即指定一个根 URL，其可以爬取到其他符合条件的 URL，进而爬取其中的内容，而不局限于传入的指定 URL。测试爬取了 1000+ 张图片。 爬去某站的相关图片crawler_main.py 入口主函数：负责统一调用其他类的方法 1234567891011121314151617181920212223242526272829303132333435# coding: utf8from Crawler import url_manager, html_downloader, html_parser, html_outputerclass CrawlerMain(object): def __init__(self): self.urls = url_manager.UrlManager() self.downloader = html_downloader.HtmlDownloader() self.parser = html_parser.HtmlParser() self.outputer = html_outputer.HtmlOutputer() def craw(self, root_url): count = 1 self.urls.add_new_url(root_url) while self.urls.has_new_url(): try: new_url = self.urls.get_new_url() print 'craw %d: %s' % (count, new_url) html_cont = self.downloader.download(new_url) new_urls, new_data = self.parser.parse(new_url, html_cont) self.urls.add_new_urls(new_urls) self.outputer.collect_data(new_data) if count == 100: break count += 1 except: print 'Crawl finished!'if __name__ == "__main__": print 'Welcome to kingcos\' PicDownloader!' root_url = 'http://www.***.***/' obj_spider = CrawlerMain() obj_spider.craw(root_url) url_manager.py URL 管理器：负责管理 URL，包括添加新 URL，判断是非存在未爬取链接等方法 1234567891011121314151617181920212223242526# coding: utf8class UrlManager(): def __init__(self): self.new_urls = set() self.old_urls = set() def add_new_url(self, url): if url is None: return if url not in self.new_urls and url not in self.old_urls: self.new_urls.add(url) def add_new_urls(self, urls): if urls is None or len(urls) == 0: return for url in urls: self.add_new_url(url) def has_new_url(self): return len(self.new_urls) != 0 def get_new_url(self): new_url = self.new_urls.pop() self.old_urls.add(new_url) return new_url html_downloader.py HTML 下载器：负责传回指定 URL 的响应 12345678910111213141516171819# coding: utf8import urllib2class HtmlDownloader(): def download(self, url): if url is None: return None header = &#123; "User-Agent": 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36'&#125; req = urllib2.Request(url, headers=header) response = urllib2.urlopen(req) if response.getcode() != 200: return None return response html_parser.py HTML 转换器：对新的 URL 对应的 HTML 分析，提取所需内容，并提取符合需求的 URL，加入到待爬取 URL 集合。 12345678910111213141516171819202122232425262728293031# coding: utf8import re, urlparsefrom bs4 import BeautifulSoupclass HtmlParser(): def _get_new_urls(self, page_url, soup): new_urls = set() links = soup.find_all('a', href = re.compile(r"http://www.***.***/\d+/")) for link in links: new_url = link['href'] new_full_url = urlparse.urljoin(page_url, new_url) new_urls.add(new_full_url) return new_urls def _get_new_data(self, page_url, soup): res_data = &#123;&#125; res_data['url'] = page_url images = soup.find(name='div', attrs=&#123;'class':'main-body'&#125;).find_all('a') return images def parse(self, page_url, html_cont): if page_url is None or html_cont is None: return soup = BeautifulSoup(html_cont, 'html.parser') new_urls = self._get_new_urls(page_url, soup) new_data = self._get_new_data(page_url, soup) return new_urls, new_data html_outputer.py HTML 输出器：对收集到数据进行取回，放置在本地文件夹内 123456789101112131415# coding: utf8import urllib, random, osclass HtmlOutputer(): def collect_data(self, images): i = 0 for img in images: image = img['href'] i += 1 if not os.path.exists('img'): os.mkdir('img') prefix = os.path.join('img', 'img') urllib.urlretrieve(image, prefix + '%d' % i + str(random.randint(1, 100)) + '.jpg') 参考资料Python 入门Python 开发简单爬虫Beautiful Soup 官方网站Beatiful Soup 4 Docs]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈谈组装电脑]]></title>
      <url>2016%2F18%2F</url>
      <content type="text"><![CDATA[自从入了 Mac 坑，就暂时没考虑过组装电脑，谈谈这次帮同学装机… 我的电脑家里的第一台电脑是 2007 年暑假买的，当时是父亲央求其同事，在电脑城配了一个总价 4000 元整的组装电脑。 这台组装电脑的配置我很早就用鲁大师看过，但已不记得 CPU 型号等等细节，只是知道 1G 的内存，以及一块 160G 的机械硬盘。由于种种原因，2012 年我用自己「积蓄」买了一台 11 寸宏碁上网本，4G 内存 500G 硬盘。虽然是奔腾处理器，没有独立显卡，但用起来很舒心。也被我折腾得跑过 Windows XP/7/8/8.1，Ubuntu，以及 Mac OS X，但是由于显卡无法驱动，便作罢。曾经想写一篇文章纪念这台上网本，结果丢在简书，只写了个开头就没再深入。 后来我把它卖了，700 元。现在想想有点后悔，这也许是我用的最久的一手电子设备。之后我入了一台二手 Mac mini，买了一台新显示器，一套键鼠，一块移动硬盘。第一次使用 Mac 觉得很好，可惜主机晚上宿舍一熄灯便不能使用，也不便携，便出手了。在体验过 Mac mini 之后，我就知道二手 Mac 的配置是绝对够用的，毕竟新的太贵，无法承受。 在出手 Mac mini 之后，我便在寻找合适的二手 MacBook Pro。最后入手了 MD313，本来是考虑 MD101，因为 MD101 与我之前的 Mac mini 配置相同。可惜预算有限，便入了配置更差的 MD313。这台 MacBook Pro 8G 内存，160G 固态，也足以满足不玩游戏的我了。实际使用中，代码的编译速度远大于自带机械硬盘的 PC 唯一的槽点便是固态太小，但我又觉得没必要再加固态。最后，在陪伴我整个大二时光之后，我把这台电脑也出了，换成了现在手里的 ME865。 我想，暂时没必要也没理由再换了吧？ 谈谈组装其实在升入大学，就基本没有考虑过组装机。一是我不玩游戏，没必要组装高性能的主机；二是主机不便携，而我习惯背着电脑跑。所以这两点就基本告别组装机了。这次也是受同学之托，帮其查阅了很多资料，才敲定的。其实对组装电脑了解不多，但经过许久的搜索和爬贴，也知道了很多新的知识。 组装电脑比笔记本性能高，散热好；比整机购买更靠谱；又能自己体验装机的过程，被许多游戏玩家追捧。「整机烈士墙」的悲剧也几乎不会发生，只有 CPU 选择淘宝购买散片，因为暂时没有可以仿造的。其他配件均为京东购买，如果有质量问题，京东的退换货服务可以更好地解决。 组装之选若想参考，注意时效性及个人用途。 Name Price 淘宝 CPU：Intel E3-1230 v3 1422 京东 机箱：爱国者 黑暗骑士 D8 139 显示器：三星 C24F390H 23.5寸曲面 979 主板：技嘉 B85-HD3 549 显卡：索泰 GTX1060-3G 1799 内存：金士顿 骇客神条8G 278 硬盘：东芝 Q300 240G 409 电源：安钛克 VP500P 500W 299 散热：九州风神 玄冰400 99.9 京东总计：4551.9-150-10 4391.9 合计： 5813.9 一点小经验…组装电脑最重要的是配置的选择，建议大家多在贴吧或专业论坛寻找，因为这里消息更新速度足够快。配置是完全跟个人预算及用途相关的，切忌眼高手低。组装电脑由于其灵活性，有远见的同学需要考虑到未来的升级。 京东的发货速度很快，前一天下单，第二天中午就到货了。京东的产品没话说，但为了防止二手东，也需要检查配件的密封。 关于发票，这次是替他人购买，为方便对方留存，选择了纸质发票。发票的抬头在下单时选择，不等同于收货人姓名。如果是自己下单，可以选择电子发票，环保不易丢。虽说凭发票保修有时候已经是多余之选，但有些时候还是需要提供必要的发票来维护自己权益。 这次组装电脑花费了 3 个多小时，说实话这是我第一次组装。如果都是新手，建议查阅相关教程视频，配合说明书组装，有不确定的接口一定先搜索在尝试。组装过程注意安全，散热器的散热片以及机箱处都有可能刮伤（别问我为什么 T T）。 组装的过程是比较顺利的，中途没有测试，组装完全才开机，一次点亮。由于学校网络故障，「娱乐大师」没有测试。不过整体的配置应当是足够的，关于这些配件，需要注意的是，如果选择的是 2.5 寸固态硬盘，可以到淘宝选购 3.5 寸的硬盘支架，方便固定硬盘。这点在拿到快递之前，是没有想到的。还有一点，如果追求音质，不妨在购机之时选择合适的音箱。 说说这次选择比较不太好的一点，机箱。建议在选购时选择质量更好，更合理的机箱。需要考虑到整体的体积大小，主板的大小，电源的上置或是下置，USB 等拓展口的位置，以及是否可走背线。如果想双显卡交火，那么机箱要选择足够容纳的。这次买的机箱性价比还是很高的，但是感觉做工一般，如果对机箱要求较高，也可以到实体店选购。 总的来说这次装机还是比较顺利的，这些配件也是足够坚固的，耐得起折腾。有一定动手能力的新手是完全可以自我尝试的。但一定的参考也是必要的。 当然这点小经验是对于几乎没有经验的小白，或是提醒自己而写的，如果有所差错，我也愿意倾听，知错便改。也谢谢相信我的这两位同学，能够有机会自己尝试装机。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sketch 中的版本控制]]></title>
      <url>2016%2F17%2F</url>
      <content type="text"><![CDATA[Sketch 是一款矢量图设计软件，简单搭配 git-sketch-plugin 插件，即可实现对其版本控制。 Info: Sketch 39.1 git-sketch-plugin 0.7 GitLab SourceTree 前言前几日在 V 站看到有人提出关于 Sketch 版本控制的问题。才发现 Sketch 已有插件支持更加方便的版本控制。Google 了下，可能是设计师对 Git 了解较少，也可能是版本控制对于非文本的支持并不能体现其优越性，所以可能很多专业的设计师并不会采用 Git。但作为程序员对于 Git 等版本控制系统应当是有所了解，而且通过插件可以更简单的查看不同版本的区别。因此，这次就来尝试下如何进行 Sketch 中的版本控制。 PS: 该插件的作者更新的速度可能较快，仅仅在本文修改的几天，就更新了两次，但基本使用应该不会有太大变化。 Demo安装 git-sketch-plugin 插件可参考 https://github.com/mathieudutour/git-sketch-plugin README 中的 Installation 部分。 1.下载插件。最新发行版本地址：https://github.com/mathieudutour/git-sketch-plugin/releases2.解压后双击 Git.sketchplugin 即可自动安装至 Sketch 中。3.如图弹窗，即安装好插件。 之后可以按个人喜好对该插件设置。 设置保存成功将会在屏幕下方出现如图标识。 配置 Git 仓库这里使用的是 GitLab 来进行托管，也可以选择 GitHub 或是国内的 Coding.net 等。这里由于以后打算模仿一些好的设计，所以建立了一个 Group，之后可以在这个组内新建 Project，方便管理。 Group 常用于多人协作，方便管理每个人的权限，这里对其建立过程，不再叙述，可自行尝试。这里简要叙述如何在 GitLab 上建立 Project。 点击 New Project 输入项目名称，描述（可选），以及可见等级。 可见等级即该项目的可见程度。Private 为私有项目，如果他人想访问则必须被授权；Internal 为内部项目，在 Group 内的成员即可访问；Public 为公有项目，所有人可以访问。 这里我选择 Public，方便交流共享。 点击 Create Project 看到如图，即创建成功。 创建 Project 后，通常需要配置 README.md, LICENSE, .gitignore 文件。由于 Sketch 非文本格式，所以不需要 .gitignore 文件。README.md 文件是描述项目的文件，当他人打开项目主页，下方会将其内容自动渲染（markdown 格式）。LICENSE 是版权声明，我通常选择较为宽松的 MIT LICENSE，若是商业项目，请咨询后添加。 配置 SSH本地想要将变更推送到远程的 Git 服务器，可以通过 HTTPS 或 SSH 进行连接。HTTPS 需要每次验证用户名及密码，（插件貌似不支持，测试时失败，待确定）。SSH 需要将本地密钥填入到 GitLab 中，这里不详述如何生成密钥，建议参考 GitLab 相应页面的有关介绍。 填入 SSH Key。 成功添加之后，我们可以在 Terminal 验证，输入 ssh -T git@gitlab.com。第一次时，有个警告，需要输入 yes，如果成功即可显示你的用户名，如果不成功，可能是 Git 中的用户名和 GitLab 不一致。可以通过以下命令全局设置，注意用户名和邮箱替换成自己的，并与所用的 GitLab 用户名以及邮箱一致。 12git config --global user.name &quot;&lt;username&gt;&quot; git config --global user.email &lt;email&gt; 本地配置在 Projetc 中切换为 SSH，复制 SSH URL，这将作为本地计算机连接远程 Git 仓库的 URL。 之后，我们需要克隆仓库，熟悉 Terminal 的同学可以直接 git clone &lt;git-remote-repository-url&gt; &lt;local-directory&gt; 克隆到本地。也可以通过 SourceTree 来管理。 打开 SourceTree，点击 + 新仓库，点击从 URL 克隆。 将刚才拷贝的 URL 粘贴到源 URL，后续两条会自动填充，也可按照个人喜好修改。 填入后点击克隆，稍等片刻即可成功克隆到本地。 在 Finder 中可以看到刚才添加的 README.md 以及 LICENSE 文件也存在，.git 的隐藏文件夹即表明当前文件夹已受 Git 版本控制。 以后即可在该目录新建 Sketch 文件，或者将已存在的 Sketch 拷贝至此目录即可。我们这里新建 Sketch 文件以演示。 之后，我们需要保存文件，Cmd + s。 git-add如果有文件想要被 Git 所管理，我们需要将其添加到 Git 中。 如果出现如下错误，可以参考本文下方的资料解决。 如图即添加成功。 git-commit当我们的文件受 Git 控制，我们就可以开始做设计了。我这里是模仿 Wunderlist 的 icon。当制作完成，我们可以 commit 一下，提交更改。 输入更改的简介，并勾选自动生成示意图。 成功后，屏幕下方会有提示（消失太快，没截到图）。如果 Commit 成功，这时就可以打开 SourceTree 看到新的 Commit。 git-push当我们需要将本地的更改推送到远程服务器（例如 GitLab），那么就需要 Push。 Push 操作是需要连网的，需要一定的时间。 成功之后我们就可以在 GitLab 上查看到新的更改。 而我们没有手动导出的示意图便自动生成，如果在进行一个版本更迭的设计时，那么我们就能更清晰的知道多种设计的不同。 后话…Git 和 SVN 都是很好的版本控制系统，在群里也看到有设计师使用 CornerStone（SVN 客户端）来进行版本管理。 不管用什么工具，设计本身才是重要的，希望能坚持下来，Design by heart… 参考资料Why am I having / how can I fix this error: “shell_session_update: command not found”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈 UIImage 内存管理问题]]></title>
      <url>2016%2F16%2F</url>
      <content type="text"><![CDATA[探究 iOS 中 UIImage 中两种不同 Initializers 带来的内存问题本文使用 Swift 版本为 3.0 beta。 Info: Swift 3.0 beta Xcode 8.0 beta 5 macOS Sierra Public Beta 3 前言近几天接触 iOS 的 UI 学习，由于 Swift 更新太快太频繁，因此看的是 Obj-C 的项目，自己修改为 Swift 3.0 beta 可编译运行的版本。Xcode 8.0 随着几个版本的更迭也趋于稳定，不过在不同 beta 版中，Swift 3.0 beta 的语法也略有改动，之前整理的 初探 Swift 3.0 系列也会略有过时了。这次是制作一个简单的图片浏览器，而且会动态的展示（伪） GIF 动画，因此需要处理 animation 以及多张图片。如果不进行适当的内存管理，那么大量的图片占用内存，将使得程序在 iOS 设备上崩溃，造成极差的用户体验。因此本文浅显地分析两种不同的 UIImage 初始化方法，为以后的使用做以适当铺垫。 不过，鉴于刚刚入门 iOS，所以某些行为或说法也许不太得当，需要学习的地方还有很多，故若有纰漏，还望指出。 init?(named: String) Loading and Caching Images init?(named: String)Returns the image object associated with the specified filename.DiscussionThis method looks in the system caches for an image object with the specified name and returns the variant of that image that is best suited for the main screen. If a matching image object is not already in the cache, this method locates and loads the image data from disk or from an available asset catalog, and then returns the resulting object.The system may purge cached image data at any time to free up memory. Purging occurs only for images that are in the cache but are not currently being used.In iOS 9 and later, this method is thread safe.Special ConsiderationsIf you have an image file that will only be displayed once and wish to ensure that it does not get added to the system’s cache, you should instead create your image using imageWithContentsOfFile:. This will keep your single-use image out of the system image cache, potentially improving the memory use characteristics of your app. 加载并缓存图像 init?(named: String)返回指定文件名所关联的图像对象。论述该方法在系统缓存中寻找指定名称的图像对象，并返回最适合主屏幕的图像的变体。若对应的图像对象已不存在于缓存，则该方法将在磁盘或存在的资源目录中定位并载入图像数据，并返回结果对象。系统可能随时清空图像数据以释放内存。清空操作只会发生在处于缓存但当前未被使用的图像。在 iOS 9 及以上版本，该方法是线程安全的。特殊考虑如果图像文件只需显示一次，且希望确保其不会被添加到系统的缓存中，你应当使用 imageWithContentsOfFile: 方法。该方法将保证其在系统图像缓存以外的单一使用，潜在提升 app 的内存使用特性。 init?(contentsOfFile: String) Creating and Initializing Image Objects init?(contentsOfFile: String)Initializes and returns the image object with the contents of the specified file.DiscussionThis method loads the image data into memory and marks it as purgeable. If the data is purged and needs to be reloaded, the image object loads that data again from the specified path. 创建并初始化图像对象 init?(contentsOfFile: String)初始化并返回指定文件内容的图像对象。论述该方法加载图像数据到内存，并标记其可以被清空。如果数据被清空，需要重新载入，图像对象将会从指定路径再次加载数据。 Demo如苹果官方文档所述，这两个 Initializer 虽然都是加载图片，但是一个做了缓存，另一个并没有。所以 init?(named: String) 更适合加载 icon 等占用小的图片，而 init?(contentsOfFile: String) 适合较大的图片。 123456// init?(named: String)let demoIcon = UIImage(named: "DemoIcon")// init?(contentsOfFile: String)let demoImagePath = Bundle.main.path(forResource: "DemoImage.png", ofType: nil)let demoImage = UIImage(contentsOfFile: demoImagePath ?? "") init?(named: String) 常用于加载小且常用的 icon，其初始化的图片，占用的缓存只会在程序退出时才清空，即使消除强引用仍会占用缓存。而 init?(contentsOfFile: String) 初始化的图片，在没有强引用时便会自动销毁。 而 init?(contentsOfFile: String) 使用有一些注意点。该方法的参数是图片的全路径，所以需要通过 Bundle 来获取，而且需要带上后缀名。需要注意的是，如果图片放置在 Assets.xcassets 中，Bundle 是无法获取到的，需要直接复制到项目中。否则的话 demoImagePath 将为 nil，导致无法获取到图片，程序也将可能崩溃。 参考资料Xcode Documentation &amp; API Reference]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven 3 安装第三方 JAR 向导翻译及 Demo]]></title>
      <url>2016%2F15%2F</url>
      <content type="text"><![CDATA[Maven 对于 JAR 的导入提供了巨大便利，然而有些 JAR 包却因为各种原因不存在于各大仓库之中，本文即是对 Maven 官网的教程翻译，希望可以帮到同样困惑的人。 PS:Maven，名词，译作专家，内行。在程序设计开发中，Maven 是一个较为强大但依赖网络的项目管理工具。本文英语原文引自 Apache Maven 官网中的 Guide to installing 3rd party JARs。Last Published: 2016-07-09最新发行时间：2016 年 7 月 9 日 [翻译]安装第三方 JAR 向导尽管很少发生，但有时会有第三方的 JAR，想要放入本地仓库为自己的构建使用，这是因为这些 JAR 不存在于任何公共仓库，例如 Maven 中心（仓库）。JAR 必须被放置在本地仓库的正确位置，这样才能被 Apache Maven 获取到。 为使得这一过程更加简单，且不易出错，我们已提供了相对简单的 Maven-安装-插件。在本地仓库安装 JAR 使用以下命令： 12mvn install:install-file -Dfile=&lt;JAR 文件路径&gt; -DgroupId=&lt;组-id&gt; \ -DartifactId=&lt;工件-id&gt; -Dversion=&lt;版本&gt; -Dpackaging=&lt;包&gt; 如果也含有 pom 文件，你可以使用以下命令： 1mvn install:install-file -Dfile=&lt;JAR 文件路径&gt; -DpomFile=&lt;pom 文件路径&gt; 使用 Maven-安装-插件 v2.5 使得安装 JAR 更加简单。如果那个 JAR 文件由 Apache Maven 构建，其在 META-INF 的子目录下还包括一个 pom.xml 文件，它将被默认读入。在这种情形下，你只需要这么做： 1mvn install:install-file -Dfile=&lt;JAR 文件路径&gt; [Demo]导入本地 ojdbc6.jar Info: JDK 1.8 Intellij IDEA 前言由于目前使用的数据库是 Oracle XE，所以在 Java 项目中需要导入其驱动包 ojdbc6.jar。而由于该 JAR 许可证过期，所以无法直接在 Maven 项目中导入。所以做此测试，验证该向导是否可行，看看其中有木有什么坑。 Run下载 ojdbc6.jar官网下载 Oracle JDBC 按要求做出命令如果在命令行，可以直接使用以下形式（注意将部分替换为你所要导入 JAR 的信息）： 12mvn install:install-file -Dfile=/Users/kingcos/Downloads/ojdbc6.jar -DgroupId=com.oracle ＼ -DartifactId=ojdbc6 -Dversion=11.2.0.3 -Dpackaging=jar 如果在 IDEA 配置中，第一行的 \ 需要删除，即： 1mvn install:install-file -Dfile=/Users/kingcos/Downloads/ojdbc6.jar -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=11.2.0.3 -Dpackaging=jar 在 IDEA 右侧找到 Maven Projects 点击 Maven Projects 菜单中的命令行按钮 输入刚才的命令并运行，查看下方区域是否显示 BUILD SUCCESS 如果出现失败，要排查上述各项命令是否正确。如果成功，即可在 pom.xml 中加入你刚刚导入的 JAR。 12345&lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;11.2.0.3&lt;/version&gt;&lt;/dependency&gt; 测试其实我们找到本地的 maven 仓库，看看需要的 JAR 在不在就可以了，如下图，我的 ojdbc6.jar 已经成功导入本地 maven 仓库。 不过，我也在这里写了一个小的测试方法，即测试连接数据库后，将查询结果打印，运行成功且输出正确，来测试刚才的配置是否正确。（本机测试成功） 测试类：App.java（由于直接测试，这里没有更改该类名） 注意：将连接数据库的代码即 SQL 语句替换为自己数据库的设置。 1234567891011121314151617181920212223242526272829303132333435package com.maimeing;import java.sql.*;public class App &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement pstm = null; ResultSet rs = null; try &#123; Class.forName("oracle.jdbc.OracleDriver"); conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe", "demo", "123456"); String sql = "select count(*) from person"; pstm = conn.prepareStatement(sql); rs = pstm.executeQuery(); while (rs.next()) &#123; System.out.println(rs.getInt(1)); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); pstm.close(); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 参考资料 ojdbc 许可证过期：摘自 Find Oracle JDBC driver in Maven repository 中一名回答者的回复]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 中的 Serializable 与 transient]]></title>
      <url>2016%2F14%2F</url>
      <content type="text"><![CDATA[目前个人对 Java 的理解应用仅限于皮毛，故若有不妥，会及时修正。 Info: JDK 1.8 Eclipse EE neon 前言Java 中的 transient 是有关对象序列化的关键字，之前学习中并没有注意，并且没有实际使用。但是这次希望可以总结一下，来了解 Java 的这个特点，故记录于此。 作用序列化（Serializable）是指把 Java 对象字节序列的过程，就是说将原本保存在内存中的对象，保存到硬盘（或数据库等）中。当需要使用时，再反序列化恢复到内存中使用。在我查到的资料中，通过网络传递对象或是RMI（Remote Method Invocation远程方法调用）都会用到对象序列化。transient 译为短暂的，在这里即不被持久化。有一些敏感数据是不适合被传输，因此需要加上 transient 关键字，即可避免序列化。 Demo实体类：Account.java 1234567891011121314151617181920212223242526272829import java.io.Serializable;// 参与序列化只需要实现 Serializable 接口即可public class Account implements Serializable &#123; // Java 的序列化机制通过判断以下 ID 来进行版本比对，本处使用默认 private static final long serialVersionUID = 1L; private Long accountId; private String username; // transient 修饰： private transient String password; private transient double balance; public static int staticVar; public Account(Long accountId, String username, String password, double balance) &#123; super(); this.accountId = accountId; this.username = username; this.password = password; this.balance = balance; &#125; public String toString() &#123; return "Account [accountId=" + accountId + ", username=" + username + ", password=" + password + ", balance=" + balance + "]"; &#125; &#125; 测试类：TestTransient.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.io.*;public class Demo01 &#123; public static void main(String[] args) &#123; // 此处需要改为你要存入的地址，注意 Win 下地址中的 \ 需要转义 String src = "/Users/kingcos/Desktop/demo.object"; Account kingcos = new Account(62278888L, "kingcos", "123456", 1000.0); Account.staticVar = 11; System.out.println("序列化之前："); System.out.println(kingcos); System.out.println("staticVar = " + Account.staticVar); write(kingcos, src); Account.staticVar = 22; Account newKingcos = read(src); System.out.println("序列化之后："); System.out.println(newKingcos); System.out.println("staticVar = " + Account.staticVar); &#125; static void write(Account acc, String src) &#123; OutputStream os = null; ObjectOutputStream oos = null; try &#123; os = new FileOutputStream(src); oos = new ObjectOutputStream(os); // 写入 oos.writeObject(acc); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; oos.flush(); oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static Account read(String src) &#123; Account acc = null; InputStream is = null; ObjectInputStream ois = null; try &#123; is = new FileInputStream(src); ois = new ObjectInputStream(is); // 读取 acc = (Account) ois.readObject(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return acc; &#125;&#125;// Console:// 序列化之前：// Account [accountId=62278888, username=kingcos, password=123456, balance=1000.0]// staticVar = 11// 序列化之后：// Account [accountId=62278888, username=kingcos, password=null, balance=0.0] 总结序列化 序列化前后的对象内容一样，地址不同，属于深拷贝（deep copy） serialVersionUID 序列化时系统会把当前类的 serialVersionUID 写入序列化的文件中（也可能是其他的中介），当反序列化的时候系统会去检测文件中的 serialVersionUID，看它是否和当前类的 serialVersionUID 一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化，否则就说明当前类和序列化的类相比发生了某些变化 Eclipse 可以根据类名，接口名，方法和属性等来生成一个 64 位的哈希字段，也可添加默认的 1L 当序列化后，对对象进行修改，再进行反序列化所出现的情形，可以查看参考资料中的讲解 静态变量 静态变量是相对于类的，而非对象，因此其也无法参与到序列化中。上面的 Demo 中，我们在写入对象后对静态变量进行修改。而再次读取对象时，该变量的值为我们所修改过的。即序列化会忽略静态变量 其它 当一个父类实现序列化，子类自动实现序列化，不需要显式实现 Serializable 接口 仅实现 Serializable 接口而无其它处理，即为默认序列化机制。在此机制下序列化对象时，不仅会序列化其本身，也会对该其引用的其它对象也进行序列化，同样，这些其它对象引用的另外对象也将被序列化，以此类推。因此有时序列化开销可能较大 transient 关键字只能修饰属性（变量），不能修饰方法和类 属性如果也是对象，则该对象对应的类需要实现 Serializable 接口 Externalizable ExternalizableExternalizable 接口内部实现了 Serializable 接口，但是为其扩展了两个方法，writerExternal() 方法在序列化时被自动调用，可以在其中控制序列化内容，readExternal() 方法在反序列化时被自动调用，可以在其中控制反序列化的内容。如果留空，（反）序列化行为将不会保存或读取任何一个字段，所以 transient 关键字也失效。因此我们可以对（反）序列化进行控制，详见下面的 Demo。注意：使用 Externalizable 进行序列化时，当读取对象时，会调用被序列化类的无参构造方法去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。因此，实现 Externalizable 接口的类必须要提供一个无参的构造器，且它的访问权限为 public。 Demo该 Demo 基于上处改编 实体类：Account.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.io.Externalizable;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectOutput;// Externalizable 接口内部也实现了 Serializablepublic class Account implements Externalizable &#123; // Java 的序列化机制通过判断以下 ID 来进行版本比对，本处使用默认 private static final long serialVersionUID = 1L; private Long accountId; private String username; // transient 修饰： private transient String password; private transient double balance; public static int staticVar; public Account() &#123; super(); System.out.println("调用了 无参构造方法"); &#125; public Account(Long accountId, String username, String password, double balance) &#123; super(); this.accountId = accountId; this.username = username; this.password = password; this.balance = balance; &#125; @Override public String toString() &#123; return "Account [accountId=" + accountId + ", username=" + username + ", password=" + password + ", balance=" + balance + "]"; &#125; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; System.out.println("调用 writeExternal"); out.writeLong(accountId); out.writeObject(password); out.writeDouble(balance); &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; System.out.println("调用 readExternal"); accountId = in.readLong(); // 对象类型需要强制类型转换 password = (String) in.readObject(); balance = in.readDouble(); &#125; &#125; 测试类：TextExternalizable.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.io.*;public class TextExternalizable &#123; public static void main(String[] args) &#123; // 此处需要改为你要存入的地址，注意 Win 下地址中的 \ 需要转义 String src = "/Users/kingcos/Desktop/demo.object"; Account kingcos = new Account(62278888L, "kingcos", "123456", 1000.0); Account.staticVar = 11; System.out.println("序列化之前："); System.out.println(kingcos); System.out.println("staticVar = " + Account.staticVar); write(kingcos, src); Account.staticVar = 22; Account newKingcos = read(src); System.out.println("序列化之后："); System.out.println(newKingcos); System.out.println("staticVar = " + Account.staticVar); &#125; static void write(Account acc, String src) &#123; OutputStream os = null; ObjectOutputStream oos = null; try &#123; os = new FileOutputStream(src); oos = new ObjectOutputStream(os); // 写入 oos.writeObject(acc); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; oos.flush(); oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static Account read(String src) &#123; Account acc = null; InputStream is = null; ObjectInputStream ois = null; try &#123; is = new FileInputStream(src); ois = new ObjectInputStream(is); // 读取 acc = (Account) ois.readObject(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return acc; &#125;&#125;// Console:// 序列化之前：// Account [accountId=62278888, username=kingcos, password=123456, balance=1000.0]// staticVar = 11// 调用 writeExternal// 调用了 无参构造方法// 调用 readExternal// 序列化之后：// Account [accountId=62278888, username=null, password=123456, balance=1000.0]// staticVar = 22 参考资料 Java transient 关键字使用小记 serialVersionUID 作用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈 Java 与 Oracle 中的日期与时间类型]]></title>
      <url>2016%2F13%2F</url>
      <content type="text"><![CDATA[目前个人对 Java 的理解应用仅限于皮毛，故若有不妥，会及时修正。 Info: JDK 1.8 Eclipse EE neon Oracle 10g XE 前言暑假学校培训，因此整理一下之前在学习过程中比较困惑的地方。方便未来查阅，也使自己能够更深入了解 Java。这次来说一说日期与时间，因为数据库和 Java 本身都有许多存储日期或时间的类型，那么如何选择合适的类型，并正确的存入以及读取便很重要。网上的资料也有些参差不齐，因此我个人整理于此，并附上可以实际运行的代码。 Java 中的日期与时间类型简介子父类关系 java.lang.Object java.lang.Object java.lang.Object java.util.Date java.util.Date java.util.Date - java.sql.Timestamp java.sql.Date 精度 类型 java.util.Date java.sql.Timestamp java.sql.Date 精度 年 月 日 时 分 秒 年 月 日 时 分 秒 毫微秒 年 月 日 初始化12345678910111213141516171819public class TestInitTime &#123; public static void main(String[] args) &#123; java.util.Date utilDate_1 = new java.util.Date(); java.util.Date utilDate_2 = new java.util.Date(System.currentTimeMillis()); java.sql.Timestamp sqlTimestamp = new java.sql.Timestamp(System.currentTimeMillis()); java.sql.Date sqlDate = new java.sql.Date(System.currentTimeMillis()); System.out.println("utilDate_1 =\t" + utilDate_1); System.out.println("utilDate_2 =\t" + utilDate_2); System.out.println("sqlTimestamp =\t" + sqlTimestamp); System.out.println("sqlDate =\t" + sqlDate); &#125;&#125;// Console:// utilDate_1 = Sun Jul 17 09:26:07 CST 2016// utilDate_2 = Sun Jul 17 09:26:07 CST 2016// sqlTimestamp = 2016-07-17 09:26:07.342// sqlDate = 2016-07-17 上述的初始化均使用了各自未过时的构造函数，输出打印后，可以看到明显的精度区别。 PSSystem.currentTimeMillis(): 返回以毫秒为单位的当前时间。CST 代表 China Standard Time（中国标准时间，即东八区，北京时间） 多种日期类型转换String -&gt; 时间 1234567891011121314151617181920212223242526272829import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;public class TransformDateOrTime &#123; public static void main(String[] args) &#123; String date = "2016-7-17 14:30:05"; DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); java.util.Date utilDate = null; try &#123; utilDate = dateFormat.parse(date); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; System.out.println("utilDate: " + utilDate); java.sql.Timestamp sqlTimestamp = java.sql.Timestamp.valueOf("2016-7-17 14:30:05"); java.sql.Date sqlDate = java.sql.Date.valueOf("2016-7-17"); System.out.println("sqlTimestamp: " + sqlTimestamp); System.out.println("sqlDate: " + sqlDate); &#125;&#125;// Console:// utilDate: Sun Jul 17 14:30:05 CST 2016// sqlTimestamp: 2016-07-17 14:30:05.0// sqlDate: 2016-07-17 java.util.Date 与 java.sql.Timestamp getTime(): 返回调用对象表示的自 1970 年 1 月 1 日 00:00:00 GMT 以来的毫秒数。 123456789101112131415161718// java.util.Date -&gt; java.sql.Timestampjava.util.Date utilDate_1 = null;try &#123; utilDate_1 = dateFormat.parse(date);&#125; catch (ParseException e) &#123; e.printStackTrace();&#125;java.sql.Timestamp sqlTimestamp_1 = new java.sql.Timestamp(utilDate_1.getTime());System.out.println(utilDate_1 + " 转换为 " + sqlTimestamp_1); // java.util.Date &lt;- java.sql.Timestamp （精度丢失）java.sql.Timestamp sqlTimestamp_2 = new java.sql.Timestamp(System.currentTimeMillis());java.util.Date utilDate_2 = new java.util.Date(sqlTimestamp_2.getTime());System.out.println(sqlTimestamp_2 + " 转换为 " + utilDate_2);// Console:// Sun Jul 17 14:30:05 CST 2016 转换为 2016-07-17 14:30:05.0// 2016-07-17 10:09:38.736 转换为 Sun Jul 17 10:09:38 CST 2016 java.util.Date 与 java.sql.Date 123456789101112// java.util.Date -&gt; java.sql.Datejava.sql.Date sqlDate_1 = new java.sql.Date(utilDate_1.getTime());System.out.println(utilDate_1 + " 转换为 " + sqlDate_1); // java.util.Date &lt;- java.sql.Datejava.sql.Date sqlDate_2 = new java.sql.Date(System.currentTimeMillis());java.util.Date utilDate_3 = new java.util.Date(sqlDate_2.getTime());System.out.println(sqlDate_2 + " 转换为 " + utilDate_3);// Console:// Sun Jul 17 14:30:05 CST 2016 转换为 2016-07-17// 2016-07-17 转换为 Sun Jul 17 11:14:15 CST 2016 如何选择？在上面最后由 java.sql.Date 转换为 java.util.Date 中，虽然我们之前查到 java.sql.Date 只能保存年月日，但是这里却可以转换为带有时分秒的 java.util.Date。而 java.sql.Date 中的 getHours()，getMinutes()，getSeconds()（也包括对应的 setter）方法均已过时，如果调用会有 java.lang.IllegalArgumentException 异常。所以 java.sql.Date 只是屏蔽了时间中的时分秒，为了和数据库中的 DATE 类型匹配，查看其源代码就可以得知，java.sql.Date 继承但没有重写 getTime() 方法，而本身的 public Date(long date) 构造方法也是调用了父类的构造方法。 而与此不同的是 java.sql.Timestamp，其对父类做了扩充，通过查看其源代码，我们可以发现，其 getTime() 中增加了纳秒（1s = 1E9nanos），而且单独增加了 getNanos() 方法。 因此 java.sql.Date 只是屏蔽年月日，而不是移除，而 java.sql.Timestamp 对父类进行了扩充。在下面的 Demo 中，会实际操作数据库，这样一存一取就可以将其特点展现。 在这里以 Oracle 数据库为例，Oracle 中有两种主要日期与时间类型，DATE 以及 TIMESTAMP。 DATE: 仅存 年 月 日TIMESTAMP: 保存 年 月 日 时 分 秒 纳秒 所以对应 Java 中，我们就应该在保存合适精度的时间下，选择合适的类型。Java 中的 java.util.Date 更为灵活，我们可以在恰当的时候将其转为合适的类型存入数据库，或者在取出时转为该类型。 DemoSQL 123456789101112131415161718-- 建表DROP TABLE T_TIME;CREATE TABLE T_TIME ( ID NUMBER(10,0) PRIMARY KEY, date_1 DATE, timestamp_1 TIMESTAMP, date_2 DATE, timestamp_2 TIMESTAMP);-- 创建自增序列drop sequence time_id;create sequence time_idincrement by 1 start with 1 nomaxvalue nominvalue nocache 实体类：TimeEntity.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class TimeEntity &#123; private int id; private java.util.Date date_1; private java.sql.Date date_2; private java.util.Date timestamp_1; private java.sql.Timestamp timestamp_2; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public java.util.Date getDate_1() &#123; return date_1; &#125; public void setDate_1(java.util.Date date_1) &#123; this.date_1 = date_1; &#125; public java.sql.Date getDate_2() &#123; return date_2; &#125; public void setDate_2(java.sql.Date date_2) &#123; this.date_2 = date_2; &#125; public java.util.Date getTimestamp_1() &#123; return timestamp_1; &#125; public void setTimestamp_1(java.util.Date timestamp_1) &#123; this.timestamp_1 = timestamp_1; &#125; public java.sql.Timestamp getTimestamp_2() &#123; return timestamp_2; &#125; public void setTimestamp_2(java.sql.Timestamp timestamp_2) &#123; this.timestamp_2 = timestamp_2; &#125; public String toString() &#123; return "TimeEntity [id=" + id + ", date_1=" + date_1 + ", date_2=" + date_2 + ", timestamp_1=" + timestamp_1 + ", timestamp_2=" + timestamp_2 + "]"; &#125; &#125; 测试类：TestTimeDateType.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.text.DateFormat;import java.text.SimpleDateFormat;public class TestTimeDateType &#123; public static void main(String[] args) &#123; try &#123; Class.forName("oracle.jdbc.OracleDriver"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; // url 中的地址要替换为自己数据的地址 String url = "jdbc:oracle:thin:@localhost:1521:XE"; // 数据库用户名及密码需要设置为自己的 String user = "demo"; String password = "123456"; Connection connection = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; connection = DriverManager.getConnection(url, user, password); String sql = "insert into t_time values (time_id.nextVal, ?, ?, ?, ?)"; ps = connection.prepareStatement(sql); ps = setAll(ps); ps.executeUpdate(); // 这里我们只运行一次，为方便起见，因此仅查询 id 为 1 的记录 sql = "select * from t_time where id = 1"; ps = connection.prepareStatement(sql); TimeEntity te = new TimeEntity(); rs = ps.executeQuery(); while (rs.next()) &#123; te.setId(rs.getInt(1)); te.setDate_1(rs.getDate(2)); te.setTimestamp_1(rs.getTimestamp(3)); te.setDate_2(rs.getDate(4)); te.setTimestamp_2(rs.getTimestamp(5)); &#125; System.out.println(te); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); ps.close(); connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static PreparedStatement setAll(PreparedStatement ps) throws Exception &#123; ps.setDate(1, returnSqlDateWithSqlDate()); ps.setTimestamp(2, returnTimestampWithTimestamp()); ps.setDate(3, new java.sql.Date(returnSqlDateWithUtilDate().getTime())); ps.setTimestamp(4,new java.sql.Timestamp(returnTimestampWithUtilDate().getTime())); return ps; &#125; static java.sql.Date returnSqlDateWithSqlDate() &#123; java.sql.Date sqlDate = java.sql.Date.valueOf("2012-2-2"); return sqlDate; &#125; static java.sql.Timestamp returnTimestampWithTimestamp() &#123; java.sql.Timestamp timestamp = java.sql.Timestamp.valueOf("2015-5-5 5:55:55.555"); return timestamp; &#125; static java.util.Date returnSqlDateWithUtilDate() throws Exception &#123; String date = "2013-3-3 3:33:33"; DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); java.util.Date utilDate = dateFormat.parse(date); return utilDate; &#125; static java.util.Date returnTimestampWithUtilDate() throws Exception &#123; String date = "2016-6-6 6:6:6"; DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); java.util.Date utilDate = dateFormat.parse(date); return utilDate; &#125;&#125;// Console:// TimeEntity [id=1, date_1=2012-02-02, date_2=2013-03-03, timestamp_1=2015-05-05 05:55:55.555, timestamp_2=2016-06-06 06:06:06.0] 小结从上面实例中，就可以基本清楚这几个类型的差别，以及其中的转换，因此在实际使用中便可以通过需要的不同精度，来确定所选的类型即可。 java.util.Date 与 Calendar在 java.util.Date 中有许多过时方法，查看其注释，有许多都被 Calendar 所代替。由于在现实中，java.util.Date 不再能胜任国际化的操作，因此建议使用 Calendar 进行日期与时间处理。由于 Calendar 类是抽象类，且 Calendar 类的构造方法是 protected 的，所以无法使用Calendar类的构造方法来创建对象，但提供了 getInstance() 静态方法来创建对象。 转化测试类：TestCalendar.java 1234567891011121314151617181920212223import java.util.Calendar;import java.util.Date;public class TestCalendar &#123; public static void main(String[] args) &#123; // Calendar 转化为 Date Calendar calendar_1 = Calendar.getInstance(); System.out.println(calendar_1.getTimeInMillis()); Date date_1 = calendar_1.getTime(); System.out.println("Calendar -&gt; Date" + date_1); // Date 转化为 Calendar Date date_2 = new Date(); Calendar calendar_2 = Calendar.getInstance(); calendar_2.setTime(date_2); System.out.println("Date -&gt; Calendar " + calendar_2); &#125;&#125;// Console:1468741779943Calendar -&gt; DateSun Jul 17 15:49:39 CST 2016Date -&gt; Calendar java.util.GregorianCalendar[time=1468741779978,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id="Asia/Shanghai",offset=28800000,dstSavings=0,useDaylight=false,transitions=19,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2016,MONTH=6,WEEK_OF_YEAR=30,WEEK_OF_MONTH=4,DAY_OF_MONTH=17,DAY_OF_YEAR=199,DAY_OF_WEEK=1,DAY_OF_WEEK_IN_MONTH=3,AM_PM=1,HOUR=3,HOUR_OF_DAY=15,MINUTE=49,SECOND=39,MILLISECOND=978,ZONE_OFFSET=28800000,DST_OFFSET=0] 参考资料 JavaSE 8 API 说明（Oracle 官方英文版） java.util.Date、java.sql.Date、java.sql.Time、java.sql.Timestamp 区别和联系 Calender 的使用详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[电池过放修复 Tips]]></title>
      <url>2016%2F12%2F</url>
      <content type="text"><![CDATA[平板只有两种，iPad 和其他 Info: WT8 数据线 电源 前言前段时间为了方便看视频，买了一个平板 TOSHIBA WT8。性能一般，但也足够用了。内存 2G，硬盘 32G，加上内存卡，去掉系统及软件，也就 20G 左右，捉襟见肘。 六级前下载了很多视频，天天带着看，天天都充电。考完六级就期末了，开始准备期末考试了，所以就没有再管过平板，一直放在书架上。偶尔还会充充电，但是这次不知怎么回事，充电闪屏，不充电又按电源键没反应，查了一番才知道电池过放这个概念。不过，按理说，很多新的电池加入了这道保护措施，但很明显，这个平板不支持。再搜一番，只得拆机。 正文其他品牌可参照，拆机前务必搜索拆机视频或拆机图再下手，以免出现不良后果 将平板后盖拆开（WT8 只需要从边缘打开，用硬卡片划开） 将电池排线取下（小心谨慎） 明确电池排线正负极 将数据线的 Micro USB 头拆掉，将红色（+）和黑色（-）里的铜线露出 将数据线红色正极与机器电池正极相接触 将数据线黑色负极与机器电池负极相接触 将数据线插入 5V USB 接口 接触时间 1 秒即可 组装回去 测试是否能充电 装回去 可能的原因： 带保护的锂电过放时，保护电路会自动断开，用高电压充一下可使保护电路重新接通 后记好的产品应当是为人服务的，不应当是折腾的。初中，高中时候折腾 iPhone 越狱美化，Android 刷机，现在只想老老实实一部手机稳定的用下去。也许是折腾累了，不过这些设备终究是为我们所服务的。如果太过折腾，那便是玩具。 所以，我还是想把这个平板出了，也许未来还是会购置 iPad mini 2/4 吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[那一年...高考]]></title>
      <url>2016%2F11%2F</url>
      <content type="text"><![CDATA[Is this my destiny?今天可以查高考分数了，又是一个几家欢喜几家愁的日子。 两年前的今天，我查了自己分数，476，刚刚好二本线。可以说是一个相当差的成绩，当时想，不论怎样，我都不会去复读，因为浪费了一年时间。而现在想想，如果当时浪费一年，也许就不会在这里浪费四年。 然而选择早已做出，在这里再后悔也没有什么用，只有继续前行，才能尽量靠近当初的梦。也许进不了一所好的院校让我的一生失去很多机会，但是谁又知道会是什么样呢？ 但愿，未来我还能坚持自己，坚持自己的方向。 晚安。 2016.6.25 凌晨]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[全站 HTTPS 已开启]]></title>
      <url>2016%2F10%2F</url>
      <content type="text"><![CDATA[HTTPS改了图床，改了好多配置，终于上 HTTPS 了。不过好像学校的校园网访问不大好了＝＝无所谓了。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio 项目目录翻译]]></title>
      <url>2016%2F9%2F</url>
      <content type="text"><![CDATA[翻译是为了更好地理解。Info: Android Studio 2.1.1 Mac OS 10.11.5 Activities An activity is one of the distinguishing features of the Android framework. Activities provide the user with access to your app, and there may be many activities. An application will usually have a main activity for when the user launches the application, another activity for when she selects some content to view, for example, and other activities for when she performs other tasks within the app. See Activities for more information. Activity 是 Android 框架的特色之一。Activity 向用户提供了访问应用的入口，并且（一个应用）可能拥有多个 Activity。当用户打开应用，通常有一个主 Activity，当用户选择一些内容到视图将会有另外的 Activity，举个例子，当用户在应用中执行其他任务，其他 Activity 将会被加载。点此查看更多关于 Activity 的信息。 在翻译之前，我们先建立一个项目，以下翻译以此为基准 app/src/main/res/layout/activity_main.xml12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context="com.maimieng.myapplication.MainActivity"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" /&gt;&lt;/RelativeLayout&gt; This XML layout file is for the activity you added when you created the project with Android Studio. Following the New Project workflow, Android Studio presents this file with both a text view and a preview of the screen UI. The file contains some default interface elements from the material design library, including the app bar and a floating action button. It also includes a separate layout file with the main content. 当使用 Android Studio 创建项目，该 XML 布局文件即代表添加的 Activity。随着新建项目的流程进行，AS 通过一个文本视图和屏幕 UI 的预览来渲染此文件。该文件包含一些 Material Design 库中默认的界面元素，包括应用条和一个浮动的按钮。同样也包含一个含有主内容的单独的布局文件。 app/src/main/res/layout/content_main.xml1&lt;!-- 该文件貌似已在最新的 AS 中默认不存在 --&gt; This XML layout file resides in activity_main.xml, and contains some settings and a TextView element that displays the message, “Hello world!”. 该 XML 布局文件隶属于 activity_main.xml，并包含一些设置和一个显示 “Hello world!” 信息的 TextView （文本视图）元素。 app/src/main/java/com.maimieng.myapplication/MainActivity.java12345678910111213package com.maimieng.myapplication;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; A tab for this file appears in Android Studio when the New Project workflow finishes. When you select the file you see the class definition for the activity you created. When you build and run the app, the Activity class starts the activity and loads the layout file that says “Hello World!” 当新建项目的流程完成，AS 将会显示该文件的标签页。当你选中该文件，将看到你所创建的 Activity 的类定义。当你构建并运行应用，Activity 类启动 Activity 并载入布局文件，显示 “Hello World!”。 app/src/main/AndroidManifest.xml1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.maimieng.myapplication"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; The manifest file describes the fundamental characteristics of the app and defines each of its components. You’ll revisit this file as you follow these lessons and add more components to your app. 该清单文件描述了应用的基本特征并定义其中的各个组件。当你按照本教程，将会再次访问该文件并向你的应用添加更多组件。 app/build.gradle1234567891011121314151617181920212223242526apply plugin: 'com.android.application'android &#123; compileSdkVersion 23 buildToolsVersion "23.0.3" defaultConfig &#123; applicationId "com.maimieng.myapplication" minSdkVersion 14 targetSdkVersion 23 versionCode 1 versionName "1.0" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.4.0'&#125; Android Studio uses Gradle to compile and build your app. There is a build.gradle file for each module of your project, as well as a build.gradle file for the entire project. Usually, you’re only interested in the build.gradle file for the module, in this case the app or application module. This is where your app’s build dependencies are set, including the defaultConfig settings: AS 使用 Gradle 编译并构建应用。项目的每一个模块将含有一个 build.gradle 文件，一整个项目对应一个 build.gradle 文件。通常，你只需关注模块的 build.gradle 文件，即这种情况下的应用模块。这是应用构建依赖所放置的地方，包括 defaultConfig 设置： compiledSdkVersion is the platform version against which you will compile your app. By default, this is set to the latest version of Android available in your SDK. (It should be Android 4.1 or greater; if you don’t have such a version available, you must install one using the SDK Manager.) You can still build your app to support older versions, but setting this to the latest version allows you to enable new features and optimize your app for a great user experience on the latest devices. compiledSdkVersion 是你将编译应用的平台版本。默认情况下，其设置为你的 SDK 中可获得到的 Android 最高版本。（其应该是 Android 4.1 或更高，如果你没有这样的版本，你必须使用 SDK 管理器下载一个。）你仍然可以构建支持较老版本的应用，但是设置此为最新版本将允许你开启新的特性并为持有最新设备的用户显著优化你的应用体验。 applicationId is the fully qualified package name for your application that you specified during the New Project workflow. applicationId 是你的应用的完全限定包名，这在新建项目流程中由你指定。 minSdkVersion is the Minimum SDK version you specified during the New Project workflow. This is the earliest version of the Android SDK that your app supports. minSdkVersion 是你在新建项目流程中指定的最低 SDK 版本。这是应用支持最早的 Android SDK 版本。 targetSdkVersion indicates the highest version of Android with which you have tested your application. As new versions of Android become available, you should test your app on the new version and update this value to match the latest API level and thereby take advantage of new platform features. For more information, read Supporting Different Platform Versions. targetSdkVersion 暗示你已经测试过的应用的最高版本。当新的 Android 版本可以获得，你应当在新版本测试你的应用，并更新其值，以匹配最新的 API 等级，并因此利用新平台的特性。有关更多信息，查看 Supporting Different Platform Versions。 See Building Your Project with Gradle for more information about Gradle. 查看 Building Your Project with Gradle 获得更多关于 Gradle 的信息。 Note also the /res subdirectories that contain the resources for your application: 同样注意 /res 子目录其包含的应用资源： drawable-&lt;density&gt;/Directories for drawable resources, other than launcher icons, designed for various densities. 可绘制资源目录，不同于启动图标，其为不同密度设计。 layout/Directory for files that define your app’s user interface like activity_main.xml, discussed above, which describes a basic layout for the MainActivity class. 定义应用用户界面的文件目录，例如 activity_main.xml，上面谈到过，其描述了 MainActivity 类的基本布局。 menu/Directory for files that define your app’s menu items. 定义应用菜单项的文件目录。 mipmap/Launcher icons reside in the mipmap/ folder rather than the drawable/ folders. This folder contains the ic_launcher.png image that appears when you run the default app. 启动图标隶属于 mipmap/ 文件夹，而不是 drawable/ 文件夹。该文件夹包含当你运行默认应用的 ic_launcher.png 图片。 values/Directory for other XML files that contain a collection of resources, such as string and color definitions. 包含资源集合的其他 XML 目录，例如字符串和颜色定义。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博客取消文章分类]]></title>
      <url>2016%2F8%2F</url>
      <content type="text"><![CDATA[博客取消文章分类，但保留标签及归档有时候总是不知道一篇文章的具体分类，而且要加上文章标题的英文，会把博文的地址变得很长，十分不美观。而标签的不唯一性可以使我更好的选择。 可是这样又造成一个后果：所有评论将会丢失… 因为多说的评论是绑定文章的链接的，不过，过一段时间可能域名也会更换，加之本来评论就不多，所以感谢曾经评论的人。 因此，博客取消文章分类，但保留标签及归档，文章的链接为 域名/年度/本年的第 n 篇博文。 标签页http://maimieng.com/tags/ 归档页http://maimieng.com/archives/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitHub 4 Eclipse]]></title>
      <url>2016%2F7%2F</url>
      <content type="text"><![CDATA[Git &amp; GitHub For Eclipse Info: Eclipse MARS.2 for Java EE GitHub 关于在多人协作如此重要的今天，Git 已经成为多数人协作开发，版本控制的第一选择。而 GitHub 作为可能是世界上最大的代码托管网站，很多人选择将项目开源于此，并与他人交流，甚至一起开发。 我在折腾这次的作业中，也体会到，与其复制粘贴代码到博客，不如直接开源在 GitHub，顺便学习和巩固一下 Git。但是在折腾中，我发现网上关于新版本的 Eclipse 的 Git 教程十分少，因此将此次折腾的记录于此，防止自己忘记，也便于他人参考。 Let’s do it!Say something…我使用的是 HTTPS 连接 GitHub，因为使用 SSH 不能计入 Contribution，不能满足一点点虚荣心… 而且步骤稍繁琐，因此本文只涉及 HTTPS 方式。 最新版本的 Eclipse 已经集成了 Egit，所以不需要再下载此插件，这也是很多其他老教程中不适用的一点。 1. 项目右键－Team－Share Project…（以 bbs_by_mm 为例） 2. 单击 RePositry Create…，选择 Git 仓库的文件夹（以 Homework 为例） 其实这个仓库文件夹名可以和 GitHub 仓库名不一致，因为我在 GitHub 的此仓库名为 CourseDesign 3. （可选）单击 Path within repository Browse…－Finish 因为一个仓库并不一定只放一个项目，像我这个仓库，需要放置在校期间的一些小项目，需要单独的文件夹归档，更加便于查找，因此设置了此子目录 4. 项目右键－Team－Push Branch ‘master’－填写相应内容－next URI 填写 GitHub 对应仓库的 HTTPS 地址 User 填写该仓库所有者的 GitHub 注册邮箱 密码为 GitHub 账户密码 Store in Secure Store 可选，如果以后也要使用，建议勾选免去每次输入账号密码的麻烦，但是如果是临时一用，建议不勾选，以防他人对你的项目做手脚 5. 此页面保持不改动－next 我在最开始配置时，此页使用默认一直无法 Push，后来勾选了 Force overwrite branch in remote if it exists and has diverged，才 Push 成功，但是弊端是如果在 GitHub 网站上有任何改动，只要强制重写，就会覆盖掉以前的所有，包括 README.md 文件也会被抹去，因此如果不是不能 Push，不建议勾选，如果是空仓库也无法 Push 可以一试。 6. 等待… 由于国内众所周知的原因，此处可能需要等待几分钟 如果出现此页面，即为成功，可以打开 GitHub 查看是否 Push 进去 日用Commit项目右键－Team－Commit－填入 Commit 备注（勾选需要 Commit 的文件） Pull项目右键－Team－Pull Push项目右键－Team－Push Branch ‘master’]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java BBS]]></title>
      <url>2016%2F6%2F</url>
      <content type="text"><![CDATA[Java Web 告别之作Info: Mac OS 10.11.4 JDK 1.7 Tomcat 7.0 MySQL 5.7 Eclipse for Java EE MARS.2 Navicat 11.1 杂七杂八 Powered by Struts 1.3 支持注册，登录 注册信息：用户名，密码，邮箱 登录验证：用户名，密码，验证码：防止暴力破解 注册用户名不得与他人重复 留言信息：发言者，发言标题，发言时间，发言内容 留言可供登录用户回复 回复信息：回复者，回复内容，回复时间 Powered by Spring MVC + MyBatis 使用 Spring MVC + MyBatis 实现相同功能 Spring MVC + MyBatis 一个不小心，我就写出来了。。。此代码参考了 Struts 1.3 版本，还参考了当时学习 Spring MVC + MyBatis 的代码，因此合成。 技能树 Java EE Spring MVC MyBatis SQL HTML 如何将项目跑在自己电脑上大部分同 Powered by Struts 1.3，数据库名尽量更换，以防错误出现，SQL 文件放置在项目根目录下的 sql 文件夹中。 数据库配置将项目导入 IDE 中，打开 BBS_with_SpringMVC_MyBatis/config/db.properties，更改为适合本机的配置。 Struts 1.3 注意基础要求已经全部完成，将在完成进阶一后公开此次基础部分均由本人独立完成，几乎未参考其他资料，毕竟 Struts 1.3 太过久远，查到的资料几乎没有参考价值 技能树 Java EE Struts 1.x SQL HTML 如何将项目跑在自己电脑上项目本身肯定是不包含数据库的，所以需要自己创建数据库并配置。另外，由于不是太懂数据库设计，没有设置外键，但是由于基础要求不高，所以也算是能完成要求＝＝ SQL 文件放置在项目根目录下的 sql 文件夹中。 数据库配置将项目导入 IDE 中，打开 BBS_by_mm/WebRoot/META-INF/context.xml，更改为适合本机的配置。 打开 BBS_by_mm/src/com.maimieng.Dao/DatabaseConnection.java，更改为适合本机的配置。 如果项目有红叉…那么可能是 JDK 或者 Tomcat 版本不一致，导致找不到 Jar 包，请在 项目右键－Build Path－Configure Build Path...，替换为本机的版本，如果想避免错误，尽量使用与此同一版本的 JDK 和 Tomcat。 Why Eclipse?有些同学可能会说，MyEclipse 更加方便好用，但是 MyEclipse 是商业软件，破解的软件既损害了开发者利益，也使得软件可能存在奇怪的问题，因此本人不会使用 MyEclipse 开发。但是，该项目可以导入 MyEclipse。如果你是一名开发者，那么我建议，从现在起，做一名拥护正版的开发者吧。 项目代码点我查看 打开速度可能会很慢，但是你能打开我的博客，就应该打开这个网站，美好的事情，慢一点，也值得。下载的方法也在里面写了，以后所有的大作业，也许都会公布在博客，项目都会发布到 GitHub。当然，我的代码也不可能确定毫无 Bug，能修复尽量修复，如果暂时没有修复，会列出。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven for Mac]]></title>
      <url>2016%2F5%2F</url>
      <content type="text"><![CDATA[Maven for MacInfo: Mac OS 10.11.4 Apache Maven 3.3.9 JDK 1.7 Eclipse MARS.2 for Java EE 关于Mac 上的中文资料相较于 Windows 实在是很匮乏，而 Maven 作为一个优秀的项目管理工具，确实值得一学。因此，我个人记录一下学习 Maven 的过程，也便于日后温习。 Maven 已经集成在最新的 Eclipse EE MARS.2，所以如果想直接查看 Maven for Eclipse 的同学可以直接跳过前面的”瞎折腾”。 下载 点击 下载页面 选择 Binary 版本 &amp; Link 的下载链接，进行下载 注意Maven 3.3 版本需要 JDK 1.7 或以上版本(It still allows you to build against 1.3 and other JDK versions by Using Toolchains 配置解压缩，得到如图所示的文件 将 apache-maven-3.3.9 整个文件夹放在 /usr/local/ 目录（也可按自己习惯放置在其他路径，但配置时要以实际路径为准）下，如图所示 注意使用 Finder-前往-前往文件夹... 即可进入隐藏的 /usr/local/ 目录 在终端控制器运行 echo $JAVA_HOME 命令查看 JDK 环境变量是否配置成功（具体配置方法可 Google） 在终端控制器运行 export PATH=/usr/local/apache-maven-3.3.9/bin:$PATH 配置 Maven 的环境变量，并在终端输入 mvn -v 查看 Maven 版本，测试是否配置成功，如图即为成功配置 使用POM.xml在 文稿即 /Users/kingcos/Documents 下，新建文件夹作为项目文件夹，命名为 MavenDemo，写入以下内容，并保存为 POM.xml 于根目录中 POM.xml 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd "&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.maimieng.maven.demo&lt;/groupId&gt; &lt;artifactId&gt;maven-demo&lt;/artifactId&gt; &lt;version&gt;SNAPSHOT-0.0.1&lt;/version&gt;&lt;/project&gt; 编译使用 Maven，源代码 .java 必须放在项目根目录的 src/main/java 下，再加上其所在包的文件夹下，所以 Hello.java 的绝对路径：/Users/kingcos/Documents/MavenDemo/src/main/java/com/maimieng/hello/Hello.java（源代码的资源文件必须放置在 src/main/resources） Hello.java 12345678910111213package com.maimieng.hello;public class Hello &#123; public String sayHello(String name) &#123; return "Hello, " + name; &#125; public static void main(String[] args) &#123; System.out.println("Hello, world!"); &#125;&#125; 在终端将目录切换到项目文件夹，输入 mvn compile，即可执行编译 编译完成，将在项目文件夹出现新的 target 文件夹，编译后的字节码文件，即在其中的 classes 文件夹内 配置 Maven 本地仓库默认仓库，位于 /Users/USERNAME/.m2 USERNAME 为个人用户名，不易管理 前往 /usr/local，打开 apache-maven-3.3.9/conf/settings.xml 在 settings.xml 插入一行 &lt;localRepository&gt;/Users/kingcos/Documents/Maven/repo&lt;/localRepository&gt;，仓库路径可自定义，本文中设置为 /Users/kingcos/Documents/Maven/repo，复制此 settings.xml 文件 前往 /Users/kingcos/Documents/Maven/repo，将 settings.xml 粘贴于此 再次 mvn compile，执行编译，Maven 会下载依赖到新的本地仓库中，等待下载完毕，进行编译 注意由于第一次编译过了，且无改动，所以此次只进行了下载依赖，编译提示 nothing to compile，如想看到编译，可提前删除 target 文件夹，再次编译 测试在 POM.xml 中 &lt;project&gt;&lt;/&lt;project&gt; 中添加 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 使用 Maven，测试代码 .java 必须放在项目根目录的 src/test/java 下，再加上其所在包的文件夹下，所以 TestHello.java 的绝对路径：/Users/kingcos/Documents/MavenDemo/src/test/j/com/maimeing/hello/TestHello.java（测试代码的资源文件必须放置在 src/test/resources） TestHello.java 1234567891011121314package com.maimieng.hello;import org.junit.*;import static junit.framework.Assert.*;public class TestHello &#123; @Test public void testHello() &#123; Hello h = new Hello(); assertEquals(h.sayHello("Maven"), "Hello, Maven"); &#125;&#125; 终端输入 mvn test 如图即测试成功 命令终端输入命令 mvn clean清除生成的文件，如图即清除成功（默认清除 target 文件夹） mvn clean compile先清理，再进行编译 mvn clean test先清理，再进行测试 mvn clean package先清理，再进行编译，测试，打包 mvn clean install先清理，再进行编译，测试，打包，并安装到本地仓库，供其它项目使用 mvn clean deploy先清理，再进行编译，测试，打包，并发布到服务器，供其他人使用 mvn archetype:generate可根据输入的信息，自动生成 Maven 构建，也可使用 Eclipse Maven for Eclipse配置自己的 Maven，settings，及仓库 新建 Maven 项目打开 Eclipse，在左边的 Package Explorer 中右键，new-Other 并如图选择 Maven Project 第一页无需改动 第二页如果建立非 Web 项目，即默认此图配置 建立 Web 项目，需如图选择 webapp 设置 Group Id 和 Artifact Id 以及包名，点击 Finish 即可完成建立 部署 Jetty在 pom.xml 中配置插件 &lt;build&gt; 内： 123456789101112131415161718&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt; &lt;webApp&gt; &lt;contextPath&gt;/test&lt;/contextPath&gt; &lt;/webApp&gt; &lt;connectors&gt; &lt;connector implementation="org.eclipse.jetty.server.nio.SelectChannelConnector"&gt; &lt;port&gt;9090&lt;/port&gt; &lt;maxIdleTime&gt;60000&lt;/maxIdleTime&gt; &lt;/connector&gt; &lt;/connectors&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt; 在项目上右键，Run As-Maven Build...，如图输入 jetty:run 即可运行 打开 http://localhost:9090/test/ 测试（端口号可在上方代码处更改，9090 仅供参考） Maven with Tomcat按如下配置POM.xml &lt;build&gt; 内： 123456789101112&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin&lt;/password&gt; &lt;path&gt;/$&#123;project.artifactId&#125;&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt; Maven 仓库内的 settings.xml &lt;servers&gt; 内： 12345&lt;server&gt; &lt;id&gt;tomcat7&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin&lt;/password&gt;&lt;/server&gt; 外部 Tomcat 路径下的 conf/tomcat-users.xml &lt;tomcat-users&gt; 内： 123&lt;role rolename="manager-gui"/&gt;&lt;role rolename="manager-script"/&gt;&lt;user username="admin" password="admin" roles="manager-gui,manager-script"/&gt; 验证运行 Tomcat，打开 http://localhost:8080/manager，在弹窗中输入账号密码，均为 admin，查看是否能登入管理页面，如果可以即可进行下一步，若有错，请检查上述是否设置正确。 运行先运行 Tomcat，再项目右键－Run As－6 Maven Build…－Tomcat7:redeploy，出现 Build SUCCESS，即为配置成功。以后每次修改项目文件，保存后，不需重启 Tomcat，重新发布即可。 One more thing…我在配置完以上并运行以后，有时候仍会报 in 错，然后在开启 Tomcat 的条件下进行验证，发现并不能验证成功，这是因为外部 Tomcat 路径下的 conf/tomcat-users.xml 又还原到了原始状态，需要再次添加上面的内容才可，暂时不知道什么原因导致的。 具体项目中使用，详见 Java BBS。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FCC]]></title>
      <url>2016%2F4%2F</url>
      <content type="text"><![CDATA[FCC 难点 JavaScript 12 12 12 12 12 Manipulate Arrays With push / pop / shift / unshift 12345678910111213var myArray = [["John", 23], ["cat", 2]];myArray.push(["dog", 3]);// ["John", 23], ["cat", 2], ["dog", 3]var removedFromMyArray = myArray.pop();// ["John", 23], ["cat", 2]var removedFromMyArray = myArray.shift();// ["cat", 2]myArray.unshift(["Paul",35]);// ["Paul",35], ["cat", 2] Quoting Strings with Single Quotes 1var myStr = '&lt;a href="http://www.example.com" target="_blank"&gt;Link&lt;/a&gt;'; Project Get Set for our Front End Development Projects Build a Tribute Page Code Pen Build a Personal Portfolio Webpage jQuery Disable an Element Using jQuery &amp; Change Text Inside an Element Using jQuery &amp; Remove an Element Using jQuery &amp; Use appendTo to Move Elements with jQuery &amp; Clone an Element Using jQuery &amp; Target the Parent of an Element Using jQuery &amp; Target the Children of an Element Using jQuery &amp; Target a Specific Child of an Element Using jQuery &amp; Target Even Numbered Elements Using jQuery &amp; Use jQuery to Modify the Entire Page 123456789101112131415161718&lt;script&gt; $(document).ready(function() &#123; $("#target1").css("color", "red"); $("#target1").prop("disabled", true); // .text(): only alters text without adding tags // .html(): add HTML tags and text within an element $("#target4").html("&lt;i&gt;#target4&lt;/i&gt;"); $("#target4").remove(); // appendTo(): move element $("#target2").appendTo("#right-well"); $("#target5").clone().appendTo("#left-well"); $("#target1").parent().css("background-color", "red"); $("#right-well").children().css("color", "orange"); $(".target:nth-child(2)").addClass("animated bounce"); $(".target:even").addClass("animated shake"); $("body").addClass("animated hinge"); &#125;);&lt;/script&gt; Target the same element with multiple jQuery Selectors &amp; Remove Classes from an element with jQuery &amp; Change the CSS of an Element Using jQuery 123456789&lt;script&gt; $(document).ready(function() &#123; $("button").addClass("animated bounce"); $(".well").addClass("animated shake"); $("#target3").addClass("animated fadeOut"); $("button").removeClass("btn-default"); $("#target1").css("color", "red"); &#125;);&lt;/script&gt; Learn how Script Tags and Document Ready Work &amp; Target Elements by Class / ID Using jQuery 12345678&lt;script&gt; // Dollar sign operator $(document).ready(function() &#123; $("button").addClass("animated bounce"); $(".well").addClass("animated shaked"); $("#target3").addClass("animated fadeOut"); &#125;);&lt;/script&gt; Bootstrap Create a Bootstrap Headline &amp; House our page within a Bootstrap Container Fluid Div &amp; Create a Bootstrap Row &amp; Split your Bootstrap Row &amp; Create Bootstrap Wells &amp; Add Elements within your Bootstrap Wells &amp; Apply the Default Bootstrap Button Style &amp; Create a Class to Target with jQuery Selectors &amp; Add ID Attributes to Bootstrap Elements &amp; Label Bootstrap Wells &amp; Give Each Element a Unique ID &amp; Label Bootstrap Buttons &amp; Use Comments to Clarify Code 12345678910111213141516171819202122&lt;div class="container-fluid"&gt; &lt;h3 class="text-primary text-center"&gt;jQuery Playground&lt;/h3&gt; &lt;div class="row"&gt; &lt;div class="col-xs-6"&gt; &lt;h4&gt;#left-well&lt;/h4&gt; &lt;div class="well" id="left-well"&gt; &lt;button id="target1" class="btn btn-default target"&gt;#target1&lt;/button&gt; &lt;button id="target2" class="btn btn-default target"&gt;#target2&lt;/button&gt; &lt;button id="target3" class="btn btn-default target"&gt;#target3&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col-xs-6"&gt; &lt;h4&gt;#right-well&lt;/h4&gt; &lt;div class="well" id="right-well"&gt; &lt;button id="target4" class="btn btn-default target"&gt;#target4&lt;/button&gt; &lt;button id="target5" class="btn btn-default target"&gt;#target5&lt;/button&gt; &lt;button id="target6" class="btn btn-default target"&gt;#target6&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Line up Form Elements Responsively with Bootstrap 123456&lt;div class="row"&gt; &lt;div class="col-xs-7"&gt; &lt;input type="text" class="form-control" placeholder="cat photo URL" required&gt;&lt;/div&gt; &lt;div class="col-xs-5"&gt; &lt;button type="submit" class="btn btn-primary"&gt;&lt;i class="fa fa-paper-plane"&gt;&lt;/i&gt; Submit&lt;/button&gt;&lt;/div&gt;&lt;/div&gt; Style Text Inputs as Form Controls 1234&lt;input type="text" class="form-control" placeholder="cat photo URL" required&gt;&lt;button type="submit" class="btn btn-primary"&gt;&lt;i class="fa fa-paper-plane"&gt;&lt;/i&gt;Submit&lt;/button&gt; Responsively Style Radio Buttons &amp; Responsively Style Checkboxes 12345678910&lt;div class="row"&gt; &lt;div class="col-xs-6"&gt;&lt;label&gt;&lt;input type="radio" name="indoor-outdoor"&gt; Indoor&lt;/label&gt;&lt;/div&gt; &lt;div class="col-xs-6"&gt;&lt;label&gt;&lt;input type="radio" name="indoor-outdoor"&gt; Outdoor&lt;/label&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-xs-4"&gt;&lt;label&gt;&lt;input type="checkbox" name="personality"&gt; Loving&lt;/label&gt;&lt;/div&gt; &lt;div class="col-xs-4"&gt;&lt;label&gt;&lt;input type="checkbox" name="personality"&gt; Lazy&lt;/label&gt;&lt;/div&gt; &lt;div class="col-xs-4"&gt;&lt;label&gt;&lt;input type="checkbox" name="personality"&gt; Crazy&lt;/label&gt;&lt;/div&gt;&lt;/div&gt; Add Font Awesome Icons to our Buttons &amp; Add Font Awesome Icons to all of our Buttons 12345678910111213&lt;link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css"/&gt; &lt;div class="row"&gt; &lt;div class="col-xs-4"&gt; &lt;button class="btn btn-block btn-primary"&gt;&lt;i class="fa fa-thumbs-up"&gt;&lt;/i&gt; Like&lt;/button&gt; &lt;/div&gt; &lt;div class="col-xs-4"&gt; &lt;button class="btn btn-block btn-info"&gt;&lt;i class="fa fa-info-circle"&gt;&lt;/i&gt; Info&lt;/button&gt; &lt;/div&gt; &lt;div class="col-xs-4"&gt; &lt;button class="btn btn-block btn-danger"&gt;&lt;i class="fa fa-trash"&gt;&lt;/i&gt; Delete&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; Create a Custom Heading 123456789&lt;div class="row"&gt; &lt;div class="col-xs-8"&gt; &lt;h2 class="text-primary text-center"&gt;CatPhotoApp&lt;/h2&gt; &lt;/div&gt; &lt;div class="col-xs-4"&gt; &lt;a href="#"&gt;&lt;img class="img-responsive thick-green-border" src="https://bit.ly/fcc-relaxing-cat"&gt;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; Ditch Custom CSS for Bootstrap 123&lt;h2 class="text-center text-primary"&gt;CatPhotoApp&lt;/h2&gt;&lt;a href="#"&gt;&lt;img class="thick-green-border img-responsive" src="https://bit.ly/fcc-relaxing-cat"&gt;&lt;/a&gt; Use the Bootstrap Grid to Put Elements Side By Side col-md-* md: medium *: a number specifying how many columns wide the element should be col-xs-* xs: extra small (like an extra-small mobile phone screen) *: the number of columns specifying how many columns wide the element should be 12345&lt;div class="row"&gt; &lt;div class="col-xs-4"&gt;&lt;button class="btn btn-block btn-primary"&gt;Like&lt;/button&gt;&lt;/div&gt; &lt;div class="col-xs-4"&gt;&lt;button class="btn btn-block btn-info"&gt;Info&lt;/button&gt;&lt;/div&gt; &lt;div class="col-xs-4"&gt;&lt;button class="btn btn-block btn-danger"&gt;Delete&lt;/button&gt;&lt;/div&gt; &lt;/div&gt; Call out Optional Actions with Button Info &amp; Warn your Users of a Dangerous Action 123&lt;button class="btn btn-block btn-info"&gt;Info&lt;/button&gt;&lt;button class="btn btn-block btn-danger"&gt;Delete&lt;/button&gt; Make Images Mobile Responsive &amp; Center Text with Bootstrap &amp; Create a Bootstrap Button &amp; Create a Block Element Bootstrap Button &amp; Taste the Bootstrap Button Color Rainbow 12345&lt;img class="img-responsive" src="http://bit.ly/fcc-running-cats"&gt;&lt;h2 class="red-text text-center"&gt;CatPhotoApp&lt;/h2&gt;&lt;button class="btn btn-block btn-primary"&gt;Like&lt;/button&gt; Use Responsive Design with Bootstrap Fluid Containers 12345&lt;!-- Responsive Design --&gt;&lt;link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css"/&gt;&lt;div class="container-fluid"&gt;&lt;/div&gt; HTML &amp; CSS Override All Other Styles by using Important 123456789101112131415161718192021&lt;style&gt; body &#123; background-color: black; font-family: Monospace; color: green; &#125; #orange-text &#123; color: orange; &#125; .pink-text &#123; color: pink !important; &#125; .blue-text &#123; color: blue; &#125;&lt;/style&gt;&lt;h1 id="orange-text" class="pink-text blue-text" style="color: white"&gt;Hello World!&lt;/h1&gt; Adjusting the Padding of an Element &amp; Adjust the Margin of an Element An element’s padding controls the amount of space between the element and its border. An element’s margin controls the amount of space between an element’s border and surrounding elements. Use HTML5 to Require a Field 12&lt;input type="text" placeholder="cat photo URL" required&gt;&lt;!-- Note: This field does not work in Safari. --&gt; Import a Google Font 123456789&lt;!-- Call --&gt;&lt;link href="http://fonts.googleapis.com/css?family=Lobster" rel="stylesheet" type="text/css"&gt;&lt;style&gt; h2 &#123; font-family: Lobster; &#125;&lt;/style&gt;&lt;h2&gt;CatPhotoApp&lt;/h2&gt; Fill in the Blank with Placeholder Text lorem ipsum text]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[百度 IFE]]></title>
      <url>2016%2F3%2F</url>
      <content type="text"><![CDATA[Team Bug 源代码及 Demo 公布区。Info: Team Bug in 百度 IFE Team Bug in GitHub 任务二十一：基础 JavaScript 练习（四） Source CodeDemo 任务二十：基础 JavaScript 练习（三） Source CodeDemo 任务十九：基础 JavaScript 练习（二） Source CodeDemo 任务十八：基础 JavaScript 练习（一） Source CodeDemo 任务十七：零基础 JavaScript 编码（五） Source CodeDemo 任务十六：零基础 JavaScript 编码（四） Source CodeDemo 任务十五：零基础 JavaScript 编码（三） Source CodeDemo 任务十四：零基础 JavaScript 编码（二） Source CodeDemo 任务十三：零基础 JavaScript 编码（一） Source CodeDemo 任务十二：学习 CSS 3 的新特性 Source CodeDemo 任务十：Flexbox 布局练习 Source CodeDemo 任务八：响应式网格（栅格化）布局 Source CodeDemo 任务五：零基础HTML及CSS编码（二） Source CodeDemo 任务四：定位和居中问题 Source CodeDemo 任务三：三栏式布局 Source CodeDemo 任务二：零基础HTML及CSS编码（一） Source CodeDemo 任务一：零基础HTML编码 Source CodeDemo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PS 快捷键备份]]></title>
      <url>2016%2F2%2F</url>
      <content type="text"><![CDATA[Photoshop Shortcuts. 基础知识界面构成： 菜单栏 工具箱 属性栏 悬浮面板 画布 默认保存格式： .psd 可保留图层，通道等信息 魔术棒工具应用条件： 画面主体或背景，至少有一个颜色相对单一 主体和背景之间的交界线清晰 选区布尔运算：针对已经存在的选区进行计算 新选区画面任意位置单击－取消选择在选区内部按住鼠标左键拖拽－移动选区 加 shift 减 option 相交 shift + option 快捷键d: 恢复到默认的前景背景色（前黑后白）f: 画布三种显示方式切换i: 吸管工具m: 创建规则选区（矩形，椭圆）t: 文字工具v: 移动工具w: 魔术棒工具x: 切换前景背景色z: 缩放工具（也可在触摸板双指缩放） tab: 隐藏除画布外的所有面板空格: 抓手工具，移动画布显示范围 command + 0: 满画布显示command + d: 取消选择command + e: 合并当前选择图层command + k: 首选项command + n: 新建画布command + o: 打开对话框command + r: 打开标尺command + t: 自由调节外框，另外鼠标选择顶点并按 shift 可等比调节或旋转command + w: 关闭画布 command + +: 放大画布command + -: 缩小画布command + ;: 隐藏参考线command + delete: 填充背景色command + return: 结束输入文字command + option + z: 撤销操作command + option + shift + n: 新建图层 control + tab: 切换画布 option + delete: 填充前景色option + 鼠标左键: 以鼠标为中心不动，向外扩散 v, delete: 删除选择的图层（移动工具下操作）v, alt + 拖拽: 位移复制 shift + 鼠标左键: 正圆或正方形shift + 相应快捷键: 切换隐藏工具]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[The First Half of 2016 Plan]]></title>
      <url>2016%2F1%2F</url>
      <content type="text"><![CDATA[计划还是要有的，万一完成了呢？ 寒假前 1.20 软件工程导论－网易云课堂2. PHP 入门篇－慕课网3. 英语谈资课－Wechat 寒假任务 1.20－2.20 专业 数据结构－网易云课堂 软件工程导论－网易云课堂 等等 英语 1. 谈资课－Wechat 阅读 借的书大致看完 读笔于博客 Date: 2016-01-02 下半年总结： 本学期有些堕落，很多计划都没有完成，需要反思。 Mooc 都是听了一半，数据结构课也没有认真听，要尽快在最后的课程设计阶段向老师学习 Swift 今年得到一本比较好的书，由于备考四级，没有坚持，寒假前要缩印，在寒假看 英语是唯一值得欣慰的， Thomas 的课最终拿了 97 分，A+，算是付出有了回报，CET-4 不出意外应该能过，下来就是准备 CET-6 和 NECCS 了 阅读这个是硬伤了，下学期新图书馆开放要积极阅读 练字这方面没有特意练过，不过在做 CET-4 新东方课的笔记时，写了 50 页左右的英语，汉字，还是可以的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[穹顶之下]]></title>
      <url>2015%2F17%2F</url>
      <content type="text"><![CDATA[THIS IS NONSENSE.我，只是希望，你我可以残存心底的良知。 Info: 穹顶之下－柴静 下载 穹顶之下－百度百科 穹顶之下－Wikipedia 穹顶之下－知乎问题页面 前言：本文为本人下周演讲的文章，但略去演讲词，并有一些改动。由于本人不善演讲，虽然经常看一些手机厂商的发布会（也算是一场场演讲）。很钦佩 Steve Jobs 和 Tim Cook 做演讲时的那种感觉，而不太喜欢国内如雷军这样的，总感觉只是讲，互动很干涩，普通话虽然讲的很好，但是还不如魅族白永祥的近人，也不如老罗的老道。奥巴马的演讲我也听过很多（目前本人在做奥巴马每周演讲的翻译），虽然不看视频但是也能感受演讲的氛围。是因为个人偏好英文的演讲？还是国内的演讲商业化太浓重？直到今年二月底看到…2015.12.20 晚其实本文未涉及演讲方向。2015.12.21 Under The DomeThere’s nothing…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何解决 MySQL 中文数据问题]]></title>
      <url>2015%2F16%2F</url>
      <content type="text"><![CDATA[These tips are just backup for myself.If something was wrong, please tell me. Info: MySQL 5.0.27 Windows XP Navicat 注：由于 MySQL 5.7.9 (zip &amp; msi) 均在 xp 上无法安装，因此使用了 MySQL 5.0.27 的安装包，不过方法应该是通用的 Steps: 一. 关闭 MySQL 服务关闭所有正在运行的 MySQL，打开系统命令行（运行 - cmd）中输入 net stop mysql 回车，提示如下图即关闭成功： 二. 更改配置文件中的编码方式打开 MySQL 安装目录，以我的为例：C:\Program Files\MySQL\MySQL Server 5.0 双击打开安装路径根目录图中红色框 my.ini 可能你的目录没有这个文件，而是 my-dafault.ini，打开它，搜索（Ctrl + f）关键词：default-character-set。将等号后面的 latin1 改为 gbk（如图为改好的样子，为安全你可以把原来的此行前加上 #，再另起一行写上 default-character-set=gbk）： 三. 重新打开 MySQL 服务打开系统命令行（运行 - cmd）中输入 net start mysql 回车，提示如下图即打开成功： 四. 检查是否更改成功打开系统命令行（cmd，注：有些人在系统命令行无法运行 MySQL 是因为你没有添加 MySQL 的 bin 目录至环境变量），输入 mysql -u root -p 回车，再输入密码进入。此时输入 status 命令，注意观察下图红框内内容，若均为 gbk 则更改成功： 五. 重新试验以上做完且成功的话，你就可以尝试重新建表，来输入中文了，以前的表因为创建时编码方式不同而此时仍会显示问号或者乱码，重新建表即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[The Second Half of 2015 Plan]]></title>
      <url>2015%2F15%2F</url>
      <content type="text"><![CDATA[计划还是要有的，万一完成了呢？ 大二第一学期（即 2015 下半年） 专业 《数据结构》 《软件工程导论》 《Java 4 Android》 Swift 英语 通过 CET-4 在 Thomas 处好好练习口语 阅读 每月买书 2 本 阅读，并做读后感于 Blog 练字 Eng 汉 Date: 2015-07-01 上半年总结： 大多数计划和规定完成。 但以下两方面未完成： 阅读－阅读量太少； 专业－数据结构未学习，Swift 学习太慢； 练字－未坚持练字。 好的方面： 电台－每周翻译，但近几周更新缓慢； 资金－学习了基金等一些概念，目前已撤； 与学校老师、领导适当沟通； 做了第一份工作－家教； 拿到了一些证书。 前言： 2015 年 7 月 1 日，2015 年已过去整整一半，大一生活宣告结束。2015 年的上半年的部分计划和要求都是比较实际的，但是在阅读方面，几乎没有读完一本书。看了一些杂志，但是整本书的阅读还是太少，可能是在学校太过于浮躁。下半年包含一个暑假和一个学期，暑假计划和学期计划会分开写出。现在有了笔记本，所以要远离温床，远离宿舍。 暑假计划 2015.07.01 - 2015.08.31 所有阶段都要做的是： 自学 Swift &amp; Java 电台及时更新 每天做 OJ 题 阅读 &amp; 练字 锻炼身体 07.20 - 08.10 完成 CET-4 《全真试卷》 背会 CET-4 《四级词汇》 背会 CET-6 《六级词汇》 自学 数据结构 08.10 - 08.31 巩固四六级基础，买卷子，背单词 完成 CET-6 样卷 &amp; 《全真试卷》 巩固数据结构 暑假主要完成： 四六级单词及卷子（LY Library） 数据结构（LY Library）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tapole 记（下）]]></title>
      <url>2015%2F14%2F</url>
      <content type="text"><![CDATA[Tapole 的最终产品终于来到，这样一款非数码产品的开箱体验会是什么呢… Date: 2015/08/21（又）一大早，顺丰小哥就敲门来送快递了＝＝（这一暑假真是麻烦了。。。）开箱吧～ 含苞待拆。 为毛和送来的免费试戴镜架的盒子一样，不是说好的黑色咩，莫非送错了＝＝ 原来庐山真面目在里面＝＝这样也能保证里面的盒子不受挤压。 果然和锤子手机的箱子好像。。。纯黑，好高档，不舍得拆。 盒子手感很好。。。不是反光的，感觉是类肤质的（是这么个形容的么＝＝）。 打开顶盖眼镜就这么出现了。。。不过说好的三角呢＝＝可能是 Bookman 弹弓铰链太蛮力了，后面的小贴纸都把持不住。。。 拿（dai）走（shang）眼镜，我们再看看下面有什么，这个包装很像苹果的。。。不过没有什么数据线，充电器＝＝ 开口特写，这是最大的小盒子，估计是眼镜袋。 果然如此，不过眼镜袋白色，真的很害怕时间久了变脏。。。希望以后多几个选择，而且眼镜袋比较软，对眼镜保护不太大呃，但是很省空间。 另外两个小盒子里就是眼镜布和保修卡，眼镜布很软，也算是种消耗品。保修卡要保存好哦，三包证明里面都有呢，保修期是一年。 哦对了眼镜的具体照片木有了＝＝先让我戴会儿，习惯下。。。度数感觉很准，没有太大的不适应，镜架也比免费试戴的好很多，总之我认为是值得的，不过镜架我可能还要找眼镜店调试下，还是有点宽＝＝所以脸小的 Bookman 一定得调整下。。。 （完）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tapole 记（中）]]></title>
      <url>2015%2F13%2F</url>
      <content type="text"><![CDATA[Tapole 免费试戴的镜架到了，让我们一起来看看吧… Date: 2015/08/16一大早，顺丰快递就敲门了，眼镜君终于来了～下面又开始多图杀猫了，因为开箱来了，虽然只是免费试戴的镜架＝＝首先提前说明一下，免费试戴的镜架都是所有用户共享的，就是说并不是全新的（下面我会提到这些免费试戴眼镜的瑕疵，所以特此声明，不代表最后拿到手里的品质也是如此，大家可以去一些网站看到，最终产品是非常完美，经过调试的，试戴只是让我们在家里更加舒心的选一款心仪的镜架），否则成本太高。。。而且有人估计会冲着镜架去。按最便宜的算，500 元 3 个设计这么好的镜架貌似也不是很亏呐。。。送来的四个镜架（还记得我在备注里写的吗？其实当时还有一种试探的心理，因为每次淘宝写备注，”我是处女座！有瑕疵你就XX了！”，完全木有用＝＝，所以有些懒得童鞋，可以直接备注就好啦，当然也可以找他们的微信客服，微博主页君～）都含有镜片，三个都是平光的，而有一个居然有度数。。。因为我试戴的时候发现好清晰＝＝不过看了试戴指南，里面的光学镜片只是用来固定镜架，而不具备光学性能，那我这个怎么解释，是不是有人退货了。。。因为虽然清晰，但明显不是我的度数＝＝好啦，正式的开箱开始： 嗷嗷待剪的顺丰快递（混进了什么 GUI）： 去掉顺丰袋子里面就是一个纸箱子，大家可能跟我一样觉得，这也太单薄了吧，不过待会你就会跟我一样恍然大悟了。。。上面印着 Tapole 的 LOGO： 这个盒子很像小米的包装盒，不过多了一些什么。。。因为 Tapole 就是从蝌蚪的英文 tadpole 进化过来的： 盒子的另一边贴着一些信息，我看到四个镜架的时候就知道，备注显灵了～： 一次性的开口，很像奥利奥三盒装的设置，不过纸很厚实，能够一次拉开，不过这也对寄回多多少少产生一些麻烦。我觉得应该像那种封起来的那种盒子（我也不知道怎么形容。。。）会更好，因为免费试戴的镜架还需要发快递回去，这样就要麻烦小哥在粘一下了： 打开盒子，看到了吗～话说这里失误，应该把纸拿走拍一下＝＝里面每个眼镜架都配一个眼镜袋，再在其外面缠上气泡防震，怪不得这么大一盒子＝＝： 把镜架拿走，一张打印好的快递单就在里面躺着，这是方便我们寄回的，而且是到付哦，做好最后的选择后，只需要给快递打个电话让他上门来取件就好了～： 开”箱”基本告一段落。。。你说还没见到镜架？所以之前那叫开”箱”。。。上面的图其实拍的很烂，因为手机是小米 2S，在 MIUI 7 的摧残下已经奄奄一息了。。。下面关于镜架部分，我用的是数码相机，多年前老爸在商场买的，佳能 IXUS 9515，没有单反那么高端的物品，桌面太难看就用的 MacBook 做垫背好了，那个 Apple LOGO 也是比格满满＝＝ 这算是一个全家福吧，下面垫的防震的很厚实，眼镜正下方的就是 Tapole 的眼镜袋，白色的，很担心会脏呃，虽然估计用不上几次。。。 第一个出镜：Bookman 第 45 作品 You are the APPLE of my eye. 这款作品的颜色不太好拍出来，设备略渣，官网的图很正，大家最好还是亲眼看看好判断。这是两个 Bookman 的镜腿部分，大家看图就能发现两个镜腿只有一边可以接触到桌面，那款黑色的更为严重。当然这只是试戴作品的问题，在寄给我的四个作品中，Imagine Dragons 可以镜腿水平，意味着 Tapole 还是有这个能力的，大家还是试戴完乖乖把镜架邮回去吧～ 镜腿靠前的部分刻着 Bookman #45。 鼻托部分。 Tapole 的标志，说实话，Bookman 的镜腿在这几款中我最喜欢，弹弓铰链使得收放镜腿很有力度，感觉比较结实，耐用。 第二个出镜：Batman 第 57 作品 You are the APPLE of my eye. 这是黑色款 Bookman 和 Batman 的合影，Batman 的镜片的框很厚很宽，会让人感觉似乎带上去视野会受到影响，事实不是这样。因为 Batman 的镜片面积要大，我戴了之后反倒觉得 Bookman 的视野比较窄，可能是因为 Bookman 的镜架没有调试到合适的宽度。 这款 Batman 的试戴作品的镜腿也没有完全水平。 鼻托部分类似 Bookman。 镜腿靠前部分刻着 Batman #57 Designed by Tapole，Batman 的桩头和平时戴的眼镜差不多，感觉还是 Bookman 的比较精致。 第三个出镜：Imagine Dragons 第 80 作品 You are the APPLE of my eye. 设计很棒，但就是因为太有设计而并不一定适合所有人。 标志圆。 鼻托部分。 镜腿刻着 Imagine Dragons #80 Designed by Tapole。 精致的雕刻（在不同角度看到的颜色会不一样哦！）。 红棕色的套裤。 俯视。 说说感觉吧。三款里面，Bookman 的镜腿我最喜欢，因为弹弓铰链，但是偏宽，Batman 和 Imagine Dragons 较紧。宽窄这些应当是都能调整的。 这个图就是 Bookman 和 Batman 的镜架宽度对比，你会发现，Bookman 很随意的就可以罩住 Batman。 Bookman 和 Imagine Dragons 也是如此。。。 最后纳闷一点的是 Batman，只能先合带标志的那一只镜腿，再合另一只，反之就会合不上，我猜测可能是 Batman 宽实的镜腿导致了这样，不过并不影响。只是使用的时候不要强合，眼睛是需要爱惜的，而窗户也是需要爱护的。 正确合好。 以上都是我直观且主观的感受，有些瑕疵也只是免费试戴才体现出来，不过有一些问题 Tapole 也要注意呢。 掉漆问题。这个问题曾在 iPhone 5 上出现过。。。但眼镜不是数码产品，不能贴膜，不能带保护壳，每天风刮日晒，我不知道一副眼镜的服役期应当是多少，但是耐用一些总没错。但这又和手机不一样，因为手机天天拿在手里，而眼镜你接触最多的是镜片，自己戴上眼镜是看不到镜框什么的，但是作为美观，不能有大的掉漆问题即可。我在 Imagine Dragons 和 Bookman 的金属桩头的位置发现了轻微掉漆，当然我不知道是不是以前的试戴者不小刮擦的，但是机械关节处由于长时间开合挤压，就可能会掉漆。如果你的选择是 Imagine Dragons，那么我建议你还是爱惜一点好。 眼镜宽度调节。网购眼镜，除了验光要靠线下，脸的宽度也决定了镜架带着是否舒服。这一点线上的指导就很重要，眼镜是一个服役期较长的物件，就如我文章开头所说”架在鼻上，挂在耳边，放在眼前”，眼镜不只是眼的问题，还要考虑舒适等问题。眼镜有时候戴的时间久，铰链处开合次数多，就会变松，希望 Tapole 能在这个地方也发挥互联网思维，能够更加便利快捷的解决这个问题。 好啦，总算开完箱了，我要去纠结选哪个镜架了＝＝ Date: 2015/08/17今天咨询了 Tapole 的微信客服 Kitty，总结几个小问题吧。 免费试戴的镜架如如上面所说都是很多人试戴过的，所以呢，肯定是有略微瑕疵的，而最后选择购买的一定是全新的，镜腿的底部也可以接触到平面。 这次发给我的 Bookman 其中有一个是光学镜片，反光是绿色的，说明镀膜有绿色的，这个官网有更详细的资料。虽然度数和我的不大一样，但能感觉到镜片是不错的，比我用了两年的依视路要清晰一些，如果是全新的那么会更好吧。干净的镜片就像 iPhone 的原装屏幕一样，滴水不散。清洗过这个眼镜后，也没有发现划痕什么的，耐用性也应该不错吧，毕竟这需要靠时间验证的。 在没有调整的情况下，Bookman 是比较适合宽脸型的，弹弓铰链能让镜腿更加岔开，而 Batman 和 Imagine Dragons 受制于固定的桩头，比较适合我这种脸不那么大的，不过具体的还是咨询客服比较好，客服给我的回答是，选 Bookman 的话，最好去专业的眼镜店进行调整，这个的确是网上无法做到的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tapole 记（上）]]></title>
      <url>2015%2F12%2F</url>
      <content type="text"><![CDATA[作为一名普通消费者加天秤座，来跟我一起看看网上配镜前的纠结吧… Tapole 出来之时便深深的俘获了我的心。从刚开始送验光消费卷，便关注了这家小厂商，也算是看着它一步步的成长。苦于价格和懒惰，终于在昨日（2015.8.8）得到了一张优惠券。所以这篇文章并不是一次完成的，我会把这次配镜过程，包括获得优惠券，验光等一系列写出来，按照时间更新。希望对那些想要在网上配镜却又不敢迈出这一步的同学给出一个范例，也希望这次”旅程”能够圆满。其实我对眼镜了解并不多，所以下面可能会有很多错误，希望指出并见谅，毕竟我只是一个普通的消费者。2015.8.9 凌晨 前言先说一下为什么选择了 Tapole 吧。 有人说眼镜行业充满了暴力，我承认。其实普通实体眼镜店的成本其实是很高的，需要有店铺的租金，验光设备等等。最重要的是一家店有时候可能一天都没有人来配镜，所以成本自然分摊到每一个去配镜的人。我也在淘宝上搜索过”依视路”的镜片，一枚 1.67 的价格（本人近视度数较高，所以选择这种镜片厚度更薄更美观）大约在 350 元左右，评价有好有坏，让我很是纠结。这样一算，一对镜片加上一个镜架，价格也差不多要到 900 多元。Tapole 的第 43 作品——Bookman 轻薄版价格是 799，貌似并不是贵的离谱，而在什么值得买，Knewone，数字尾巴以及微博的搜索情况看，Tapole 的服务更好，可以免费试戴，客服也很棒，都是加分点。并且，我获得了优惠券，于是就决定还是买 Tapole 的眼镜，体验一下网上配镜是什么感觉。但是由于我之前没有体验过网上配镜，所以无从比较，不过我可能会在 Tapole 买了之后再在网上买一副便宜的作为备用，毕竟我可能会不舍得在恶劣的环境下用它。 Date: 2015/08/08昨天转发并评论了 Tapole 主页君的微博，&quot;说说你最喜欢 Tapole 呈现给你的哪些细节？&quot;。我写了一篇文章，从设计，服务，还有一些特色来表达了我对这家公司产品的喜欢（链接点我）。毕竟我现在还没有买，所以更深层次的细节我也不知道，大概今天中午（现在凌晨＝＝）准备付款吧。所有流程尽可能截图，发在这里。其实本来中了 100 元的优惠券，心不甘呐，没想到 Tapole 主页君居然把自己中的送给了我，很感激！先附上截图： 自己剩下的那个 100 元的决定赠送给 V2EX 社区的朋友，已经发帖了（链接点我），如果没人要就再在微博上问问。再贴一张今天偶然试到的 Tapole 测试页（链接点我），（222.html怎么不是 1024.html，失望－－）不过样子怎么变了呢＝＝，下午的时候是这样：凌晨变成这样了（难道说要上新品了？）： 要睡觉了，虽然已是 9 号，不过日期还是按 8 号吧。 Date: 2015/08/09因为款式不太多，所以就选了三款不同的设计，颜色也不尽相同，来进行试戴： 1 Imagine Dragons 第 80 作品 2 Bookman 第 45 作品 3 Batman 第 57 作品 刚才有人回帖需要，就把那个优惠券送出去了。希望大家都可以有一副好眼镜呐～ Date: 2015/08/11准备先添加一下优惠卷，怕过期，在购买的最后一步可以添加： 这样就可以了： Date: 2015/08/13昨日夜里，天津某化工厂发生了爆炸。多难兴邦，希望逝去的人们走好，而活着的人们，除了祈福，更多的，应当是抹去眼泪继续前行，毕竟，生活还是要继续… 昨天晚上，准备睡觉时，突然刷微博看到了这个震惊的消息。顿时整个人都不困了，看了各种版本的视频，只希望伤亡人数少一些，少一些不必要的牺牲。我是大概 3 点钟才睡去的，早上 8 点半就起来了，今天不知道怎么回事，并不是那么困。其实我是想好好睡一觉，让眼睛休息休息再去验光，觉得那样更准，不过优惠卷快到期了＝＝，所以上午预约，下午看完小米的发布会，就驱车（自行车…）前往”XX眼科医院”。 大概叙述下验光的过程吧，先在网上咨询了医院。在两家中选了眼科的专科医院，也不知道怎么样，因为之前都是在本地的眼镜店验光完就配镜。这个眼科医院是综合验光，可以插片试戴。看知乎上说年龄到达一定岁数可以不进行散瞳，所以上午就预约了，免费的，而且可以只验光，不配镜。 到了医院，医院大厅有个导医台，我跟护士（应该是护士吧？）说我在网上预约的，查了我的名字就帮我写了份条子，领我去办卡。卡是押金 10 元，验完光就可以退，现在好像都是这个样子，估计是避免医生收现金吧。然后她开了个验光的条，我们这里不算是什么大城市，29 元就可以了，交完钱我就去了验光区。先是一台机器，让我把下巴放在机器上看远处的房子，验光师操作了一番，机器会左右眼单独测，大概两分钟就好了，让我去楼上测之前眼镜的度数。之前听说过测眼镜度数，没想到一个小机器就能测出镜片的各种参数＝＝也是蛮神奇。测好我拿着单子下楼又找验光师，就开始在一个大机器上估测度数吧？把眼睛放在那个洞上，验光师就在对面的墙上打出视力表还有那种红绿底色的视力表。上面有很多镜片，验光师会根据你说的是否清晰进行调整，大概五分钟就好了。下来就是插片试戴了，这个跟刚才差不多试了一会儿，验光师让我带着那个插片眼镜到大厅转转，后来听验光师说，是因为我之前眼镜左边度数有点高，但是我又没在试片中表现的度数高了就清晰了，以为可能是有点误差，就让我歇了会再继续。不过最后也是一样所以可能是之前配的眼镜左眼度数过高了，这次就调低了点。最后验光师给我测了测瞳距。该走的时候验光师问我在哪里配镜，因为之前跟他说过我准备在网上配的（其实这个医院也可以配，当初还担心因为我不配镜而不受待见…）。我就跟他说了在 Tapole，她又没听说过这么小众的牌子，就让我给她写下来，方便她以后给别人推荐…所以…咳咳…广告费，你懂得$_$ 整个过程，从进店开始算起大概 40 分钟，我自己一个人去的，如果中间验光师不让我在外面溜达会儿，估计 30 分钟内就能搞定。验光结果令我还是比较高兴的，两年近视度数没涨（我的镜片已经刮花的不成样子了…），右眼散光略微增长。一切弄清楚，问了问 Tapole 客服，近视和散光度数是否加起来超过了 800，Kitty 说，没有～所以终于可以下单了～毕竟如果度数高于 800，超轻薄版的价格实在不能接受… 一起跟着我看看下单的步骤吧，首先我先选的是用 Bookman 第 45 作品下单，然后试戴另外两款。如果你最后选择了比下单时价格更高或更低的款式，多退少补即可。 下面就是多图杀猫了： 度数在 500～800 之间，自然选择轻薄版，折射率是 1.67。 这是三款的试戴选择，除了本身透蓝色的 Bookman，选择了铜色的 Imagine Dragons 和黑色的 Batman。 这里我选择了直接填度数等信息，大家可以选其它自己方便的也可以。 暑假在家，自然什么时候收货都可以了。 发票选择电子发票，环保，不易弄丢，存一份即可。 勾选优惠卷，并留言～不知道 Tapole 的客服是否能够满足小小的要求呢～ 付款完成，手机也会收到信息哦～ 基本的购物过程就这样结束了，明天不知道会不会发货呢，好期待～ Date: 2015/08/14以为不会发货呢，没想到晚上终于发货了～可以不用上网站查呢，发货有短信提醒哦～ Date: 2015/08/15应主页君所邀，待会我会把上面这些用锤子便签生成图片，方便微博同学浏览～]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[寻找下一个地球]]></title>
      <url>2015%2F11%2F</url>
      <content type="text"><![CDATA[人类在宇宙中是如此的渺小，却又如此的幸运。这个蓝色星球承载着我们的一切。宇宙如此广袤，地球绝不是孑然一身，让我们跟着 NASA，寻找下一个地球…本文摘自 NASA 官方网站的一篇题为“Finding Another Earth”的文章，经本人翻译放出。 译者注：我相信，每一个孩子都曾仰望苍穹。孩子们用幼稚的眼神望着浩瀚的星空，一片漆黑，却又繁星闪闪，好奇又恐惧。而如今，每当夜晚，举头仰望，繁星早已不在，却仍有几个微小的星星向我们传来微弱的光。太阳落下，黑色的天空就像一本战书，向那些最具有远见卓识和勇敢的人发出挑战。而 NASA 绝对是其中的冲锋者。人类，从未停止探索…国内部分媒体和自媒体关于这件事情的报道，实在是太让人些许无奈，制造一个特别大的标题（这也归于 NASA 提前三天说有“重大发现”），但内容却寥寥几句，不够深入。国内的果壳网、知乎等做得更有深度。我们就一起看看 NASA 官方是怎么说的吧，我只选取了其中一篇进行翻译，第一是因为这件事来的突然，我从未翻译过这样一个未知领域的文章；第二科技文的翻译也必须要确凿的，不能夸张或者曲解，需要链接许多相关资料，难度骤增。但我也希望通过这篇文章唤起你在匆忙的生活中，偶尔抬头望下星空，思考下这个广袤无垠的宇宙与己与你的命运。 Distant Planets遥远的行星July 23, 20152015 年 7 月 23 日 Finding Another Earth寻找下一个地球 A newly discovered exoplanet, Kepler-452b, comes the closest of any found so far to matching our Earth-sun system. This artist’s conception of a planetary lineup shows habitable-zone planets with similarities to Earth: from left, Kepler-22b, Kepler-69c, the just announced Kepler-452b, Kepler-62f and Kepler-186f. Last in line is Earth itself.Credits: NASA/Ames/JPL-Caltech一个最近发现的系（译者注：太阳系）外行星（exoplanet），Kepler-452b，是迄今为止发现的和我们的日地系统（Earth-sun system）最为相似的星球。上述艺术家描绘的行星阵容图表示与地球类似的宜居（habitable-zone）星球：从左开始分别为：Kepler-22b，Kepler-69c，刚刚宣布的 Kepler-452b，Kepler-62f，和 Kepler-186f。最后一个是地球自己。图片来源及所属：NASA/Ames/JPL-Caltech Of the 1,030 confirmed planets from Kepler, a dozen are less than twice the size of Earth and reside in the habitable zone of their host stars. In this diagram, the sizes of the exoplanets are represented by the size of each sphere. These are arranged by size from left to right, and by the type of star they orbit, from the M stars that are significantly cooler and smaller than the sun, to the K stars that are somewhat cooler and smaller than the sun, to the G stars that include the sun. The sizes of the planets are enlarged by 25 times compared to the stars. The Earth is shown for reference.Credits: NASA/Ames/JPL-Caltech在 1030 个由开普勒（Kepler）计划已证实的行星中，有十二个的体积小于两倍的地球（体积），并在宜居带（habitable zone）围绕着自己的寄主星（hosts stars）。在这张图表中，系外行星的体积通过球体大小等效表示出。从左到右按体积从小到大依次排开，并且按轨道（orbit）类型，从温度极低且体积小于太阳的 M 型星（M stars）到温度较低且体积小于太阳的 K 型星（K stars）再到包括太阳在内的 G 型星（G stars）。图中，行星（planets）的体积被放大了 25 倍以便和恒星（stars）比较。地球同样在图中标出。图片来源及所属：NASA/Ames/JPL-Caltech The discovery of a super-Earth-sized planet orbiting a sun-like star brings us closer than ever to finding a twin of our own watery world. But NASA’s Kepler space telescope has captured evidence of other potentially habitable planets amid the sea of stars in the Milky Way galaxy.运行轨道围绕类日（sun-like）恒星的超级地球（super-Earth-sized）行星的发现使我们更加易于寻找类似我们自己赖以生存的淡水世界。NASA 的开普勒太空望远镜（Kepler space telescope）已经在星罗云布的银河系中（Milky Way galaxy）找到了其它潜在的宜居行星（存在）的证据。 To take a brief tour of the more prominent contenders, it helps to zero in on the “habitable zone” around their stars. This is the band of congenial temperatures for planetary orbits – not too close and not too far. Too close and the planet is fried (we’re looking at you, Venus). Too far and it’s in deep freeze. But settle comfortably into the habitable zone, and your planet could have liquid water on its surface – just right. Goldilocks has never been more relevant. Scientists have, in fact, taken to calling this water-friendly region the “Goldilocks zone.”为了简单叙述更加突出的（地球）竞争者，（让我们）把聚焦于它们恒星的“宜居带”（habitable zone）。这是具有适合人类生存所需温度的行星公转轨道——不太近也不太远（公转轨道半径恰好适中）。太近（公转轨道半径太小）行星将被炙烤（我们说的就是金星（Venus））。太远（公转轨道半径太大）却又会是一个冰冻星球（译者注：这里的冰，并不单一指 H2O 的固态形式，例如：甲烷等一些气体在温度低于熔点也可凝结成冰，地球上也天然存在这样的冰例如可燃冰（天然气水合物））。但恰好位于宜居带（habitable zone）的行星表面将会有液态水——恰如其分。Goldilocks（译者注：Goldilocks 原意：金发姑娘）与此并没有关系。但实际上，科学家已开始将水以液态存在的（空间）区域称为古迪洛克区（Goldilocks zone）（译者注：也称“适居带”）。 The zone can be a wide band or a narrow one, and nearer the star or farther, depending on the star’s size and energy output. For small, red-dwarf stars, habitable zone planets might gather close, like marshmallow-roasting campers around the fire. For gigantic, hot stars, the band must retreat to a safer distance.这个区域可能很宽也可能很拥挤（译者注：这是指此类似环形区域的内外圆半径之差），紧邻恒星又或远离恒星（译者注：这是指此类似环形区域的内圆半径长度），这些是由恒星的体积大小和能量输出来决定的。对于体积小的红矮星（red-dwarf stars）来说，其处在宜居带（habitable zone）的行星彼此更加靠近，就像围在焰火旁烤棉花糖（译者注：marshmallow-roasting 扩展：棉花糖－烧烤，这可能是美国人在野外烧烤的一道佳肴）吃的野营者。对于巨大，炽热的恒星，它的这个区域必须后撤到一个更加安全的距离。 About a dozen habitable zone planets in the Earth-size ballpark have been discovered so far – that is, 10 to 15 planets between one-half and twice the diameter of Earth, depending on how the habitable zone is defined and allowing for uncertainties about some of the planetary sizes.迄今为止有大约 12 个类地（Earth-size）大小且位于宜居带（habitable zone）的行星被发现——即有 10 到 15 个行星直径为地球的 1.5 到 2 倍之间，这取决于宜居带（habitable zone）是如何定义并宽容一些不规则大小的行星。 The new discovery, Kepler-452b, fires the planet hunter’s imagination because it is the most similar to the Earth-sun system found yet: a planet at the right temperature within the habitable zone, and only about one-and-a-half times the diameter of Earth, circling a star very much like our own sun. The planet also has a good chance of being rocky, like Earth, its discoverers say.Kepler-452b 的最新发现，激发了行星探索者们的想象，因为这是迄今为止发现的最类似于我们的日地系统（Earth-sun system）的星球：一个位于宜居带（habitable zone）、温度适宜、且直径仅为地球的 1.5 倍的星球，还围绕着一颗极为相似于太阳的恒星。同样，它有很大可能是岩质行星（rocky ／terrestrial planet），像地球一样，它的发现者说。 Kepler-452b is more similar to Earth than any system previously discovered. And the timing is especially fitting: 2015 marks the 20th anniversary of the first exoplanet confirmed to be in orbit around a typical star.Kepler-452b 比以往发现的任何星体系统都更类似于地球。而且（发现的）时机尤其适合，2015 年是（人类）发现首颗围绕一个典型恒星运转的系（译者注：太阳系）外行星（exoplanet）被确认的 20 周年纪念日。 But several other exoplanet discoveries came nearly as close in their similarity to Earth.但是（也有）许多其它系（译者注：太阳系）外行星（exoplanet）在个别方面类似于地球。 Before this, the planet Kepler-186f held the “most similar” distinction (they get the common moniker, “Kepler,” because they were discovered with the Kepler space telescope). About 500 light-years from Earth, Kepler-186f is no more than 10 percent larger than Earth, and sails through its star’s habitable zone, making its surface potentially watery.在此之前，行星 Kepler-186f 是“最为相似（于地球）”的星球（它们的名字拥有相同的前缀，“Kepler”，因为它们均为开普勒太空望远镜（Kepler space telescope）所发现的）。Kepler-186f 距离地球 500 光年（译者注：light-years 扩展：光年意思基本可以理解为：光传播一年的距离，即光速乘以相应单位年，这个名词是表示距离。在宇宙中（依据大爆炸假说），空间在起点急剧膨胀，在膨胀了约百亿多年后，形成了今天这样的宇宙，天体之间距离很远，便采取光传播一年的距离作为衡量天体距离的单位。），（体积）不超过地球的 1.1 倍，处在其恒星的宜居带（habitable zone）使其表面可能有水。 But its 130-day orbit carries it around a red-dwarf star that is much cooler than our sun and only half its size. Thus, the planet is really more like an “Earth cousin,” says Thomas Barclay of the Bay Area Environmental Research Institute at NASA’s Ames Research Center, Moffett Field, California, a co-author of the paper announcing the discovery in April 2014.但它的公转周期为 130 天，其所围绕的红矮星（red-dwarf stars）比太阳的温度要低得多，并且大小只有太阳的一半。因此，这个行星确实十分像“地球的姊妹”，工作在位于墨菲特联邦机场（Moffett Field／Moffett Federal Airfield）的 NASA 阿姆斯研究中心（NASA’s Ames Research Center）中的海湾地区环境研究所（Bay Area Environmental Research Institute）宣布此发现的 2014 年 4 月论文的共同作者之一的 Thomas Barclay 说到。 Kepler-186f gets about one-third the energy from its star that Earth gets from our sun. And that puts it just at the outside edge of the habitable zone. Scientists say that if you were standing on the planet at noon, the light would look about as bright as it does on Earth an hour before sunset.Kepler-186f 获得其恒星的能量约为地球获得太阳能量的 1/3。并且，它位于宜居带（habitable zone）的外缘。科学家称，如果中午时刻站在那个星球上，看到其恒星的亮度将会和地球上日落前一个小时的太阳亮度相当。 That doesn’t mean the planet is bereft of life, although it doesn’t mean life exists there, either.这并不意味着这颗星球完全不能够居住，同样也不意味着那里没有生命。 Before Kepler-186f, Kepler-62f was the exoplanet known to be most similar to Earth. Like the new discovery, Kepler-62f is a “super Earth,” about 40 percent larger than our home planet. But, like Kepler-186f, its 267-day orbit also carries it around a star that is cooler and smaller than the sun, some 1,200 light-years away in the constellation Lyra. Still, Kepler-62f does reside in the habitable zone.在 Kepler-186f 之前，Kepler-62f 是当时已知最类似地球的行星。就像新的发现，Kepler-62f 是一个“超级地球”，体积大约是我们地球妈妈的 1.4 倍。但是，如 Kepler-186f 一样，Kepler-62f 公转周期为 267 天，其所围绕的恒星温度同样要比太阳低得多，体积也比太阳小得多，在距离我们约 1200 光年的天琴座（constellation Lyra）中。尽管如此，Kepler-62f 确实仍位于宜居带（habitable zone）。 Kepler-62f’s discovery was announced in April 2013, about the same time as Kepler-69c, another super Earth – though one that is 70 percent larger than our home planet. That’s the bad news; astronomers are uncertain about the planet’s composition, or just when a “super Earth” becomes so large that it diminishes the chance of finding life on its surface. That also moves it farther than its competitors from the realm of a potential Earth twin. The good news is that Kepler-69c lies in its sun’s habitable zone, with a 242-day orbit reminiscent of our charbroiled sister planet, Venus. Its star is also similar to ours in size with about 80 percent of the sun’s luminosity. Its planetary system is about 2,700 light-years away in the constellation Cygnus.Kepler-62f 在 2013 年 4 月被宣布发现，大约在同一时间，Kepler-69c——另一个超级地球被发现——虽然其大小约为地球的 1.7 倍。这不是个好消息；天文学家不确定这个星球的组成，而且当这个“超级地球”体积如此巨大，其表面生命存在可能性便大大降低。因此将它排在潜在地球孪生姐妹的名单中更加靠后的位置。好消息是，Kepler-69c 位于其恒星的宜居带（habitable zone），242 天的公转周期让我们联想起地球的姐妹星，金星（Venus）。它的恒星大小与太阳相似，亮度约为太阳的 80%。它的行星系统在距离我们约 2700 光年的天鹅座（constellation Cygnus）。 Kepler-22b also was hailed in its day as the most like Earth. It was the first of the Kepler planets to be found within the habitable zone, and it orbits a star much like our sun. But Kepler-22b is a sumo wrestler among super Earths, about 2.4 times Earth’s size. And no one knows if it is rocky, gaseous or liquid. The planet was detected almost immediately after Kepler began making observations in 2009, and was confirmed in 2011. This planet, which could have a cloudy atmosphere, is 600 light-years away, with a 290-day orbit not unlike Earth’s.Kepler-22b 同样在当时被认为最像地球。它是被找到的第一个位于宜居带（habitable zone）的开普勒星球，并且其公转所围绕的恒星十分类似于我们的太阳。但是 Kepler-22b 在超级地球中身材类似于相扑选手，约为地球体积的 2.4 倍。并且没有人知道它是岩质，气态还是液态的星球。这颗行星在 2009 年开普勒太空望远镜（译者注：简称：Kepler）开始进行观测时就几乎被立刻发现，并在 2011 年确认存在。这个星球，拥有多云的大气层，距离我们 600 光年，并且公转周期 290 天不同于地球。 Not all the planets jostling to be most like Earth were discovered using Kepler. A super Earth known as Gliese 667Cc also came to light in 2011, discovered by astronomers combing through data from the European Southern Observatory’s 3.6-meter telescope in Chile. The planet, only 22 light-years away, has a mass at least 4.5 times that of Earth. It orbits a red dwarf in the habitable zone, though closely enough – with a mere 28-day orbit – to make the planet subject to intense flares that could erupt periodically from the star’s surface. Still, its sun is smaller and cooler than ours, and Gliese 667Cc’s orbital distance means it probably receives around 90 percent of the energy we get from the sun. That’s a point in favor of life, if the planet’s atmosphere is something like ours. The planet’s true size and density remain unknown, however, which means it could still turn out to be a gas planet, hostile to life as we know it. And powerful magnetic fluxes also could mean periodic drop-offs in the amount of energy reaching the planet, by as much as 40 percent. These drop-offs could last for months, according to scientists at the University of Oslo’s Institute of Theoretical Astrophysics in Norway.当然，并不只是由开普勒太空望远镜（译者注：简称：Kepler）所观测到的所有行星都争抢着最类似于地球。在 2011 年，一个命名为 Gliese 667Cc 的超级地球同样被曝光，这是一位天文学家凭借坐落于智利的欧洲南方天文台（European Southern Observatory）口径 3.6 米的望远镜观察后并梳理数据得来的。这颗行星，距离我们只有 22 光年，质量约为地球的 4.5 倍。它位于宜居带（habitable zone）并围绕着一颗红矮星（red dwarf）公转，而且足够紧邻——公转周期 28 天，使得这颗星球遭受来自其恒星表面周期性的强烈耀斑（flare）。尽管如此，其恒星比我们的太阳体积更小，温度更低，并且 Gliese 667Cc的公转轨道距离意味着它将可能接收到其恒星约 90% 的能量。这颗行星的大气层是否类似于地球将是生命是否存在的关键。这颗行星真实的大小和密度仍然未知，这意味着它仍有可能是一个气态行星（gas planet／giant），如我们所知一样不适宜生命存在。并且强大的磁场（magnetic fluxes）可能导致到达此行星的能量将周期性衰减 40%。这些衰减将会持续数月，据位于挪威的奥斯陆大学（University of Oslo）的理论物理研究所（Institute of Theoretical Astrophysics）所说。 Deduct two points.推论两点。 Too big, too uncertain, or circling the wrong kind of star: Shuffle through the catalog of habitable zone planets, and the closest we can come to Earth – at least so far – appears to be the new kid on the interstellar block, Kepler-452b.（体积）太大，（性质）太不确定，或者围绕着一颗错误类型的恒星：遍历处在宜居带（habitable zone）的所有行星，并且要最接近地球——至少目前为止——一个新的行星出现在星际区域，即 Kepler-452b。 NASA’s Ames Research Center in Moffett Field, California, manages the Kepler and K2 missions for NASA’s Science Mission Directorate. NASA’s Jet Propulsion Laboratory in Pasadena, California, managed Kepler mission development. Ball Aerospace &amp; Technologies Corp. operates the flight system with support from the Laboratory for Atmospheric and Space Physics at the University of Colorado in Boulder.位于加利福尼亚州（California）墨菲特联邦机场（Moffett Field／Moffett Federal Airfield）的 NASA 阿姆斯研究中心（NASA’s Ames Research Center），为 NASA 科学任务部门（NASA&#39;s Science Mission Directorate）担任开普勒（计划）和 K2 任务（译者注：详见参考资料 3）。位于加利福尼亚州（California）帕萨迪纳市（Pasadena）的 NASA 喷气推进实验室（译者注：Jet Propulsion Laboratory 简称：JPL）管理开普勒计划的发展。鲍尔航天科技公司（Ball Aerospace &amp; Technologies Corp.）在位于科罗拉多大学波德分校（University of Colorado (in) Boulder）的大气和空间物理实验室（Laboratory for Atmospheric and Space Physics）提供的支持下管理飞行系统。 JPL is managed by The California Institute of Technology for NASA.喷气推进实验室（JPL／Jet Propulsion Laboratory）由 The California Institute of Technology（译者注：加州理工大学） 为 NASA 管理。 More information about Kepler is online at:在线获取更多相关 Kepler 的信息请访问：http://www.nasa.gov/kepler More information about NASA’s planet-hunting efforts is online at:在线获取更多相关 NASA 行星探索计划的信息请访问：http://planetquest.jpl.nasa.gov A related news release about Kepler’s latest planetary find is online at:在线获取近期相关 Kepler 所发现的最新行星的新闻请访问：http://www.nasa.gov/press-release/nasa-kepler-mission-discovers-bigger-older-cousin-to-earth Written by Pat Brennan, PlanetQuest作者：Pat Brennan, PlanetQuestWhitney ClavinJet Propulsion Laboratory, Pasadena, Calif.818-354-4673whitney.clavin@jpl.nasa.gov 2015-244 Last Updated: Aug. 1, 2015网页最后更新于：2015-08-01（译者注：此非原文的最后更新时间，而是本人翻译时打开此网页的最后时间。）Editor: Tony Greicius编辑：Tony Greicius 尾注：其实翻译完，发现这篇文章对于最新发现的 Kepler-452b 的描述十分少。而是如同题目“寻找下一个地球”所说，简要的介绍了开普勒计划中发现的一些类似地球的行星。想了解更多相关信息，可以点击上述文章内的链接，也可以在下方“参考资料”及“相关阅读”寻找资料。第一次尝试翻译此种类型的文章，其中的一些词组都是天文学的专有词汇，本人尽量做到了每条翻译后均附带原文（即高亮处理部分），并链接到 Wikipedia（不链接到百度百科的原因是，百度百科的准确性不太高，且链接太长）。点击带下划线的词组即可直接跳转，如果访问不到，那只能怪高墙太高，你需要一把梯子，或者尝试百度。部分词汇也有本人进行了解说。有一些句子进行了改造，但尽力做到了不影响原意。原文版权归 NASA 所有，翻译版权归本人所有，请勿私自商用或转载，谢谢合作。 参考资料： NASA 官网 Google 翻译 Wikipedia Bing 词典 欧路词典 Free for Mac 相关阅读： NASA 官网 Kepler-452b in Wikipedia Kepler(spacecraft) in Wikipedia 果壳网｜10个问题，释疑NASA的“另一个地球” 知乎｜2015 年 7 月 23 日，NASA 宣布发现 Kepler-452b 意味着什么？ 寻找下一个地球 由 萌面大道 创作，采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于http://nasa.gov/jpl/finding-another-earth上的作品创作。本许可协议授权之外的使用权限可以从 http://maimieng.com/ 处获得。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[这一年，我，去哪里了...]]></title>
      <url>2015%2F10%2F</url>
      <content type="text"><![CDATA[这篇文章原本计划给某些人看的，不过，这里还不想被人发现，还是等更好的时候吧。文笔不好，从小写作难，情商低，大家小心被吓着。前言：从小语文就很差，不擅于写作文。还记得小学有一次，老师特意把作文课（通常是连着的两节 40 分钟的语文课），放在下午放学前，谁写完谁就可以放学回家，写不完就一直写。放学铃响了，我望着教室里稀稀拉拉的同学，实在是不愿意在校外接我的父亲等得太久。于是我就随便一写，字数够了就交了。然后收拾书包就走了，走出班门，我就撕开了中午买的泡泡糖嚼了起来。刚下到二楼的时候，楼上跑下来个同学（不记得是谁了），到我面前说，“老师让你的作文重写！”，当时我的心情…我就直接把泡泡糖吐了，又上楼了。一直都是个很怂的人，或者说好听点是很听话的人。后来，我也不记得发生了什么，但是对自己吐泡泡糖的行为倒是记忆犹新。我一直都不擅长写作，可能写出来都是流水账，没有人懂。但那是你看不看的权利，我还是想写，毕竟这些话，我没有人能说。所以，看不看由你。正文：14 年 6 月，高考。似乎对于这场考试并没有太大的信心，我也不记得当时脑子里想的什么，我是个健忘的人，回忆在脑子里总是搅乱着，让我自己也分不清是梦还是真实。高中，便这样结束了。说句实话，在高中，我一直感觉自己不曾融入到这个班级。或许是自己一直很自卑吧，我很少感觉自己能融入一个大集体。我没有去过网吧，没有玩各种游戏，自认为自己的努力打动了自己，却没打动过成绩。但，我不后悔。报志愿时候的记忆也很模糊了，直到现在，我才突然意识到，当初似乎从未听说过南阳这个城市，就这样来到了这里。我也在好奇自己为何没有考虑过郑州或者更好的城市，但已经过去那么远了，也没什么意义了。欣慰的是，这里似乎没有一位我曾认识的人。在一座陌生的城市，开始新的生活，没有人认识曾经的你，一切都是从新开始。就这么糊里糊涂的来到南阳，就这么上了一所自己从未耳闻的学院，也许，我永远都不会知道“大学”和这里有什么区别吧。还好，专业是软件工程，至少，和电脑打交道。我是个不擅于社交的人，我已经接触网络八年了，但我并没有在一些社交媒体上刷存在感，也不想让自己的生活完全暴露在网络之下。我就是喜欢和这些冷冰冰的物件打交道，可能比不上一些大神，但比起很多普通人，我还是“有余的”。机器不会撒谎，不会有偏见，不需要我去编造一些花言巧语，而且不离不弃。似乎很多动物也是这样，但许多人不是。说到这里，可能大多数人已经认为我是个宅，愤青。的确，是那么有点宅，是那么有点喜欢国外的环境，但我不愤青，有些事情我都知道，但我没有说，只是在脑子里想想，然后算了…来到这里的一年，我几乎没参加过任何的聚会，没去了解过这个城市，没有自发地离开校园去外面转转，没有在这里转街买过衣服，什么都没有。到现在，我都没有真正融入这座城市，做家教的那几天，在公交车上看这个城市，每次都是那么陌生。我唯一思考的是，这四年，甚至说三年，我怎么样才能离开这里，去一个我愿意了解、融入的城市。毕业以后，我绝对不会待在这里。当然，这里并不是那样的不堪，只是，我的穷志不允许我在这里，我想到外面去看看。那么，我这一年，去哪里了呢？这一年，我的努力程度并不高。因为总是有很多事情阻碍着我。说句实话，我一直都是个爱好学习的人（我所理解的学习：学习是一个很宽泛的词，学习只是一个动作，但并没有指定学习的方向，社会是有分工的，每个人的兴趣和能力都不一样，每个人每一天都是不断学习的过程。），但结果很惨：学得很卖力，别人觉得装逼；学得效果很渣，反被别人虐。在大学以前，我的努力只感动了自己，却从未打动过其他任何，可能努力的功做的还不够，也可能是力的方向根本不对。有人可能会说，学习是自己的事情，何必管他人的目光呢？只能说，我做不到不受影响。到大学总算是有个比较中意的专业了，可是有不少人都已经“抢跑”了，或者有更好的“教练”，或者穿着更专业的“跑鞋”，又或者天生“跑步因子”。这些，都是公平的，我从来不会去否认一个人的努力，努力是个褒义词，但是努力并不一定有结果，对的方向才能产生对的结果，然而方向是需要不断地努力不断地调整的。我十分敬佩那些努力的人，也许还没有什么结果，但是付出是值得肯定的，哪怕失败了。这一年，在这个班里，我自告奋勇当了学习委员。这个职位，低于班长、团支书，需要听命于他们，但又专管学习，忙的程度不亚于他们。大学了，每个人都是独立的个体，上课只是一方面，但通知必须告知到每个人，老师或是学校的任务需要让每一分子知晓。这一年的责任我问心无愧。这个班里没有我上这么多年学见到的那些不学习却影响他人的人，我很欣慰。在这学期末我考虑转方向时，很多人劝我不要离开，或者鼓励我离开，我十分感动，我不是个擅长表达的人，但我不是个没心没肺的人。谢谢你们，我不会离开这个班，希望大家能够在一起好好的，有时候觉得你们就像孩子，希望我可以尽我所能帮到你们吧。有很多人说，大学就像一个社会，但我却在这里感觉融入了进来，社会，也许并不是很多人认为的勾心斗角，如果我们可以以诚相待，将心比心，你所在的小社会也会美好吧。这一年，在这个拥挤的宿舍里。很少有那种攀比，无论是学习还是其他。离得越近的人，摩擦就越多，偶尔的小吵小闹，过几天就会消散。人与人之间不可能总是美好，缝缝补补的日子，才是真实的。我不想说多么煽情的话，也是希望我们可以好好的，这也许是最后的几年宿舍生活了吧。这一年，也感谢很多学长的帮忙。让我对未来了解了很多，也知道了很多坑。这一年，也感谢各个老师的辛苦，和你们打交道比较多，老师们各个也都是出身名校，让我感到了很多差距，也和你们了解了许多。这一年，也感谢学院的一些领导，转方向的事找你们多次，可我现在还是决定了，不离开了。这一年，感谢南阳，虽然我不曾了解你，不愿融入你，但是我曾在这落脚，不能负恩。这一年，也没什么成果。成绩总算是符合了我的努力，也终于有了自己的网站，电台虽然现在只有 13 个节目，订阅人数在今天突破了 1000，这些事情看似都没有意义，但我觉得值得。当努力有了应有的回报，便值得我更加努力。这一年发的说说，几乎全部都是只让大学的同学们看到。我并不是想隐瞒什么，只是不想让别人看到我在这里“装”。有时候发英文，只是觉得，如果那样直白，就没意义了。有时候会觉得活得很累，什么都知道，但是没人说，有人却说不出。这篇文章，我也许放在博客的某个角落，也许只是让大学的你们看到。这一年吃的苦，也没必要让所有人看到。至于感情方面，我不在行，I don’t care.梦，还远未到，而我，还在这里。The people who are crazy enough to think they can change the world are the ones who do. 文笔太烂，如能看完，不胜感激]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[本博格式规范]]></title>
      <url>2015%2F9%2F</url>
      <content type="text"><![CDATA[本博客的一些格式规范说明，读者可忽略。 本博客采用 Hexo 生成，并使用了 next 主题。 md 文件基本格式：1234567891011title: date: - -tags: categories: ---&lt;blockquote class=&quot;blockquote-center&quot;&gt;摘要。&lt;/blockquote&gt;&lt;!--more--&gt;正文 其他： 数字，英文，代码块的前后要有一个空格，若有标点，可省略空格； 中文文字使用 （） 等符号，英文文字使用 () 等符号； 使用 ### 或 ## 以及 - 来标记段落，并需要和正文之间保留一个空格的距离； 奥巴马每周演讲翻译电台不在首页列出，可在左侧 iProgram 出中找到； 暂时取消分类，只留标签，但文章分类仍会显示； 博文链接为标题的英文，全部小写字母，单词间使用 _ 连接，博文 md 源文件名称需在前加上年份； 占位补充。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello, world!]]></title>
      <url>2015%2F8%2F</url>
      <content type="text"><![CDATA[你好，世界！ 很高兴，新的博客又一次开通了，之前用 WordPress + 万网的免费虚拟主机，实在是有些臃肿。这次换成 Hexo + GitHub／GitCafe 希望可以简约一些，毕竟文字才是最重要的。 by kingcos PS: 由于稳定性考虑，本站目前只在 GitHub Pages 托管，因此国内访问速度较慢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Key Points of C++]]></title>
      <url>2015%2F7%2F</url>
      <content type="text"><![CDATA[本文总结的重点摘自：《双语版 C++ 程序设计》文章语言：English 注意：本文档主要目的是个人存档，以防忘记，不对考试的正确率和原题负责，而且并不保证英文的语义及语法的准确性请知悉。 Note:The most basic knowledge is not included. String12345678910char c[10], d[10], e, f[10];cin &gt;&gt; c;cin.getline(d, 10, '\n')// If the last line has 'cin', you have to use the 'ignore()' function.cin &gt;&gt; e;ignore(80, '\n');cin.getline(e, 10, '\n'); C-String Functions 123456789101112131415161718192021222324252627282930313233343536373839// Lengthchar c[20] = &quot;MaiMieng&quot;;int len;len = strlen(c);// len = 8, excluding &apos;/0&apos;// Copychar a[20] = &quot;MaiMieng&quot;;char b[20];strcpy(b, a);// b[] = &quot;MaiMieng&quot;;// Concatenationchar a[50] = &quot;http://www.&quot;;char b[] = &quot;maimieng.com&quot;;strcat(a, b);// a[] = &quot;http://www.maimieng.com&quot;;// Comparechar a[50] = &quot;http://www.&quot;;char b[] = &quot;maimieng.com&quot;;int c = strcmp(a, b);// Othchar a[] = &quot;mai&quot;;char b[] = &quot;mieng.com&quot;;strncat(a, b, 5);// a[] = &quot;maimieng&quot;;strncpy(a, b, 5);// a[] = &quot;mieng&quot;;// Convert C-string -&gt; number// header:#include &lt;cstdlib&gt;char ch[] = &quot;123.5&quot;;atoi(ch); // Integer 整型atof(ch); // Double float 双精度浮点型atol(ch); // Long integer 长整型 C++ String 123456789// header:#include &lt;string&gt;string s = &quot;maimieng&quot;;// Strings in C++ are defined by class.string str = &quot;http://maimieng.com&quot;;int i = (str == s); // 0// See details in the chapter of comparisons. C++ string member function assign 1234567891011string a(5, &apos;-&apos;);// a = &quot;-----&quot;;string b.assign(3, &apos;.&apos;);// b = &quot;...&quot;;string c = &quot;mieng&quot;;string d.assign(c, 0, 1);// d = &quot;mi&quot;; // The index start from 0.// 下标从0开始。 swap 123456string s = &quot;mai&quot;;string str = &quot;mieng&quot;;s.swap(str);// s = &quot;mieng&quot;;// str = &quot;mai&quot;; append 1234567891011121314string a = &quot;mai&quot;;string b = &quot;mieng&quot;;string c = a + b;// c = &quot;maimieng&quot;;c.append(&quot;mai&quot;);// c = &quot;maimai&quot;;c.append(b, 0, 1);// c = &quot;maimaimi&quot;;c.append(2, &apos;=&apos;);// c = &quot;maimaimi==&quot;; at, substr 1234567891011string a = &quot;maimieng.com&quot;cout &lt;&lt; a.at(0);// m// Equal to access the string from index.string b = &quot;maimieng&quot;;cout &lt;&lt; b.substr(3, 5) &lt;&lt; endl;cout &lt;&lt; b.substr(3, 2) &lt;&lt; endl;// mieng// mi replace 12345678string a = &quot;mai&quot;;string b = &quot;mieng&quot;;a.replace(1, 2, b, 1, 4);// a = &quot;mieng&quot;;a.replace(1, 2, b);// a = &quot;mmieng&quot;; erase, empty 12345678910111213string a = &quot;http://mai&quot;;string b = &quot;mieng.com&quot;;b.erase(5);// b = &quot;mieng&quot;;a.erase(0, 7);// a = &quot;mai&quot;;a.erase();// a = &quot;&quot;;int i = a.empty();// i = 1;i = b.empty();// i = 0; find, rfind 123456789101112131415161718192021222324string a = &quot;maimieng&quot;;int i;i = a.find(&quot;mi&quot;);// i = 3;i = a.rfind(&quot;com&quot;);// i = -1;// Find from right side.i = a.find_first_of(&quot;ni&quot;);// i = 2;// Find first of n or i.i = a.find_last_of(&quot;ni&quot;);// i = 6;// Find last of n or i.i = a.find_first_not_of(&quot;mai&quot;);// i = 5;// Which index character other than m, a, i first found in.i = a.find_last_not_of(&quot;mai&quot;);// i = 7;// Which index character other than m, a, i last found in. ==, !=, &gt;, &lt;, &gt;=, &lt;=, compare 12345678910111213141516string s = &quot;mai&quot;;string str = &quot;mieng&quot;;int i;i = (s &gt; str);// i = 0;// s &lt; str;i = s.compare(str);// i = -1;// s &lt; stri = s.compare(0, 2, str);// i = -1// &quot;ma&quot; &lt; str// compare() returns int, when the strings are equal, return 0; when the first string is smaller than the second one, it return negative numbers, otherwise positive numbers. string input getline 123string s;getline(cin, s, &apos;\n&apos;);// So s can store blanks. string convertions 1234567891011121314151617string s = &quot;mai&quot;;char c[] = &quot;mieng&quot;;int i = s.length();// C++ -&gt; Cs.copy(c, len);c[len] = &apos;\0&apos;;// c[] = &quot;mai&quot;;s.copy(c, 2, 1);c[2] = &apos;\0&apos;;// c[] = &quot;ai&quot;;// C -&gt; C++s = c;// s = &quot;ai&quot;; Character Classification isalnum A-Z, a-z, 0-9 isalpha A-Z, a-z islower a-z isupper A-Z isprint Printable character. tolower toupper FunctionPassing arguements by reference 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;void test(int &amp; p);int main()&#123; int n = 1; int &amp; r = n; cout &lt;&lt; r &lt;&lt; endl; n = 2; cout &lt;&lt; r &lt;&lt; endl; test(r); cout &lt;&lt; r &lt;&lt; endl; return 0;&#125;void test(int &amp; p)&#123; cout &lt;&lt; p &lt;&lt; endl; p += 1; cout &lt;&lt; p &lt;&lt; endl;&#125;// Pass structure variable or strings by reference. &amp; ^ 12// &amp;: XNOR 同或// ^: XOR 异或 Passing multi-dimensional array 12345void test(const int i[][3], int no_of_rows);&#123; int i[2][3] = &#123; &#123;1, 2, 3&#125; , &#123;4, 5, 6&#125; &#125;; test(i, 2);&#125; Function overloading Difference: Quantity of arguements. Type of agruements. We can use :: to access the global variable when it is hidden by a local variable. Headers &lt;cmath&gt; -&gt; sin(), cos(), tan() In radians. &lt;cstdlib&gt; -&gt; rand(), srand() &lt;ctime&gt; -&gt; time() Objects and classInline function Features: Short Efficient Pointers &amp; Dynamic Memoryconst with pointers From right to left, which variable has the const before it, it will not be changed. 123456789101112int i, j;const int * p = &amp; i;// *p is a constant, but p isn&apos;t.int const * p = &amp; i;// *p is a constant, but p isn&apos;t.int * const p = &amp; i;// p is a constant, but *p isn&apos;t.const int * const p = &amp; i;// p &amp; *p are constants. 12345678910111213141516171819// ONE-dimensional arraysint a[5];// a is equal to &amp;a[0].int * p;p = a;// a[2] is equal to p[2] and *(a + 2).// MULTI-dimensional arraysint i[3][2] = &#123; &#123;4, 6&#125;, &#123;1, 3&#125;, &#123;9, 7&#125; &#125;;// i[0] is equal to &amp;i[0][0].// i[1] is equal to &amp;i[i][0].// *i[0] is equal to i[0][0].// *(i[0] + 1) is equal to i[0][1].int * p[3];// 3 pointers.int * (p[3]);// 1 pointer. 1#include &lt;iostream&gt; using namespace std; void swap(int * a, int * b) &#123; * a = * a + * b; * b = * a - * b; * a = * a - * b; &#125; int main() &#123; int a = 5; int b = 10; swap(&amp;a, &amp;b); cout &lt;&lt; a &lt;&lt; endl &lt;&lt; b; return 0; &#125; 123456789// How to new a object room.class Test&#123; int test1();&#125;Test * T;T = new Test;T.test1();delete T; 123456789101112131415161718// MUITI-dimensional arraysint i[3][2] = &#123; &#123;4, 6&#125;, &#123;1, 3&#125;, &#123;9, 7&#125; &#125;;int **data;int r = 3;int c = 2;// newdata = new int * [r];for(int i = 0; i &lt; r; i++)&#123; data[i] = new int [c];&#125;// deletefor (i = 0; i &lt; r; i++)&#123; delete[] data[i];&#125;delete[] data; 1234567// Memory checkvoid out_of_memory()&#123; cerr &lt;&lt; &quot;Error&quot; &lt;&lt; endl; exit(1);&#125;set_new_handler(out_of_memory); Operator OverloadingCan not be overloaded: . .* :: ?: sizeof + 12345678910111213141516171819202122232425262728// 1CLASS operator+(TYPE VAR) const;CLASS CLASS::operator+(TYPE VAR) const&#123; CLASS OBJECT; ... return OBJECT;&#125;// 2CLASS operator+(const CLASS &amp; VAR) const;CLASS CLASS::operator+(const CLASS &amp; OBJECT) const&#123; CLASS OBJECT; ... // It can use 1 here. return OBJECT;&#125;// 3// Non-member overload.CLASS operator+(TYPE VAR, const CLASS &amp; OBJECT)]&#123; CLASS OBJECT; ...// It can use 1 / 2 here. return OBJECT;&#125; ++ 12345678910111213141516171819// PrefixCLASS operator++();CLASS &amp; CLASS::operator++&#123; * this = * this + 1; // It can use + 1 / 2 / 3. return * this;&#125;// PostfixCLASS &amp; operator++(int);CLASS &amp; CLASS::operator++&#123; CLASS TEMP; TEMP = * this; * this = * this + 1; return TEMP;&#125; == 123456789bool operator == (const CLASS &amp; OBJECT) const;bool CLASS::operator == (const CLASS &amp; OBJECT) const&#123; if ... return true; else ... return false;&#125; &gt;&gt;, &lt;&lt; 123456789101112// Non-member overload.ostream&amp; operator&lt;&lt;(ostream&amp; os, const CLASS &amp; OBJECT)&#123; os &lt;&lt; ...; return os;&#125;istream&amp; operator&gt;&gt;(istream&amp; is, CLASS &amp; OBJECT)&#123; is &gt;&gt; ...; return is;&#125; Conversion 1234567operator int();CLASS::operator int()&#123; int ... = ...; return ...;&#125; = 12345678910const CLASS&amp; operator=(const CLASS&amp; OBJECT);const CLASS&amp; CLASS::operator=(const CLASS&amp; OBJECT)&#123; if (this != &amp;OBJECT) // Avoid self-assignment &#123; ... &#125; return * this;&#125; [ ] 1234567891011121314151617181920TYPE&amp; operator[](int index);void check_index(int index) const;int * data;int number_of_elements = N;TYPE&amp; CLASS::operator[](int index)&#123; check_index(index); return data[index];&#125;void check_index(int index) const&#123; if ( index &lt; 0 || index &gt;= number_of_elements ) &#123; ... exit(1); &#125;&#125; For example 1#include &lt;iostream&gt; #include &lt;iomanip&gt; using namespace std; class Vector &#123; public: Vector(int a = 0, int b = 0); void get_vector(int&amp; a, int&amp; b) const; void set_vector(int a, int b); Vector operator+(const Vector v) const; Vector operator++(); Vector operator++(int); const Vector&amp; operator=(const Vector&amp; v); private: int x; int y; &#125;; Vector::Vector(int a, int b):x(a), y(b)&#123;&#125; void Vector::set_vector(int a, int b) &#123; x = a; y = b; &#125; void Vector::get_vector(int&amp; a, int&amp; b) const &#123; a = x; b = y; &#125; Vector Vector::operator+(const Vector v) const &#123; Vector temp; temp.x += v.x + x; temp.y += v.y + y; return temp; &#125; Vector Vector::operator++() &#123; (*this).x += 1; (*this).y += 1; return *this; &#125; Vector Vector::operator++(int) &#123; Vector temp; temp = *this; (*this).x += 1; (*this).y += 1; return temp; &#125; const Vector&amp; Vector::operator=(const Vector&amp; v) &#123; if (this != &amp;v) // Avoid self-assignment &#123; (*this).x = v.x; (*this).y = v.y; &#125; return *this; &#125; ostream&amp; operator&lt;&lt;(ostream&amp; os, const Vector v) &#123; int x, y; v.get_vector(x, y); os &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y; return os; &#125; istream&amp; operator&gt;&gt;(istream&amp; is, Vector&amp; v) &#123; int a, b; is &gt;&gt; a &gt;&gt; b; v.set_vector(a, b); return is; &#125; int main() &#123; int x, y; Vector V; Vector v; Vector A; cin &gt;&gt; V; cin &gt;&gt; v; cout &lt;&lt; V &lt;&lt; endl; cout &lt;&lt; v &lt;&lt; endl; A = V + v; cout &lt;&lt; A &lt;&lt; endl; ++V; cout &lt;&lt; V &lt;&lt; endl; cout &lt;&lt; V++ &lt;&lt; endl; cout &lt;&lt; V &lt;&lt; endl; A = v; cout &lt;&lt; A &lt;&lt; endl; return 0; &#125; File &amp; Streams#include &lt;fstream&gt; Open a file 12345ifstream in;ofstream out;in.open(&quot;...&quot;);out.open(&quot;...&quot;); Close a file 12in.close();out.close(); File error checking 1234// File class&apos;s member function.fail();good();eof(); Single character I/O 123456char c;while (in.get(c)) // Read&#123; ...&#125;out.put(); // Write Read a line 123456789string str;char ch[11];// Cin.getline(c, 11);cout &lt;&lt; c &lt;&lt; endl;// Cppgetline(in, str);cout &lt;&lt; str &lt;&lt; endl; Append ios::app Append ios::binary Binary ios::in ifstream default ios::out ofstream default Binary I/O 1234567ofstream out(&quot;...&quot;, ios::binary);if (out.fail())&#123; &#125;out.write(reinterpret_cast&lt;char *&gt;(&amp; ...), SIZE);out.close();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Key Points of Linux]]></title>
      <url>2015%2F6%2F</url>
      <content type="text"><![CDATA[本文总结的重点摘自：《Linux 操作系统（第 1 版）》文章语言：English 注意：本文档主要目的是个人存档，以防忘记，不对考试的正确率和原题负责，而且并不保证英文的语义及语法的准确性请知悉。 Why English? As we know, all the commands in Linux consist of the English names. So it’s easy to remember the commands with the help of English. Basic KnowledgeLinux’s feature: Open source Everybody can get, spread and even modify the source code freely Linux plays an important role in Server-Side and Embeded platform Linux has 4 major parts: Kernel Shell File-System and Applications Linux has 2 kinds of versions: Kenel version and Distribution Kernel has 3 numbers：r.x.y 1. r：The main kernel version 2. x：Even number for stable, while the odd number for beta 3. y：Count of modification Common distribution：Mandriva Red Hat SUSE Debian Ubuntu Gentoo Slackware Red Flag We don’t use the root account to login the system because it’s not safe Fedora’s default graphical interface: GNOME Fedora’s explorer: Mozilla Firefox User prompt：Super user# common user$ Linux system running level is a kind of state. Command Of Shutdown123456789101112131415// C: shutdownshutdown -h nowshutdown -h 45 // 45minutes// C: halthalt// C: reboot (Restart)reboot// C: initinit 0 // Shutdowninit 1 // Single user modeinit 2 // Multiuser modeinit 3 // Character interfaceinit 4 // Unusedinit 5 // X Windowinit 6 // Reboot get help 1man ls // Find ls&apos;s meaning vi Editor3 Working modes 1. Command mode 2. Insert mode 3. Last line mode Switch among 3 modes 1 －&gt; 2 Input ‘i’ 2 -&gt; 1 Press ‘ESC’ 1 -&gt; 3 Press ‘:’ and input ‘wq’ to save and exit All the directories and devices in Linux exist by file Linux file type1. common file 12-rw-r--r--// first &apos;-&apos; 2. directory file 12drwxr-xr-x// first &apos;d&apos; /etc : Include most parts of configuration files in Linux system Operation among files and their directories 12345678pwd// return working directory namecd /etccd ~cd ..// change working directoryls -l /root// list directory contents Line Describtion 1 1:file type 2-4:file owner’s access permission 5-7:user group’s access permission 8-10:other user’s access permission 2 count of file links 3 file’s owner 4 file’s user group 5 bytes of the file 6~8 date of last modification 9 file name 12345678910111213mkdir newdir1// make directoriesmkdir -m 777 newdir2// set permission in the same timermdir newdir1// remove (empty) directoriescp /etc/1.c /etc/2.ccp /etc/1.c /varcp -r /boot /root// copy filesrm -i file4// then input &apos;y&apos;// remove directory entries Linux Common Commandscat […] [filename] concatenate and print files …: -n: Number the output lines, starting at 1. -b: Number the non-blank output lines, starting at 1. -s: Squeeze multiple adjacent empty lines, causing the output to be single spaced. -E: Output $ when each line’s end sort […] [file] sort lines of text files …: -m -c -u -d -f -I -M -r grep […] [search mode] [filename] file pattern searcher find [file path] […] [-print] walk a file hierarchy uname […] Print operating system name date […] [+’date form’] Shell ProgrammingRead the book from 106 to 121 CAREFULLY User Management3 kinds of user 1. root user 2. virtual user 3. common user /etc/passwd details 1MaiMieng:x:500:500:MM:/home/maimieng:/bin/bash Username Password User ID User Grop ID User Full Name Main Directory Login Shell MaiMieng x 500 500 MM /home/maimieng /bin/bash useradd add user passwd [user name] set password userdel [-r] [user name] delete user Disk And File System3 kinds of partition 1. Primary 2. Extand (container of Logic) 3. Logic Read the book from 152 to 156 CAREFULLY mkfs mount umount File and Directory Permission We can limit 3 kinds of users: 1. File owner 2. Users which under the file owner’s group 3. Other users in the system Set Permissionby Wordschmod [who] [+|-|=] [mode] [file/directory name] change file modes or Access Control List by Numbers1. r: 4 2. w: 2 3. x: 1 4. -: 0 chmod [n1n2n3] [file/directory name] Daily ManagementRPM commands 1. Install rpm -ivh [file name] 2. Uninstall rpm -e [file name] 3. Inquire rpm -q [file name] tar commands Linux condensing files: .gz .tar.gz tgz bz2 .Z .tar The differences between condensing and pack pack: means several files pack to one total file condensing: means a big file condenses to a small one by some condensing algorithms System process ps […] process status kill -9 [PID] terminate or signal a process df […] display free disk space du […] [file name] display disk usage statistics Network Settings in Linuxifcfg-th0 include the FIRST network card information ifcfg-th1 include the SECOND network card information ping: P224 arp: P226 address resolution display and control service [service name] […] Improve Performance of Security Setup firewall Turn down the unused services and ports Forbid to set up the default route Password management Partition management Keep away from network sniffer Full logs management Use the security application Use the saving IP Install antivirus program Promote login security Install latest patches Linux Security methods Lauch and Login BIOS User password Dafault account Password file Forbid ‘Ctrl+Alt+Del’ to restart Limit ‘su’ commond Linux Network Server SettingsP239 VNC in P243-244]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++ 编程代码风格指南]]></title>
      <url>2015%2F5%2F</url>
      <content type="text"><![CDATA[本文翻译自C++ Programming Style Guidelines原文地址；参考资料：Google 机翻；本文仅供参考，如有错误，希望指出；如有侵权，会立即删除，本文决不用于任何商业用途。 本文为 ID: 萌面大道 http://maimieng.com/ 翻译，授权网易云课堂 C++ 程序设计入门(上)的崔毅东老师作为课件使用，大家可以免费下载，禁止用于商业用途，如需转载，需联系本人并保留此版权声明。(CC 版权声明在文末)祝大家学有所成！ ——Powered by 萌面大道 1 介绍 这份文档列出了 C++ 开发社区中 C++ 代码编写的基本指南。 这些建议是基于多个来源，个人经验，实际需求及一些给定的建议［1］－［4］收集来的而确定的标准。 引入一份新的指南而不只是引用以上的资料原因有很多。最主要是因为那些资料范围太过宽泛，并且更多的具体规则（尤其是命名规范）需要建立。同时，这份指南拥有注释，可以让它比大多数现存指南更简单地使用于检查项目中的代码。此外，编程指导通常以莫名其妙的方式和编程语言的技术问题混在一起。不过虽然这份文档不包含任何 C++ 技术建议，但聚焦于主要的编程风格。其他可以参考 C++ 编程实践指南。 集成开发环境（IDE）能够通过可视化接口，高亮代码，自动补全等提高代码可读性。程序员应该拒绝依赖这些特性。源代码应该被我们更多地注意而不是 IDE 对于代码的照顾，并且应当使代码独立于任何 IDE 但获得最大化的可读性。 1.1 指南布局 这些指南以不同主题分组，并且每个建议都被标明序号，在审查代码时可以更方便地参考。（译者注：最后一条是 94，不过在这其中有几条并不存在，源网站也没有。） 以下是指南的布局： n. 指南简述 恰当的例子（以下此处不译） 原因, 来源 和 附加信息。 第三行很重要。代码标准和指南有可能引发争论，因此为它们标注来源是很重要的。 1.2 指南的重要性 在指南部分里，“必须”，“推荐”，“建议”均有特殊含义。“必须”是一定要遵守的，“推荐”是强烈建议，“建议”是一般指引。（译者注：为了标明此，有些语言进行了重组。） 2 通用指南 1. 任何违反此指南但提高代码可读性都是允许的。 该指南的主要目的是提高代码可读性，从而使得一般数量级的代码更好的理解和维护。此指南不可能涵盖所有的特殊情况，这需要程序员的随机应变、灵活运用。 2. 如果您和它持强烈不同的意见，您完全不必遵守此指南。 制作这份指南，并不是用一个特定的代码风格去强加于每个人。有经验的程序员虽然通常采用类似这种规范，但有一份这样的指南，且让每个人都去熟悉它，通常可以使人们开始思考代码风格并评判在这个领域他们自己的习惯。 另一方面，没有经验的程序员或者编程新手想要进入这一行当，通常遵循一个代码风格指南会让这段路途走得更加惬意。 3 命名规范 3.1 一般命名规定 3. 变量和常量类型的命名每个单词的首字母必须大写。 Line, SavingsAccount C++ 开发社区惯例。 4. 变量的命名首字母必须小写（其他单词首字母大写）。 line, savingsAccount C++ 开发社区惯例。使得变量便于区别于类型，并且有效地解决了命名冲突，类似：Line line;。 5. 常量的命名（包括枚举值）必须用下划线分隔单词并全部大写。 MAX_ITERATIONS, COLOR_RED, PI C++ 开发社区惯例。通常，常量应尽量避免使用。大多数情况下，作为函数执行所得值是更好的选择： 1234int getMaxIterations() // NOT: MAX_ITERATIONS = 25&#123; return 25;&#125; 这种形式既能增加代码可读性，又能确保了对于类的值具有统一的接口。 6. 函数或方法的命名必须是动词词组且首字母小写（其他单词首字母大写）。 getName(), computeTotalWidth() C++ 开发社区惯例。此命名规范类似于变量的命名，但 C++ 函数通过不同形式区别于变量名。 7. 命名空间推荐以全部小写命名。 model::analyzer, io::iomanager, common::math::geometry C++ 开发社区惯例。 8. 命名模版类型推荐使用单一的大写字母。 12| template&lt;class T&gt; ...| template&lt;class C, class D&gt; ... C++ 开发社区惯例。这使得模版名称突出于所有其他名称。 9. 作为名称使用时，缩略词不得使用全部大写［4］。 12exportHtmlSource(); // NOT: exportHTMLSource();openDvdPlayer(); // NOT: openDVDPlayer(); 使用全部大写命名基本名称将会和上述的命名规范冲突。像 dVD, hTML 等如此命名的变量可读性显然不高。另外还有一个问题在上述例子中已经说明；当名称和另外一个有联系，代码可读性会严重下降；缩略词并不那么像它本身那样独特。 10. 全局变量推荐使用::操作符。 ::mainWindow.open(), ::applicationContext.getName() 通常，应避免使用全局变量。可以考虑使用单件模式对象来代替。 11. 类的私有变量命名推荐以下划线为结尾。 1234class SomeClass &#123; private: int length_ ;&#125; 除了变量的名称和类型，作用域是其最重要的特性。使用下划线指示类的作用域可以很简单的区分局部变量和类的成员变量。这点很重要，因为类的成员变量比函数变量具有更大的作用域，因此更值得被程序员注意。此方法的另一个作用就是它很好的解决了为了给函数或构造器设值寻找合理的变量名： 1234void setDepth (int depth)&#123; depth_ = depth;&#125; 有一个问题就是使用前缀还是后缀下划线。两者都被广泛的使用，但是更加建议使用后缀，因为这样可以维持更好的可读性。 需要注意的是，变量作用域的争议问题已经持续很久了，虽然好像现在这个指南已经获得了赞同，并且这将作为一条惯例在专业的开发者社区变得越来越普遍。 12. 通用的变量推荐和其类型一致。 12345678void setTopic(Topic* topic)// NOT: void setTopic(Topic* value)// NOT: void setTopic(Topic* aTopic)// NOT: void setTopic(Topic* t)void connect(Database* database)// NOT: void connect(Database* db)// NOT: void connect (Database* oracleDB) 通过减少术语和名称来减少代码复杂程度。此外，使得仅给出名字推断出类型变得容易。如果有一些原因似乎不能强烈地指出其类型名，就说明这是一种错误的选择。非通用的变量有一个特殊的角色。这些变量可以经常结合类型命名： 12Point startingPoint, centerPoint;Name loginName; 13. 所有名称推荐使用英文。 fileName; // NOT: filNavn 在国际化开发中，英文是首选语言。 14. 变量作用域越长，推荐使用更长的名称，作用域越短，建议使用较短的名称［1］。 暂时存储或索引的临时变量名字最好较短。程序员阅读这些变量应该能推断出它的值不会在几行代码之外使用。常见的整型临时变量有：i, j, k, m, n，字符型：c, d。 15. 对象的名字是暗示的且要避免出现在函数名称中。 line.getLength(); // NOT: line.getLineLength(); 后者在类的声明中看起来很自然，但被在例子中被证明在使用中这是多余的。 3.2 特定命名规定 17. 术语 get/set 必须使用在直接存取属性的地方。 1234employee.getName();employee.setName(name);matrix.getElement(2, 4);matrix.setElement(2, 4, value); C++ 开发社区惯例。在 Java 语言中，这个规定几乎已成为一种标准。 18. 术语 compute 建议使用在需要计算的方法（函数）中。 valueSet-&gt;computeAverage(); matrix-&gt;computeInverse(); 给阅读代码者直接线索，这可能会是一个潜在的超时操作，若重复使用时，可能要考虑缓存的结果。一致的使用此规范可以增加代码可读性。 19. 术语 find 建议使用在需要查找的方法（函数）中。 vertex.findNearestVertex(); matrix.findMinElement(); 给阅读代码者直接线索，这会是一个查找的方法（函数），只涉及简单的操作。一致的使用此规范可以增加代码可读性。 20. 术语 initialize 建议使用在建立对象或概念。 printer.initializeFontSet(); 美式 initialize 优于英式 initialise。最好避免使用缩略词init。 21. 代表 GUI（图形化）组件的变量推荐使用组件类型作为后缀。 mainWindow, propertiesDialog, widthScale, loginText,leftScrollbar, mainForm, fileMenu, minLabel, exitButton, yesToggle etc. 从名称给出变量类型和对象资源的线索，可以提高代码可读性。 22. 复数形式在表示对象集合时推荐使用。 vector&lt;Point&gt; points; int values[]; 从名称给出变量类型和其中元素要进行的操作的线索，可以提高代码可读性。 23. 若存在多个对象推荐加上前缀 n。 nPoints, nLines 这种标号方式来自于数学，是一种已建立为标明多个对象的惯例。 24. 独立的（实体）序号推荐加上后缀 No。 tableNo, employeeNo 这种标号方式来自于数学，一种已建立为标明独立的（实体）序号的惯例。 一种更为优雅的方式是使用前缀i：iTable, iEmployee。 这可以有效的命名迭代程序。 25. 迭代程序（器）推荐命名为 i，j，k 等。 1234567for (int i = 0; i &lt; nTables); i++) &#123; :&#125;for (vector&lt;MyClass&gt;::iterator i = list.begin(); i != list.end(); i++) &#123; Element element = *i; ...&#125; 这种标号方式来自于数学，一种已建立为标明迭代程序（器）的惯例。 变量名 j，k 等，推荐只在嵌套的循环中使用。 26. 布尔变量和方法（函数）推荐加上前缀 is。 isSet, isVisible, isFinished, isFound, isOpen C++ 开发社区和 Java 部分强制惯例。 使用后缀解决了一个常见的问题，即选择不好的布尔变量名称，类似：status, flag。而 isStatus 或 isFlag 又不太合适，因此程序员将被迫选择更多有含义的名字。 这里有一些在某些条件下更好的前缀方案供选择，他们是 has, can 和 should 前缀： 123bool hasLicense();bool canEvaluate();bool shouldSort(); 27. 互补的名称必须用在互补的操作［1］。 123get/set, add/remove, create/destroy, start/stop, insert/delete,increment/decrement, old/new, begin/end, first/last, up/down, min/max,next/previous, old/new, open/close, show/hide, suspend/resume, etc. 通过对称性减少代码复杂程度。 28. 名称中最好避免出现缩略词。 computeAverage(); // NOT: compAvg(); 有两种类型的单词需要注意。第一种是词典中列出的普通词，这些不得简写，千万不要这样写： cmd 代替 command cp 代替 copy pt 代替 point comp 代替 compute init 代替 initialize 等 另一种是具有特殊含义的词组，通过他们的缩略词可以更自然的为人们所知，这些词组要保持缩略形式，千万不要这样写： HypertextMarkupLanguage 代替 html CentralProcessingUnit 代替 cpu PriceEarningRatio 代替 pe 等 29. 最好避免特殊地命名指针。 123Line* line;// NOT: Line* pLine;// NOT: LIne* linePtr; C/C++ 环境有许多指针类型的变量，所以很多规定几乎无法遵守。此外，程序员应当忽略 C++ 的对象通常斜体的特殊惯例。只有当对象的实际类型具有特殊意义，名称才应强调类型。 30. 最好避免出现否定的布尔变量名。 bool isError; // NOT: isNoError bool isFound; // NOT: isNotFound 当一个名称出现双重否定时，会出现问题。因为不能从 !isNotFound 直接看出其含义。 31. 枚举常量建议以共同的类型名作为前缀。 12345enum Color &#123; COLOR_RED, COLOR_GREEN, COLOR_BLUE&#125;; 在声明处给出额外的信息，可以看出哪些常量是共通的，以及这些常量所代表的意义。一种代替方案是总是通过共同的类型名联系这些常量：Color::RED, Airline::AIR_FRANCE 等。 注意，枚举名应当是典型的单数 Color {...}。一个复数的名称像 Colors {...}，在声明时并没有什么区别，但这样的用法看起来比较笨拙。 32. 例外的类推荐加上后缀 Exception。 1234class AccessException&#123; :&#125; 例外的类其实不是程序主要设计的一部分，通过命名让它们相对于其他类更加突出。 33. 函数（具有返回值的方法）推荐命名为它们执行后的返回或者规程（void 型方法）。 增加代码可读性。使得可以很清晰的看出其功能，尤其是其不支持什么功能。这将再一次使代码简化避免副作用的产生。 4 文件 4.1 源文件 34. C++ 头文件推荐以 .h（推荐）或 .hpp 作为扩展名。源文件应该为 .c++（推荐）, .c, .cc 或 .cpp。 MyClass.c++, MyClass.h 以上均为 C++ 标准支持的文件后缀名。 35. 类推荐在头文件中声明，并在类名和文件名匹配的源文件中定义。 MyClass.h, MyClass.c++ 易于找到给定类的相关文件。一个明显的例外，即模版类声明和定义必须在同一个 .h 文件内。 36. 推荐把所有的定义包含在源文件中。 12345678class MyClass&#123;public: int getValue () &#123;return value_ ;&#125; // NO! ...private: int value_;&#125; 头文件应当声明一个接口，源文件应执行它。当寻找,执行时，程序员应总是清楚它可以在源文件中找到。 37. 文件目录必须在 80 列内。 80 列是编辑器，终端，显示端和调试器中共同的宽度，并且文件将在很多人中共享，所以应当保持这些系统规定参数。在程序员之间传递代码时，避免无意义的断行，能够提升代码可读性。 38. 分页符和 Tab 等特殊符号必须避免在程序中出现。 这些字符用在多人编程，多平台时将必定导致编辑器，显示端，终端模拟器或者调试器出现问题。 39. 分行显示的代码必须使其显而易见［1］。 12345678910111213totalSum = a + b + c + d + e;function (param1, param2, param3);setText (&quot;Long line split&quot; &quot;into two parts.&quot;);for (int tableNo = 0; tableNo &lt; nTables; tableNo += tableStep) &#123; ...&#125; 当一段代码超过 80 列的极限时需要分行。很难给出严格的规定什么情况需要分行，但是上面的例子可以作为参考。通常： 逗号后分行 操作符后分行 对准上一行的表达式的开始的新的一行 4.2 包含文件和包含语句 40. 头文件必须放在一个保护装置中。 1234#ifndef COM_COMPANY_MODULE_CLASSNAME_H#define COM_COMPANY_MODULE_CLASSNAME_H :#endif // COM_COMPANY_MODULE_CLASSNAME_H 这个结构是为了避免产生编译错误。 这个命名规定统一了源代码中头文件的位置，避免了命名冲突。 41. Include 语句推荐将其按分类排级，并按等级从低到高排序。在两个 Include 语句类之间空行分隔。 12345678#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;qt/qbutton.h&gt;#include &lt;qt/qtextfield.h&gt;#include &quot;com/company/ui/PropertiesDialog.h&quot;#include &quot;com/company/ui/MainWindow.h&quot; 除了展示给阅读代码者清晰的包含文件结构，同样可以直接看出涉及哪些模块。 Include文件目录不能使用绝对路径。编译器指令应改为用于为包含的文件指示根目录。 42. include语句必须只放在文件顶端。 通用规范。避免隐藏（在文件内）的 include 语句产生编译错误。 5 语句 5.1 类型 43. 在文件内部使用的量的类型建议在此文件内声明。 确保信息隐藏。 44. 类的一部分必须分为公共，保护和私有三部分［2］［3］。所有部分必须明确。不合适的部分不应混在一起。 顺序通常为将 public 部分放在最上，所以当人们可以看到 protected/private 部分即可不再阅读。 45. 类型转换必须明确作出。绝不能依赖隐性类型转换。 floatValue = static_cast&lt;float&gt;(intValue); // NOT: floatValue = intValue; 通过这点，程序员可以意识到涉及到的不同类型，并且混合是有意的。 5.2 变量 46. 变量推荐在声明处初始化。 这确保了变量在任何时候都是有效的。有时不能以一个有效值初始化变量，就像： int x, y, z; getCenter(&amp;x, &amp;y, &amp;z); 这些情况，应当保持未初始化，这要好于初始化假值。 47. 变量绝不能拥有双重含义。 通过确保变量唯一地代表概念来提升代码可读性。减少副作用导致错误的机会。 48. 尽量避免使用全局变量。 在 C++ 中，全局变量并不是必需的。同样适用于全局函数或者文件范围的（静态）变量。 49. 类中变量尽量不要在 public 中声明。 公有变量将会破环 C++ 的信息隐藏性和封装性。使用私有变量和访问函数代替。这种规则的一种例外是当类本质上是没有行为（类似 C 的结构体）的一种数据结构。这种情况下，让实例变量变公有是恰当的［2］。 注意：C++ 的结构体只是为了和 C 语言的一致性，并通过减少构建结构体的数量避免增加代码可读性。使用类来代替。 51. C++ 的指针和引用的符号推荐靠近类型名，而不是靠近名称。 float* x; // NOT: float *x; int&amp; y; // NOT: int &amp;y ; 变量的指针或者引用属性是类型的性质，而不是命名的。C 语言程序员经常在两者中取舍，而 C++ 中遵守这个规则已越来越普遍。 53. 隐式测试 0 不推荐用于布尔变量和指针。 if (nLines != 0) // NOT: if (nLines) if (value != 0.0) // NOT: if (value) 依据 C++ 标准，没必要定义 int 和 float 型的 0 和二进制 0 行为相同。此外，使用明确的测试语句可以使被测试的类型更清晰。建议指针同样不应用 0 隐式测试也很普遍，即 if (line == 0) 代替 if (line)。后者在 C/C++ 看起来很普遍也可以使用。 54. 推荐在尽可能小的范围内进行变量声明。 在小范围保持变量的操作，这样可以更简单的控制其作用和副作用。 55. for() 语句内必须只能可包含循环控制语句。 sum = 0; // NOT: for (i = 0, sum = 0; i &lt; 100; i++) for (i = 0; i &lt; 100; i++) sum += value[i]; sum += value[i]; 增强代码的可维护性和可读性。使得控制体和循环包含更加清晰。 56. 循环变量推荐在循环之前被初始化。 12345678910isDone = false;while (!isDone) &#123; // ...&#125;// NOT: bool isDone = false;// ...while (!isDone) &#123;// ...&#125; 57. do－while 建议不使用。 do－while 循环比普通的 while 循环可读性差，因为其循环控制条件在底部。阅读代码者必须完全看完循环才能明确循环的范围。 此外，do－while 循环非必要。任何 do－while 循环都可以重写为 while 或 for 循环。减少这种结构的使用来提高代码可读性。 58. 循环体的 break 和 continue 建议避免使用。 如果这些语句相较于同样的结构化代码可以提高代码可读性，否则建议不使用。 60. while(true) 这种形式推荐用于无限循环中。 1234567891011while (true) &#123; :&#125;for (;;) &#123; // NO! :&#125;while (1) &#123; // NO! :&#125; 依靠对于 1 进行的测试既没有必要也没有意义。for (;;) 可读性极差，并且表面上看不出它实际是个无限循环。 5.4 条件语句 61. 复杂的条件表达式必须避免。引入临时布尔变量代替［1］。 1234567891011bool isFinished = (elementNo &lt; 0) || (elementNo &gt; maxElement);bool isRepeatedEntry = elementNo == lastElement;if (isFinished || isRepeatedEntry) &#123; :&#125;// NOT:if ((elementNo &lt; 0) || (elementNo &gt; maxElement)|| elementNo == lastElement) &#123; :&#125; 通过给表达式分配布尔变量，程序可以自动记录（分析）。这样的结构造可以更简单的阅读，改正和维护。 62. if 语句中，象征性的部分推荐放在 if() 部分，例外放在 else() 部分。 1234567bool isOk = readFile (fileName);if (isOk) &#123; :&#125;else &#123; :&#125; 确保例外不会使得正常路径难以理解。这对于代码的可读性和性能均很重要。 63. 条件语句推荐放在单独的一行。 if (isDone) // NOT: if (isDone) doCleanup(); doCleanup(); 这是为了方便调试。当写在一行中，无法清晰的知道真或假。 64. 条件语句中的执行语句必须避免。 123456789File* fileHandle = open(fileName, &quot;w&quot;);if (!fileHandle) &#123; :&#125;// NOT:if (!(fileHandle = open(fileName, &quot;w&quot;))) &#123; :&#125; 条件语句中的执行语句使得代码难以阅读。这需要 C/C++ 的新程序员尤其注意。 5.5 杂项 65. 代码中推荐尽量避免幻数的使用。除了 0 和 1，其他的推荐考虑声明常量代替。 如果一个数字自身没有一个显而易见的含义，通过引入命名常量代替来增加代码可读性。另一种不同的方法是在量被访问处引入一个方法（函数）。 66. 浮点数推荐总是带有小数点和至少一位小数。 123456double total = 0.0; // NOT: double total = 0;double speed = 3.0e8; // NOT: double speed = 3e8;double sum;:sum = (a + b) * 10.0; 这强调了整型和浮点型不同的性质。这两种算数模型是完全不同且毫不相容的概念。 同样，在上述最后一个例子中，他在某处强调了代码中变量（sum）分配的类型，虽然这可能看起来不太明显。 67. 小于 0 的浮点数推荐总是在小数点前写上数码 0。 double total = 0.5; // NOT: double total = .5; C++ 的数字和表达式系统借鉴于数学，并且语法应当只要允许就遵守数学惯例。同样， 0.5 的可读性明显大于 .5；也不会使其和 5 混淆。 68. 函数必须要明确列出返回值类型。 1234int getValue() // NOT: getValue()&#123; :&#125; | 如果没有明确列出，C++ 将会默认返回值为 int 型。程序员不得依赖这个特点，因为这会使其他程序员觉得这种形式难以理解。 69. goto 语句推荐尽量避免使用。 goto 语句打破了代码的结构。只有在非常少的情况下（例如跳出一个深层的嵌套结构）goto 语句建议考虑，并且仅当替代的选择结构被证明有较差的可读性。 70. 0推荐用来代替 NULL。 NULL 是标准 C 语言库的部分，但在 C++ 中已被淘汰。 6.1 布局 71. 基本的缩进推荐为 2 个空格。 12for (i = 0; i &lt; nElements; i++) a[i] = 0; | 缩进 1 对于强调代码的逻辑布局显得太短。| 缩进大于 4 使得深层的嵌套代码很难阅读，并且增加了必须分行的可能。选择缩进 2, 3, 4 之一，2 和 4 更加普遍，且选择 2 可以降低代码分行的可能。 72. 代码块的布局推荐如例 1（推荐）或者例 2，但绝不要如例 3［4］。函数和类代码块必须使用例 2 的布局。 12345678910111213141516while (!done) &#123; doSomething(); done = moreToDo();&#125;while (!done)&#123; doSomething(); done = moreToDo();&#125;while (!done) &#123; doSomething(); done = moreToDo(); &#125; 例 3 引入一个特别的缩进，使得强调的代码逻辑结构不如例 1 和例 2 清晰。 73. 类推荐使用以下格式声明： 1234567891011class SomeClass : public BaseClass&#123; public: ... protected: ... private: ...&#125; 这一定程度上遵守了以上通用的代码块规则。 74. 方法（函数）推荐使用以下格式定义： 1234void someMethod()&#123; ...&#125; 这遵守了以上通用的代码块规则。 75. if－else 语句推荐使用以下格式： 1234567891011121314151617181920if (condition) &#123; statements;&#125;if (condition) &#123; statements;&#125;else &#123; statements;&#125;if (condition) &#123; statements;&#125;else if (condition) &#123; statements;&#125;else &#123; statements;&#125; 这一定程度上遵守了以上通用的代码块规则。但是，如果一个 else 从句和紧邻的 if 或 else 从句的括号在一行也是可行的，即： 12345if (condition) &#123; statements;&#125; else &#123; statements;&#125; 代码中 if－else 语句每个部分单独一行是更好的选择。这将使得语句控制变得更加简单，例如当需要移动 else 部分时。 76. for 语句推荐使用以下格式： 123for (initialization; condition; update) &#123; statements;&#125; | 这遵守了以上通用的代码块规则。 77. 空的 for 语句推荐使用以下格式： 12for (initialization; condition; update) ; 这强调了 for 语句是空的，并且由于这是故意的所以使得代码阅读者清楚。不过，空循环应当避免。 78. while 语句推荐使用以下格式： 123while (condition) &#123; statements;&#125; 这遵守了以上通用的代码块规则。 79. do－while 语句推荐使用以下格式： 123do &#123; statements;&#125; while (condition); 这遵守了以上通用的代码块规则。 80. switch 语句推荐使用以下格式： 1234567891011121314151617switch (condition) &#123; case ABC : statements; // Fallthrough case DEF : statements; break; case XYZ : statements; break; default : statements; break;&#125; | 注意整个 switch 语句中每个 case 关键字相对缩进。这使得整个 switch 语句清晰突出。此外注意“：”前的额外的空格。当 case 语句不包含 break 语句应当有明确的贯穿注释。省略 break 是个普通错误，如果故意省略必须要让代码清晰。 81. try-catch 语句推荐使用以下格式： 123456try &#123; statements;&#125;catch (Exception&amp; exception) &#123; statements;&#125; | 这一定程度上遵守了以上通用的代码块规则。if－else 语句关于大括号的规则通样可以运用于 try-catch 语句。 82. 单独的 if－else, for 或 while 语句建议不加大括号。 12345678if (condition) statement;while (condition) statement;for (initialization; condition; update) statement; 通常推荐应当是在任何情况大括号都不应缺少。但是，通常语言构造中大括号是用来归纳多条语句。单条语句使用大括号会显得多余。不过，有一种反对此语法的声音，如果增加语句而忘记加大括号，代码就会出错。但不论怎样，代码绝不应当为了适应可能发生的改变。 83. 函数的返回值类型建议放在函数名上方左对齐。 12345voidMyClass::myMethod(void)&#123; :&#125; 这使得更容易发现函数名，因为它们都在第一列开始。 6.2 空白 84. －常规操作符推荐在前后加空格以间隔。 －C++ 保留字后推荐加空格以间隔。 －逗号后推荐加空格以间隔。 －冒号推荐在前后加空格以间隔 －for 循环语句内的分号后推荐加空格以间隔。 123456789101112a = (b + c) * d; // NOT: a=(b+c)*dwhile (true) // NOT: while(true) &#123; ...doSomething(a, b, c, d); // NOT: doSomething(a,b,c,d);case 100 : // NOT: case 100:for (i = 0; i &lt; 10; i++) &#123; // NOT: for(i=0;i&lt;10;i++)&#123; ... 让语句的每一部分都独立出来。增加代码可读性。在 C++ 代码中，很难给出一个完整的空格使用建议列表。以上的例子只是给出一个通常的建议。 85. 方法（函数）名后若相连其他名称，建议以空格隔开。 doSomething (currentFile); 让每个名称独立出来。增加代码可读性。当后面没有名称，空格可以省略（doSomething()），这种情况名称就不用独立。左圆括号后是否加空格这个规范并没有要求，即都是可以的。这个规范通常在右括号前留一个空格： doSomething( currentFile );这样做使得每个名称作为不同含义而独立，但是右括号前的空格更像是一种艺术，并且没有那个空格的语句会显得不对称(doSomething( currentFile);)。 86. 逻辑集合代码块推荐以空行分隔。 1234567891011Matrix4x4 matrix = new Matrix4x4();double cosAngle = Math.cos(angle);double sinAngle = Math.sin(angle);matrix.setElement(1, 1, cosAngle);matrix.setElement(1, 2, sinAngle);matrix.setElement(2, 1, -sinAngle);matrix.setElement(2, 2, cosAngle);multiply(matrix); 通过在不同的逻辑集合代码块加入空行增加代码可读性。 87. 方法（函数）推荐以三个空行分隔。 通过大空行使得方法（函数）在类中独立。 88. 变量声明建议左对齐。 AsciiFile* file; int nPoints; float x, y; 增加代码可读性。变量可以通过对齐简单的分别类型。 89. 当使用对齐可以增加代码可读性就使用对齐。 12345678910111213141516if (a == lowValue) compueSomething();else if (a == mediumValue) computeSomethingElse();else if (a == highValue) computeSomethingElseYet();value = (potential * oilDensity) / constant1 + (depth * waterDensity) / constant2 + (zCoordinateValue * gasDensity) / constant3;minPosition = computeDistance(min, x, y, z);averagePosition = computeDistance(average, x, y, z);switch (value) &#123; case PHASE_OIL : strcpy(phase, &quot;Oil&quot;); break; case PHASE_WATER : strcpy(phase, &quot;Water&quot;); break; case PHASE_GAS : strcpy(phase, &quot;Gas&quot;); break;&#125; 尽管这点违反了普遍的规范，但是代码中很多地方需要如此来增加代码可读性就是允许的。上述很多情况下不得不要将代码对齐。代码对齐的通用规范很难给出，但是以上的例子就是很通用的线索。 6.3 注释 90. 无厘头的代码不需要注释，需要重写！［1］。 通常，注释应当通过代码命名的选择和明确的逻辑结构提升自身文档化而尽量减少使用。 91. 所有注释推荐使用英文书写［2］。 在国际化开发环境中，英文是首选语言。 92. 所有注释均用 //，包括多行注释。 // Comment spanning // more than one line. 自从多级 C 注释不被支持，使用 // 注释确保注释所有文件部分总是可能的。调试等目的时使用 /**/。 推荐真正注释和 // 之间保留一个空格，并且注释应当以一个大写字母开头，以句号结束。 93. 推荐将注释和代码同等位置（缩进）。 123456789while (true) &#123; // Do something something(); &#125; &#125;// NOT: while (true) &#123; // Do something something(); 这是为了避免注释打破程序的逻辑结构。 94. 类和方法的初始注释推荐依照 javaDoc 规定。 作为标准的类和方法文档，Java 开发社区比 C/C++ 开发社区要更加成熟。这是因为标准自动化 Javadoc 工具是开发套件的一部分，并且它用这些注释帮助做出高质量超文本文档。类 Javadoc工具同样可用于 C++。这些相同的标签语法类似于 Javadoc。看这里的 Doc++ 或 Doxygen 实例。 7 引用（以下不再翻译）[1] Code Complete, Steve McConnell - Microsoft Press [2] Programming in C++, Rules and Recommendations, M Henricson, e. Nyquist, Ellemtel (Swedish telecom) http://www.doc.ic.ac.uk/lab/cplus/c%2b%2b.rules/ [3] Wildfire C++ Programming Style, Keith Gabryelski, Wildfire Communications Inc. http://www.wildfire.com/~ag/Engineering/Development/C++Style/ [4] C++ Coding Standard, Todd Hoff http://www.possibility.com/Cpp/CppCodingStandard.htm [5] Doxygen documentation system http://www.stack.nl/~dimitri/doxygen/index.html [Translate]C++编程代码风格指南 由 萌面大道 创作，采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于http://geosoft.no/development/cppstyle.html上的作品创作。本许可协议授权之外的使用权限可以从 http://maimieng.com/ 处获得。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2015 年 3 月苹果发布会后感]]></title>
      <url>2015%2F4%2F</url>
      <content type="text"><![CDATA[Apple Watch, new MacBook…Designed by Apple 还有哪些亮点呢？让我们谈谈这次的 Apple 发布会吧。 这次苹果的发布会可以分成三个重要的部分，而我也将对这三点分别说说自己的观点： ResearchKit Apple Watch Mac Update 1. ResearchKitResearchKit，可以说，这是发布会之前没有人预测到的。因为它并不是一种具体的产品，发布会后关注度明显低于其他那两个产品。而我认为能够比下面产品意义更大的就是 ResearchKit。我个人认为医学发展很大程度受限于样本太少，而且部分人是不愿意去医院接受检查的，不论是因为医学条件受限，或是经济原因，更或是心理上对医院反感。而且如苹果官网 ResearchKit 宣传视频所展示，现代医学和很久之前在调查方式上并没有多么大的区别，不知道国内医学环境如何，况且国外仍采取“贴小广告”来调查研究，而且收效甚微。Apple 第一季度财报显示，仅仅第一季度就售出 7450 万台 iPhone，且不说之前的销量，就目前来说，iPhone 是一切向好的。苹果公司如今和美国众多大学，研究院（国内目前有首都医科大学宣武医院）合作，而且把 ResearchKit 开源，这不得不说是一个伟大的开端。伟大是因为，这已不是一个公司对于商业利益的追求，而是对全人类的利益息息相关。病症是人类共同的敌人，虽然现在 ResearchKit 仅仅在美国提供，而且全球化会比较慢，毕竟这是一门严谨的学科，各国的医疗条件等等会有很大的差别，而且没有先例，这只能算是个开端。现在可以说只有苹果公司能够做到，作为全球市值第一大的苹果公司，拥有上千亿美元的现金，用户遍及全球。苹果在中国的官网也提供了含带字幕的宣传视频，里面也提到了国内帕金森症的严重性，说明苹果这个项目完完全全就是开放的，可以说就是造福全人类的。我希望如果在进入国内的医院，高校也能接入，而不是一致的唱衰，抵制。中国，人口最多的国家，大数据如果可以在这里起到作用，那将是巨大的。 当然，会有些人还是会顾虑隐私，甚至考虑到是否会耗电。隐私我们就希望苹果公司在官网所写： 分享你的数据，但同时保护你的隐私。我们深知，你很重视自己信息的隐私，ResearchKit 正是基于这一宗旨而设计。你可以选择想要参与的研究，控制向哪些 app 提供何种信息，并查看要分享的数据。来自 Apple 官网 ResearchKit 页面 我还是愿意去相信，苹果公司可以保护好隐私，我也相信 iOS 的安全性能还是不错的。当然，这个项目也是自愿的，未来肯定会有更完善的方式。关于耗电，是因为苹果在官网写的： 数据采集越频繁，研究结果越精确。来自 Apple 官网 ResearchKit 页面 数据采集意味着会调用更多的传感器，耗费更大的电量。不过 ResearchKit 和 HealthKit 携手并进，他们可能都只会调用协处理器，新出的 Apple Watch可能是更好的贴身设备，来帮助你检测和监控身体。而未来我也希望电池能够有长足的发展，电池的 Revolution 将是移动设备的再次 Revolution。 2. Apple Watch 定价与外观 Apple Watch 一出，大家都在吐槽定价和款式。的确，2,588 到 126,800 的售价让人只能看看，而至于两者的区别，也就是表壳和表带的区别了吧。内置是完全相同的（Zealer 视频提到）。我虽然对手表了解不多，而且从没买过超过 200 块的表（xx 身份暴露啊），但我却天天戴着表，可能是从小养成的习惯，现在有时候忘记戴表就会没有安全感。现在手上这块早已不正常，秒针五秒动一次，一次动五秒，冬天内表面有水蒸气。。。说实话看苹果官网的图，逼格的确高，不过我还是更喜欢圆形的表面。而 Moto 360 的下巴，我也不太喜欢，而且感觉比较厚，可能是没有像 Apple Watch 那样的弧形吧。Apple Watch 更换表带看上去也比较容易，真想吐槽传统手表，为什么换个表带都那么难，有些还换不了。未来可能有第三方制造的表带，既然苹果官方也做表带，那么我想会不会像 Lightning 数据线一样有识别功能呢？算了，还是交给万能的华强北吧＝＝ 至于 Apple Watch 续航大家可以点击那个链接详细看看。当然等正式发售之后，看评测也可以。总之如果你拥有 iPhone，而且不在意戴个智能手表，那么 Apple Watch 就可以选择。版本的话，就看你有多少票子了。反正我是很心水＝＝ 升级 Apple Watch 出了之后我一直在考虑苹果会以怎样的方式更新这款产品，毕竟最高高达 12 万的售价，总不能每年推出新款。其实新款也没什么可以更新的吧，表带可以更换，配置对于一款手表来说，基本的功能的都已有，只是 App 的支持。我看了几个新闻，可能未来 Apple Watch 采取升级内置的方式，电池四年更换一次（需要收费），其实我觉得，Apple Watch 完全没必要一年一代，但是这样销量瓶颈可能会达到得很快，就不知道苹果是怎样考虑的了。因为传统的手表还有一种传承的含义在里面，智能手表不能和手机一样走快消。 PS： Apple Watch还有一个巨大的切入点就是能够使用 ApplePay，据闻 ApplePay 马上就要进入国内。Apple Watch 要比 iPhone 方便快捷许多，而且也会更安全，毕竟我们不会随便把手表借出去吧。Apple Watch 的 Force Touch 的尝试也会为 iPhone 做好铺垫，前几天看有人用新的 rMBP 的 Force Touch 绘图，如果 iPhone 也搭载，这将再一次改变手机的屏幕用途。 3. Mac Update MacBook or MBA 大家预测的 rMBA 并没有出现，而是出现了 NewMacBook，配置不在赘述，争议最大的就是他那颗 Core M 处理器和 USB－C 插口还有 9288 的售价。9288 的售价直接跳过 MBA，进入 rMBP。除了出色的设计，好多评测都觉得 NMB 的配置远逊于 MBA，而且由于无风扇设计，所以别装 Win 了吧。我个人觉得，如果你不用电脑处理很多的图片，非程序员，只是看电影，做文档，那么这个还是可以的，就是价格有点让人接受不了，但是出色的设计，又让人纠结，哈哈，反正我就看看＝＝至于 USB－C，如果你都买了，还会在乎买个拓展器么，我只是衷心的希望苹果不要把 rMBP 的 USB 只弄这么一个。。。 MacBook Pro with Retina 13’ 相较于之前的 rMBP 13’，这次升级了处理器，触摸板也升级到 Force Touch，ssd 读写更加迅猛，显卡的升级也使得其可以接双4K显示器，详细的可以到官网看他们的技术规格。总之这次的升级我觉得是非常良心的，可以说这次的 rMBP 13’ 是性价比最高的 MacBook 了。 Force Touch 这个 Force Touch 就是最新的触摸板，用在 NMB 和 rMBP 13’ 了。据反映好像按不下去了，也不支持三指了，不过有压力感应了，这么高端的，也没用过＝＝看起来不错的样子，就是好多熟悉之前的现在需要适应适应了。 利益相关： 凭渣听力艰难看完无字幕全英文版发布会 看过 Zealer 关于 Apple Watch 定价策略的视频 看过 Apple 官网的中文字幕视频 果粉（努力学习 Swift 中＝＝）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Count On Me 歌词翻译]]></title>
      <url>2015%2F3%2F</url>
      <content type="text"><![CDATA[Count On Me 是一首很暖心的歌（原唱 Bruno Mars）。Connie Talbot 的翻唱的却充满童真，让我们一起欣赏下吧～ 今天歌曲推荐出来的，真的很好听，歌词也很棒，十分暖心，虽然不是专业英语，也没有多高的文学素质，不过用心翻译了下，希望大家可以和自己的朋友都能好好的～ Count On MeConnie Talbot 翻唱If you ever find yourself stuck in the middle of the sea,如果你曾困在大海中I’ll sail the world to find you我将扬帆去全世界找寻你If you ever find yourself lost in the dark and you can’t see,如果你曾在黑暗中无法看清而迷失自己I’ll be the light to guide you我将化身光芒来指引你Find out what we’re made of清楚我们是什么吗What we are called to help our friends in need什么叫帮助陷入困境的朋友You can count on me like 1 2 3你们可以依靠我（，我们）就像 1，2，3（紧密相连）I’ll be there我会在这里And I know when I need it I can count on you like 4 3 2我也懂得当我有需要时也可以依靠你们（，我们）就像 4，3，2（永不分离）And you’ll be there Cause that’s what friends are supposed to do, oh yeah你们会在那里因为这就是身为朋友我（愿意）应该做的，噢～耶～Wooooh, Wooooh yeah Yeah唔～唔～耶～耶～If you toss and you turn and you just can’t fall asleep如果你感到不安，难受而难以入眠I’ll sing a song beside you我会在你身边为你轻唱And if you ever forget how much you really mean to me如果你也曾忘记你对于我到底有多么重要Everyday I will remind you Ohh每天我都会想起你，噢～Find out what we’re made of（清楚）我们是什么吗What we are called to help our friends in need什么叫帮助有需要的朋友You can count on me like 1 2 3你们可以依靠我（，我们）就像 1，2，3（紧密相连）I’ll be there我会在这里And I know when I need it I can count on you like 4 3 2我也懂得当我有需要时也可以依靠你们（，我们）就像 4，3，2（永不分离）And you’ll be there你们也会在这里Cause that’s what friends are supposed to do, oh yeah因为这就是身为朋友应该做的，噢～耶～Wooooh, Wooooh yeah Yeah唔～唔～耶～耶～You’ll always have my shoulder when you cry当你哭泣的时候可以永远依靠我的肩I’ll never let go我将不会离去Never say goodbye you know我们约定好的从不说再见You can count on me like 1 2 3你们可以依靠我（，我们）就像 1，2，3（紧密相连）I’ll be there我会在这里And I know when I need it I can count on you like 4 3 2我也懂得当我有需要时也可以依靠你们（，我们）就像 4，3，2（永不分离）And you’ll be there你们也会在这里Cause that’s what friends are supposed to do因为这就是身为朋友应该做的Count on me like 1 2 3依靠我（，我们）就像 1，2，3（紧密相连）I’ll be there我会在这里And I know when I need it I can count on you like 4 3 2我也懂得当我有需要时也可以依靠你们（，我们）就像 4，3，2（永不分离）And you’ll be there你们也会在这里Cause that’s what friends are supposed to do, oh yeah因为这就是身为朋友该做的，噢～耶～Wooooh, Wooooh唔，唔～You can count on me cos’ I can count on you你们依靠我因为我也依靠你们]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[The First Half of 2015 Plan]]></title>
      <url>2015%2F2%2F</url>
      <content type="text"><![CDATA[计划还是要有的，万一完成了呢？ 前言新年到了，祝大家新年快乐哦！每一年都要新的计划来激励自己，时间飞逝，而今年下半年就该大二了，所以我也先计划上半年的吧～！由于第一次发简书…好怕被喷=。=大家如果有想法有意见或者建议，也可以告诉我～嘿嘿～！ 分类①专业 ②英语 ③阅读 ④资金 ⑤预购 ⑥生活 ⑦社交 1.专业 ①学习 C++，Java，自学 Python ②自学数据结构（Mooc），编译原理 ③若购入 Mac，自学 Swift ④希望可以在暑假找一份实习或者独立开发一款 App，而不是荒芜的或者去卖“体力”来度过一个暑假 2.英语 ①单词——词汇量至少达到六级水平 ②写作——能够用英文去阐述自己的思想 ③翻译——借助词典，可以翻译部分文档或文章 ④口语——可以清晰阐述自己想要表达的内容 ⑤考证——最好可以在 15 年上达到六级水平，并在 15 年下半年考过六级 ⑥练字——每周跟着写字吧的周练用钢笔用心写，并要尽量保证在日常书写中工整写字 3.阅读 时间：晚上睡前工具：Kindle Paperwhite 2 + 非专业书籍 ①中文书——至多 10 本，读书不在多而在真正从书中的获得 ②英文书——至多 5 本，书单参考恶魔的奶爸 ③感想——至少和所读本数相当，要在简书和博客写出自己的思考，与他人分享 4.资金 ①养成记账习惯 ②尽力争取奖学金 5.预购 ①笔记本：4 - 6k ——必需品，目前手中上网本实在是渣= =…准备入 Mac(二手) ②其他杂类：1k ——清单列在手机备忘录 6.生活 ①晚上作息要在 12:00 前入睡，睡前喝牛奶，不玩手机 ②一日三餐不能漏，尽量使营养均衡 ③坚持每天吃钙片==，不能浪费妈妈的一番心意～ ④每天都要洗头==，要学会整理自己，不能屌丝味太浓… ⑤要发现生活中的美，然后用 iTouch+VSCO cam 记录下来，不要做器材党 ⑥想学习吉他～ 7.社交 ①不吸烟不喝白酒：对自己和未来负责 ②酒桌文化不要过分参与 ③坚持在简书和博客写文章，哪怕无人喜欢，无人观赏 ④希望微信公众号能够和简书、博客同节奏更新，若实在无法管理可以暂时放置 ⑤退学习类社团，加入并学会使用 Github Last but not least. 计划说的再美也没用，只有脚踏实地的去做。希望这几个月生活可以更加充实～]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[王自如对话 Moto 总裁 Rick Osterloh]]></title>
      <url>2015%2F1%2F</url>
      <content type="text"><![CDATA[Moto回来了。这次的回归是否能使它在国内的市场涅磐重生？ 视频地址 人物简介： 王自如的介绍不必多说，也是前几个月在风口浪尖的人，Zealer 拿了厂商的投资，继续作着第三方测评，公正性使得网民怀疑，但这又或许是不得不的选择。而在 2014 年 8 月 27 日，王自如和罗永浩（锤子科技 CEO）在优酷越架，也使事态发生到了最高潮。我当时全程观看了直播，不再过多赘述，而对于 Rick Osterloh，都是比较陌生的，我 Google 后，在 Moto 官网，有他的简介，这里大致翻译下： Rick Osterloh（以下简称 Rick）摩托罗拉移动业务总裁兼首席运营官 Rick 从 2014 年 4 月开始领导摩托罗拉的移动业务。在 Moto 和工业领域拥有长时间并十分出色的业绩。成为总裁之前，Rick 是摩托罗拉的产品高级副总裁，负责所有产品的战略规划和分发。而在此之前，他曾在 Skype 担任产品设计和副总裁，在那里他曾负责产品于 Skype 每月超过 2.5 亿用户。加入 Skype 之前，Rick 在摩托罗拉负责 Android 平台的软件分发和运营。加入 Moto 之前，Rick 曾在 Good Technology 担任产品经理；曾在 Deloitte Consulting Group 为财富 1000 强的公司管理企业软件项目；曾在 Amazon.com 担任产品经理；曾在 Kleiner Perkins Caufield &amp; Byers 做无线产业投资分析。 Zealer 的视频制作一直都可以说是相当高水平，高逼格的，而这次王自如用英语直接和 Rick 交谈，也是逼格满满，Rick 的本地化的英语还是十分清晰易懂的，而自如的英语听起来似乎有些吃力，也许是这样的对比太明显的，但毕竟没有与生俱来的纯正，而且这种性质的谈话十分正式，对于自如也是压力不小。而视频刚上来是王自如对于新的一档节目的简介，伴着回音显得十分正式，详细的阐述了对话这一档新节目的意义，目的。从这个对话大体来看，Moto 的高层还是寄希望很大来拓展国内市场，而且十分明确的知道国内目前 Moto 占有率几乎为0（毕竟海淘的人数还是比较少的），而且目前国内的竞争也十分激烈，而国内的手机市场也趋于饱和。在 Moto 离去这几年，小米，华为等一系列公司在千元档和两千元档展开了胶着的竞争。魅族也在去年年初，黄章重新出山后，发生了巨大的改变，从 9 月开始几乎每月都有发布会，截止到现在，魅族手机的产品线已经从 699 一直展开到 2499 。而国内的小米在1月发布小米 Note，顶配版售价达 3299，业内人士估计3月份左右才可能出货，而且小米的智能家居步伐正在慢慢加速，路由器，小米电视，还有一群各种米的合作伙伴推出的小米手环，小米插座等等，小米凭借着“低价”，“发烧”杀入市场，靠营销和 MIUI 来稳固市场，而最新的估值小米公司已经达到 450 亿美元，相当于多少个 Moto 咱们就不说了。华为作为世界 500 强的公司，推出独立的品牌荣耀，加上自己研发的麒麟处理器，是国人的自豪。但是我认为华为的弱项还是在系统UI方面，华为如果加大对这方面开发，适当减缓出新机的频率，而要把 UI 方面做的有些特色，而且对自己产品的版本需要梳理清晰一点，营销在多下功夫，要有自己独立的意识，不能去攀附小米，但是可以去和一些不错的软件公司合作，这才是一家真正强大有追求的公司应该做的。 总之，这次的 Dialogue，不涉及过多的利益相关，而是完完全全的对 Moto 重新归来之时 Moto 高层的一个对话，或者说采访。既然今天来说这个对话，我们就主要针对手机方面，其他暂时不谈。 Rick 对 Moto 的回归是十分期待，充满希望的，国内市场的大蛋糕，谁都想来，而 Moto 这一老牌，在消失了几年之后重新回归，必定要注入新的能量。谈到被谷歌收购，Rick 表示消减了运营规模，但是这样使他们更加专注于朝着市场所需的方向发展，然后把选择权交给用户。确实，谷歌收购 Moto 更多的出于对专利的“收购”，因为谷歌并非硬件公司，但旗下 Android 操作系统，已经占据了绝大多数的智能手机。越扩张，专利就越为重要，而 Moto 作为老牌手机厂商，其拥有众多专利，谷歌的收购，可以使谷歌对待专利流氓或者打官司时，胜算更多，但 Moto 的硬件对于谷歌来说，却并不重要，所以，这也是去年 Moto 再次被收购的一个重要原因。Rick 说 Moto 现在已经从最初几个国家扎根，扩张到目前的 52 个国家，而中国也是最具价值的国家（之一），而对于国内市场的竞争，Rick 表示，首先他承认中国是世界上智能手机行业竞争最强烈的国家（之一），但是这是对于消费者是好事，而不是坏事，所以 Moto 在被联想收购 3 个月之后，选择了重新回归。而这样的选择是基于 Moto 自身的业务需要拓展加上联想收购后的催化，而在谷歌旗下的 Moto 由于某些原因无法回归，便选择了国内智能手机市场竞争胶着的此时。此时的环境已和 Moto 离开时大不一样。国内市场，高端（四千元以上）被苹果三星占领，而在三千元档有 OPPO、VIVO、华为（部分机型）等所占领，最为激烈的两千元档被小米、华为、魅族牢牢占领，而在千元档也有红米、魅蓝、华为还有部分酷派，小辣椒等机型，在此激战。手机的价格已几乎成为所有人购买手机的第一要素，因为现在的手机在功能上，700 元与 4000 元并没有太大的差别，只是对于产品的优化，体验上会有较大的差别，这就使得很多年轻人不愿意去买更高价位的手机。而魅族在千元机中将优秀的手感，设计引入， 无疑是在这激烈的战场上又吹起了号角，其后盖采用和 iPhone 5c 类似设计，各大媒体也都十分称赞，这使得我们购买高价位手机又少了一个理由。Moto 作为一家类似跨国公司，定价就显得尤为难以操办。王自如又问道，Moto 独自离开中国而这次作为联想的子公司重新回归，是否会有落差，是否会和联想的产品线有冲突，Rick 的问答说明了，Moto 是期待回归的，但是对待国内消费者并没有过多的“关照”，依旧是原生 Android 操作系统，只是将国内无法使用的谷歌服务用本地化的用以代替（当然联想的自家应用优先了）。然后继续实施全球范围内的战略——即专注于优秀的产品，将选择权交给用户，通过 Moto Maker 这一平台将个性化的设计彻彻底底交给用户，当然，目前 Moto Maker 进入本土化还需要时间（官网预计今年上半年即可）。Rick 对于产品的质量也是十分自信，老 Moto 和老诺基亚曾经的质量都已是品牌效应， Moto 对材质的追求也能看出对于质量的重视优先级是不低的，Moto Maker 也证明了 Moto 的创新能力，不过在国内市场，如何避免手机需要抢，又如何避免大规模囤货这就显得尤为重要。而原生的 Android 系统，对于普通消费者可能较于 MIUI 与 Flyme 难以上手，而对于一些需要原生系统的人来说，又缺少了谷歌服务，这其中的矛盾对于 Moto 来说都是不小的挑战，特别是在手机主题如此火爆的情境下，普通年轻用户如果拿到手机自己装各种 Launcher，似乎对本来性能就弱于同价位手机会有些许吃力。当然，我这里并不是希望 Moto 去开发本地化的 Launcher 来迎合，因为国内的这种环境完全是由于谷歌完全被挡在外，所以国内各大 UI 自己高度定制所造成的，所以对于三星、Moto 这样的洋选手就不可能再针对进行适配，而这又给我们本土的手机厂商多了些胜算，因为国内的环境和国外的差别是不小的。而后王自如说IBM在被联想收购后走了下坡路，问 Rick，Moto 是否也会重蹈覆辙，Rick 很机智的说反驳王的观点，联想目前是全球最大的 PC 制造商，Thinkpad 也是顶级品牌（这里就不吐槽Thinkpad了= =）。进而明确了 Moto 将会专注于设计，而在制造和供应链方面，联想为其铺路，使得 Moto 可以更加快的转型，而对供应链的调整主要表现在 Moto Maker 的问世，因为 Moto Maker 的自由组合约 4000 种，而未来登陆国内就十分考验 Moto 和联想。产品组装也会分担到各个具体市场，未来国内也会有 Moto 的组装产品线。Rick 也强调 Moto 作为联想的子公司，但是会继续保持独立的运营（设计，工程，品牌）。可以说，联想收购 Moto 将会彻底开始全球化销售手机，依托 Moto 的知名度和设计，加上联想本身的 PC 前身制造和供应链还有销售渠道，将会很容易的把这些手机输送到其他国家，而这样做比国内的一步一步拓展东南亚市场的速度会快很多，而且效果也将会比较不错，Moto 的部分专利技术和独有的设计和内置的原生 Android 操作系统将会更加强有力的进入外国市场，而小米的探索却是比较艰难的，毕竟踏出国土，需要更多的重视专利技术是否侵权，还要将供应链拓展出去是比较缓慢的。Rick 又说 Moto 作为联想子公司将专注高端，而联想中低端，其实我觉得这里并不完全是这样。Moto G LTE 售价 1299 元也并非多么高端，而联想此前出的 VIBE 系列售价也是十分惊人，只能说 Moto 是比较独立的子品牌，其产品和国外应该是统一的，而联想也有自己的步伐，只是不知道未来 Moto 会不会现在 Thinkpad 一样，低端高端都有，而且镶上 Lenovo 的铭牌。Moto 进入国内将也采取多元的销售策略，网上销售，这都快被玩坏了，采取网上销售几乎所有厂商都是在网上预订，限量抢购（话说刚刚体验了下抢魅族…只能说抢不到的黑历史继续了…），Moto 一定要避免也出现这种状况。Moto 的回归也带给我们新的在线销售手机的模式，即 Moto Maker，高度自由化的定制手机的后盖材质和色彩，这是从来没有的，而且我觉得国内厂商暂时还不敢效仿 Moto 的这一方案，因为不论小米还是魅族，推出多颜色（仅仅后盖颜色不同）都不能同时发售，而且每次抢购量远远满足不了市场需求，这就说明有几种可能，第一：国内的部分手机公司是没有例如苹果的那种自信的，即害怕生产过多无法销售造成囤积；第二：这种预订，再慢慢发货，可以使资金优先回笼；第三，产品出货量较低，或者对于供应链的控制力较弱；第四，国内手机销售，必须在工信部认证，认证是公开的，为了防止设计，配置泄漏，有些公司会先召开发布会，再认证，这样时间就会进一步拉长。根据 Moto 官网说明，今年的上半年，Moto Maker 将会登陆中国，希望 Moto 可以顺利解决上面这些问题，并且选择不会缩水。而 Rick 也提到和运营商合作，这点对于线下的销量提升应该有所帮助，不过，希望 Moto 可以说服运营商避免将 Logo 印在机身上，而且定制的软件需要可以不 Root 卸载，如果能够提供纯净版的固件，那就更好了。王自如问 Rick，Moto 2015 年有什么目标没有，Rick 没有透漏或者说今年只是做好回归，不求量，但是要把Moto的回归让大多数人知道，就像 Zealer 在本期视频结尾所说，慢几步，深几度，我还是希望专注于产品的品牌可以在国内市场拥有更好的表现。Rick 说，这个行业 20 年以来，没有任何公司可以独领风骚超过 7 年，还特意举了个例子，三星，的确，三星似乎已经开始走下坡路，而我认为的，这次 Moto 回归将首先带给三星再一次冲击。三星手机的设计受到很多人非议，大塑料，但似乎三星为了大规模出货保证良品率而不得不采用塑料机身，而内置系统也十分不接地气，而此次 Moto X 的定价在 3299 元和 3699 元，也针对的是较高端市场，当然，Moto 还未在中国发布 Moto X Pro（Nexus 6），这样的售价对于国产机来说并不亲民，而三星高端和 iPhone 6/6 Plus 的价格均高于此。Android 阵营高端机型，一直以来被三星霸占，HTC 和其他品牌只能略微抢占这一蛋糕，而 Moto 的归来，品牌效应不必多说，个性化定制的后盖更能让高端的商务人士青睐，所以我觉得 Moto 未来和三星的竞争将会十分激烈，而 Rick 将 Moto 和小米等厂商联系在一起，说他们以更低的价格提供更好的产品，这里我觉得小米公司的野心是不小的，而且他们的骁龙 810 处理器的小米 Note 顶配版售价为 3299 元，而且支持双卡双待，这就表明小米已经开始要征战高端的市场了，Moto X 的配置可以说并不及小米 Note，甚至差很远，但是Moto牌子的厚重感是远远高于小米的，所以要使自己的机型卖的更好，Moto就需要把手机的体验优化，续航都要做的均衡一些，这样拥有良好口碑的 Moto 我相信，在国内的高端市场能迅速提升占有率。而听 Rick 所言，Moto 和苹果三星的对抗，主要押注在 Moto Maker 的多样化选择，因为苹果三星也都提供着高品质产品。对于当时 Moto 的离开，很多优秀的技术人员离职，Rick 表示很自豪，很从容，并没有太大的压力。谈到 Moto 是否会构建自己的生态，Rick 告诉我们，Moto 未来还是会基于Android 的，因为 Moto 和 Google 的关系的确十分不一般，而国内的很厂商都在做准备，传闻中的 MI OS，魅族和 Ubuntu 的合作，三星的 Tizen，都在为如果 Google 的 Android 出现状况而做着第二手准备。而手机周边，Moto 360 十分吸引人眼球，搭载 Android Wear 操作系统，设计十分精美，甚至我觉得它比 Apple Watch 看起来更漂亮，未来就看 Moto 如何把可穿戴设备发挥到更好的层次。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手机选购指南－2014]]></title>
      <url>2014%2F1%2F</url>
      <content type="text"><![CDATA[本文在此留存使用，对于现在想找我推荐手机的，答案只有 iPhone。 这篇文章是 2014 年 6 月 9 日发布在点点轻博客的，（当时刚结束高考啊…泪奔），所以略有时效性，但由于这篇文章当我今年再看的时候，颇有感慨，所以放在这里，留存吧，也对大家买手机还是有些许参考性的，如果再让我做一次选择，还是买 iPhone 吧… 如何选购智能手机智能手机的普遍性就不啰嗦了，下面就来说一下买智能手机的几个注意点，顺序不分先后。本文所说手机均为品牌手机，出货量极少的牌子不推荐，因为售后，更新会很难普及。利益相关：果粉- – 价格智能手机价格分布大概有 1000 元以下千元机市场一直很火爆，大部分手机采用 MTK 处理器，或者低端高通处理器，参数不再详解，此价格手机最主要看手机的稳定性以及售后。我在这里只推荐红米系列和诺基亚低端 Lumia。因为此价格机器参差不齐，价格战战的用户已经分不出来到底该选什么好。 红米：红米采用 MIUI V5 基于安卓高度定制的系统，优化比山寨机之流好很多，各种服务都很齐全，预算不够的同学可以考虑，而且红米为双卡系列，但是要注意一点，红米手机制式很多，建议大家在小米官网购买，不要在淘宝上面购买，容易买到假货，在实体店购买，价格会比网购多很多，自己斟酌；而且选购时要看清楚自己使用的是什么手机卡，联通，电信或是移动，而且要看自己用的是 2G 还是 3G 卡，4G 红米还没有出，因为 4G 专利大部分握在高通之手，而且现在 4G 不太稳定，而且资费还是不便宜。 诺基亚 Lumia 系列：诺基亚一直以优秀的做工，完美的质量让人信服，但是注意，现在手机屏幕尺寸提升，想让诺基亚砸核桃并不现实。撸妹采用 WP8 系统，马上推送 WP8.1，说实话 WP8.1 才算是一个基本的手机系统，完善很多小 Bug，WP 系统视觉风格完全不同于安卓和 iOS，本人认为，撸妹手机差别只在于：屏幕大小，相机像素，手机外观，运存大小。其实并没有太大差别，而且目前WP商店软件不全，参差不齐，虽然必备软件都有，但是质量不好，尤其喜欢玩大型游戏的人，不建议考虑，当然这种情况在慢慢改善，如果你有耐心，请购买，但我个人不太建议普通小白用户购买。 1000-1500这个价格有很多选择，基本上为前年的旗舰机，比如小米 2s，魅族 MX2，诺基亚也有很多选择，数码产品有人说买新不买旧，也对，但是如果普通用户，我不建议买太高端的手机，目前手机性能过剩，屏幕过大，没有必要，你要是想装逼那我没话说，手机基本功能差不多，只要不要出现太大的差错就行，一般国产机不建议购买第一批，因为第一批基本上为小白鼠，各种问题，很麻烦，而且第一批购买者基本上是被广告软文害的，所以不建议购入第一批。这个价位手机大家看看其做工，信号，续航即可，如果让我推荐，我只推荐小米 2S，原因，我不知道还有什么，MX2 不推荐是因为不能换电池，发热较严重，续航不足，信号不好，不大建议，当然你要认为这是小事，那你可以购买，而且只要 1299，还送半年延保，具体上官网查看。小米 2s：功能齐全，但是不能插内存卡，32G 版本比 16G 版本多 16G 储存空间，而且摄像头从 800W 升级到 1300W，其实这不重要，底下再说。而且 2s 支持更换电池，官网还有大电池套装，性能也很好。貌似这个价位段还有华为荣耀的机型，我不太了解，自己查查吧，不再细说。 1500-2000这个价位大概是去年国产旗舰的价格，有魅族 MX3，小米 3，还有新宠 IUNI U2。先说说 U2，其实这是 IUNI 第一款机子，不要被 2 迷惑了，他也是采用自己高度定制的安卓系统，其实挺喜欢这个系统，纯净，没有像 MIUI 那么多冗杂的功能，很单纯，单纯的连音乐播放器都没（不知道现在有没有。。。），手机问题就一点，他是其旗下第一款手机，毕竟会有缺点，例如有些硌手，会掉漆等，但是价格挺便宜，而且是今年上半年的旗舰配置，没有玩过，大家可以查查看，金属后盖，有不少优点，性价比不错。 魅族 MX3：这款手机几乎占据所有科技媒体评的 2013 年度最美国产手机，当然审美自己看吧，手感也不错，就是现在所有旗舰的通病，太大了，单手操作真心不稳，但是他是当时全球最薄边框，所以视觉冲击特别棒，建议大家去魅族专卖店体验一下，而且他的 Flyme 系统很像 iOS 7 的扁平化，但是功能来说比 MIUI 还是差很多，当然 MIUI 是太多了，他是有些太少了，不过，现在 Flyme 也已经感受到压力，正在慢慢改变。有人说 Ubuntu 系统，这个是魅族在 CES 展出时采用了的一个系统，但是这个系统还比较小众，也许是魅族为了以后谷歌的安卓出状况的一种备用方案吧。 小米 3：这款手机出的时候，大家都惊呆了，不是因为他太牛，而是因为他很像诺记的撸妹… 到手才发现，原来是个大板砖，MIUI V5 对于我来说真心有些审美疲劳，而且功能太多，真心不是太喜欢，但是现在这个系统太火了，而且云服务很棒，所以很有可能导致你用了以后摆脱不了，因为你的资料很难全部转移到一部新手机上，所以不要被绑架了哦，当然你是米粉也许就很喜欢了~ Mi3 之所以说是板砖，因为他的边框太厚了，本来屏幕都不小，然后再来个厚边框，又硌手又拿不住，所以我推荐 MX3，当然 MX3 也有缺点，还是电量问题，和发热，不过发热已经好了很多，所以建议入手 MX3。当然他们的更新版估计要在今年下半年出，你有耐心吗？对了，还有一加手机，感觉很用心，大家可以关注下。 2000-2500这个价位真心不知道有什么好。。。自己看吧。。。哦对了，iPhone 4s其实不是太推荐 4s，毕竟已经很过时了，但是他还是可以跑今年秋天的 iOS 8 的，只不过，肯定会卡，当然你要是不嫌弃他屏幕小，还是可以选择的，毕竟稳定性，售后都没得说，拍照也很牛，不对比你是不知道的，不要再拿小米照月亮来秀下限了。 2500-3500这个价位，刚出了一款锤子 T1，等发货还早着呢，不推荐，原因不说了，省得锤粉骂我= =当然我没用过，不能评价。。。这个价位还有 iPhone 5c，真心觉得这款手机很棒，你们可以去体验店体验一下，很适合我们，色彩很多，不会撞机，屏幕比 4s 大，比 5s 没少多少东西，当然你要是特别喜欢指纹识别的话，那就买吧。。。对了，还有一款，Vivo Xplay 3s ，还是去体验店玩玩吧，这个价位我只推荐 iPhone 5c。3s 配置什么的也特别牛逼，2k 屏幕，6 英寸大屏，没玩过不评价。这个价位貌似还有 Oppo 的旗舰，大家也可以看看。 3500-3500+iPhone 5s原因，不解释。现在说说为什么推荐苹果手机，他又没给我广告费。 系统iOS 8 开发者版已经出现，更加开放，更加热爱中国的苹果来了，觉得还不够开放，可以越狱。小白就可以尽情用 iPhone 了，不用教，不用 root，软件齐全，不用担心隐私泄露，手机是拿来用的，不是用来折腾的，只是很少一部分人喜欢折腾，折腾的目的也只是想达到，能流畅的使用，能更加安全，这里我真的希望大家不要越狱下载盗版软件，和下载盗版音乐，正版化即将来临，6 元一个软件不算贵，但是却是支持开发者的动力，如果还有盗版，开发者只会在系统里植入广告，占取屏幕空间，没有办法的办法，知道开发者账号一年的费用吗？99 刀一年，大概 700 元，只有付了钱才能上架软件，个人开发者为什么选择苹果这个平台？因为它是一个良性的平台，公平竞争，安卓上面充斥着盗版软件，木马软件，开发者没有心思去做，苹果的开发者必须要有一台 Mac，Mac 最便宜需要 4000 元，再加上年费，还不一定能卖的出去，久而久之开发者就没有动力了，而且越狱后苹果是不给保修的，而且会造成电不耐用白苹果等，所以建议大家如果看到好的应用，可以购买支持一下，6 元钱只是两瓶绿茶，却可以给一个开发者力量。 品控品控即品质的控制。苹果的品控可以说在全世界是第一的，因为他的出货量太多，所以它可以要求富士康或者其他代工厂，如果合格率不达到一个值，需要代工厂全部销毁而且赔偿损失，也就是说苹果不会允许参差不齐的产品流入到你手中，当然，有时候也会发现刚拆封的手机有掉漆，但是很少，而且如果有可以继续拆，直到拆到完好的机器，当然这是官方店的做法，我们这里就没有这个福气了，但是也可以要求他重新换机。 价格苹果手机从来没有低价过，只是当新一代产品出现，老一代手机降价，而且不会降很多，从来没有大跳水，苹果手机的硬件成本大概 200 刀，产品溢价太多，但是为什么还是卖的那么好呢？有太多原因了，大家应该知道吧。我们洛阳没有苹果的专卖店，你所见到的只是授权店，郑州即将建成一家专卖店，苹果的专卖店有一个地方叫做 Genius bar 俗称天才吧，你所有的售后问题可以找他，当然现在有黄牛预定再高价卖出，很无奈。不管你是苹果的任意产品，但是需要是当地购买的版本，而且在保修期内，拿到那里给他说问题所在，他就会诊断，如果不好修，他会给你换新机，而且，注意而且保修期重新（即一年）计算！！ 质量苹果手机曾经有过天线门，掉漆门… 这种大规模的问题。但是有上述的售后，我相信这个问题影响不大，而且如果你手里有 iPhone 4，他绝对还可以流畅运行，但是换做小米，三星等安卓手机也许就不行了。耐用性这方面真的很好。WP 也不错，但是没有长时间用过，没有发言权。 最后说下我个人的选择倾向，如果给我钱让我选择，我也许会选择 4s 或者 5c，省下来的钱还可以买 iPad，但是 = = 我没有钱。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PC 选购指南－2014]]></title>
      <url>2014%2F2%2F</url>
      <content type="text"><![CDATA[本文的一些观点略有过时。 这篇文章是 2014 年 6 月 11 日发布在点点轻博客的，本文和手机选购那篇属于同一风格，但由于对电脑了解不深入，所以只能是略微谈谈，不过也算是尽力了，软件专业买电脑的童鞋就不要看了，怕误导你们。 如何选购个人电脑电脑是大学的三件套之一，我对电脑的了解并不多，只是简单谈一下好了，首先说明一点，据我所知，有些大学第一年是不允许带电脑过去的，在通知书上应该会提到，原因很简单，第一怕影响学习，第二怕丢，高校的安全措施是很不好的，所以不大建议同学们直接买很高档的电脑，最后沦为打游戏，刷淘宝，看韩剧的用途，而且如果有同学借，你会舍得吗？当然你自己决定，我干涉不了。好了，不谈这些了，我们谈一谈更深入的吧~ 系统这里主要说明 Windows 和 Mac OS Windows系统就不用追根溯源了，自己百度百科去，Windows 在市面上还在售卖的笔记本所搭载系统为 Win 8.1 、Win 8 、Win 7 基本上就这几种，而且以前两种为主。当然有人说 Win RT，我们还是不说这个半残的系统了= =。Win 8.1 和 Win 8 采用了最新的 Metro UI，就是一块块的小磁贴，图片不想贴了，自己百度，这个界面主要是微软为了应对触屏化，并且和自己的 WP 形成一体的界面，使用户感受得到提升，新一代苹果系统 Mac OS X 10.10 也和 iOS 的扁平化融为一体，目的就是让你用了之后，使得你无法转向别的平台，说难听点就是绑架，但是是好是坏，也并不一定，既方便你又帮人家赚钱，两全其美。Windows 平台十分宽松，而且我觉得基本上大家对 Windows 的操作已经熟能生巧，而且用户量决定了大量的游戏软件在 Windows 上遍地开花，但是有些软件参差不齐，而且比较容易中毒，其实现在电脑中毒已经很少了，只要不要乱下载软件，有安全措施，其实还是挺安全的，如果中毒了，多半是用户自己误删等导致自己以为中毒，男生还是学学修电脑吧，以后可以帮女生修修电脑修不好没关系= =可以干点别的嘛~我擦，跟你们说的太多了= =还有，再强调一句，学电脑不等于修电脑，汉子们，多用用百度吧，累不死你们的！！！！ 这里简单插一点怎么用搜索引擎搜索自己想要的答案： 不要用问人的口吻来问电脑，你确定人家解答问题的人跟你的口气一样？不要加那么多”为什么”、标点符号、”怎么样”等等类似的，当然百度比较好，出了个百度知道，所以你可以找到一些 关键词之间用空格来分开，在淘宝中搜索也可以，原因不说了，中学信息技术里面提到过 继续说 Win。Win 系统的本子太多了，好处，可以找到自己心水的配置外形（土豪果粉滚粗= =）的机机，坏处，机型太乱了，你要是去尸体店，对，没错尸体店，八成会被转型，就是说你在网上查好的配置，机型到了尸体店，他会以各种理由让你放弃你查好的机型，然后给你拿出一款他所谓比你配置更高端的机机，最后你就屈服购买了，还送你一堆配件，到家上网一查，尿了吧，傻了吧，所以其实网购更加透明，安全，只要选择京东或者天猫基本上就 OK，当然你要是觉得自己可以战胜奸商可以去挑战下，战败了别告诉我没提醒你= =关于配置，不要听那些数据什么 2G 超大显存，独立显卡，1T 超大硬盘，15 寸高清大屏，巧克力键盘。。。数据是数据，数据提升容易，架构完全不同，底层完全不同，数据是死的，所以大家追求大，更大，其实没必要，体验最重要，如果不知道选什么，还是建议大家去实体店体验，不要带钱，一分都不要带！就 OK 了。女孩也许都喜欢外形骚的，炫的，代价不轻，剁手谨慎！其实现在的品牌电脑，配置都还说得过去，电脑真心了解不多，但是自我感觉 3000 以上的机型跑大部分网络游戏已经足够，记得买个散热器，为你生命着想= =当然这是个人认为，如果有人更清楚，欢迎指点，不胜感激。当然你可以查你玩的游戏的推荐配置，然后比较一下，即可。基本上这个价位的配置玩网游的瓶颈在于网速，多花钱整个好点的宽带我觉得更为有用，而且这样的电脑操着不心疼~当然你可以买一台不错的电脑，自己配个键盘鼠标，换个屏幕也是可以的，当然后者难度高，建议拿去给专修电脑的师傅，自己淘宝屏幕，花点手工费，给师傅一包烟就成。女生其实我并不推荐买笔记本电脑，但是可能大学老师需要 Word、Exel、PPT 等，还是有个 Win 的电脑比较好，iPad 数据联通方面不太好，其实如果很少做那些，iPad 是最好的选择。好了，不说 Win 了，说 Mac 吧。 Mac OS X苹果电脑也许是唯一从 A 面一个徽标即可看出高端气质，苹果电脑的掌托从来没有贴画，知道贴画作用吗？反正可以换钱，当然钱让你电脑赚去了。乔布斯追求完美的性格，使得苹果电脑的简约化从头至今都依旧保留，Mac 只在苹果电脑上完美呈现，苹果是不可能允许别人来适配的，所以这就造就了苹果生态系统的完美统一，但是略有封闭，在 1985 年乔布斯离开苹果之后，微软反超，直到今天苹果电脑的占有率都十分低下，但是它并不低价，所以有人认为买了Mac是来装逼，其实没必要，除非他用 Mac 装了 Win 的系统。Mac 系统界面和 Win 相差很多，我不甚了解，大家如果购买了不会使用，可以搜索下 Mac 轻松玩，这个是个专业教你怎么玩 Mac 的视频教程，他的 App 在苹果商店有售 ￥25。或者百度一下，看看自己喜不喜欢，实在拿不定主意，建议你去苹果店里实际操作一下，除了你的专业必须用 Mac、钱多的没处花之外，我建议不选择 Mac，一体化铝制造型，流畅的运行，但是我仍不推荐，而且容易被盗。好了，说完系统了，说说别的。 其他一些问题尺寸下至 11.6 寸，上至 17 寸，最好的办法，去超市，苏宁等大卖场自己感觉，苹果电脑 MacBook Air 建议选择 13 寸，MacBook Pro with Retina 建议选择 15 寸。大屏幕视野广阔，小屏幕便携，按需求自己选择。 系统版本如果电脑自带触摸屏，建议选择 Win 8 及以上，较大的磁贴便于按压，但是我不推荐购买屏幕带触摸功能的电脑，很鸡肋，可以自己试试，土豪继续滚粗= = 便携程度现在有一种超级本的东西，其实没那么玄乎，就是为了对抗苹果的笔记本，但是 Win 系统的碎片化等等，导致根本无法对抗苹果电脑，Win 电脑普遍待机（拔掉电源）3 个小时，6 个小时已经是牛逼了，苹果 MBA 11 寸待机 9 个小时，13 寸 12 个小时，iPad 10 个小时，这个时间是有人操作的时间，当然可能有机型差异，但是除了特别宣称 Win 电脑待机的，基本都这个样，所以这也是为什么星巴克咖啡馆里面的人都用苹果的原因了，别的早回家充电了，而且 Win 系统关机再开机会损失之前的数据，而 Mac 完全停电再打开之后，还是和停电之前完全一样，这里不是吹苹果多牛逼，再牛逼目前没有可能赶超微软。 系统操作Win 都熟悉，Mac 你去体验店里玩一会就泪奔了，没办法，先入为主。 玩大型单机游戏买什么我的建议，你买外星人之流是挺好，挺装逼，但是那么沉，还不如买个笔记本组装个台式，以后升级还方便，不怕散热不怕丢，当然个人建议。 推荐几个牌子这还真不好说，反正有名的都差不多，神舟笔记本是挺性价比的，但是散热，屏幕是硬伤，不过可以加散热器，换屏幕。 平板电脑推荐个除了 iPad，别无选择，即使不买最新一代，买二手也完虐安卓，这里不是指配置，是体验。 我用的什么电脑我个屌丝，又不玩游戏，所以还是宏基的一款本，买的时候 2340，2013 年 1 月 25 日买的，配置一般，现在跑 Win 8.1，主要看中轻，便携，便宜，而且不准备更换，估计下次更换要上 MBA 定制版，因为某些软件只有 Mac 平台有，所以无奈，所以继续努力攒钱= = 最后，推荐一个比较显卡和 CPU 性能的图，俗称天梯图（PS: 过时太快，大家还是动动手百度一下吧）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[骑车回家幻想记]]></title>
      <url>2013%2F2%2F</url>
      <content type="text"><![CDATA[高中每周往返于学校与家之间的路上的那段时光，聆听了这座城市聒噪，思考过许多的无意义，文字无法记起那一段路程，更无法承受我对这里的爱。【Future】2013年4月26日骑车回家幻想记（原文题）我要的幸福 注：此文最早由本人发表于萌面大道吧，后转于此。 今天，一个人骑车回家，洛阳的春天又像孩子一样变得热烈起来，整个空气中布满了烦躁，可我还是那么冷静，听说不能留校后便背起书包，骑车回家！ 我不觉得我是个多么有思想的人，但是至少我可以思想，每次来去学校的路上，无聊，便时常观察路上的风景，有时憧憬一下未来，今天，也不知怎的，便开始想象我以后的人生。 我学习不好，至少在一高是这样的，我觉得是自己不够努力，太堕落，没有一个支撑下去的动力。所以我便想，既然学习不太好，所以大学可能考的就不怎么地，但是大学的意义就是让你与和你相似的人在一起，然后去学习做人的规则。大学毕业以后怎么办呢？现在工作难找，况且文凭不好，想不受气只能自己创业，感觉创业这个词太大了，可我也找不到更合适的了。当然这个憧憬假设在我找到了个合适的人。呵呵，某些人别乱猜了= = 如果我长大了，也找到了对的人，我希望我们的幸福可以简单一点，我虽然崇拜乔布斯的伟大，但是我又很想幻想一下一个普通人的幸福。我们可以就在洛阳，对，是洛阳（希望她也是洛阳的），洛阳虽然不算什么发达的城市，但是我爱她，她并没有像别的发达城市一样，总是以经济为主，而抛弃人文。我们在洛阳，开一家小饼店（只是假设，也可以干别的，都听你的），店面不用太大，就我们两个人，刚开始可能我并没有房子车子，我们可以住在店里，或者破一些的出租屋里，每天早晨，我轻轻的起床，在厨房为你做一桌早餐，可能不太丰盛，可能有些咸，或者难吃，然后我把你叫醒，把饭菜端到床上，你起床，享受这早晨的惬意，而我陪你吃完早餐，便整装待发，去准备一天所需要的东西，当我回来时，你已准备好迎接新的一天，我们服务每位顾客，让他们感受到我们的真心。每天你累了，便会悄悄告诉我，我们便结束了一天的忙碌。 中午，我可以去买你最爱吃的东东，晚上我们一起下厨，晚饭过后，我会亲自帮你洗脚，帮你按摩，你也会告诉我电视或者电脑上的新鲜内容。每天，我们都要锻炼身体，我会责怪你又瘦了，让你吃好的，每个星期，我们一起骑车去龙门，去动物园，还有，我们一定要去看我们的爸爸妈妈，让他们享受晚年的乐趣，每个月，我们都要去旅游一次，或是去看你偶像的各种会，可以去放松，去享受属于我们的青春，当我们一点点积累了财富，我们会在洛阳买一套房子，不要太大，温馨就行，我们自己设计。然后我们可以买一辆小车，代步就足够。每个月，我们要拿出一部分钱去捐款，去把钱实实在在的送到需要的人手中。幻想，总是很简单，而实现很难。我不知道有几个人会喜欢这样简单的幸福，而我也只是想想罢了，呵呵。我也知道我写的很乱，好吧，我只是自己看看，自我陶醉罢了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[仅以此文献给高班和总统]]></title>
      <url>2013%2F1%2F</url>
      <content type="text"><![CDATA[有些人始终只能存在于记忆之中，这…也许是为了未来的重逢吧…此文最早由本人发表于萌面大道吧，为留存以纪念后转于此。【Friend Ship】仅以此文献给高班和总统（原文题） 注：在很早之前，我的个人贴吧就开张了，不过到现在，带上自己也只有区区 6 人，两年前我在那里写过两篇，这就是其中之一。我文笔不好，不善言谈，但我也要写下来，因为回忆吧。到现在，我仍然没有他们的联系方式，他们也不曾看过这几百个弱小的文字。只希望，一切安好。 其实很早就有写篇东西给他们的冲动，但是咱文笔不好，没有华丽的词藻，只有平淡的语言，而且会语无伦次。 高班话说我们是同一个小学的。他很爱踢球，我也是，可我并没有报什么培训班之类的，他总是拿他丰富的经验来耍我（- -承认他技术好，但是主要我太瘦弱了。。。）。当时他在班里也是蛮风骚的。。。（NC会不会打我呢）木办法啊，人长得zun，学习也不赖！当然更受欢迎==，而我那个时候太单纯。。。初中，大家各奔东西。到了高中，开始也没见他的影子，后来高一下半学期分班，就正好分到这个八班了，他是班长，但觉得关系还和以前一样。。。不过更负责任，专一了= =足球还是那么好。。。希望你能好好读军校，刻苦一些，别放弃 NC，加油！就像龙井的《朋友》一样，“都是大老爷们，说的有点女人了”在那边吃好玩好，我也就放心了，可能你看不到这吧，不过证明我有个心意就知足了。你该走的时候，我没有去说什么，甚至一声再见，只是问你要了手机号，我知道以后可能很少联系了（平时也没有= =），祝保重！ 总统你因为和李明博同名，大家就叫你总统。。。记得初中的时候，有次看到一本作业，上面写着你的名字，当时我们就喷了= =~。如今李明博下去了，你也不在回来了，还记得上学期吗？咱俩做同桌，晚自习，我看生物你看政治。。。我还老是问你生物，嘿嘿，还记得那时候，你说你要拿 iPhone 5s 来找我= =，考不好就陪我一起拿 iPhone 6 嘿嘿！（顿时觉得高富帅。。。）当然你最好还是拿着 iPhone 5s 走吧。。。毕竟那条路前途更好，这个学期没和你做同桌，你平时也不是高调的人，总是默默无闻，走的时候，也是自己一个人背着书包走的，没有和别人说，也没人送你，到了大学以后可要开朗一点啊，总统身体好一定能吸引很多人的！记得一定回来告诉我你的电话！！ 你们走了，而我也只能努力奋斗了，你们也要继续努力，为了爱而战斗！]]></content>
    </entry>

    
  
  
</search>
