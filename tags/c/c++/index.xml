<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C/C&#43;&#43; on iBlog</title>
    <link>/tags/c/c&#43;&#43;/</link>
    <description>Recent content in C/C&#43;&#43; on iBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 22 Jul 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/c/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>C/C&#43;&#43;/Obj-C 中的 static、const &amp; extern</title>
      <link>/posts/2019/static_const_extern_in_cpp_obj-c/</link>
      <pubDate>Mon, 22 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/static_const_extern_in_cpp_obj-c/</guid>
      <description>Date Notes Notes     2019-07-23 首次提交     Preface 虽然天天接触 C/C++/Obj-C，但其实很多人（包括我）对于 static、const &amp;amp; extern 关键字具体的作用却含糊不清，尤其是遇到指针时。我们可能只是知道它们和常量有关，现在是时候搞清楚它们了。
C/C++ 基础类型 int a = 0; a = 10; const int b = 0; // error: cannot assign to variable &#39;b&#39; with const-qualified type &#39;const int&#39; // b = 10; int const c = 0; // c = 10;  对于基础类型，const
集合类型 int a[] = {1, 2, 3}; a[0] = 0; int const b[] = {1, 2, 3}; // error: read-only variable is not assignable // b[0] = 1; const int c[] = {1, 2, 3}; // c[0] = 1;  指向基础类型的指针 int foo = 0; int bar = 10; int *c = &amp;amp;foo; c = &amp;amp;bar; *c = foo; const int *d = &amp;amp;foo; d = &amp;amp;bar; // error: read-only variable is not assignable // *d = foo; int const *e = &amp;amp;foo; e = &amp;amp;bar; // *e = foo; int *const f = &amp;amp;foo; // error: cannot assign to variable &#39;f&#39; with const-qualified type &#39;int *const&#39; // f = &amp;amp;bar; *f = foo;  指向对象类型的指针 class Foo { public: double bar; Foo(double _bar) { bar = _bar; } }; Foo *foo1 = new Foo(0.</description>
    </item>
    
    <item>
      <title>将 Obj-C 代码翻译为 C/C&#43;&#43; 代码</title>
      <link>/posts/2019/obj-c_to_c&#43;&#43;/</link>
      <pubDate>Fri, 17 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/obj-c_to_c&#43;&#43;/</guid>
      <description>Date Notes     2019-06-15 增加常用参数列表   2019-05-17 首次提交    Solution ➜ ~ clang --version Apple LLVM version 10.0.0 (clang-1000.11.45.5) Target: x86_64-apple-darwin18.2.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin  Xcode 中，C/C++/Obj-C/C++ 的编译器是 clang，其通过 -rewrite-objc 参数可以将 Obj-C 代码翻译为 C++ 代码，即 clang -rewrite-objc main.m -o main.cpp；也可以结合 xcrun -sdk 命令设置编译所基于的 SDK。
   Options Usage     -arch arm64 指定编译架构   -framework UIKit 依赖 UIKit 框架   -fobjc-arc 使用 ARC（自动引用计数）模式   -fobjc-runtime=ios-8.</description>
    </item>
    
  </channel>
</rss>