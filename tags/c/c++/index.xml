<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C/C&#43;&#43; on iBlog</title>
    <link>/tags/c/c&#43;&#43;/</link>
    <description>Recent content in C/C&#43;&#43; on iBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved by kingcos.me</copyright><atom:link href="/tags/c/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MustOverride 源码解读</title>
      <link>/posts/2019/dive_into_mustoverride/</link>
      <pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/dive_into_mustoverride/</guid>
      <description>Date Notes Source Code Commit / Tag     2019-12-07 首次提交 nicklockwood/MustOverride c63007e / 1.1   2020-01-05 增加 Extension 一节 - -    Preface MustOverride 是 nicklockwood 多年前开源的一个 Obj-C 库。其作用正如其名「MustOverride」即可以使得子类必须重写父类中的某些方法，防止子类因未实现父类的某些方法而出现不可预知的错误。
How 这个库的使用非常简单，如果是 CocoaPods 管理依赖的项目，直接通过 pod &#39;MustOverride&#39; 即可引入；之后引入 MustOverride.h 头文件并在需要必须子类重写的父类（或父类的分类）方法中放入 SUBCLASS_MUST_OVERRIDE; 宏即可：
// Foo.m  #import &amp;#34;Foo.h&amp;#34; #import &amp;#34;MustOverride.h&amp;#34;  @implementation Foo - (void)foo { SUBCLASS_MUST_OVERRIDE; } @end // Foo+Ext.m  #import &amp;#34;Foo+Ext.h&amp;#34; #import &amp;#34;MustOverride.</description>
    </item>
    
    <item>
      <title>将 Obj-C 代码翻译为 C/C&#43;&#43; 代码</title>
      <link>/posts/2019/obj-c_to_c&#43;&#43;/</link>
      <pubDate>Sat, 30 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/obj-c_to_c&#43;&#43;/</guid>
      <description>Date Notes     2019-05-17 首次提交   2019-06-15 增加常用参数列表   2019-11-30 细节补充    Solution ➜ ~ clang --version Apple LLVM version 10.0.0 (clang-1000.11.45.5) Target: x86_64-apple-darwin18.2.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin Xcode 中，C/C++/Obj-C/C++ 的编译器是 clang，其通过 -rewrite-objc 参数可以将 Obj-C 代码翻译为 C++ 代码，即 clang -rewrite-objc main.m -o main.cpp；也可以结合 xcrun -sdk 命令设置编译所基于的 SDK。
   Options Usage     -arch arm64 指定编译架构   -framework UIKit 依赖 UIKit 框架   -fobjc-arc 使用 ARC（自动引用计数）模式   -fnoobjc-arc 使用 MRC（手动引用计数）模式   -fobjc-runtime=ios-12.</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43; 中的位域与共用体</title>
      <link>/posts/2019/bit_field_union_in_cpp/</link>
      <pubDate>Sat, 17 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/bit_field_union_in_cpp/</guid>
      <description>Date Notes Env     2019-08-17 首次提交 clang++、macOS 10.14.4    Preface C/C++ 中有许多「奇技淫巧」来让开发者能够以效率更高的方式使用内存，这也是一些高级语言着力去避讳的一点，但这种能够直面内存细节的「踏实感」让我个人觉得非常安心。本文将简单涉及 C/C++ 中的位域（Bit Field）与共用体（Union）的概念。
位域 布尔类型 对于布尔（Boolean）类型，我们都知道其只有两种值：逻辑真或逻辑假。在 C 语言中，其实并没有严格意义上的布尔类型；而在 C++ 中，则诞生了专用的 bool 类型：
#include &amp;lt;iostream&amp;gt; using namespace std; int main() { bool foo = true; bool bar = 0; cout &amp;lt;&amp;lt; foo &amp;lt;&amp;lt; endl; // 1  cout &amp;lt;&amp;lt; bar &amp;lt;&amp;lt; endl; // 0  cout &amp;lt;&amp;lt; sizeof(foo) &amp;lt;&amp;lt; endl; // 1  cout &amp;lt;&amp;lt; sizeof(bar) &amp;lt;&amp;lt; endl; // 1  return 0; } 如上，在 C++ 中，true 和非 0 代表布尔类型中的逻辑真，false 和 0 代表逻辑假。bool 类型的值通常在 C++ 中占用一个字节长度（「通常」代表对于不同的编译器结果可能并非完全一致）。</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43; 中的 const、static &amp; extern</title>
      <link>/posts/2019/const_static_extern_in_cpp/</link>
      <pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/const_static_extern_in_cpp/</guid>
      <description>Date Notes Env     2019-07-23 首次提交 clang++、macOS 10.14.4    Preface const、static &amp;amp; extern 是 C/C++ 中的关键字，而在 iOS 开发中的 Obj-C/C++ 又是 C/C++ 的超集，那么本篇就简单梳理一下这些关键字的作用。
const 基础类型 int a = 0; a = 10; 对于基础类型，其在内存中存储的即是该类型的变量本身，经过 const 修饰后，此处的变量不可变，即常量。const 的位置并不会影响其作用，更为推荐的写法应当是编译器提示的 const &amp;lt;TYPE&amp;gt;。
以下是在 C/C++ 中的用例，由于 Obj-C/C++ 分别是 C/C++ 的超集，对于 C/C++ 的基础类型，其在 Obj-C/C++ 中的表现是一致的：
const int b = 0; // error: cannot assign to variable &amp;#39;b&amp;#39; with const-qualified type &amp;#39;const int&amp;#39; // b = 10;  int const c = 0; // c = 10; 对于 Obj-C 中特有的基础类型，const 也与修饰 C/C++ 中基础类型的行为一致：</description>
    </item>
    
  </channel>
</rss>
