<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>iOS on iBlog</title>
    <link>/tags/ios/</link>
    <description>Recent content in iOS on iBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 13 Apr 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/ios/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>iOS 中的 Category</title>
      <link>/posts/2019/category_in_obj-c/</link>
      <pubDate>Sat, 13 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/category_in_obj-c/</guid>
      <description>Date Notes Source Code Demo     2019-04-13 首次提交 objc4-750、xnu-4903.221.2 Category in Obj-C    Preface 在 Obj-C 中，我们经常会使用 Category（中文常译作分类，但为表述清晰，下文仍将使用 Category）来对一个类进行扩展，使得类可以具备更多的功能；也会对一个类进行拆分，使得其结构更加清晰条理。本文将由浅入深，谈谈 iOS 中 Category 的结构、实现原理、以及与 Class Extension 的区别等。对于 + load 等专题性更强的内容，将单独放置在独立篇章中讲述，请各位参考文末的「Reference」。
category_t // Person+Life.h /** LifeProtocol */ @protocol LifeProtocol &amp;lt;NSObject&amp;gt; - (void)eat; @end /** Person+Life */ @interface Person (Life) &amp;lt;LifeProtocol&amp;gt; @property (nonatomic, copy) NSString *name; // Instance method - (void)run; // Class method + (void)foo; // Protocol method - (void)eat; @end  以 Person 类为例，创建一个 Life 的 Category，并在其中遵守协议、声明属性、定义并实现对象方法和类方法。为了便于分析，我们使用 xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc Person+Life.</description>
    </item>
    
    <item>
      <title>Obj-C &amp; Swift 的类型内省与反射</title>
      <link>/posts/2019/type_introspection_and_reflection/</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/type_introspection_and_reflection/</guid>
      <description>Date Notes Swift Demo     2019-04-08 首次提交 4.2 Type Introspection and Reflection    Preface 许多编程语言中都有类型内省（又称自省，Introspection）和反射（Reflection）这两个概念，本文将探讨一下 Obj-C 和 Swift 中类型内省和反射的相关概念与具体使用。
What 维基百科中对于类型内省定义如下：
 In computing, type introspection is the ability of a program to examine the type or properties of an object at runtime. Some programming languages possess this capability.
Introspection should not be confused with reflection, which goes a step further and is the ability for a program to manipulate the values, meta-data, properties and/or functions of an object at runtime.</description>
    </item>
    
    <item>
      <title>Xcode 中的 Link Map 文件</title>
      <link>/posts/2019/link_map_file_in_xcode/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/link_map_file_in_xcode/</guid>
      <description>Date Notes Xcode     2019-04-01 首次提交 10.1    Preface Link Map File，译作链接映射文件（下文将称 Link Map 文件）。在构建可执行文件之前，需要先编译为目标文件（Object File），并链接所需要的其他库，那么 Link Map 文件就记录了链接器（Linker）在链接过程中产生的一些信息，本文将谈谈这个文件的构成。
What Xcode 中默认是不会将 Link Map 文件在构建时暴露出来的，需要我们手动在「Build Settings」-「Write Link Map File」-「Yes」打开该写入该文件的设置。这样当我们再次编译项目，默认就可以在 ~/Library/Developer/Xcode/DerivedData/&amp;lt;TARGET_NAME&amp;gt;-&amp;lt;Random_ID&amp;gt;/Build/Intermediates.noindex/&amp;lt;TARGET_NAME&amp;gt;.build/Debug-&amp;lt;Device_Type&amp;gt;/&amp;lt;TARGET_NAME&amp;gt;.build/&amp;lt;TARGET_NAME&amp;gt;-LinkMap-normal-&amp;lt;Arch&amp;gt;.txt 中找到。如有更改 Link Map 文件路径的需求也可以在「Path to Link Map File」中更改。
举个例子，我的 DemoiOS 项目中 Link Map 文件的完整路径为：/Users/kingcos/Library/Developer/Xcode/DerivedData/DemoiOS-hifhuapijabsaxgpelrpiwhbzlqv/Build/Intermediates.noindex/DemoiOS.build/Debug-iphonesimulator/DemoiOS.build/DemoiOS-LinkMap-normal-x86_64.txt。
How 下面来分析一下 Link Map 文件的构成。
Path # Path: /Users/kingcos/Library/Developer/Xcode/DerivedData/DemoiOS-hifhuapijabsaxgpelrpiwhbzlqv/Build/Products/Debug-iphonesimulator/DemoiOS.app/DemoiOS  Path 为最终生成「可执行文件」的路径。
Arch // Target: Simulator # Arch: x86_64 // Target: iPhone # Arch: arm64  Arch 为「可执行文件」的架构，具体架构与设备的对照可参考下表：</description>
    </item>
    
    <item>
      <title>Obj-C 中成员变量和类的访问控制</title>
      <link>/posts/2019/ivar_access_control_in_obj-c/</link>
      <pubDate>Sat, 30 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/ivar_access_control_in_obj-c/</guid>
      <description>Date Notes macOS     2019-03-30 gcc, clang macOS 10.14.2    Preface Obj-C 中的成员变量，即 Instance Variables，简称为 ivar。在面向对象的概念中，一个类的对外暴露决定了其所提供的能力，对子类则需要提供一定的扩展性，但有些时候我们不希望外界甚至子类知道一些细节，这时就用到了访问控制（Access Control）。在 C++、Java、Swift 等大多数高级语言中都有这样的概念，这次就来谈谈 Obj-C 中成员变量和类的访问控制。
访问控制修饰符 @public @interface Computer : NSObject { @public NSString *_name; } @end @implementation Computer @end Computer *cpt = [[Computer alloc] init]; cpt-&amp;gt;_name = @&amp;quot;My PC&amp;quot;; NSLog(@&amp;quot;%@&amp;quot;, cpt-&amp;gt;_name); // My PC  声明为 @public 的成员变量是访问控制中开放范围最大的，其允许外界可以直接访问到（当然，前提是引入包含该类的头文件）。
@protected @interface Computer : NSObject { int _memorySize; @protected int _diskSize; } @end @implementation Computer @end @interface Mac : Computer - (instancetype)initWithDiskSize:(int)diskSize memorySize:(int)memorySize; - (instancetype)init NS_UNAVAILABLE; - (void)printDiskAndMemoryInfo; @end @implementation Mac - (instancetype)initWithDiskSize:(int)diskSize memorySize:(int)memorySize { self = [super init]; if (self) { _diskSize = diskSize; _memorySize = memorySize; } return self; } - (void)printDiskAndMemoryInfo { NSLog(@&amp;quot;My Mac&#39;s disk size is %d GB, memory size is %d GB.</description>
    </item>
    
    <item>
      <title>Obj-C 中的重载与重写</title>
      <link>/posts/2019/override_and_overload_in_obj-c/</link>
      <pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/override_and_overload_in_obj-c/</guid>
      <description>Platform     macOS 10.14.2    Preface 重载（Overload）和重写（Override）是面向对象语言中十分基本的两个概念，本文将谈谈 Obj-C 中的重载与重写。
重载  In some programming languages, function overloading or method overloading is the ability to create multiple functions of the same name with different implementations. Calls to an overloaded function will run a specific implementation of that function appropriate to the context of the call, allowing one function call to perform different tasks depending on context.</description>
    </item>
    
  </channel>
</rss>