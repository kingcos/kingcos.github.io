<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Practice on iBlog</title>
    <link>/tags/practice/</link>
    <description>Recent content in Practice on iBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 08 Apr 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/practice/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Obj-C &amp; Swift 的类型内省与反射</title>
      <link>/posts/2019/type_introspection_and_reflection/</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/type_introspection_and_reflection/</guid>
      <description>Date Notes Swift Demo     2019-04-08 首次提交 4.2 Type Introspection and Reflection    Preface 许多编程语言中都有类型内省（又称自省，Introspection）和反射（Reflection）这两个概念，本文将探讨一下 Obj-C 和 Swift 中类型内省和反射的相关概念与具体使用。
What 维基百科中对于类型内省定义如下：
 In computing, type introspection is the ability of a program to examine the type or properties of an object at runtime. Some programming languages possess this capability.
Introspection should not be confused with reflection, which goes a step further and is the ability for a program to manipulate the values, meta-data, properties and/or functions of an object at runtime.</description>
    </item>
    
    <item>
      <title>Obj-C 中成员变量和类的访问控制</title>
      <link>/posts/2019/ivar_access_control_in_obj-c/</link>
      <pubDate>Sat, 30 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/ivar_access_control_in_obj-c/</guid>
      <description>Date Notes macOS     2019-03-30 gcc, clang macOS 10.14.2    Preface Obj-C 中的成员变量，即 Instance Variables，简称为 ivar。在面向对象的概念中，一个类的对外暴露决定了其所提供的能力，对子类则需要提供一定的扩展性，但有些时候我们不希望外界甚至子类知道一些细节，这时就用到了访问控制（Access Control）。在 C++、Java、Swift 等大多数高级语言中都有这样的概念，这次就来谈谈 Obj-C 中成员变量和类的访问控制。
访问控制修饰符 @public @interface Computer : NSObject { @public NSString *_name; } @end @implementation Computer @end Computer *cpt = [[Computer alloc] init]; cpt-&amp;gt;_name = @&amp;quot;My PC&amp;quot;; NSLog(@&amp;quot;%@&amp;quot;, cpt-&amp;gt;_name); // My PC  声明为 @public 的成员变量是访问控制中开放范围最大的，其允许外界可以直接访问到（当然，前提是引入包含该类的头文件）。
@protected @interface Computer : NSObject { int _memorySize; @protected int _diskSize; } @end @implementation Computer @end @interface Mac : Computer - (instancetype)initWithDiskSize:(int)diskSize memorySize:(int)memorySize; - (instancetype)init NS_UNAVAILABLE; - (void)printDiskAndMemoryInfo; @end @implementation Mac - (instancetype)initWithDiskSize:(int)diskSize memorySize:(int)memorySize { self = [super init]; if (self) { _diskSize = diskSize; _memorySize = memorySize; } return self; } - (void)printDiskAndMemoryInfo { NSLog(@&amp;quot;My Mac&#39;s disk size is %d GB, memory size is %d GB.</description>
    </item>
    
  </channel>
</rss>