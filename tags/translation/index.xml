<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Translation on iBlog</title>
    <link>/tags/translation/</link>
    <description>Recent content in Translation on iBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved by kingcos.me</copyright>
    <lastBuildDate>Thu, 05 Mar 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/translation/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[译] Swift 编译器</title>
      <link>/posts/2020/swift_compiler/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_compiler/</guid>
      <description>作者 原文链接     Swift.org Swift Compiler    Swift 主仓库中包含了 Swift 编译器和标准库的源代码、相关组件，如 SourceKit（用于 IDE 集成），以及 Swift 回归测试套件和实现级别的文档。
Swift 驱动库中包含了 Swift 编译器驱动（Driver）的新版实现，目的是替换现有编译器驱动，以增强可扩展性、可维护性以及鲁棒性（Robust）。
编译器架构 整体而言，Swift 编译器的主要职责在于将 Swift 源代码翻译为高效执行的机器码。但是 Swift 编译器的前端同样支持许多其它工具，包括与 IDE 集成的语法高亮、代码补全、以及其它提供便利的工具。本文对 Swift 编译器的主要组件提供了高阶描述：
 解析（Parsing）：解析器是一个简易的递归下降解析器（在 lib/Parse 中实现），并带有完整手动编码的词法分析器。 语义分析（Semantic Analysis）：语义分析阶段（在 lib/Sema 中实现）负责获取已解析的 AST（抽象语法树）并将其转换为格式正确且类型检查完备的 AST，以及在源代码中提示出现语义问题的警告或错误。语义分析包含类型推断，如果可以成功推导出类型，则表明此时从已经经过类型检查的最终 AST 生成代码是安全的。 Clang 导入器（Clang Importer）：Clang 导入器（在 lib/ClangImporter 中实现）负责导入 Clang 模块，并将导出的 C 或 Objective-C API 映射到相应的 Swift API 中。最终导入的 AST 可以被语义分析引用。 SIL 生成（SIL Generation）：Swift 中间语言（Swift Intermediate Language，SIL）是一门高级且专用于 Swift 的中间语言，适用于对 Swift 代码的进一步分析和优化。SIL 生成阶段（在 lib/SILGen 中实现）将经过类型检查的 AST 弱化为所谓的「原始」SIL。SIL 的设计在 docs/SIL.</description>
    </item>
    
    <item>
      <title>[译] 摊平由「try?」造成的嵌套可选</title>
      <link>/posts/2019/0230-flatten-optional-try_zh/</link>
      <pubDate>Mon, 08 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/0230-flatten-optional-try_zh/</guid>
      <description>提案: SE-0230 作者: BJ Homer 审查管理员: John McCall 状态: 已实现 (Swift 5) 实现: apple/swift#16942 审查: (论坛帖子) (验收)  介绍 Swift 中的 try? 语句目前很容易引入嵌套可选（译者注：嵌套可选即类似 var foo: String?? 可选的可选类型）。而用户难以推断嵌套可选的产生原因，所以 Swift 尝试避免在一些常见情况下产生嵌套可选。
该文档提议给予 try? 与其它常见的 Swift 功能中相同的可选摊平行为（译者注：可选摊平即将可选类型的值去掉可选的一层），来避免常见的嵌套可选。
Swift-evolution 帖子: 使 try? 与可选链摊平协同工作
动机 目前，使用 try? 非常容易产生嵌套的 Optional 类型。虽然构建嵌套可选是被允许的，但这通常并非是开发者所希望的。
Swift 拥有许多机制来避免意外创建嵌套可选。比如：
// 注意 as? 是如何可以无视被转换的值是否是可选类型的，其总是产生了相同的类型 let x = nonOptionalValue() as? MyType // x 是 &amp;#39;MyType?&amp;#39; 类型 let y = optionalValue() as? MyType // y 是 &amp;#39;MyType?</description>
    </item>
    
    <item>
      <title>[译] 在 Objective-C API 中指定可空性</title>
      <link>/posts/2019/nullability_in_obj-c/</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/nullability_in_obj-c/</guid>
      <description>作者 原文链接     Apple Inc. Designating Nullability in Objective-C APIs    使用可空性（Nullability）标志或标志一块区域，以控制将 Objective-C 声明导入 Swift 中的方式。
 框架：  Swift 标准库     概览 在 Objective-C 中，常用可以为空的指针来和对象的引用打交道，这（个空）就是 Objective-C 中的 nil。在 Swift 中，所有值——包括对象实例——都被确保为非空（Non-null）。取而代之，表示一个可能丢失的值可以将其包裹在可选（Optional）类型中。当我们需要表示一个值的丢失，可以使用 nil 值。
我们可以在 Objective-C 的代码中标示声明，以指示一个实例是否可以有空（Null）或 nil 值。这些标志改变了 Swift 如何导入声明（的方式）。举个 Swift 如何导入未标示声明的例子，如下：
@interface MyList : NSObject - (MyListItem *)itemWithName:(NSString *)name; - (NSString *)nameForItem:(MyListItem *)item; @property (copy) NSArray&amp;lt;MyListItem *&amp;gt; *allItems; @end Swift 导入了每个对象实例的参数、返回值、以及作为隐式包裹可选的属性（译者注：隐式包裹即 Type!</description>
    </item>
    
    <item>
      <title>[译] URL 加载系统</title>
      <link>/posts/2019/url_loading_system/</link>
      <pubDate>Mon, 06 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/url_loading_system/</guid>
      <description>作者 原文链接     Apple Inc. URL Loading System    使用标准互联网协议与 URL 交互，并和服务器通信。
 框架：  Foundation     概览 URL 加载系统通过标准协议比如 HTTPS 或自建协议提供对 URL 标识资源的访问。加载过程是异步的，所以 App 可以保持响应并当数据到达或出错时进行处理。
使用 URLSession 实例可以创建一个或多个 URLSessionTask 实例，来抓取并返回数据给 App、下载文件、或者上传数据和文件到远程地址。使用 URLSessionConfiguration 对象可以配置会话（Session），可以控制类似如何使用缓存和 Cookie 的行为、以及是否允许蜂窝网络连接。
一个会话可以重复地创建任务。举个例子，浏览器可能有分隔的会话以区分普通和隐私浏览，隐私会话将不缓存数据。图 1 展示了不同配置的两种会话可以创建许多任务。
 默认浏览：URLSession [默认配置] -&amp;gt; URLSessionDataTask 隐私浏览：URLSession [临时配置] -&amp;gt; URLSessionDataTask  为了接收定期的更新（或错误），每个会话都与一个代理关联。默认代理将调用提供的回调 Block；如果选择提供自定义的代理，该 Block 不再调用。
通过配置 App 运行在后台时的会话，即可当 App 被挂起时，系统可以代替其下载数据并唤起 App 以分发结果。</description>
    </item>
    
    <item>
      <title>[译] Swift 名字修饰（Name Mangling）</title>
      <link>/posts/2020/friday_qa_swift_name_mangling/</link>
      <pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/friday_qa_swift_name_mangling/</guid>
      <description>作者 原文链接   Gwynne Raskind Friday Q&amp;A 2014-08-08: Swift Name Mangling    译者注
1.「Name Mangling」在本文中将译作「名字修饰」，这主要是参考了 Wikipedia 中关于该项技术的翻译；
2.「Friday Q&amp;amp;A」中文意为「周五问与答」，但限于该名称是作者文章的系列名称，故保留原文不再翻译。
 许久没有参与到 Friday Q&amp;amp;A 中，不过我带着全新主题的文章又回来了：Swift。在最近的几篇文章中，Mike 具体介绍了 Swift 的内部结构是什么样的，但他只是轻描淡写了当查看包含 Swift 的二进制文件时，链接器所看到的：被修饰的（Mangled）符号名。
 在 C 之类的编程语言中，任何给定的名称（符号）都只能对应一个函数或者一条数据，那么名字修饰（Name Mangling）就不是必需的。尽管如此，如果我们查看典型的纯 C 二进制文件的符号表，仍然能发现每个函数名中都有一个 _（下划线）作为前缀。举个例子：
$ echo &amp;#39;int main() { return 0; }&amp;#39; | xcrun clang -x c - -o ./test $ xctest nm ./test # 译者注：xctest 命令可能无法直接找到，也可直接使用 nm ./test 0000000100000000 T __mh_execute_header 0000000100000f80 T _main U dyld_stub_binder $ 这种简单的「修饰」没有什么作用，其存在主要是历史原因，由于兼容性与统一性而被保留。按照约定，C 中定义的名称将带有下划线，而纯汇编定义的全局符号则没有（尽管许多汇编语言的作者仍会为了统一性而使用下划线作为前缀）。</description>
    </item>
    
    <item>
      <title>[译] 为 App 执行一次性设置</title>
      <link>/posts/2018/performing_one-time_setup_for_your_app/</link>
      <pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/performing_one-time_setup_for_your_app/</guid>
      <description>作者 原文链接     Apple Inc. Performing One-Time Setup for Your App    确保 App 环境被正确配置。
 框架  UIKit     概览 当用户第一次启动 App，我们可能希望通过一些一次性任务预备 App 环境。举个例子，可能想要：
 从服务器下载必要的数据。 从 App 包（bundle）中拷贝文档模版或可修改的数据文件至一个可写入的目录。 为用户配置默认偏好设置。 设置用户账户或获取其他必要数据。  在 App 代理的 application(_:willFinishLaunchingWithOptions:) 或 application(_:didFinishLaunchingWithOptions:) 方法中执行任何一次性任务。当非必需用户输入时，绝不要因任务阻塞 App 的主线程。取而代之，使用调度队列（dispatch queue）异步开启任务，当 App 完成启动时，让其运行在后台。对于那些必需用户输入的任务，在 application(_:didFinishLaunchingWithOptions:) 方法中作出用户界面的改变。
在合适的位置安放文件 App 拥有其自身包含的目录来保存文件，我们也应当总是将 App 特定的文件放在 ~/Library 的子目录中。特别地，将以下文件保存在 ~/Library 的子目录：
 ~/Library/Application Support/ —— 保存想要备份用户的其他内容的 App 特定文件（可以根据需要创建自定义的子目录。）使用该目录保存数据文件，配置文件，文档模版，等等。 ~/Library/Caches/ —— 保存便于重复产生或下载的临时文件。  使用 FileManager 的 urls(for:in:) 方法获得 App 容器的目录 URL。</description>
    </item>
    
    <item>
      <title>[译] 关于 App 启动顺序</title>
      <link>/posts/2018/about_the_app_launch_sequence/</link>
      <pubDate>Fri, 16 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/about_the_app_launch_sequence/</guid>
      <description>作者 原文链接     Apple Inc. About the App Launch Sequence    学习在启动时的代码执行顺序。
 框架  UIKit     概览 一个 App 的启动需要经过许多复杂的步骤，其中大部分由 UIKit 自动处理。在启动过程中，UIKit 会调用 App 代理中的方法，因此我们可以执行自定义的任务。图中的步骤展示了从 App 启动的时间开始直到被认为初始化完成的过程。
 由用户显式或系统隐式启动 App。 Xcode 提供的 main 函数调用 UIKit 的 UIApplicationMain(_:_:_:_:) 函数。 UIApplicationMain(_:_:_:_:) 函数创建 UIApplication 对象和 App 代理。 UIKit 从主 storyboard 或 nib 文件加载 App 的默认界面。 UIKit 调用 App 代理的 application(_:willFinishLaunchingWithOptions:) 方法。 UIKit 执行状态恢复（state restoration），即调用 App 代理和视图控制器中的额外的方法。 UIKit 调用 App 代理的 application(_:didFinishLaunchingWithOptions:) 方法。  当初始化完成，系统将 App 转到激活（前台）状态或后台状态。当 App 转到激活状态，其窗口出现在屏幕上，并开始响应用户交互。当 App 转到后台状态，其窗口保持隐藏，并在被暂停前运行极短的时间。</description>
    </item>
    
    <item>
      <title>[译] 起底 SourceKit</title>
      <link>/posts/2018/uncovering_sourcekit/</link>
      <pubDate>Sun, 08 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/uncovering_sourcekit/</guid>
      <description>作者 原文链接     JP Simard Uncovering SourceKit     为了支持一门新颖的语言（译者注：这里指 Swift），灵活的实时 IDE 特性，以及令人印象深刻的跨语言协同能力（译者注：这里指 Swift 与 Obj-C），Apple 必须开发一些新的基础工具。这里我们将聚焦于 SourceKit，一个被忽视的 Xcode 搭档。
 什么是 SourceKit？ SourceKit 是一套工具集，使得大多数 Swift 源代码层面的操作特性得以支持，例如源代码解析、语法高亮、排版（Typesetting）、代码自动补全、跨语言头文件生成等许多功能。
架构 一般来说，Xcode 在进程中运行其编译器（Clang），这意味着编译器随时可能出现的崩溃都会导致 IDE 崩溃。
更有甚者，Xcode 容易唤起编译器进行成千上万次解析、高亮、以及排版源代码等操作，而所有这一切均在用户按下「⌘ + B」之前。这是因为不像大多数编辑器（Vim、Sublime 等），Xcode 并不使用正则表达式解析源代码，而是使用 Clang 强大的（也的确更加复杂的）解析器（Parser）和令牌生成器（Tokenizer）。
幸运的是，Xcode 6 中的 Swift 抛弃了该架构1，将所有源代码操作的特性组合至一个独立的进程，并和 Xcode 通过 XPC 交流：sourcekitd。每当 Xcode 6 加载任何 Swift 代码时，都将启动该 XPC 守护进程。
Xcode 怎样使用 SourceKit 由于 SourceKit 是一个私有且没有文档记录的工具，我们需要获得一些小点子来学习如何使用它。通过设定 SOURCEKIT_LOGGING2 环境变量，Xcode 将其与 SourceKit 的通信记录到 stdout，从而使我们可以观察到它们的实时交流。这就是本文中的许多命令的来源。</description>
    </item>
    
  </channel>
</rss>