<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Translation on iBlog</title>
    <link>/tags/translation/</link>
    <description>Recent content in Translation on iBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 09 May 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/translation/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[译]在 Objective-C API 中指定可空性</title>
      <link>/posts/2019/nullability_in_obj-c/</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/nullability_in_obj-c/</guid>
      <description>作者 原文链接     Apple Inc. Designating Nullability in Objective-C APIs    使用可空性（Nullability）标志或标志一块区域，以控制将 Objective-C 声明导入 Swift 中的方式。
 框架：  Swift 标准库   概览 在 Objective-C 中，常用可以为空的指针来和对象的引用打交道，这（个空）就是 Objective-C 中的 nil。在 Swift 中，所有值——包括对象实例——都被确保为非空（Non-null）。取而代之，表示一个可能丢失的值可以将其包裹在可选（Optional）类型中。当我们需要表示一个值的丢失，可以使用 nil 值。
我们可以在 Objective-C 的代码中标示声明，以指示一个实例是否可以有空（Null）或 nil 值。这些标志改变了 Swift 如何导入声明（的方式）。举个 Swift 如何导入未标示声明的例子，如下：
@interface MyList : NSObject - (MyListItem *)itemWithName:(NSString *)name; - (NSString *)nameForItem:(MyListItem *)item; @property (copy) NSArray&amp;lt;MyListItem *&amp;gt; *allItems; @end  Swift 导入了每个对象实例的参数、返回值、以及作为隐式包裹可选的属性（译者注：隐式包裹即 Type!</description>
    </item>
    
    <item>
      <title>[译]URL 加载系统</title>
      <link>/posts/2019/url_loading_system/</link>
      <pubDate>Mon, 06 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/url_loading_system/</guid>
      <description>作者 原文链接     Apple Inc. URL Loading System    使用标准互联网协议与 URL 交互，并和服务器通信。
 框架：  Foundation   概览 URL 加载系统通过标准协议比如 HTTPS 或自建协议提供对 URL 标识资源的访问。加载过程是异步的，所以 App 可以保持响应并当数据到达或出错时进行处理。
使用 URLSession 实例可以创建一个或多个 URLSessionTask 实例，来抓取并返回数据给 App、下载文件、或者上传数据和文件到远程地址。使用 URLSessionConfiguration 对象可以配置会话（Session），可以控制类似如何使用缓存和 Cookie 的行为、以及是否允许蜂窝网络连接。
一个会话可以重复地创建任务。举个例子，浏览器可能有分隔的会话以区分普通和隐私浏览，隐私会话将不缓存数据。图 1 展示了不同配置的两种会话可以创建许多任务。
 默认浏览：URLSession [默认配置] -&amp;gt; URLSessionDataTask 隐私浏览：URLSession [临时配置] -&amp;gt; URLSessionDataTask  为了接收定期的更新（或错误），每个会话都与一个代理关联。默认代理将调用提供的回调 Block；如果选择提供自定义的代理，该 Block 不再调用。
通过配置 App 运行在后台时的会话，即可当 App 被挂起时，系统可以代替其下载数据并唤起 App 以分发结果。</description>
    </item>
    
    <item>
      <title>[译]为 App 执行一次性设置</title>
      <link>/posts/2018/performing_one-time_setup_for_your_app/</link>
      <pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/performing_one-time_setup_for_your_app/</guid>
      <description>作者 原文链接     Apple Inc. Performing One-Time Setup for Your App    确保 App 环境被正确配置。
 框架  UIKit   概览 当用户第一次启动 App，我们可能希望通过一些一次性任务预备 App 环境。举个例子，可能想要：
 从服务器下载必要的数据。 从 App 包（bundle）中拷贝文档模版或可修改的数据文件至一个可写入的目录。 为用户配置默认偏好设置。 设置用户账户或获取其他必要数据。  在 App 代理的 application(_:willFinishLaunchingWithOptions:) 或 application(_:didFinishLaunchingWithOptions:) 方法中执行任何一次性任务。当非必需用户输入时，绝不要因任务阻塞 App 的主线程。取而代之，使用调度队列（dispatch queue）异步开启任务，当 App 完成启动时，让其运行在后台。对于那些必需用户输入的任务，在 application(_:didFinishLaunchingWithOptions:) 方法中作出用户界面的改变。
在合适的位置安放文件 App 拥有其自身包含的目录来保存文件，我们也应当总是将 App 特定的文件放在 ~/Library 的子目录中。特别地，将以下文件保存在 ~/Library 的子目录：
 ~/Library/Application Support/ —— 保存想要备份用户的其他内容的 App 特定文件（可以根据需要创建自定义的子目录。）使用该目录保存数据文件，配置文件，文档模版，等等。 ~/Library/Caches/ —— 保存便于重复产生或下载的临时文件。  使用 FileManager 的 urls(for:in:) 方法获得 App 容器的目录 URL。</description>
    </item>
    
    <item>
      <title>[译]关于 App 启动顺序</title>
      <link>/posts/2018/about_the_app_launch_sequence/</link>
      <pubDate>Fri, 16 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/about_the_app_launch_sequence/</guid>
      <description>作者 原文链接     Apple Inc. About the App Launch Sequence    学习在启动时的代码执行顺序。
 框架  UIKit   概览 一个 App 的启动需要经过许多复杂的步骤，其中大部分由 UIKit 自动处理。在启动过程中，UIKit 会调用 App 代理中的方法，因此我们可以执行自定义的任务。图中的步骤展示了从 App 启动的时间开始直到被认为初始化完成的过程。
 由用户显式或系统隐式启动 App。 Xcode 提供的 main 函数调用 UIKit 的 UIApplicationMain(_:_:_:_:) 函数。 UIApplicationMain(_:_:_:_:) 函数创建 UIApplication 对象和 App 代理。 UIKit 从主 storyboard 或 nib 文件加载 App 的默认界面。 UIKit 调用 App 代理的 application(_:willFinishLaunchingWithOptions:) 方法。 UIKit 执行状态恢复（state restoration），即调用 App 代理和视图控制器中的额外的方法。 UIKit 调用 App 代理的 application(_:didFinishLaunchingWithOptions:) 方法。  当初始化完成，系统将 App 转到激活（前台）状态或后台状态。当 App 转到激活状态，其窗口出现在屏幕上，并开始响应用户交互。当 App 转到后台状态，其窗口保持隐藏，并在被暂停前运行极短的时间。</description>
    </item>
    
    <item>
      <title>[译]起底 SourceKit</title>
      <link>/posts/2018/uncovering_sourcekit/</link>
      <pubDate>Sun, 08 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/uncovering_sourcekit/</guid>
      <description>作者 发表时间 原文链接     JP Simard 20140706 https://www.jpsim.com/uncovering-sourcekit/     为了支持一门奇特的新编程语言（译者注：即 Swift），漂亮的实时 IDE 特性，以及令人印象深刻的跨语言协同性（译者注：即 Swift 与 Obj-C），Apple 不得不开发一些新的底层工具。这里我们将专注于 SourceKit，Xcode 背后的功臣。
 什么是 SourceKit？ SourceKit 是一套工具集，使得大多数 Swift 源代码层面的操作特性得以支持，例如源代码解析、语法高亮、排版（typesetting）、自动补全、跨语言头文件生成，等等。
架构 传统上，Xcode 在运行时跑着其编译器（Clang），即意味着编译器将可能在任何时候崩溃，IDE 同样。
更有甚者，Xcode 容易唤起编译器进行成千上万次解析、高亮、以及排版源代码，所有这一切都在用户键入「⌘ + B」之前。这是因为不像大多数编辑器（Vim/Sublime/&amp;hellip;），Xcode 并不使用正则表达式解析源代码，而是使用 Clang 强大的（也更加复杂的）解析器（parser）和标记器（tokenizer）。
庆幸的是，Xcode 6 中的 Swift 移除了该特性1，合并所有源代码操作特性至一个独立的进程，并和 Xcode 通过 XPC 交流：sourcekitd。无论 Xcode 6 何时加载任何 Swift 代码，该 XPC 守护进程将被启动。
Xcode 如何使用 SourceKit 因为 SourceKit 是一个私有且无文档的工具，我们需要获得一些小点子来学习如何使用它。通过设定 SOURCEKIT_LOGGING2 环境变量，Xcode 将记录 SourceKit 与 stdout 间的通信，允许我们观察到它们的实时通信。这就是如何发现本文中的许多命令。</description>
    </item>
    
  </channel>
</rss>