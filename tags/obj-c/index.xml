<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Obj-C on iBlog</title>
    <link>/tags/obj-c/</link>
    <description>Recent content in Obj-C on iBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 18 May 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/obj-c/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>iOS 中的关联对象</title>
      <link>/posts/2019/associated_objects_in_ios/</link>
      <pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/associated_objects_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-05-18 首次提交 objc4-750 -    Preface 提到 iOS 中的关联对象，即 Associated Objects，又可以算是一项利用 Runtime 的「黑魔法」。然而作为初学者，很难从其名称联想到是为谁关联对象，以及是如何关联对象的，那么今天就来一起研究下 iOS 中的关联对象是什么、怎么用、以及为什么。
What 虽然这部分的官方文档已经「年久失修」，不过我们仍然简单看一下官方的概括：
 Associative References
Associative references, available starting in OS X v10.6, simulate the addition of object instance variables to an existing class. Using associative references, you can add storage to an object without modifying the class declaration. This may be useful if you do not have access to the source code for the class, or if for binary-compatibility reasons you cannot alter the layout of the object.</description>
    </item>
    
    <item>
      <title>Swift/Obj-C 混编项目升级 Swift 5.0 踩坑</title>
      <link>/posts/2019/swift_4_to_5/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/swift_4_to_5/</guid>
      <description>Date Swift     2019-05-08 Swift 4.2 -&amp;gt; 5.0    Preface 在 ABI 稳定前，每次 Swift 升级都是一个比较「痛苦」的体验。这次笔者花费约总共一天时间将 Swift/Obj-C 混编项目升级到 Swift 5.0，其中还是有一些踩坑经验值得分享的。
Xcode 为了适配 Swift 5.0，首先需要安装 Xcode 10.2。而我们不能完全抛弃 Xcode 10.1，毕竟在未完全转换到 Swift 5.0 的过渡阶段仍然需要使用。因此我们可以将本地的 Xcode 更名为 Xcode-10.1，再在 https://developer.apple.com/download/more/ 检索 Xcode 下载 10.2 版本即可。
 ⚠️ 为了防止类似 XcodeGhost 事件再次发生，建议从该官方渠道或 App Store 直接下载。
 为了便于区分，我们将新的 Xcode 命名为 Xcode-10.2，并打开、同意安装 Xcode Command Line Tools。由于我们目前安装了两个 Xcode，如果需要命令行执行 swift 或 xcodebuild 等命令，可以使用 xcode-select 来进行切换不同版本。</description>
    </item>
    
    <item>
      <title>《编写高质量 iOS 与 OS X 代码的 52 个有效方法》阅读笔记</title>
      <link>/posts/2019/effective_obj-c_2.0_notes/</link>
      <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/effective_obj-c_2.0_notes/</guid>
      <description>Book ISBN     编写高质量 iOS 与 OS X 代码的 52 个有效方法 9787111451297   Date Chapters   2019-05-01     熟悉 Objective-C 了解 Objective-C 语言的起源  消息结构（Message Structure）的语言，运行时执行的代码由运行环境决定；函数调用（Function Calling）的语言，运行时所执行的代码由编译器决定，对于多态，则按照虚函数表（Virtual Method Table）寻找。 运行时组件（Runtime Component） 本质上是一种与开发者所编写代码相链接的「动态库（Dynamic Library），这样的好处是只需要更新运行时组件（无需重新编译）即可提升程序性能。 Obj-C 是 C 的超集。 Obj-C 中的对象所占内存总是分配在堆空间（Heap Stack）；而指向对象的指针所占内存总是分配在栈帧（Stack Frame）中。 堆中的内存需要程序员自己管理，栈中的内存会在其栈帧弹出（Pop）时自动清理。 创建对象相比创建结构体（C 结构体）需要额外开销，例如分配和释放堆内存等。  // ⚠️ 由于 Obj-C 中的字符串（NSString）略有特殊，此处并未使用书中的 NSString 作为范例 // 对象本身被分配在堆上；obj1 &amp;amp; obj2 被分配在栈上 NSObject *obj1 = [[NSObject alloc] init]; NSObject *obj2 = obj1; // (lldb) p obj1 // (NSObject *) $0 = 0x00000001005092b0 // (lldb) p obj2 // (NSObject *) $1 = 0x00000001005092b0 // (lldb) p &amp;amp;obj1 // (NSObject **) $2 = 0x00007ffeefbff508 // (lldb) p &amp;amp;obj2 // (NSObject **) $3 = 0x00007ffeefbff500  在类的头文件中尽量少引入其他头文件  当需要知道有一个类的存在时，而不关心其内部细节时，可以使用向前声明（Forward Declaring）告知编译器，即可以在 .</description>
    </item>
    
    <item>
      <title>iOS 中的 &#43;initialize 方法</title>
      <link>/posts/2019/&#43;initialize_in_ios/</link>
      <pubDate>Sun, 21 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/&#43;initialize_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-04-21 首次提交 objc4-750 -   2019-05-01 补充细节 - Initialize_Demo    Preface 在 iOS 中，经常与 +load 相提并论的一个方法便是 +initialize。从方法名来看，它的作用是进行初始化，但不同于平时使用的 init，+initialize 是一个类方法。那么它的本质到底是什么呢？
为了更好地叙述 +initialize 的特点，本文部分描述尝试与 +load 方法对比，建议阅读本文前先阅读「iOS 中的 +load 方法」。
What // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { + (void)initialize; }  Obj-C 中的 +initialize 方法指的是 NSObject 中的 + (void)initialize 类方法。官方文档中的 +initialize 如下：
 Initializes the class before it receives its first message.</description>
    </item>
    
    <item>
      <title>iOS 中的 &#43;load 方法</title>
      <link>/posts/2019/&#43;load_in_ios/</link>
      <pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/&#43;load_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-04-20 首次提交 objc4-750 Load_Obj-C_Demo    Preface 在 iOS 开发中，我们经常会使用 +load 方法来做一些在 main 函数之前的操作，比如方法交换（Method Swizzle）等。那么 +load 到底是如何被调用的呢？
What // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { + (void)load; }  Obj-C 中的 +load 方法指的是 NSObject 中的 + (void)load 类方法。官方文档中的 +load 如下：
 Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</description>
    </item>
    
    <item>
      <title>iOS 中的 Category</title>
      <link>/posts/2019/category_in_ios/</link>
      <pubDate>Sat, 13 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/category_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-04-16 优化结构 - -   2019-04-13 首次提交 objc4-750、xnu-4903.221.2 Category in iOS    Preface iOS 中的 Category 中文常译作分类、类别（为表述统一，本文将使用 Category 特指该技术）。我们经常会使用 Category 来对一个类进行扩展，使得在不破坏主类结构的同时可以具备更多的功能；也可以使用 Category 对一个类进行拆分，使得其结构更加清晰条理。本文将从 What - How - Why 谈谈 iOS 中 Category。
What 什么是 Category 呢？
Category 是 Obj-C 语言中所提供的一项功能，它可以为 Obj-C 类添加额外的属性、方法，也可以遵守其他协议。
Xcode 中已经为 Category 已经提供了模版来建立，只需要指定 Category 的名称以及被添加 Category 类名即可。当然，我们也可以手动来自己建立，Category 的语法与类的声明与实现比较类似：
@interface Foo (Bar) &amp;lt;SomeProtocol&amp;gt; - (void)foo; @end @implementation Foo (Bar) - (void)foo {} - (void)someMethodFromProtocol {} @end  How Category 通常都有哪些用处呢？</description>
    </item>
    
    <item>
      <title>Obj-C &amp; Swift 的类型内省与反射</title>
      <link>/posts/2019/type_introspection_and_reflection/</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/type_introspection_and_reflection/</guid>
      <description>Date Notes Swift Demo     2019-04-08 首次提交 4.2 Type Introspection and Reflection    Preface 许多编程语言中都有类型内省（又称自省，Introspection）和反射（Reflection）这两个概念，本文将探讨一下 Obj-C 和 Swift 中类型内省和反射的相关概念与具体使用。
What 维基百科中对于类型内省定义如下：
 In computing, type introspection is the ability of a program to examine the type or properties of an object at runtime. Some programming languages possess this capability.
Introspection should not be confused with reflection, which goes a step further and is the ability for a program to manipulate the values, meta-data, properties and/or functions of an object at runtime.</description>
    </item>
    
    <item>
      <title>Xcode 中的 Link Map 文件</title>
      <link>/posts/2019/link_map_file_in_xcode/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/link_map_file_in_xcode/</guid>
      <description>Date Notes Xcode Swift     2019-04-16 增加 Swift 项目 10.1 4.2   2019-04-01 首次提交 10.1 -    Preface Link Map File，译作链接映射文件（下文将称 Link Map 文件）。Xcode 在构建可执行文件之前，需要先编译为目标文件（Object File），并链接所需要的其他库，那么 Link Map 文件就记录了链接器（Linker）在链接过程中产生的一些信息，本文将谈谈这个文件的构成。
What Xcode 中默认是不会将 Link Map 文件在构建时暴露出来的，需要我们手动在「Build Settings」-「Write Link Map File」-「Yes」打开该写入该文件的设置。这样当我们再次编译项目，默认就可以在 ~/Library/Developer/Xcode/DerivedData/&amp;lt;TARGET_NAME&amp;gt;-&amp;lt;Random_ID&amp;gt;/Build/Intermediates.noindex/&amp;lt;TARGET_NAME&amp;gt;.build/Debug-&amp;lt;Device_Type&amp;gt;/&amp;lt;TARGET_NAME&amp;gt;.build/&amp;lt;TARGET_NAME&amp;gt;-LinkMap-normal-&amp;lt;Arch&amp;gt;.txt 中找到。如有更改 Link Map 文件路径的需求也可以在「Path to Link Map File」中更改。
举个例子，我的 DemoiOS 项目（Obj-C）中 Link Map 文件的完整路径为：/Users/kingcos/Library/Developer/Xcode/DerivedData/DemoiOS-hifhuapijabsaxgpelrpiwhbzlqv/Build/Intermediates.noindex/DemoiOS.build/Debug-iphonesimulator/DemoiOS.build/DemoiOS-LinkMap-normal-x86_64.txt。
How 下面来分析一下 Link Map 文件的构成。
Path # Path: /Users/kingcos/Library/Developer/Xcode/DerivedData/DemoiOS-hifhuapijabsaxgpelrpiwhbzlqv/Build/Products/Debug-iphonesimulator/DemoiOS.</description>
    </item>
    
    <item>
      <title>Obj-C 中成员变量和类的访问控制</title>
      <link>/posts/2019/ivar_access_control_in_obj-c/</link>
      <pubDate>Sat, 30 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/ivar_access_control_in_obj-c/</guid>
      <description>Date Notes     2019-03-30 gcc, clang; macOS 10.14.2   2019-04-29 完善 @package    Preface Obj-C 中的成员变量，即 Instance Variables，简称为 ivar。在面向对象的概念中，一个类的对外暴露决定了其所提供的能力，对子类则需要提供一定的扩展性，但有些时候我们不希望外界甚至子类知道一些细节，这时就用到了访问控制（Access Control）。在 C++、Java、Swift 等大多数高级语言中都有这样的概念，这次就来谈谈 Obj-C 中成员变量和类的访问控制。
访问控制修饰符 @public @interface Computer : NSObject { @public NSString *_name; } @end @implementation Computer @end Computer *cpt = [[Computer alloc] init]; cpt-&amp;gt;_name = @&amp;quot;My PC&amp;quot;; NSLog(@&amp;quot;%@&amp;quot;, cpt-&amp;gt;_name); // OUTPUT: // My PC  声明为 @public 的成员变量是访问控制中开放范围最大的，其允许外界可以直接访问到（当然，前提是引入包含该类的头文件）。需要注意的是，在类声明中的属性（@property），系统会自动为我们创建一个 _ 开头的成员变量，这个成员变量的可见程度也默认 @public。</description>
    </item>
    
    <item>
      <title>iOS 中的 KVC</title>
      <link>/posts/2019/kvc_in_ios/</link>
      <pubDate>Mon, 25 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/kvc_in_ios/</guid>
      <description>Date Notes     2019-03-25 首次提交    Preface KVC，即 Key-Value Coding，译作键值编码（下文简称 KVC）。当对象兼容 KVC 时，可以通过统一的 API 访问对象中某个键对应的属性值。Cocoa 中的许多功能都依赖 KVC，比如，KVO、Cocoa 绑定机制、Core Data、以及 AppleScript 等。本文将主要探讨 KVC 及其本质相关，关于其它的内容可参考文末的「Reference」。
Basics How #import &amp;lt;Foundation/Foundation.h&amp;gt; @interface Speaker : NSObject @property (nonatomic) int volume; @end @implementation Speaker @end @interface Computer : NSObject @property (nonatomic) NSString *name; @property (nonatomic) NSArray *speakers; @end @implementation Computer @end int main(int argc, const char * argv[]) { @autoreleasepool { Computer *cpt = [[Computer alloc] init]; // ➡️ 通过 setter 设置 [cpt setName:@&amp;quot;My Mac 1&amp;quot;]; // ➡️ 通过 getter 读取 NSLog(@&amp;quot;name from getter - %@&amp;quot;, [cpt name]); // ➡️ 通过 setValue:forKey: 设置 [cpt setValue:@&amp;quot;My Mac 2&amp;quot; forKey:@&amp;quot;name&amp;quot;]; // ➡️ 通过 valueForKey: 读取 NSLog(@&amp;quot;name from KVC - %@&amp;quot;, [cpt valueForKey:@&amp;quot;name&amp;quot;]); Speaker *s1 = [[Speaker alloc] init]; s1.</description>
    </item>
    
    <item>
      <title>Obj-C 中的重载与重写</title>
      <link>/posts/2019/override_and_overload_in_obj-c/</link>
      <pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/override_and_overload_in_obj-c/</guid>
      <description>Date Platform     2019-03-20 macOS 10.14.2    Preface 重载（Overload）和重写（Override）是面向对象语言中十分基本的两个概念，本文将谈谈 Obj-C 中的重载与重写。
重载  In some programming languages, function overloading or method overloading is the ability to create multiple functions of the same name with different implementations. Calls to an overloaded function will run a specific implementation of that function appropriate to the context of the call, allowing one function call to perform different tasks depending on context.</description>
    </item>
    
    <item>
      <title>Obj-C 中的对象</title>
      <link>/posts/2019/objects_in_obj-c/</link>
      <pubDate>Mon, 18 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/objects_in_obj-c/</guid>
      <description>Date Notes Source Code     2019-03-18 首次提交 objc4-750    对象的分类 Obj-C 中的对象，主要有三种，实例对象（Instance Object）、类对象（Class Object）、以及元类对象（Meta-class Object）。类对象和元类对象的类型均为 Class，即 typedef struct objc_class *Class;，所以它们的结构其实是一致的，只是存放的内容不同。
定义一个继承自 NSObject 的 Computer 类，方便后续的 Demo。
// EDdeviceProtocol 协议 @protocol EDdeviceProtocol - (void)powerOn; @end // Computer 类，继承自 NSObject，遵守 EDdeviceProtocol @interface Computer : NSObject &amp;lt;EDdeviceProtocol&amp;gt; { // 成员变量 @public int _memorySize; int _diskSize; } // 属性 @property (copy) NSString *model; // 实例方法 - (void)print:(NSString *)content; // 类方法 + (NSString *)arch; @end @implementation Computer - (void)print:(NSString *)content { NSLog(@&amp;quot;Print Content: %@&amp;quot;, content); } // 协议方法 - (void)powerOn { NSLog(@&amp;quot;Start.</description>
    </item>
    
    <item>
      <title>iOS 中的 KVO</title>
      <link>/posts/2019/kvo_in_ios/</link>
      <pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/kvo_in_ios/</guid>
      <description>Date Notes     2019-03-13 首次提交    Preface KVO 即 Key-Value Observing，译作键值监听（下文简称 KVO），通常用于监听对象的某个特定属性值的变化。本文将由浅入深，谈谈 iOS 中的 KVO。
How #import &amp;quot;ViewController.h&amp;quot; @interface Computer : NSObject @property (nonatomic, assign) int buttonClickTimes; @end @implementation Computer @end @interface ViewController () @property (nonatomic, strong) Computer *cpt; @end @implementation ViewController - (Computer *)cpt { if (!_cpt) { _cpt = [[Computer alloc] init]; // ➡️ 为 cpt 属性的键路径 buttonClickTimes 增加监听者 self（该控制器） // options 决定监听者将同时接收到新值和旧值 // context 决定附带的上下文信息「ViewController-buttonClickTimes」。 [_cpt addObserver:self forKeyPath:@&amp;quot;buttonClickTimes&amp;quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@&amp;quot;ViewController-buttonClickTimes&amp;quot;]; } return _cpt; } - (void)dealloc { // ➡️ 在监听者销毁前将其移除 [self.</description>
    </item>
    
    <item>
      <title>iOS 中的 NSObject</title>
      <link>/posts/2019/nsobject_in_ios/</link>
      <pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/nsobject_in_ios/</guid>
      <description>Date Notes Source Code     2019-03-13 首次提交 objc4-750、libmalloc-166.220.1、glibc-2.29    NSObject 实例对象的大小 // NSObject Obj-C -&amp;gt; C NSObject_IMPL struct NSObject_IMPL { Class isa; }; // 指向 objc_class 结构体的指针 typedef struct objc_class *Class;  将 Obj-C 源码通过 clang -rewrite-objc 翻译为 C++（其实大部分为 C），可以发现 Obj-C 中的 NSObject 类其实就是 C 中的 NSObject_IMPL 结构体，其中只有一个成员变量，即 isa。isa 的类型是 Class，本质是一个指向 objc_class 结构体的指针。在 64 位系统中，指针占用 8 个字节（Byte），即 NSObject 的实例对象大小应该为 8 个字节。我们也可以尝试用 C 语言中的 sizeof() 运算符来证明这一点：</description>
    </item>
    
    <item>
      <title>iOS 多线程技术实践之 pthreads</title>
      <link>/posts/2019/multithread_techs_in_ios-1/</link>
      <pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/multithread_techs_in_ios-1/</guid>
      <description>Date Notes Swift Xcode     2019-03-08 首次提交 4.2 10.1     在 iOS 中的多线程（Multithreading）技术通常有以下几种实现方式：pthreads、NSThread、GCD、NSOperation。首先，我们来一起看一看 pthreads。
 Preface  POSIX Threads, usually referred to as pthreads, is an execution model that exists independently from a language, as well as a parallel execution model. It allows a program to control multiple different flows of work that overlap in time. Each flow of work is referred to as a thread, and creation and control over these flows is achieved by making calls to the POSIX Threads API.</description>
    </item>
    
    <item>
      <title>Objective-C 与 Swift 桥接中的坑</title>
      <link>/posts/2019/obj-c_swift_bridge_tips/</link>
      <pubDate>Thu, 17 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/obj-c_swift_bridge_tips/</guid>
      <description>Date Notes     2019-01-17 添加「Optional 与 Nullability」
添加「NSNotificationName 与 Notification.Name」    Preface Objective-C 与 Swift 的混编是全面转向 Swift 中的必经之路，本篇即是这一过程中的踩坑「真实」记录。
Optional 与 Nullability  Swift 4.2  在大多数项目中，我们都是在中途决定转向 Swift，Swift 中比较核心且常见的概念便是 Optional，可选类型，而这与 Obj-C 中的概念不大相同。在 Swift 中使用 Obj-C 桥接的属性（特别是 Block）时，尤其要注意：Obj-C 默认属性将被转换为隐式解包类型（SomeClass!），而在 Swift 中这代表开发者要保证值不为 nil，编译器将不再提示。当属性是 Block 时，若直接调用了为 nil 的 Closure 时，将会出现崩溃。
   Obj-C Usage Swift     nullable 可空 SomeClass?   nonnull 不可空 SomeClass   null_unspecified 未指定是否可空（默认） SomeClass!</description>
    </item>
    
    <item>
      <title>浅谈 iOS 应用启动过程</title>
      <link>/posts/2017/ios_app_start_up/</link>
      <pubDate>Tue, 28 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/ios_app_start_up/</guid>
      <description>Date Notes Swift Xcode     2017-05-26 CS193p UIApplication 3.1 8.3.2   2017-03-28 首次提交 3.0 8.2.1    Preface 首先要感谢没故事的卓同学大大送的泊学会员，在泊学学了几节课，了解了很多不同角度的 iOS 开发知识。这篇文章就启发自其 iOS 101 中的一个纯手工的 Single View Application 一文。但本文将更加深入的叙述了启动过程，且实现均为 Swift 3.0。
本文对应的 Demo 可以在：https://github.com/kingcos/SingleViewAppManually-Demo 查看、下载。
Manually or Storyboard main.m in Objective-C Single View Application
#import &amp;lt;UIKit/UIKit.h&amp;gt; #import &amp;quot;AppDelegate.h&amp;quot; int main(int argc, char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } }   自从 Storyboard 诞生以来，关于纯代码、Xib、以及 Storyboard 的选择就在 iOS 开发圈中炸开了锅。这里不会探讨各种姿势的优劣，只是可能很多和我一样的初学者，从一开始就被 Storyboard 先入为主。加上方便灵活的拖控件，自然而然就可能没有机会去思考一个 iOS 应用是如何启动起来的。加上 Swift 的诞生，使得整个项目的初始结构得到了更大的简化（少了 main.</description>
    </item>
    
  </channel>
</rss>