<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Obj-C on iBlog</title>
    <link>/tags/obj-c/</link>
    <description>Recent content in Obj-C on iBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved by kingcos.me</copyright>
    <lastBuildDate>Tue, 02 Jun 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/obj-c/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Obj-C 中的 Boolean</title>
      <link>/posts/2020/booleans_in_objc/</link>
      <pubDate>Tue, 02 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/booleans_in_objc/</guid>
      <description>Preface Boolean，即布尔值，通常用来表明逻辑中的真或假。但在 Obj-C 中，我们似乎既可以使用 BOOL 又可以使用 bool，那么它们到底有何不同呢？
 ⚠️ 注意：
为了避免读者（和笔者）记混，这里简单说明下 #define 与 typedef 的异同：#define A B 意为将已存在的 B 定义为 A，A 与 B 等价；typedef C D 意为将已存在的 C 定义为 D，C 与 D 等价；后者通常用于类型定义。
 Boolean 与 boolean_t // usr/include - MacTypes.h  /******************************************************************************** Boolean types and values Boolean Mac OS historic type, sizeof(Boolean)==1 bool Defined in stdbool.h, ISO C/C++ standard type false Now defined in stdbool.h true Now defined in stdbool.</description>
    </item>
    
    <item>
      <title>Obj-C 中实例变量和类的访问控制</title>
      <link>/posts/2019/ivar_access_control_in_obj-c/</link>
      <pubDate>Fri, 17 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/ivar_access_control_in_obj-c/</guid>
      <description>Date Notes     2019-06-14 增加 man nm 截图   2019-04-29 完善 @package   2019-03-30 gcc, clang; macOS 10.14.2   2020-01-17 勘误，部分细节调整    Preface Obj-C 中的实例变量，即 Instance Variables，简称为 ivar。在面向对象的概念中，一个类的对外暴露决定了其所提供的能力，对子类则需要提供一定的扩展性，但有些时候我们不希望外界甚至子类知道一些细节，这时就用到了访问控制（Access Control）。在 C++、Java、Swift 等大多数高级语言中都有这样的概念，那么这次就来谈谈 Obj-C 中实例变量和类的访问控制。
访问控制修饰符 @public @interface Foo : NSObject { @public NSString *_ivar; } @end @implementation Foo @end int main(int argc, char * argv[]) { Foo *f = [[Foo alloc] init]; f-&amp;gt;_ivar = @&amp;#34;kingcos.</description>
    </item>
    
    <item>
      <title>MustOverride 源码解读</title>
      <link>/posts/2019/dive_into_mustoverride/</link>
      <pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/dive_into_mustoverride/</guid>
      <description>Date Notes Source Code Commit / Tag     2019-12-07 首次提交 nicklockwood/MustOverride c63007e / 1.1   2020-01-05 增加 Extension 一节 - -    Preface MustOverride 是 nicklockwood 多年前开源的一个 Obj-C 库。其作用正如其名「MustOverride」即可以使得子类必须重写父类中的某些方法，防止子类因未实现父类的某些方法而出现不可预知的错误。
How 这个库的使用非常简单，如果是 CocoaPods 管理依赖的项目，直接通过 pod &#39;MustOverride&#39; 即可引入；之后引入 MustOverride.h 头文件并在需要必须子类重写的父类（或父类的分类）方法中放入 SUBCLASS_MUST_OVERRIDE; 宏即可：
// Foo.m  #import &amp;#34;Foo.h&amp;#34; #import &amp;#34;MustOverride.h&amp;#34;  @implementation Foo - (void)foo { SUBCLASS_MUST_OVERRIDE; } @end // Foo+Ext.m  #import &amp;#34;Foo+Ext.h&amp;#34; #import &amp;#34;MustOverride.</description>
    </item>
    
    <item>
      <title>Obj-C 中的对象</title>
      <link>/posts/2019/objects_in_obj-c/</link>
      <pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/objects_in_obj-c/</guid>
      <description>Date Notes Refer.     2019-03-18 首次提交 objc4-750   2019-08-18 抽离 isa 部分；
重整文章结构 Obj-C 中的 isa 指针 - kingcos   2019-08-29 增加 class_rw_t 等细节 -   2019-12-23 细节微调 objc4-756.2    Preface Obj-C 中的对象分为实例对象（Instance Object）、类对象（Class Object）、以及元类对象（Meta-class Object）三种，本文将借助源码简单了解一下不同类型对象的真实构造。
为了方便下文举例，这里我们定义一个 EDdeviceProtocol 协议，并让继承自 NSObject 的 Computer 类遵守该协议：
// EDdeviceProtocol 协议 @protocol EDdeviceProtocol - (void)powerOn; @end // Computer 类，继承自 NSObject，遵守 EDdeviceProtocol @interface Computer : NSObject &amp;lt;EDdeviceProtocol&amp;gt; { // 成员变量 @public int _memorySize; int _diskSize; } // 属性 @property (copy) NSString *model; // 实例方法 - (void)print:(NSString *)content; // 类方法 + (NSString *)arch; @end @implementation Computer - (void)print:(NSString *)content { NSLog(@&amp;#34;Print content: %@.</description>
    </item>
    
    <item>
      <title>iOS 多线程技术实践之 pthreads（一）</title>
      <link>/posts/2019/multithreading_techs_in_ios-1/</link>
      <pubDate>Sat, 14 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/multithreading_techs_in_ios-1/</guid>
      <description>Date Notes Swift Xcode     2019-03-08 首次提交 4.2 10.1   2019-12-14 内容重整 5.1 10.3    Preface 在现代计算机中，操作系统一般都会支持多进程（Process）以及多线程（Thread）技术，使得其可以同时运行多个程序且效率更高。而我们在开发 iOS app 中也时常需要利用到这些特性，以为用户提供更加良好的使用体验。通常来说，一个 iOS app 为一个进程，其中又至少有一个线程，即主线程；前者进程由操作系统创建我们很难干预，而线程则「自由」许多，可以为我们所用。由于多线程技术内容较多，我将把相关内容进行拆分，本文作为该系列第一篇，先从 pthreads 说起。
What  POSIX Threads, usually referred to as pthreads, is an execution model that exists independently from a language, as well as a parallel execution model. It allows a program to control multiple different flows of work that overlap in time.</description>
    </item>
    
    <item>
      <title>将 Obj-C 代码翻译为 C/C&#43;&#43; 代码</title>
      <link>/posts/2019/obj-c_to_c&#43;&#43;/</link>
      <pubDate>Sat, 30 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/obj-c_to_c&#43;&#43;/</guid>
      <description>Date Notes     2019-05-17 首次提交   2019-06-15 增加常用参数列表   2019-11-30 细节补充    Solution ➜ ~ clang --version Apple LLVM version 10.0.0 (clang-1000.11.45.5) Target: x86_64-apple-darwin18.2.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin Xcode 中，C/C++/Obj-C/C++ 的编译器是 clang，其通过 -rewrite-objc 参数可以将 Obj-C 代码翻译为 C++ 代码，即 clang -rewrite-objc main.m -o main.cpp；也可以结合 xcrun -sdk 命令设置编译所基于的 SDK。
   Options Usage     -arch arm64 指定编译架构   -framework UIKit 依赖 UIKit 框架   -fobjc-arc 使用 ARC（自动引用计数）模式   -fnoobjc-arc 使用 MRC（手动引用计数）模式   -fobjc-runtime=ios-12.</description>
    </item>
    
    <item>
      <title>Obj-C 中的 Block</title>
      <link>/posts/2019/block_in_obj-c/</link>
      <pubDate>Sun, 24 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/block_in_obj-c/</guid>
      <description>Date Notes Demo Source Code     2019-07-27 首次提交 - -   2019-11-24 重新整理部分内容；补充《Effective Objective-C 2.0》&amp;amp;《Objective-C 高级编程》相关内容 Block_in_Obj-C objc4-756.2、libclosure-73    Preface 从 OS X Snow Leopard 和 iOS 4 开始，Apple 引入了 Block 的概念。Obj-C 中的 Block 即通常意义上的匿名函数，而之所以引入是因为 C 语言中并不支持匿名函数。这使得 Block 在 Obj-C 中可以称为是一类公民（First-Class Citizen），既可以作为类的属性，也可以作为函数参数或返回值来传递。那么本文就将着眼于此，谈谈 Obj-C 中的 Block。
Prerequisites 匿名函数与 Block 匿名函数顾名思义，即不带名称的函数，而 C 语言中即使是函数指针也仍然需要通过函数名来获得其地址：
// C 语言函数 int cFunc(int arg) { return arg; } int main_1(int argc, const char * argv[]) { int result1 = cFunc(10); // C 语言中的函数指针需要通过函数名来获得其地址  int (*cFuncPtr)(int) = &amp;amp;cFunc; int result2 = (*cFuncPtr)(10); printf(&amp;#34;result1 = %d, result2 = %d\n&amp;#34;, result1, result2); return 0; } // OUTPUT: // result1 = 10, result2 = 10 Obj-C 中的匿名函数被称为 Block，中文有译作块、闭包（Closure），其实很多语言都有类似的机制，比如 Swift 中的 Closure，Java / Python / C++ 11 中的 Lambda（λ）表达式，JavaScript 中的匿名函数等。</description>
    </item>
    
    <item>
      <title>《编写高质量 iOS 与 OS X 代码的 52 个有效方法》阅读笔记</title>
      <link>/posts/2019/effective_obj-c_2.0_notes/</link>
      <pubDate>Sun, 24 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/effective_obj-c_2.0_notes/</guid>
      <description>Book ISBN Notes     《编写高质量 iOS 与 OS X 代码的 52 个有效方法》 9787111451297 《Effective Objective-C 2.0》   Date Num. Xcode   2019-05 1-3 10.2.1   2019-06 4 10.2.1   2019-07 5-12 10.2.1   2019-10 13-20 11.1 &amp;amp; 11.2   2019-11 20-52 11.1 &amp;amp; 11.2    Preface 《编写高质量 iOS 与 OS X 代码的 52 个有效方法》原著名为《Effective Objective-C 2.0》，是类似笔者这样的 iOS 初级入门者必读书目之一。本文不仅是此书的阅读笔记，也有 Demo 代码等，较为独立的篇章内容则融入笔者以往的独立文章中。</description>
    </item>
    
    <item>
      <title>iOS 中的库与框架</title>
      <link>/posts/2019/libraries_in_ios/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/libraries_in_ios/</guid>
      <description>Date Notes     2019-09-14 首次提交，持续更新完善   2019-09-22 适配 Xcode 11，持续更新完善   2019-10-29 添加 Demo：libraries_in_ios-demo    Preface 随着软件工程的发展，很多我们需要的功能前人都已经很好地实现了，为了提高效率避免重复建设，这些功能实现的代码被封装为代码库，有时也称框架。我们只需要在用到的时候通过依赖管理工具将它们以适当的方式引入即可。本文将简单聊聊 iOS 中的库与框架相关概念。
基本概念 在切入正题之前，我们先来达成一些共识。
不管是老派 Obj-C 还是新秀 Swift，它们的本质都是编译型语言。对于编译型语言，源代码会首先经由编译器编译为目标文件，链接器再将多个目标文件链接为可执行文件。针对链接阶段，主要分为静态链接与动态链接。
静态，即 Static。按照字面意思，静态即一旦确定，就不再容易改变。静态链接，即在链接阶段，直接将多个目标文件链接为一个文件。而静态库就可以理解为共同编译为一个目标文件的源代码集合。
动态，即 Dynamic。按照字面意思，动态即推迟到运行时动态地决议。动态链接，即在运行时才将各个部分组合形成完整的程序。而动态库就可以理解为支持动态链接方式的源代码集合。
静态链接的好处是，运行时不再额外需要时间动态链接；坏处则是由于链接的粒度是目标文件，那么可能会链接了没有使用到的函数，会造成可执行文件过大；而且当某一个目标文件的源代码改动时，那么所有依赖该目标文件的静态库都需要重新编译；动态链接则解决了静态链接的空间浪费与重复编译问题，比如在 iOS 中，系统库采用了 dyld_shared_cache 动态链接，这样其它程序就无需再将系统库重复链接，当 iOS 系统更新时也无需将所有 app 重新编译。而在移动端开发中，app 的启动时间与包体积大小将是一个权衡问题，值得我们侧重与考量。
另外，虽然广义上的库（Library）与框架（Framework）含义是类似的，但在 iOS 开发中，官方将这两个概念进行了区分，因此下文中我们会明确两个词的使用。
Cocoa Touch Static Library 我们先从 Xcode 中能够直接创建的 Cocoa Touch Static Library 说起（注意，在 Xcode 11 中，这里已经变成 Framework 与 Library，更加清晰）：</description>
    </item>
    
    <item>
      <title>iOS 中的 Category</title>
      <link>/posts/2019/category_in_ios/</link>
      <pubDate>Wed, 23 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/category_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-04-16 优化结构 - -   2019-04-13 首次提交 objc4-750、xnu-4903.221.2 Category in iOS   2019-10-23 添加首图，细节微调 - -    Preface iOS 中的 Category 中文常译作分类、类别（为表述统一，本文将使用 Category 特指该技术）。我们经常会使用 Category 来对一个类进行扩展，使得在不破坏主类结构的同时可以具备更多的功能；也可以使用 Category 对一个类进行拆分，使得其结构更加清晰条理。本文将从 What - How - Why 谈谈 iOS 中 Category。
What 什么是 Category 呢？
Category 是 Obj-C 语言中所提供的一项功能，它可以为 Obj-C 类添加额外的属性、方法，也可以遵守其他协议。
Xcode 中已经为 Category 已经提供了模版来建立，只需要指定 Category 的名称以及被添加 Category 类名即可。当然，我们也可以手动来自己建立，Category 的语法与类的声明与实现比较类似：</description>
    </item>
    
    <item>
      <title>浅尝 objc_msgSend</title>
      <link>/posts/2019/objc_msgsend/</link>
      <pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/objc_msgsend/</guid>
      <description>Date Notes Refers.     2019-07-20 首次提交 objc4-750.1   2019-09-07 完成「缓存、动态方法解析」等部分 Obj-C 中的对象 - kingcos   2019-10-21 补充《Effective Objective-C 2.0》相关内容 《〈编写高质量 iOS 与 OS X 代码的 52 个有效方法〉阅读笔记 - kingcos》    Preface Obj-C 中方法调用的本质是消息发送机制，即 [foo bar] 是向 foo 对象发送一条 bar 的消息，而消息发送就是通过 objc_msgSend 所进行的。那么这次本文就简单窥探一下 objc_msgSend 吧。
Why 在开始之前，先思考以下为什么 Obj-C 中方法调用的本质是 objc_msgSend 呢？
我们创建一个使用 Obj-C 的 iOS 项目，如下在 ViewController 中添加一个按钮，并在按钮的点击事件中创建一个 Obj-C 对象，再调用其方法：
#import &amp;#34;ViewController.</description>
    </item>
    
    <item>
      <title>iOS 中的 &#43;load 方法</title>
      <link>/posts/2019/&#43;load_in_ios/</link>
      <pubDate>Fri, 13 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/&#43;load_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-04-20 首次提交 objc4-750 Load_Obj-C_Demo   2019-09-13 增加 Swift 等部分 - -    Preface 在 iOS 开发中，我们经常会使用 +load 方法来做一些在 main 函数之前的操作，比如方法交换（Method Swizzle）等。那么本文就来简单了解下 iOS 中 +load 方法。
What iOS 中的 +load 方法指的是 NSObject 中的 + (void)load 类方法：
// NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { + (void)load; } 官方文档中的 +load 如下：
 Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</description>
    </item>
    
    <item>
      <title>Obj-C 中的 isa 指针</title>
      <link>/posts/2019/isa_in_objc/</link>
      <pubDate>Sun, 18 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/isa_in_objc/</guid>
      <description>Date Notes Refer.     2019-08-18 首次提交 objc4-750.1    Preface isa 指针是所有 Obj-C 对象中都拥有的一个成员。因为除了继承链之外，Obj-C 还特有一条从实例对象到类对象、元类对象的链。而后者正是依靠 isa 而串联起来的，那么本文就将结合源码谈谈 Obj-C 中的 isa。
对于不大熟悉 Obj-C 中对象的同学，可以先行阅读 Obj-C 中的对象一文。
Where // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { #pragma clang diagnostic push #pragma clang diagnostic ignored &amp;#34;-Wobjc-interface-ivars&amp;#34;  Class isa OBJC_ISA_AVAILABILITY; // ⬅️ #pragma clang diagnostic pop } // objc-runtime-new.h struct objc_class : objc_object { // Class ISA; } // objc-private.</description>
    </item>
    
    <item>
      <title>Xcode 中的 Link Map 文件</title>
      <link>/posts/2019/link_map_file_in_xcode/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/link_map_file_in_xcode/</guid>
      <description>Date Notes Xcode Swift     2019-04-01 首次提交 10.1 -   2019-04-16 增加 Swift 项目 10.1 4.2   2019-07-28 增加目录导图，折叠过长内容 - -    Preface Link Map File，译作链接映射文件（下文将称 Link Map 文件）。Xcode 在构建可执行文件之前，需要先编译为目标文件（Object File），并链接所需要的其他库，那么 Link Map 文件就记录了链接器（Linker）在链接过程中产生的一些信息，本文将谈谈这个文件的构成。
What Xcode 中默认是不会将 Link Map 文件在构建时暴露出来的，需要我们手动在「Build Settings」-「Write Link Map File」-「Yes」打开该写入该文件的设置。这样当我们再次编译项目，默认就可以在 ~/Library/Developer/Xcode/DerivedData/&amp;lt;TARGET_NAME&amp;gt;-&amp;lt;Random_ID&amp;gt;/Build/Intermediates.noindex/&amp;lt;TARGET_NAME&amp;gt;.build/Debug-&amp;lt;Device_Type&amp;gt;/&amp;lt;TARGET_NAME&amp;gt;.build/&amp;lt;TARGET_NAME&amp;gt;-LinkMap-normal-&amp;lt;Arch&amp;gt;.txt 中找到。如有更改 Link Map 文件路径的需求也可以在「Path to Link Map File」中更改。
举个例子，我的 DemoiOS 项目（Obj-C）中 Link Map 文件的完整路径为：/Users/kingcos/Library/Developer/Xcode/DerivedData/DemoiOS-hifhuapijabsaxgpelrpiwhbzlqv/Build/Intermediates.noindex/DemoiOS.build/Debug-iphonesimulator/DemoiOS.build/DemoiOS-LinkMap-normal-x86_64.txt。
How 下面来分析一下 Link Map 文件的构成。</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43; 中的 const、static &amp; extern</title>
      <link>/posts/2019/const_static_extern_in_cpp/</link>
      <pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/const_static_extern_in_cpp/</guid>
      <description>Date Notes Env     2019-07-23 首次提交 clang++、macOS 10.14.4    Preface const、static &amp;amp; extern 是 C/C++ 中的关键字，而在 iOS 开发中的 Obj-C/C++ 又是 C/C++ 的超集，那么本篇就简单梳理一下这些关键字的作用。
const 基础类型 int a = 0; a = 10; 对于基础类型，其在内存中存储的即是该类型的变量本身，经过 const 修饰后，此处的变量不可变，即常量。const 的位置并不会影响其作用，更为推荐的写法应当是编译器提示的 const &amp;lt;TYPE&amp;gt;。
以下是在 C/C++ 中的用例，由于 Obj-C/C++ 分别是 C/C++ 的超集，对于 C/C++ 的基础类型，其在 Obj-C/C++ 中的表现是一致的：
const int b = 0; // error: cannot assign to variable &amp;#39;b&amp;#39; with const-qualified type &amp;#39;const int&amp;#39; // b = 10;  int const c = 0; // c = 10; 对于 Obj-C 中特有的基础类型，const 也与修饰 C/C++ 中基础类型的行为一致：</description>
    </item>
    
    <item>
      <title>iOS 中的关联对象</title>
      <link>/posts/2019/associated_objects_in_ios/</link>
      <pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/associated_objects_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-05-18 首次提交 objc4-750 -    Preface 提到 iOS 中的关联对象，即 Associated Objects，又可以算是一项利用 Runtime 的「黑魔法」。然而作为初学者，很难从其名称联想到是为谁关联对象，以及是如何关联对象的，那么今天就来一起研究下 iOS 中的关联对象是什么、怎么用、以及为什么。
What 虽然这部分的官方文档已经「年久失修」，不过我们仍然简单看一下官方的概括：
 Associative References
Associative references, available starting in OS X v10.6, simulate the addition of object instance variables to an existing class. Using associative references, you can add storage to an object without modifying the class declaration. This may be useful if you do not have access to the source code for the class, or if for binary-compatibility reasons you cannot alter the layout of the object.</description>
    </item>
    
    <item>
      <title>[译] 在 Objective-C API 中指定可空性</title>
      <link>/posts/2019/nullability_in_obj-c/</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/nullability_in_obj-c/</guid>
      <description>作者 原文链接     Apple Inc. Designating Nullability in Objective-C APIs    使用可空性（Nullability）标志或标志一块区域，以控制将 Objective-C 声明导入 Swift 中的方式。
 框架：  Swift 标准库     概览 在 Objective-C 中，常用可以为空的指针来和对象的引用打交道，这（个空）就是 Objective-C 中的 nil。在 Swift 中，所有值——包括对象实例——都被确保为非空（Non-null）。取而代之，表示一个可能丢失的值可以将其包裹在可选（Optional）类型中。当我们需要表示一个值的丢失，可以使用 nil 值。
我们可以在 Objective-C 的代码中标示声明，以指示一个实例是否可以有空（Null）或 nil 值。这些标志改变了 Swift 如何导入声明（的方式）。举个 Swift 如何导入未标示声明的例子，如下：
@interface MyList : NSObject - (MyListItem *)itemWithName:(NSString *)name; - (NSString *)nameForItem:(MyListItem *)item; @property (copy) NSArray&amp;lt;MyListItem *&amp;gt; *allItems; @end Swift 导入了每个对象实例的参数、返回值、以及作为隐式包裹可选的属性（译者注：隐式包裹即 Type!</description>
    </item>
    
    <item>
      <title>Swift/Obj-C 混编项目升级 Swift 5.0 踩坑</title>
      <link>/posts/2019/swift_4_to_5/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/swift_4_to_5/</guid>
      <description>Date Note     2019-05-08 Swift 4.2 -&amp;gt; 5.0   2019-07-08 完善内容    Preface 在 ABI 稳定前，每次 Swift 升级都是一个比较「痛苦」的体验。这次笔者花费约总共一天时间将 Swift/Obj-C 混编项目升级到 Swift 5.0，其中还是有一些踩坑经验值得分享的。
Xcode 为了适配 Swift 5.0，首先需要安装 Xcode 10.2。而我们不能完全抛弃 Xcode 10.1，毕竟在未完全转换到 Swift 5.0 的过渡阶段仍然需要使用。因此我们可以将本地的 Xcode 更名为 Xcode-10.1，再在 https://developer.apple.com/download/more/ 检索 Xcode 下载 10.2 版本即可。
 ⚠️ 注意：为了防止类似 XcodeGhost 事件再次发生，建议从该官方渠道或 App Store 直接下载。
 为了便于区分，我们将新的 Xcode 命名为 Xcode-10.2，并打开、同意安装 Xcode Command Line Tools。由于我们目前安装了两个 Xcode，如果需要命令行执行 swift 或 xcodebuild 等命令，可以使用 xcode-select 来进行切换不同版本。</description>
    </item>
    
    <item>
      <title>iOS 中的 &#43;initialize 方法</title>
      <link>/posts/2019/&#43;initialize_in_ios/</link>
      <pubDate>Sun, 21 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/&#43;initialize_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-04-21 首次提交 objc4-750 -   2019-05-01 补充细节 - Initialize_Demo    Preface 在 iOS 中，经常与 +load 相提并论的一个方法便是 +initialize。从方法名来看，它的作用是进行初始化，但不同于平时使用的 init，+initialize 是一个类方法。那么它的本质到底是什么呢？
为了更好地叙述 +initialize 的特点，本文部分描述尝试与 +load 方法对比，建议阅读本文前先阅读「iOS 中的 +load 方法」。
What // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { + (void)initialize; } Obj-C 中的 +initialize 方法指的是 NSObject 中的 + (void)initialize 类方法。官方文档中的 +initialize 如下：
 Initializes the class before it receives its first message.</description>
    </item>
    
    <item>
      <title>Obj-C &amp; Swift 的类型内省与反射</title>
      <link>/posts/2019/type_introspection_and_reflection/</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/type_introspection_and_reflection/</guid>
      <description>Date Notes Swift Demo     2019-04-08 首次提交 4.2 Type Introspection and Reflection    Preface 许多编程语言中都有类型内省（又称自省，Introspection）和反射（Reflection）这两个概念，本文将探讨一下 Obj-C 和 Swift 中类型内省和反射的相关概念与具体使用。
What 维基百科中对于类型内省定义如下：
 In computing, type introspection is the ability of a program to examine the type or properties of an object at runtime. Some programming languages possess this capability.
Introspection should not be confused with reflection, which goes a step further and is the ability for a program to manipulate the values, meta-data, properties and/or functions of an object at runtime.</description>
    </item>
    
    <item>
      <title>iOS 中的 KVC</title>
      <link>/posts/2019/kvc_in_ios/</link>
      <pubDate>Mon, 25 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/kvc_in_ios/</guid>
      <description>Date Notes     2019-03-25 首次提交    Preface KVC，即 Key-Value Coding，译作键值编码（下文简称 KVC）。当对象兼容 KVC 时，可以通过统一的 API 访问对象中某个键对应的属性值。Cocoa 中的许多功能都依赖 KVC，比如，KVO、Cocoa 绑定机制、Core Data、以及 AppleScript 等。本文将主要探讨 KVC 及其本质相关，关于其它的内容可参考文末的「Reference」。
Basics How #import &amp;lt;Foundation/Foundation.h&amp;gt;  @interface Speaker : NSObject @property (nonatomic) int volume; @end @implementation Speaker @end @interface Computer : NSObject @property (nonatomic) NSString *name; @property (nonatomic) NSArray *speakers; @end @implementation Computer @end int main(int argc, const char * argv[]) { @autoreleasepool { Computer *cpt = [[Computer alloc] init]; // ➡️ 通过 setter 设置  [cpt setName:@&amp;#34;My Mac 1&amp;#34;]; // ➡️ 通过 getter 读取  NSLog(@&amp;#34;name from getter - %@&amp;#34;, [cpt name]); // ➡️ 通过 setValue:forKey: 设置  [cpt setValue:@&amp;#34;My Mac 2&amp;#34; forKey:@&amp;#34;name&amp;#34;]; // ➡️ 通过 valueForKey: 读取  NSLog(@&amp;#34;name from KVC - %@&amp;#34;, [cpt valueForKey:@&amp;#34;name&amp;#34;]); Speaker *s1 = [[Speaker alloc] init]; s1.</description>
    </item>
    
    <item>
      <title>Obj-C 中的重载与重写</title>
      <link>/posts/2019/override_and_overload_in_obj-c/</link>
      <pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/override_and_overload_in_obj-c/</guid>
      <description>Date Platform     2019-03-20 macOS 10.14.2    Preface 重载（Overload）和重写（Override）是面向对象语言中十分基本的两个概念，本文将谈谈 Obj-C 中的重载与重写。
重载  In some programming languages, function overloading or method overloading is the ability to create multiple functions of the same name with different implementations. Calls to an overloaded function will run a specific implementation of that function appropriate to the context of the call, allowing one function call to perform different tasks depending on context.</description>
    </item>
    
    <item>
      <title>iOS 中的 KVO</title>
      <link>/posts/2019/kvo_in_ios/</link>
      <pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/kvo_in_ios/</guid>
      <description>Date Notes     2019-03-13 首次提交    Preface KVO 即 Key-Value Observing，译作键值监听（下文简称 KVO），通常用于监听对象的某个特定属性值的变化。本文将由浅入深，谈谈 iOS 中的 KVO。
How #import &amp;#34;ViewController.h&amp;#34;  @interface Computer : NSObject @property (nonatomic, assign) int buttonClickTimes; @end @implementation Computer @end @interface ViewController () @property (nonatomic, strong) Computer *cpt; @end @implementation ViewController - (Computer *)cpt { if (!_cpt) { _cpt = [[Computer alloc] init]; // ➡️ 为 cpt 属性的键路径 buttonClickTimes 增加监听者 self（该控制器）  // options 决定监听者将同时接收到新值和旧值  // context 决定附带的上下文信息「ViewController-buttonClickTimes」。  [_cpt addObserver:self forKeyPath:@&amp;#34;buttonClickTimes&amp;#34; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@&amp;#34;ViewController-buttonClickTimes&amp;#34;]; } return _cpt; } - (void)dealloc { // ➡️ 在监听者销毁前将其移除  [self.</description>
    </item>
    
    <item>
      <title>iOS 中的 NSObject</title>
      <link>/posts/2019/nsobject_in_ios/</link>
      <pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/nsobject_in_ios/</guid>
      <description>Date Notes Source Code     2019-03-13 首次提交 objc4-750、libmalloc-166.220.1、glibc-2.29    NSObject 实例对象的大小 // NSObject Obj-C -&amp;gt; C NSObject_IMPL struct NSObject_IMPL { Class isa; }; // 指向 objc_class 结构体的指针 typedef struct objc_class *Class; 将 Obj-C 源码通过 clang -rewrite-objc 翻译为 C++（其实大部分为 C），可以发现 Obj-C 中的 NSObject 类其实就是 C 中的 NSObject_IMPL 结构体，其中只有一个成员变量，即 isa。isa 的类型是 Class，本质是一个指向 objc_class 结构体的指针。在 64 位系统中，指针占用 8 个字节（Byte），即 NSObject 的实例对象大小应该为 8 个字节。我们也可以尝试用 C 语言中的 sizeof() 运算符来证明这一点：</description>
    </item>
    
    <item>
      <title>Objective-C 与 Swift 桥接中的坑</title>
      <link>/posts/2019/obj-c_swift_bridge_tips/</link>
      <pubDate>Thu, 17 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/obj-c_swift_bridge_tips/</guid>
      <description>Date Notes     2019-01-17 添加「Optional 与 Nullability」
添加「NSNotificationName 与 Notification.Name」    Preface Objective-C 与 Swift 的混编是全面转向 Swift 中的必经之路，本篇即是这一过程中的踩坑「真实」记录。
Optional 与 Nullability  Swift 4.2  在大多数项目中，我们都是在中途决定转向 Swift，Swift 中比较核心且常见的概念便是 Optional，可选类型，而这与 Obj-C 中的概念不大相同。在 Swift 中使用 Obj-C 桥接的属性（特别是 Block）时，尤其要注意：Obj-C 默认属性将被转换为隐式解包类型（SomeClass!），而在 Swift 中这代表开发者要保证值不为 nil，编译器将不再提示。当属性是 Block 时，若直接调用了为 nil 的 Closure 时，将会出现崩溃。
   Obj-C Usage Swift     nullable 可空 SomeClass?   nonnull 不可空 SomeClass   null_unspecified 未指定是否可空（默认） SomeClass!</description>
    </item>
    
    <item>
      <title>浅谈 iOS 应用启动过程</title>
      <link>/posts/2017/ios_app_start_up/</link>
      <pubDate>Tue, 28 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/ios_app_start_up/</guid>
      <description>Date Notes Swift Xcode     2017-05-26 CS193p UIApplication 3.1 8.3.2   2017-03-28 首次提交 3.0 8.2.1    Preface 首先要感谢没故事的卓同学大大送的泊学会员，在泊学学了几节课，了解了很多不同角度的 iOS 开发知识。这篇文章就启发自其 iOS 101 中的一个纯手工的 Single View Application 一文。但本文将更加深入的叙述了启动过程，且实现均为 Swift 3.0。
本文对应的 Demo 可以在：https://github.com/kingcos/SingleViewAppManually-Demo 查看、下载。
Manually or Storyboard main.m in Objective-C Single View Application
#import &amp;lt;UIKit/UIKit.h&amp;gt; #import &amp;#34;AppDelegate.h&amp;#34;  int main(int argc, char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } }  自从 Storyboard 诞生以来，关于纯代码、Xib、以及 Storyboard 的选择就在 iOS 开发圈中炸开了锅。这里不会探讨各种姿势的优劣，只是可能很多和我一样的初学者，从一开始就被 Storyboard 先入为主。加上方便灵活的拖控件，自然而然就可能没有机会去思考一个 iOS 应用是如何启动起来的。加上 Swift 的诞生，使得整个项目的初始结构得到了更大的简化（少了 main.</description>
    </item>
    
  </channel>
</rss>