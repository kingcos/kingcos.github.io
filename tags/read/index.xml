<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Read on iBlog</title>
    <link>/tags/read/</link>
    <description>Recent content in Read on iBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved by kingcos.me</copyright>
    <lastBuildDate>Mon, 21 Oct 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/read/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>《编写高质量 iOS 与 OS X 代码的 52 个有效方法》阅读笔记</title>
      <link>/posts/2019/effective_obj-c_2.0_notes/</link>
      <pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/effective_obj-c_2.0_notes/</guid>
      <description>Book ISBN Notes     编写高质量 iOS 与 OS X 代码的 52 个有效方法 9787111451297 -   Date Num. Xcode   2019-05 1-3 10.2.1   2019-06 4 10.2.1   2019-07 5-12 10.2.1   2019-10 13 11.1    熟悉 Objective-C 了解 Objective-C 语言的起源  消息结构（Message Structure）的语言，运行时执行的代码由运行环境决定；函数调用（Function Calling）的语言，运行时所执行的代码由编译器决定，对于多态，则按照虚函数表（Virtual Method Table）寻找。 运行时组件（Runtime Component） 本质上是一种与开发者所编写代码相链接的「动态库（Dynamic Library），这样的好处是只需要更新运行时组件（无需重新编译）即可提升程序性能。 Obj-C 是 C 的超集。 Obj-C 中的对象所占内存总是分配在堆空间（Heap Stack）；而指向对象的指针所占内存总是分配在栈帧（Stack Frame）中。 堆中的内存需要程序员自己管理，栈中的内存会在其栈帧弹出（Pop）时自动清理。 创建对象相比创建结构体（C 结构体）需要额外开销，例如分配和释放堆内存等。  // ⚠️ 由于 Obj-C 中的字符串（NSString）略有特殊，此处并未使用书中的 NSString 作为范例 // 对象本身被分配在堆上；obj1 &amp;amp; obj2 被分配在栈上 NSObject *obj1 = [[NSObject alloc] init]; NSObject *obj2 = obj1; // (lldb) p obj1 // (NSObject *) $0 = 0x00000001005092b0 // (lldb) p obj2 // (NSObject *) $1 = 0x00000001005092b0 // (lldb) p &amp;amp;obj1 // (NSObject **) $2 = 0x00007ffeefbff508 // (lldb) p &amp;amp;obj2 // (NSObject **) $3 = 0x00007ffeefbff500  在类的头文件中尽量少引入其他头文件  当需要知道有一个类的存在时，而不关心其内部细节时，可以使用向前声明（Forward Declaring）告知编译器，即可以在 .</description>
    </item>
    
  </channel>
</rss>