<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Swift on iBlog</title>
    <link>/tags/swift/</link>
    <description>Recent content in Swift on iBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved by kingcos.me</copyright>
    <lastBuildDate>Sun, 23 Aug 2020 00:00:00 +0000</lastBuildDate><atom:link href="/tags/swift/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Swift 中的 @autoclosure</title>
      <link>/posts/2018/swift_autoclosure/</link>
      <pubDate>Sun, 23 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/swift_autoclosure/</guid>
      <description>Date Notes Swift Xcode Source Code     2020-08-23 完善排版与表述 5.1 11.3 -   2018-04-05 更新并明确源代码所用版本 4.1 9.3 Swift 4.1 Release   2018-01-13 首次提交 4.0.3 9.2 -    Preface Swift 中的闭包（Closure）十分类似于 Obj-C 中的 Block，但不仅写法更加简洁，也带来了许多新的特性。@autoclosure 即自动闭包属于类型属性（Type Attribute）的一种，意味着其可以对类型作出一些限定，那么本文就来简单介绍一下。
How 自动闭包 @autoclosure 名称中即明确了这是一种自动闭包，即可以让返回该参数类型变量自动转换为闭包。但其只可以修饰无参闭包 () -&amp;gt; T，否则将会报错：error: argument type of @autoclosure parameter must be &#39;()&#39;。
func logIfTrue(_ predicate: () -&amp;gt; Bool) { if predicate() { print(#function) } } // logIfTrue(predicate: () -&amp;gt; Bool) logIfTrue { 1 &amp;lt; 2 } func logIfTrueWithAutoclosure(_ predicate: @autoclosure () -&amp;gt; Bool) { if predicate() { print(#function) } } // logIfTrueWithAutoclosure(predicate: Bool) logIfTrueWithAutoclosure(1 &amp;lt; 2) // OUTPUT: // logIfTrue // logIfTrueWithAutoclosure 延迟调用 在 Swift 中，由于函数是第一类型，我们可以声明变量为函数类型：</description>
    </item>
    
    <item>
      <title>Swift 拾遗 - 闭包</title>
      <link>/posts/2020/swift_closure/</link>
      <pubDate>Sun, 23 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_closure/</guid>
      <description>Date Notes     2020-08-16 首次提交    Preface 《Swift 拾遗》是一个关于 Swift 的新文章专辑，这个系列的文章将不会涉及基本语法的层面，而是尝试从底层「拾」起之前所忽视的内容。今天我们将一起简单探究 Swift 中的闭包（Closure）。
闭包捕获 局部变量 我们将参数和返回值类型为 Int 的函数（也可称作闭包）(Int) -&amp;gt; Int 易名为 Closure，并定义一个函数返回该闭包类型：
// main.swift typealias Closure = (Int) -&amp;gt; Int func foo() -&amp;gt; Closure { var bar = 5 func baz(_ val: Int) -&amp;gt; Int { bar += val // BREAKPOINT 🔴 return bar } bar = 10 return baz // BREAKPOINT 🔴 } var f = foo() f(1) // 11 f(2) // 13 f(3) // 16 通过 f(n) 函数多次执行的结果，我们发现局部变量 bar 似乎在每次调用后并没有被销毁，原因其实是 baz 对 bar 进行了「捕获」，接下来我们将仔细研究这一过程。</description>
    </item>
    
    <item>
      <title>Swift 拾遗 - 汇编</title>
      <link>/posts/2020/swift_with_asm/</link>
      <pubDate>Mon, 10 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_with_asm/</guid>
      <description>Date Notes     2020-08-10 首次提交    Preface 《Swift 拾遗》是一个关于 Swift 的新文章专辑，这个系列的文章将不会涉及基本语法的层面，而是尝试从底层「拾」起之前所忽视的内容。本文涉及了各个部分关于汇编的内容。
struct &amp;amp; class struct 栈区 // main.swift struct Foo { var a: Int var b: Int } func bar() { var foo1 = Foo(a: 10, b: 11) // BREAKPOINT 🔴 var foo2 = foo1 foo2.a = 20 foo2.b = 22 } bar() 我们定义一个结构体 Foo，并在函数 bar 中声明和构造后赋值于 foo1，之后将 foo1 赋值给新变量 foo2；此时改变 foo2 中的值，由于结构体是值类型，因此对于 foo2 的改变将不会影响 foo1，我们尝试从汇编底层看一下这个过程：</description>
    </item>
    
    <item>
      <title>Swift 拾遗 - struct &amp; class</title>
      <link>/posts/2020/swift_struct_and_class/</link>
      <pubDate>Thu, 06 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_struct_and_class/</guid>
      <description>Date Notes     2020-08-06 首次提交    Preface 《Swift 拾遗》是一个关于 Swift 的新文章专辑，这个系列的文章将不会涉及基本语法的层面，而是尝试从底层「拾」起之前所忽视的内容。今天我们将一起简单探究 Swift 中的枚举 struct 和 class。&amp;quot;
结构体 Swift 中的结构体被广泛使用，这是因为它和枚举都是值类型，在操作时会更加安全。我们这里定义一个简单的结构体：
struct Foo { var a = 1 var b = 1 } var foo = Foo() // Breakpoint 🔴 withUnsafeMutablePointer(to: &amp;amp;foo) { print(&amp;#34;\($0)&amp;#34;) } // 0x00000001000030d8 print(MemoryLayout&amp;lt;Foo&amp;gt;.size) // 16 print(MemoryLayout&amp;lt;Foo&amp;gt;.stride) // 16 print(MemoryLayout&amp;lt;Foo&amp;gt;.alignment) // 8 // (lldb) memory read 0x00000001000030d8 // 0x1000030d8: 01 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 .</description>
    </item>
    
    <item>
      <title>Swift 拾遗 - enum</title>
      <link>/posts/2020/swift_enum/</link>
      <pubDate>Sat, 01 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_enum/</guid>
      <description>Date Notes     2020-08-01 首次提交    Preface 《Swift 拾遗》是一个关于 Swift 的新文章专辑，这个系列的文章将不会涉及基本语法的层面，而是尝试从底层「拾」起之前所忽视的内容。今天我们将一起简单探究 Swift 中的枚举 enum。
内存布局 内存布局（Memory Layout）指的是变量在内存中的占用情况，了解内存布局可以使我们对于数据类型的本质更加熟悉。
简单枚举 简单枚举这里指不带关联值与原始值的枚举类型。当 case 个数小于等于 256 个时，其占用 1 个字节（当然，超过 256 个时，将占用 2 个字节）：
enum Foo { case first, second, third } print(MemoryLayout&amp;lt;Foo&amp;gt;.size) // 1 print(MemoryLayout&amp;lt;Foo&amp;gt;.stride) // 1 print(MemoryLayout&amp;lt;Foo&amp;gt;.alignment) // 1 var foo = Foo.third withUnsafePointer(to: &amp;amp;foo) { print(&amp;#34;\($0)&amp;#34;) } // 0x00000001000040e0 // View Memory: // 0x00000001000040e0 -&amp;gt; // 02  View Memory</description>
    </item>
    
    <item>
      <title>Swift 拾遗 - 内联函数</title>
      <link>/posts/2020/swift_inline/</link>
      <pubDate>Sun, 26 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_inline/</guid>
      <description>Date Notes     2020-07-26 首次提交    Preface 《Swift 拾遗》是一个关于 Swift 的新文章专辑，这个系列的文章将不会涉及基本语法的层面，而是尝试从底层「拾」起之前所忽视的内容。今天我们将一起简单探究 Swift 中的内联函数。
编译器优化等级 由于内联函数会将函数调用展开为函数体，因此当编译器内联某一函数时，该函数本身将不再会被调用。而在 Debug 模式下，由于我们经常会使用打断点等调试手段，如果此时内联将不利于我们排查问题。因此在 Debug 模式下，编译器默认将不进行内联。
控制编译器优化等级的设置位于：Xcode - TARGETS - Build Settings - Swift Compiler - Optimization Level，其中便会影响 Swift 函数是否内联：
Swift 编译器所支持的优化等级具体如下：
   Level Part     [-Onone] 无优化（Debug 模式默认）   [-O] 速度优先（Release 模式默认）   [-Osize] 体积优先    经过实际测试，如下 foo 函数在 [-O] 与 [-Osize] 等级下均被优化：</description>
    </item>
    
    <item>
      <title>Swift 拾遗 - inout</title>
      <link>/posts/2020/swift_inout/</link>
      <pubDate>Sat, 25 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_inout/</guid>
      <description>Date Notes     2020-07-25 首次提交    Preface 《Swift 拾遗》是一个关于 Swift 的新文章专辑，这个系列的文章将不会涉及基本语法的层面，而是尝试从底层「拾」起之前所忽视的内容。今天我们将一起简单探究修饰 Swift 中函数参数的 inout 关键字。
本质 我们声明一个使用 inout 参数的函数，并在外界将变量 &amp;amp; 按地址传入：
var foo = 5 func inoutDemoFunc(_ innerFoo: inout Int) { innerFoo = 9 } inoutDemoFunc(&amp;amp;foo) // BREAKPOINT 🔴 // foo == 9 尝试将以上代码转换为汇编（Xcode Menu - Debug - Debug Workflow - Always Show Disassembly）：
; inout demo`main: 0x100001d60 &amp;lt;+0&amp;gt;: pushq %rbp 0x100001d61 &amp;lt;+1&amp;gt;: movq %rsp, %rbp 0x100001d64 &amp;lt;+4&amp;gt;: subq $0x30, %rsp 0x100001d68 &amp;lt;+8&amp;gt;: leaq 0x1459(%rip), %rax ; leetcode.</description>
    </item>
    
    <item>
      <title>iOS 中的数组</title>
      <link>/posts/2020/array_in_ios/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/array_in_ios/</guid>
      <description>Preface 数组，是我们在开发中经常使用的数据结构，其使用一段连续的内存空间存储。在 Obj-C 中，数组的类型分为 NSArray 不可变数组
Objective-C NSArray &amp;amp; NSMutableArray 我们都知道，NSArray 是 Obj-C 中的不可变数组，而 NSMutableArray 是 Obj-C 的可变数组。这里我将 Obj-C 中几乎所有可能涉及到的数组对象，进行尝试打印其类别信息：
NSLog(@&amp;#34;%@&amp;#34;, [[NSMutableArray alloc] class]); // __NSPlaceholderArray NSLog(@&amp;#34;%@&amp;#34;, [[NSArray alloc] class]); // __NSPlaceholderArray NSLog(@&amp;#34;%@&amp;#34;, [[[NSArray alloc] class] superclass]); // NSMutableArray NSLog(@&amp;#34;%@&amp;#34;, [[[[NSArray alloc] class] superclass] superclass]); // NSArray NSLog(@&amp;#34;%@&amp;#34;, [[[[[NSArray alloc] class] superclass] superclass] superclass]); // NSObject  NSLog(@&amp;#34;%@&amp;#34;, [[NSArray array] class]); // __NSArray0 NSLog(@&amp;#34;%@&amp;#34;, [[[NSArray alloc] init] class]); // __NSArray0 NSLog(@&amp;#34;%@&amp;#34;, [[[[NSArray alloc] init] class] superclass]); // NSArray  NSLog(@&amp;#34;%@&amp;#34;, [[NSMutableArray array] class]); // __NSArrayM NSLog(@&amp;#34;%@&amp;#34;, [[[NSMutableArray array] class] superclass]); // NSMutableArray  NSLog(@&amp;#34;%@&amp;#34;, [@[@1] class]); // __NSSingleObjectArrayI NSLog(@&amp;#34;%@&amp;#34;, [[@[@1] class] superclass]); // NSArray  NSLog(@&amp;#34;%@&amp;#34;, [@[@1, @2] class]); // __NSArrayI NSLog(@&amp;#34;%@&amp;#34;, [[@[@1, @2] class] superclass]); // NSArray  NSMutableArray *arr = [NSMutableArray array]; NSLog(@&amp;#34;%@&amp;#34;, [arr class]); // __NSArrayM  [arr addObject:@1]; NSLog(@&amp;#34;%@&amp;#34;, [arr class]); // __NSArrayM 由以上结果，我们可得出下图的继承树：</description>
    </item>
    
    <item>
      <title>Swift 拾遗 - Swift Tips</title>
      <link>/posts/2020/swift_tips/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_tips/</guid>
      <description>Preface 《Swift 拾遗》是一个关于 Swift 的新文章专辑，这个系列的文章将不会涉及基本语法的层面，而是尝试从底层「拾」起之前所忽视的内容。那么作为起始篇，随着整个系列的进行，其中「遗」漏的基本使用将在本文中得到补充。
Content Void 按照 Swift 标准库的定义，Void 即空元组 ()：
public typealias Void = () 函数重载（Overload） Swift 中的函数重载有一些坑，因此尽量不要产生命名歧义性（比如结合默认参数值等用法）。
 Obj-C 中的重载与重写  @discardableResult Swift 是一门要求很严格的语言，当函数的返回值未被使用到时，编译器就会提示相关的警告。我们可以使用 @discardableResult 将函数声明为可丢弃结果，即可告知编译器不产生警告：
import Foundation func foo() -&amp;gt; String { return &amp;#34;kingcos.me&amp;#34; } @discardableResult func bar() -&amp;gt; String { return &amp;#34;kingcos.me&amp;#34; } foo() // WARNING: Result of call to &amp;#39;foo()&amp;#39; is unused // 当然也可以赋值到占位符 _ 以避免警告 _ = foo() bar()  Defaulting non-Void functions so they warn on unused results - swift-evolution  swiftc swiftc 是 Swift 编译器（前端），位于 Xcode 中 Xcode.</description>
    </item>
    
    <item>
      <title>[译] Swift 编译器</title>
      <link>/posts/2020/swift_compiler/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_compiler/</guid>
      <description>作者 原文链接     Swift.org Swift Compiler    Swift 主仓库中包含了 Swift 编译器和标准库的源代码、相关组件，如 SourceKit（用于 IDE 集成），以及 Swift 回归测试套件和实现级别的文档。
Swift 驱动库中包含了 Swift 编译器驱动（Driver）的新版实现，目的是替换现有编译器驱动，以增强可扩展性、可维护性以及鲁棒性（Robust）。
编译器架构 整体而言，Swift 编译器的主要职责在于将 Swift 源代码翻译为高效执行的机器码。但是 Swift 编译器的前端同样支持许多其它工具，包括与 IDE 集成的语法高亮、代码补全、以及其它提供便利的工具。本文对 Swift 编译器的主要组件提供了高阶描述：
 解析（Parsing）：解析器是一个简易的递归下降解析器（在 lib/Parse 中实现），并带有完整手动编码的词法分析器。 语义分析（Semantic Analysis）：语义分析阶段（在 lib/Sema 中实现）负责获取已解析的 AST（抽象语法树）并将其转换为格式正确且类型检查完备的 AST，以及在源代码中提示出现语义问题的警告或错误。语义分析包含类型推断，如果可以成功推导出类型，则表明此时从已经经过类型检查的最终 AST 生成代码是安全的。 Clang 导入器（Clang Importer）：Clang 导入器（在 lib/ClangImporter 中实现）负责导入 Clang 模块，并将导出的 C 或 Objective-C API 映射到相应的 Swift API 中。最终导入的 AST 可以被语义分析引用。 SIL 生成（SIL Generation）：Swift 中间语言（Swift Intermediate Language，SIL）是一门高级且专用于 Swift 的中间语言，适用于对 Swift 代码的进一步分析和优化。SIL 生成阶段（在 lib/SILGen 中实现）将经过类型检查的 AST 弱化为所谓的「原始」SIL。SIL 的设计在 docs/SIL.</description>
    </item>
    
    <item>
      <title>iOS 多线程技术实践之 pthreads（一）</title>
      <link>/posts/2019/multithreading_techs_in_ios-1/</link>
      <pubDate>Sat, 14 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/multithreading_techs_in_ios-1/</guid>
      <description>Date Notes Swift Xcode     2019-03-08 首次提交 4.2 10.1   2019-12-14 内容重整 5.1 10.3    Preface 在现代计算机中，操作系统一般都会支持多进程（Process）以及多线程（Thread）技术，使得其可以同时运行多个程序且效率更高。而我们在开发 iOS app 中也时常需要利用到这些特性，以为用户提供更加良好的使用体验。通常来说，一个 iOS app 为一个进程，其中又至少有一个线程，即主线程；前者进程由操作系统创建我们很难干预，而线程则「自由」许多，可以为我们所用。由于多线程技术内容较多，我将把相关内容进行拆分，本文作为该系列第一篇，先从 pthreads 说起。
What  POSIX Threads, usually referred to as pthreads, is an execution model that exists independently from a language, as well as a parallel execution model. It allows a program to control multiple different flows of work that overlap in time.</description>
    </item>
    
    <item>
      <title>iOS 中的库与框架</title>
      <link>/posts/2019/libraries_in_ios/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/libraries_in_ios/</guid>
      <description>Date Notes     2019-09-14 首次提交，持续更新完善   2019-09-22 适配 Xcode 11，持续更新完善   2019-10-29 添加 Demo：libraries_in_ios-demo    Preface 随着软件工程的发展，很多我们需要的功能前人都已经很好地实现了，为了提高效率避免重复建设，这些功能实现的代码被封装为代码库，有时也称框架。我们只需要在用到的时候通过依赖管理工具将它们以适当的方式引入即可。本文将简单聊聊 iOS 中的库与框架相关概念。
基本概念 在切入正题之前，我们先来达成一些共识。
不管是老派 Obj-C 还是新秀 Swift，它们的本质都是编译型语言。对于编译型语言，源代码会首先经由编译器编译为目标文件，链接器再将多个目标文件链接为可执行文件。针对链接阶段，主要分为静态链接与动态链接。
静态，即 Static。按照字面意思，静态即一旦确定，就不再容易改变。静态链接，即在链接阶段，直接将多个目标文件链接为一个文件。而静态库就可以理解为共同编译为一个目标文件的源代码集合。
动态，即 Dynamic。按照字面意思，动态即推迟到运行时动态地决议。动态链接，即在运行时才将各个部分组合形成完整的程序。而动态库就可以理解为支持动态链接方式的源代码集合。
静态链接的好处是，运行时不再额外需要时间动态链接；坏处则是由于链接的粒度是目标文件，那么可能会链接了没有使用到的函数，会造成可执行文件过大；而且当某一个目标文件的源代码改动时，那么所有依赖该目标文件的静态库都需要重新编译；动态链接则解决了静态链接的空间浪费与重复编译问题，比如在 iOS 中，系统库采用了 dyld_shared_cache 动态链接，这样其它程序就无需再将系统库重复链接，当 iOS 系统更新时也无需将所有 app 重新编译。而在移动端开发中，app 的启动时间与包体积大小将是一个权衡问题，值得我们侧重与考量。
另外，虽然广义上的库（Library）与框架（Framework）含义是类似的，但在 iOS 开发中，官方将这两个概念进行了区分，因此下文中我们会明确两个词的使用。
Cocoa Touch Static Library 我们先从 Xcode 中能够直接创建的 Cocoa Touch Static Library 说起（注意，在 Xcode 11 中，这里已经变成 Framework 与 Library，更加清晰）：</description>
    </item>
    
    <item>
      <title>SwiftTips in Reverse</title>
      <link>/posts/2019/swift_tips_in_reverse/</link>
      <pubDate>Tue, 27 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/swift_tips_in_reverse/</guid>
      <description>Preface SwiftTips 是 John Sundell 在 GitHub 开源的 Swift 小技巧列表。随着 Swift 5 的发布以及 ABI 稳定，是时候再学习一遍 Swift 啦。本文将是该列表的实践版本，并保证文中代码的可运行性，且尽可能做到倒序日更。（But why in reverse? 🤫）
关于本文的代码，都可以在 swift-tips-in-practice 下载并实际运行。
   Date Update Date Update Date Update     2019.08.22 #102 2019.08.23 #100 2019.08.27 #99    #102 让异步测试执行更快更稳定 异步代码似乎总是很难去编写单元测试，因为我们不清楚什么时候请求才能回来。现在在 Swift 中，我们可以使用 expectation（预料）简单设定超时时间，并在 Closure 回调时调用 fulfill() 即可轻松实现。
Talk is cheap, show me the code!
import XCTest @testable import TestUnitTest class TestUnitTestTests: XCTestCase { func fetchFromNetwork(_ completion: @escaping (String) -&amp;gt; Void) { DispatchQueue.</description>
    </item>
    
    <item>
      <title>Xcode 中的 Link Map 文件</title>
      <link>/posts/2019/link_map_file_in_xcode/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/link_map_file_in_xcode/</guid>
      <description>Date Notes Xcode Swift     2019-04-01 首次提交 10.1 -   2019-04-16 增加 Swift 项目 10.1 4.2   2019-07-28 增加目录导图，折叠过长内容 - -    Preface Link Map File，译作链接映射文件（下文将称 Link Map 文件）。Xcode 在构建可执行文件之前，需要先编译为目标文件（Object File），并链接所需要的其他库，那么 Link Map 文件就记录了链接器（Linker）在链接过程中产生的一些信息，本文将谈谈这个文件的构成。
What Xcode 中默认是不会将 Link Map 文件在构建时暴露出来的，需要我们手动在「Build Settings」-「Write Link Map File」-「Yes」打开该写入该文件的设置。这样当我们再次编译项目，默认就可以在 ~/Library/Developer/Xcode/DerivedData/&amp;lt;TARGET_NAME&amp;gt;-&amp;lt;Random_ID&amp;gt;/Build/Intermediates.noindex/&amp;lt;TARGET_NAME&amp;gt;.build/Debug-&amp;lt;Device_Type&amp;gt;/&amp;lt;TARGET_NAME&amp;gt;.build/&amp;lt;TARGET_NAME&amp;gt;-LinkMap-normal-&amp;lt;Arch&amp;gt;.txt 中找到。如有更改 Link Map 文件路径的需求也可以在「Path to Link Map File」中更改。
举个例子，我的 DemoiOS 项目（Obj-C）中 Link Map 文件的完整路径为：/Users/kingcos/Library/Developer/Xcode/DerivedData/DemoiOS-hifhuapijabsaxgpelrpiwhbzlqv/Build/Intermediates.noindex/DemoiOS.build/Debug-iphonesimulator/DemoiOS.build/DemoiOS-LinkMap-normal-x86_64.txt。
How 下面来分析一下 Link Map 文件的构成。</description>
    </item>
    
    <item>
      <title>[译] 摊平由「try?」造成的嵌套可选</title>
      <link>/posts/2019/0230-flatten-optional-try_zh/</link>
      <pubDate>Mon, 08 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/0230-flatten-optional-try_zh/</guid>
      <description>提案: SE-0230 作者: BJ Homer 审查管理员: John McCall 状态: 已实现 (Swift 5) 实现: apple/swift#16942 审查: (论坛帖子) (验收)  介绍 Swift 中的 try? 语句目前很容易引入嵌套可选（译者注：嵌套可选即类似 var foo: String?? 可选的可选类型）。而用户难以推断嵌套可选的产生原因，所以 Swift 尝试避免在一些常见情况下产生嵌套可选。
该文档提议给予 try? 与其它常见的 Swift 功能中相同的可选摊平行为（译者注：可选摊平即将可选类型的值去掉可选的一层），来避免常见的嵌套可选。
Swift-evolution 帖子: 使 try? 与可选链摊平协同工作
动机 目前，使用 try? 非常容易产生嵌套的 Optional 类型。虽然构建嵌套可选是被允许的，但这通常并非是开发者所希望的。
Swift 拥有许多机制来避免意外创建嵌套可选。比如：
// 注意 as? 是如何可以无视被转换的值是否是可选类型的，其总是产生了相同的类型 let x = nonOptionalValue() as? MyType // x 是 &amp;#39;MyType?&amp;#39; 类型 let y = optionalValue() as? MyType // y 是 &amp;#39;MyType?</description>
    </item>
    
    <item>
      <title>Swift/Obj-C 混编项目升级 Swift 5.0 踩坑</title>
      <link>/posts/2019/swift_4_to_5/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/swift_4_to_5/</guid>
      <description>Date Note     2019-05-08 Swift 4.2 -&amp;gt; 5.0   2019-07-08 完善内容    Preface 在 ABI 稳定前，每次 Swift 升级都是一个比较「痛苦」的体验。这次笔者花费约总共一天时间将 Swift/Obj-C 混编项目升级到 Swift 5.0，其中还是有一些踩坑经验值得分享的。
Xcode 为了适配 Swift 5.0，首先需要安装 Xcode 10.2。而我们不能完全抛弃 Xcode 10.1，毕竟在未完全转换到 Swift 5.0 的过渡阶段仍然需要使用。因此我们可以将本地的 Xcode 更名为 Xcode-10.1，再在 https://developer.apple.com/download/more/ 检索 Xcode 下载 10.2 版本即可。
 ⚠️ 注意：为了防止类似 XcodeGhost 事件再次发生，建议从该官方渠道或 App Store 直接下载。
 为了便于区分，我们将新的 Xcode 命名为 Xcode-10.2，并打开、同意安装 Xcode Command Line Tools。由于我们目前安装了两个 Xcode，如果需要命令行执行 swift 或 xcodebuild 等命令，可以使用 xcode-select 来进行切换不同版本。</description>
    </item>
    
    <item>
      <title>Obj-C &amp; Swift 的类型内省与反射</title>
      <link>/posts/2019/type_introspection_and_reflection/</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/type_introspection_and_reflection/</guid>
      <description>Date Notes Swift Demo     2019-04-08 首次提交 4.2 Type Introspection and Reflection    Preface 许多编程语言中都有类型内省（又称自省，Introspection）和反射（Reflection）这两个概念，本文将探讨一下 Obj-C 和 Swift 中类型内省和反射的相关概念与具体使用。
What 维基百科中对于类型内省定义如下：
 In computing, type introspection is the ability of a program to examine the type or properties of an object at runtime. Some programming languages possess this capability.
Introspection should not be confused with reflection, which goes a step further and is the ability for a program to manipulate the values, meta-data, properties and/or functions of an object at runtime.</description>
    </item>
    
    <item>
      <title>[译] Swift 名字修饰（Name Mangling）</title>
      <link>/posts/draft/friday_qa_swift_name_mangling/</link>
      <pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/draft/friday_qa_swift_name_mangling/</guid>
      <description>作者 原文链接   Gwynne Raskind Friday Q&amp;A 2014-08-08: Swift Name Mangling    译者注
1.「Name Mangling」在本文中将译作「名字修饰」，这主要是参考了 Wikipedia 中关于该项技术的翻译；
2.「Friday Q&amp;amp;A」中文意为「周五问与答」，但限于该名称是作者文章的系列名称，故保留原文不再翻译。
 许久没有参与到 Friday Q&amp;amp;A 中，不过我带着全新主题的文章又回来了：Swift。在最近的几篇文章中，Mike 具体介绍了 Swift 的内部结构是什么样的，但他只是轻描淡写了当查看包含 Swift 的二进制文件时，链接器所看到的：被修饰的（Mangled）符号名。
 在 C 之类的编程语言中，任何给定的名称（符号）都只能对应一个函数或者一条数据，那么名字修饰（Name Mangling）就不是必需的。尽管如此，如果我们查看典型的纯 C 二进制文件的符号表，仍然能发现每个函数名中都有一个 _（下划线）作为前缀。举个例子：
$ echo &amp;#39;int main() { return 0; }&amp;#39; | xcrun clang -x c - -o ./test $ xctest nm ./test # 译者注：xctest 命令可能无法直接找到，也可直接使用 nm ./test 0000000100000000 T __mh_execute_header 0000000100000f80 T _main U dyld_stub_binder $ 这种简单的「修饰」没有什么作用，其存在主要是历史原因，由于兼容性与统一性而被保留。按照约定，C 中定义的名称将带有下划线，而纯汇编定义的全局符号则没有（尽管许多汇编语言的作者仍会为了统一性而使用下划线作为前缀）。</description>
    </item>
    
    <item>
      <title>Combine</title>
      <link>/posts/draft/combine_1/</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/draft/combine_1/</guid>
      <description>Foundation and UIKit/AppKit 中的异步机制：   NotificationCenter：事件发生时执行一段代码（eg. 设备方向改变，软键盘显示或隐藏） 代理（Delegate）模式：定义代表另一个对象的代理对象（eg. AppDelegate 中定义当新的远程推送到达时的操作，但对代码执行时机和次数未知） GCD &amp;amp; NSOperation：安排在穿行队列中顺序执行的代码，或者在不同优先级的不同队列中同时运行多个任务 闭包：创建可分离的代码段，便于其他对象可以决定是否执行、执行次数、以及执行时机  Publisher&amp;lt;Int, Never&amp;gt; ┌────┐ ┌────┐ ┌────┐ ┌────┐ │ │ │ │ │ │ │ │ ───│ 13 │──▶│ 27 │─────▶│ 35 │──▶│ 56 │──│─▶ │ │ │ │ │ │ │ │ └────┘ └────┘ └────┘ └────┘ time 0:01 0:05 0:15 0:19 STOP Publisher /// Declares that a type can transmit a sequence of values over time.</description>
    </item>
    
    <item>
      <title>Objective-C 与 Swift 桥接中的坑</title>
      <link>/posts/2019/obj-c_swift_bridge_tips/</link>
      <pubDate>Thu, 17 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/obj-c_swift_bridge_tips/</guid>
      <description>Date Notes     2019-01-17 添加「Optional 与 Nullability」
添加「NSNotificationName 与 Notification.Name」    Preface Objective-C 与 Swift 的混编是全面转向 Swift 中的必经之路，本篇即是这一过程中的踩坑「真实」记录。
Optional 与 Nullability  Swift 4.2  在大多数项目中，我们都是在中途决定转向 Swift，Swift 中比较核心且常见的概念便是 Optional，可选类型，而这与 Obj-C 中的概念不大相同。在 Swift 中使用 Obj-C 桥接的属性（特别是 Block）时，尤其要注意：Obj-C 默认属性将被转换为隐式解包类型（SomeClass!），而在 Swift 中这代表开发者要保证值不为 nil，编译器将不再提示。当属性是 Block 时，若直接调用了为 nil 的 Closure 时，将会出现崩溃。
   Obj-C Usage Swift     nullable 可空 SomeClass?   nonnull 不可空 SomeClass   null_unspecified 未指定是否可空（默认） SomeClass!</description>
    </item>
    
    <item>
      <title>在 Swift 中对集合类型元素的弱引用</title>
      <link>/posts/2018/weakly_collections/</link>
      <pubDate>Thu, 08 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/weakly_collections/</guid>
      <description>Date Notes Swift Xcode     2018-03-15 更新部分表述，并将题目扩展至集合类型 4.0 9.2   2018-03-08 首次提交 4.0 9.2    Preface 为了方便下述 Demo，这里定义一个 Pencil 类，并会使用 func CFGetRetainCount(_ cf: CoreFoundation.CFTypeRef!) -&amp;gt; CFIndex 方法，即传入一个 CFTypeRef 类型的对象即可获取其引用计数。什么是 CFTypeRef？查阅官方文档即可得知 typealias CFTypeRef = AnyObject，所以 CFTypeRef 其实就是 AnyObject。而 AnyObject 又是所有类隐含遵守的协议。
class Pencil { var type: String var price: Double init(_ type: String, _ price: Double) { self.type = type self.price = price } } CFGetRetainCount(Pencil(&amp;#34;2B&amp;#34;, 1.</description>
    </item>
    
    <item>
      <title>浅谈 iOS 应用启动过程</title>
      <link>/posts/2017/ios_app_start_up/</link>
      <pubDate>Tue, 28 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/ios_app_start_up/</guid>
      <description>Date Notes Swift Xcode     2017-05-26 CS193p UIApplication 3.1 8.3.2   2017-03-28 首次提交 3.0 8.2.1    Preface 首先要感谢没故事的卓同学大大送的泊学会员，在泊学学了几节课，了解了很多不同角度的 iOS 开发知识。这篇文章就启发自其 iOS 101 中的一个纯手工的 Single View Application 一文。但本文将更加深入的叙述了启动过程，且实现均为 Swift 3.0。
本文对应的 Demo 可以在：https://github.com/kingcos/SingleViewAppManually-Demo 查看、下载。
Manually or Storyboard main.m in Objective-C Single View Application
#import &amp;lt;UIKit/UIKit.h&amp;gt; #import &amp;#34;AppDelegate.h&amp;#34;  int main(int argc, char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } }  自从 Storyboard 诞生以来，关于纯代码、Xib、以及 Storyboard 的选择就在 iOS 开发圈中炸开了锅。这里不会探讨各种姿势的优劣，只是可能很多和我一样的初学者，从一开始就被 Storyboard 先入为主。加上方便灵活的拖控件，自然而然就可能没有机会去思考一个 iOS 应用是如何启动起来的。加上 Swift 的诞生，使得整个项目的初始结构得到了更大的简化（少了 main.</description>
    </item>
    
    <item>
      <title>探究 UIViewController 生命周期</title>
      <link>/posts/2017/uiviewcontroller_life_cycle/</link>
      <pubDate>Fri, 10 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/uiviewcontroller_life_cycle/</guid>
      <description>Date Notes Swift Xcode     2017-03-10 首次提交 3.0 8.2.1    前言 对象的生命周期一直是开发者所需要关心的，教授 CS193p 的老师 Paul 也详细的讲述了 UIViewController 的生命周期。为了记述这一过程，故作此文。由于 Xcode 提供了纯代码和 Storyboard（Xib 同理）两种布局 UI 的方式，因此初始化部分略有不同。
为了方便观察，我创建了一个 BaseViewController，继承自原本的 UIViewController，重写其中的生命周期方法，并让后续新的控制器继承自该控制器，以便观察。
本文对应的 Demo 可以在 https://github.com/kingcos/UIViewController-UIView-LifecycleDemo 查看、下载。
Initialization Storyboard  OUTPUT:
 init(coder:) awakeFromNib()   init(coder:)  当使用 Storyboard 时，控制器的构造器为 init(coder:)。 该构造器为必需构造器，如果重写其他构造器，则必须重写该构造器。 该构造器为可失败构造器，即有可能构造失败，返回 nil。 该方法来源自 NSCoding 协议，而 UIViewController 遵从这一协议。 该方法被调用意味着控制器有可能（并非一定）在未来会显示。 在控制器生命周期中，该方法只会被调用一次。  awakeFromNib()  当使用 Storyboard 时，该方法会被调用。 当调用该方法时，将保证所有的 outlet 和 action 连接已经完成。 该方法内部必须调用父类该方法，虽然默认实现为空，但 UIKit 中许多类的该方法为非空。 由于控制器中对象的初始化顺序不能确定，所以构造器中不应该向其他对象发送消息，而应当在 awakeFromNib() 中安全地发送。 通常使用 awakeFromNib() 可以进行在设计时无法完成的必要额外设置。  Code  OUTPUT:</description>
    </item>
    
    <item>
      <title>Swift 中的 Selector</title>
      <link>/posts/2017/swift_selector/</link>
      <pubDate>Tue, 31 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/swift_selector/</guid>
      <description>Date Notes Swift Xcode     2017-01-31 首次发布（简书 &amp;amp; 掘金） 3.0 8.2.1    Preface  Focus，即专注。笔者希望可以尽力将一些不是那么透彻的点透过 Demo 和 Source Code 而看到其本质。由于国内软件开发仍很大程度依赖国外的语言、知识，所以该博客中的术语将使用英文表述，除非一些特别统一的词汇或整段翻译时将使用中文，但也会在首次提及时标注英文。笔者英文水平有限，这样的目的也是尽可能减少歧义，但在其中不免有所错误，遗漏，还请大家多多批评、指正。
本文及更新会首发于笔者的 GitHub 的 Perspective 仓库：https://github.com/kingcos/Perspective，欢迎 Star 🌟。
 What 常用纯代码来开发的同学都应该比较熟悉这个方法：
func addTarget(_ target: Any?, action: Selector, for controlEvents: UIControlEvents) Selector 源自 Objective-C，例如 SEL 类型，以及 @selector() 方法选择器。Swift 中也兼容了这个概念，不过随着 Swift 的迭代，Selector 的一些写法也出现了很大的变化。比较遗憾的是，官方文档对于 Selector 没有介绍。
因此只能自己总结一下 Swift 3.0 中的 Selector，便有利于自己理解，也便于以后的参考。注：以下 Demo 中的 cyanButton 是用 StoryBoard 拖拽的。</description>
    </item>
    
    <item>
      <title>浅谈 Swift 中的属性（Property）</title>
      <link>/posts/2016/swift_properties/</link>
      <pubDate>Wed, 26 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/2016/swift_properties/</guid>
      <description>Date Notes Swift Xcode     2017-04-27 扩充 #延迟存储属性# 部分并新增 #devxoul/Then# 3.1 8.3.2   2016-10-26 首次提交 3.0 8.1 Beta 3    前言 Swift 中的属性分为存储属性与计算属性，存储属性即为我们平时常用的属性，可以直接赋值使用，而计算属性不直接存储值，而是根据其他（存储）属性计算得来的值。
在其他面向对象的编程语言中，例如 Java 和 Objective-C 中，get 和 set 方法提供了统一、规范的接口，可以使得外部访问或设置对象的私有属性，而不破坏封装性，也可以很好的控制权限（选择性实现 get 或 set 方法）。而 Swift 中似乎并没有见到类似的 get 和 set 方法，而 Swift 使用了一种名为属性观察器的概念来解决该问题。
本文简单介绍下 Swift 中的这两种属性，以及属性观察器。
延迟存储属性  存储属性使用广泛，即是类或结构体中的变量或常量，可以直接赋初始值，也可以修改其初始值（仅指变量）。 延迟存储属性是指第一次使用到该变量再进行运算（这里的运算不能依赖其他成员属性，但可以使用静态／类属性）。 延迟存储属性必须声明为 var 变量，因为其属性值在对象实例化前可能无法得到，而常量必须在初始化完成前拥有初始值。 在 Swift 中，可以将消耗性能才能得到的值作为延迟存储属性，即懒加载。 全局的常量和变量也是延迟存储属性，但不需要显式声明为 lazy（不支持 Playground）。  Demo  这里假定在 ViewController.</description>
    </item>
    
    <item>
      <title>[译] Swift 编译器性能</title>
      <link>/posts/2020/swift_compiler_performance/</link>
      <pubDate>Sun, 25 Jun 2000 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_compiler_performance/</guid>
      <description>作者 原文链接 版本     apple/swift Swift Compiler Performance 5dcc32f    本文档是一份关于理解、诊断并报告 Swift 编译器编译性能问题的指南。即：编译器编译代码的速度，而非代码运行的速度。
虽然本指南较长，但内容其实相当简单。在很大程度上，性能分析需要耐住性子、考虑周全且坚持不懈，谨小慎微且始终如一地测量，并逐步消除噪音且专注于一个信号。
影响编译性能的流程与因素概述 本节从较为宏观的角度论述关于编译器在运行时所做的工作，不仅包括显而易见的「编译」，以及影响编译器耗时的主要因素。
当我们使用 Xcode 或在命令行中编译或运行 Swift 程序时，通常将调用 swift 或 swiftc（后者是前者的符号链接），这是一个根据不同参数能够以显著不同的方式运行的程序。
虽然它可以直接编译或运行代码，但它通常会反过来运行一个或多个 swift 或 swiftc 副本作为子进程。在典型的批量编译中，swiftc 的第一个副本将被作为驱动（Driver）进程运行，之后它将在进程树中运行一些所谓的前端（Frontend）子进程。当我们要理解 Swift 编译时，我们必须清楚地了解哪些进程在运行，以及它们在做什么：
 驱动：子进程树中的顶层 swiftc 进程。负责决定哪些文件需要被编译或重新编译，以及运行子进程。子进程即所谓的作业（Jobs），它们运行编译和链接步骤。通常在运行时，驱动是空闲的，等待其它子进程完成。 前端作业（Frontend Jobs）：由驱动启动的子进程，运行 swift -frontend ...、运行编译、PCH 文件生成、模块合并等。这些作业大量增加了编译开销。 其它作业（Other Jobs）：由驱动启动的子进程，运行 ld、swift -modulewrap、swift-autolink-extract、dsymutil、dwarfdump，以及涉及收尾前端已完成作业等类似工具。其中一些也是 swift 程序，但它们并非「运行前端作业」，因此将会有完全不同的分析。  这些运行的一系列作业以及它们的耗时方式高度依赖于编译模式。有关编译性能的这些模式信息将在下一节中详述；关于驱动的更多详细信息，请参阅驱动文档、以及有关驱动内部和驱动可解析输出的文档。
在下一节讨论完编译模式之后，我们还将涉及可能在没有明显热点（Hotspot）出现的情况下，所发生的工作量大幅变化，这将分别从懒惰策略（Laziness Strategies）与近似两个角度论述。
编译模式 编译器有许多不同的选项可以控制驱动和前端作业，但导致行为上最显著差异的两个维度通常被称作模式（Modes）。因此当我们着眼于编译时，弄清楚 swiftc 的运行模式便十分重要，以及要时常对每个模式进行独立的分析。这些重要的模式如下：
 主文件（Primary-File）与全模块（Whole-Module）：不同模式取决于驱动是否使用 -wmo（又名 -whole-module-optimization）参数运行。  批量（Batch）与单文件（Single-File）主文件模式：随着 Swift 4.</description>
    </item>
    
  </channel>
</rss>
