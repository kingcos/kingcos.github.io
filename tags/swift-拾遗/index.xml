<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Swift 拾遗 on iBlog</title>
    <link>/tags/swift-%E6%8B%BE%E9%81%97/</link>
    <description>Recent content in Swift 拾遗 on iBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved by kingcos.me</copyright>
    <lastBuildDate>Mon, 10 Aug 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/swift-%E6%8B%BE%E9%81%97/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Swift 拾遗 - 汇编</title>
      <link>/posts/2020/swift_with_asm/</link>
      <pubDate>Mon, 10 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_with_asm/</guid>
      <description>Date Notes     2020-08-10 首次提交    Preface 《Swift 拾遗》是一个关于 Swift 的新文章专辑，这个系列的文章将不会涉及基本语法的层面，而是尝试从底层「拾」起之前所忽视的内容。本文涉及了各个部分关于汇编的内容。
struct &amp;amp; class struct 栈区 // main.swift struct Foo { var a: Int var b: Int } func bar() { var foo1 = Foo(a: 10, b: 11) // BREAKPOINT 🔴 var foo2 = foo1 foo2.a = 20 foo2.b = 22 } bar() 我们定义一个结构体 Foo，并在函数 bar 中声明和构造后赋值于 foo1，之后将 foo1 赋值给新变量 foo2；此时改变 foo2 中的值，由于结构体是值类型，因此对于 foo2 的改变将不会影响 foo1，我们尝试从汇编底层看一下这个过程：</description>
    </item>
    
    <item>
      <title>Swift 拾遗 - struct &amp; class</title>
      <link>/posts/2020/swift_struct_and_class/</link>
      <pubDate>Thu, 06 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_struct_and_class/</guid>
      <description>Date Notes     2020-08-06 首次提交    Preface 《Swift 拾遗》是一个关于 Swift 的新文章专辑，这个系列的文章将不会涉及基本语法的层面，而是尝试从底层「拾」起之前所忽视的内容。今天我们将一起简单探究 Swift 中的枚举 struct 和 class。&amp;rdquo;
结构体 内存布局 Swift 中的结构体被广泛使用，这是因为它和枚举都是值类型，在操作时会更加安全。我们这里定义一个简单的结构体：
struct Foo { var a = 1 var b = 1 } var foo = Foo() // Breakpoint 🔴 withUnsafeMutablePointer(to: &amp;amp;foo) { print(&amp;#34;\($0)&amp;#34;) } // 0x00000001000030d8 print(MemoryLayout&amp;lt;Foo&amp;gt;.size) // 16 print(MemoryLayout&amp;lt;Foo&amp;gt;.stride) // 16 print(MemoryLayout&amp;lt;Foo&amp;gt;.alignment) // 8 // (lldb) memory read 0x00000001000030d8 // 0x1000030d8: 01 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 .</description>
    </item>
    
    <item>
      <title>Swift 拾遗 - enum</title>
      <link>/posts/2020/swift_enum/</link>
      <pubDate>Sat, 01 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_enum/</guid>
      <description>Date Notes     2020-08-01 首次提交    Preface 《Swift 拾遗》是一个关于 Swift 的新文章专辑，这个系列的文章将不会涉及基本语法的层面，而是尝试从底层「拾」起之前所忽视的内容。今天我们将一起简单探究 Swift 中的枚举 enum。
内存布局 内存布局（Memory Layout）指的是变量在内存中的占用情况，了解内存布局可以使我们对于数据类型的本质更加熟悉。
简单枚举 简单枚举这里指不带关联值与原始值的枚举类型。当 case 个数小于等于 256 个时，其占用 1 个字节（当然，超过 256 个时，将占用 2 个字节）：
enum Foo { case first, second, third } print(MemoryLayout&amp;lt;Foo&amp;gt;.size) // 1 print(MemoryLayout&amp;lt;Foo&amp;gt;.stride) // 1 print(MemoryLayout&amp;lt;Foo&amp;gt;.alignment) // 1 var foo = Foo.third withUnsafePointer(to: &amp;amp;foo) { print(&amp;#34;\($0)&amp;#34;) } // 0x00000001000040e0 // View Memory: // 0x00000001000040e0 -&amp;gt; // 02  View Memory</description>
    </item>
    
    <item>
      <title>Swift 拾遗 - 内联函数</title>
      <link>/posts/2020/swift_inline/</link>
      <pubDate>Sun, 26 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_inline/</guid>
      <description>Date Notes     2020-07-26 首次提交    Preface 《Swift 拾遗》是一个关于 Swift 的新文章专辑，这个系列的文章将不会涉及基本语法的层面，而是尝试从底层「拾」起之前所忽视的内容。今天我们将一起简单探究 Swift 中的内联函数。
编译器优化等级 由于内联函数会将函数调用展开为函数体，因此当编译器内联某一函数时，该函数本身将不再会被调用。而在 Debug 模式下，由于我们经常会使用打断点等调试手段，如果此时内联将不利于我们排查问题。因此在 Debug 模式下，编译器默认将不进行内联。
控制编译器优化等级的设置位于：Xcode - TARGETS - Build Settings - Swift Compiler - Optimization Level，其中便会影响 Swift 函数是否内联：
Swift 编译器所支持的优化等级具体如下：
   Level Part     [-Onone] 无优化（Debug 模式默认）   [-O] 速度优先（Release 模式默认）   [-Osize] 体积优先    经过实际测试，如下 foo 函数在 [-O] 与 [-Osize] 等级下均被优化：</description>
    </item>
    
    <item>
      <title>Swift 拾遗 - inout</title>
      <link>/posts/2020/swift_inout/</link>
      <pubDate>Sat, 25 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_inout/</guid>
      <description>Date Notes     2020-07-25 首次提交    Preface 《Swift 拾遗》是一个关于 Swift 的新文章专辑，这个系列的文章将不会涉及基本语法的层面，而是尝试从底层「拾」起之前所忽视的内容。今天我们将一起简单探究修饰 Swift 中函数参数的 inout 关键字。
本质 我们声明一个使用 inout 参数的函数，并在外界将变量 &amp;amp; 按地址传入：
var foo = 5 func inoutDemoFunc(_ innerFoo: inout Int) { innerFoo = 9 } inoutDemoFunc(&amp;amp;foo) // BREAKPOINT 🔴 // foo == 9 尝试将以上代码转换为汇编（Xcode Menu - Debug - Debug Workflow - Always Show Disassembly）：
; inout demo`main: 0x100001d60 &amp;lt;+0&amp;gt;: pushq %rbp 0x100001d61 &amp;lt;+1&amp;gt;: movq %rsp, %rbp 0x100001d64 &amp;lt;+4&amp;gt;: subq $0x30, %rsp 0x100001d68 &amp;lt;+8&amp;gt;: leaq 0x1459(%rip), %rax ; leetcode.</description>
    </item>
    
    <item>
      <title>Swift 拾遗 - Swift Tips</title>
      <link>/posts/2020/swift_tips/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_tips/</guid>
      <description>Preface 《Swift 拾遗》是一个关于 Swift 的新文章专辑，这个系列的文章将不会涉及基本语法的层面，而是尝试从底层「拾」起之前所忽视的内容。那么作为起始篇，随着整个系列的进行，其中「遗」漏的基本使用将在本文中得到补充。
Content Void 按照 Swift 标准库的定义，Void 即空元组 ()：
public typealias Void = () 函数重载（Overload） Swift 中的函数重载有一些坑，因此尽量不要产生命名歧义性（比如结合默认参数值等用法）。
 Obj-C 中的重载与重写  @discardableResult Swift 是一门要求很严格的语言，当函数的返回值未被使用到时，编译器就会提示相关的警告。我们可以使用 @discardableResult 将函数声明为可丢弃结果，即可告知编译器不产生警告：
import Foundation func foo() -&amp;gt; String { return &amp;#34;kingcos.me&amp;#34; } @discardableResult func bar() -&amp;gt; String { return &amp;#34;kingcos.me&amp;#34; } foo() // WARNING: Result of call to &amp;#39;foo()&amp;#39; is unused // 当然也可以赋值到占位符 _ 以避免警告 _ = foo() bar()  Defaulting non-Void functions so they warn on unused results - swift-evolution  swiftc swiftc 是 Swift 编译器（前端），位于 Xcode 中 Xcode.</description>
    </item>
    
  </channel>
</rss>