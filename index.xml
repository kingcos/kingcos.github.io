<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>iBlog</title>
    <link>/</link>
    <description>Recent content on iBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 30 Apr 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Effective Objective-C 2.0 笔记</title>
      <link>/posts/2019/effective_objc_2.0_notes/</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/effective_objc_2.0_notes/</guid>
      <description>Book ISBN     编写高质量 iOS 与 OS X 代码的 52 个有效方法 9787111451297   Date Chapters   2019-05-01     熟悉 Objective-C 了解 Objective-C 语言的起源  消息结构（Message Structure）的语言，运行时执行的代码由运行环境决定；函数调用（Function Calling）的语言，运行时所执行的代码由编译器决定，对于多态，则按照虚函数表（Virtual Method Table）寻找。 运行时组件（Runtime Component） 本质上是一种与开发者所编写代码相链接的「动态库（Dynamic Library），这样的好处是只需要更新运行时组件（无需重新编译）即可提升程序性能。 Obj-C 是 C 的超集。 Obj-C 中的对象所占内存总是分配在堆空间（Heap Stack）；而指向对象的指针所占内存总是分配在栈帧（Stack Frame）中。 堆中的内存需要程序员自己管理，栈中的内存会在其栈帧弹出（Pop）时自动清理。 创建对象相比创建结构体（C 结构体）需要额外开销，例如分配和释放堆内存等。  // @&amp;quot;string&amp;quot; 被分配在堆上；a &amp;amp; b &amp;amp; c 被分配在栈上 NSString *a = @&amp;quot;string&amp;quot;; NSString *b = a; NSString *c = @&amp;quot;string&amp;quot;; // (lldb) p a // (__NSCFConstantString *) $0 = 0x0000000100001020 @&amp;quot;string&amp;quot; // (lldb) p b // (__NSCFConstantString *) $1 = 0x0000000100001020 @&amp;quot;string&amp;quot; // (lldb) p c // (__NSCFConstantString *) $2 = 0x0000000100001020 @&amp;quot;string&amp;quot; // (lldb) p &amp;amp;a // (NSString **) $4 = 0x00007ffeefbff548 // (lldb) p &amp;amp;b // (NSString **) $5 = 0x00007ffeefbff540 // (lldb) p &amp;amp;c // (NSString **) $6 = 0x00007ffeefbff538 // (lldb)  在类的头文件中尽量少引入其他头文件  当需要知道有一个类的存在时，而不关心其内部细节时，可以使用向前声明（Forward Declaring）告知编译器，即可以在 .</description>
    </item>
    
    <item>
      <title>iOS 中的 &#43;initialize 方法</title>
      <link>/posts/2019/&#43;initialize_in_ios/</link>
      <pubDate>Sun, 21 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/&#43;initialize_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-04-21 首次提交 objc4-750 -   2019-05-01 补充细节 - Initialize_Demo    Preface 在 iOS 中，经常与 +load 相提并论的一个方法便是 +initialize。从方法名来看，它的作用是进行初始化，但不同于平时使用的 init，+initialize 是一个类方法。那么它的本质到底是什么呢？
为了更好地叙述 +initialize 的特点，本文部分描述尝试与 +load 方法对比，建议阅读本文前先阅读「iOS 中的 +load 方法」。
What // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { + (void)initialize; }  Obj-C 中的 +initialize 方法指的是 NSObject 中的 + (void)initialize 类方法。官方文档中的 +initialize 如下：
 Initializes the class before it receives its first message.</description>
    </item>
    
    <item>
      <title>iOS 中的 &#43;load 方法</title>
      <link>/posts/2019/&#43;load_in_ios/</link>
      <pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/&#43;load_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-04-20 首次提交 objc4-750 Load_Obj-C_Demo    Preface 在 iOS 开发中，我们经常会使用 +load 方法来做一些在 main 函数之前的操作，比如方法交换（Method Swizzle）等。那么 +load 到底是如何被调用的呢？
What // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { + (void)load; }  Obj-C 中的 +load 方法指的是 NSObject 中的 + (void)load 类方法。官方文档中的 +load 如下：
 Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</description>
    </item>
    
    <item>
      <title>iOS 中的 Category</title>
      <link>/posts/2019/category_in_ios/</link>
      <pubDate>Sat, 13 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/category_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-04-16 优化结构 - -   2019-04-13 首次提交 objc4-750、xnu-4903.221.2 Category in iOS    Preface iOS 中的 Category 中文常译作分类、类别（为表述统一，本文将使用 Category 特指该技术）。我们经常会使用 Category 来对一个类进行扩展，使得在不破坏主类结构的同时可以具备更多的功能；也可以使用 Category 对一个类进行拆分，使得其结构更加清晰条理。本文将从 What - How - Why 谈谈 iOS 中 Category。
What 什么是 Category 呢？
Category 是 Obj-C 语言中所提供的一项功能，它可以为 Obj-C 类添加额外的属性、方法，也可以遵守其他协议。
Xcode 中已经为 Category 已经提供了模版来建立，只需要指定 Category 的名称以及被添加 Category 类名即可。当然，我们也可以手动来自己建立，Category 的语法与类的声明与实现比较类似：
@interface Foo (Bar) &amp;lt;SomeProtocol&amp;gt; - (void)foo; @end @implementation Foo (Bar) - (void)foo {} - (void)someMethodFromProtocol {} @end  How Category 通常都有哪些用处呢？</description>
    </item>
    
    <item>
      <title>Obj-C &amp; Swift 的类型内省与反射</title>
      <link>/posts/2019/type_introspection_and_reflection/</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/type_introspection_and_reflection/</guid>
      <description>Date Notes Swift Demo     2019-04-08 首次提交 4.2 Type Introspection and Reflection    Preface 许多编程语言中都有类型内省（又称自省，Introspection）和反射（Reflection）这两个概念，本文将探讨一下 Obj-C 和 Swift 中类型内省和反射的相关概念与具体使用。
What 维基百科中对于类型内省定义如下：
 In computing, type introspection is the ability of a program to examine the type or properties of an object at runtime. Some programming languages possess this capability.
Introspection should not be confused with reflection, which goes a step further and is the ability for a program to manipulate the values, meta-data, properties and/or functions of an object at runtime.</description>
    </item>
    
    <item>
      <title>Xcode 中的 Link Map 文件</title>
      <link>/posts/2019/link_map_file_in_xcode/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/link_map_file_in_xcode/</guid>
      <description>Date Notes Xcode Swift     2019-04-16 增加 Swift 项目 10.1 4.2   2019-04-01 首次提交 10.1 -    Preface Link Map File，译作链接映射文件（下文将称 Link Map 文件）。Xcode 在构建可执行文件之前，需要先编译为目标文件（Object File），并链接所需要的其他库，那么 Link Map 文件就记录了链接器（Linker）在链接过程中产生的一些信息，本文将谈谈这个文件的构成。
What Xcode 中默认是不会将 Link Map 文件在构建时暴露出来的，需要我们手动在「Build Settings」-「Write Link Map File」-「Yes」打开该写入该文件的设置。这样当我们再次编译项目，默认就可以在 ~/Library/Developer/Xcode/DerivedData/&amp;lt;TARGET_NAME&amp;gt;-&amp;lt;Random_ID&amp;gt;/Build/Intermediates.noindex/&amp;lt;TARGET_NAME&amp;gt;.build/Debug-&amp;lt;Device_Type&amp;gt;/&amp;lt;TARGET_NAME&amp;gt;.build/&amp;lt;TARGET_NAME&amp;gt;-LinkMap-normal-&amp;lt;Arch&amp;gt;.txt 中找到。如有更改 Link Map 文件路径的需求也可以在「Path to Link Map File」中更改。
举个例子，我的 DemoiOS 项目（Obj-C）中 Link Map 文件的完整路径为：/Users/kingcos/Library/Developer/Xcode/DerivedData/DemoiOS-hifhuapijabsaxgpelrpiwhbzlqv/Build/Intermediates.noindex/DemoiOS.build/Debug-iphonesimulator/DemoiOS.build/DemoiOS-LinkMap-normal-x86_64.txt。
How 下面来分析一下 Link Map 文件的构成。
Path # Path: /Users/kingcos/Library/Developer/Xcode/DerivedData/DemoiOS-hifhuapijabsaxgpelrpiwhbzlqv/Build/Products/Debug-iphonesimulator/DemoiOS.</description>
    </item>
    
    <item>
      <title>Obj-C 中成员变量和类的访问控制</title>
      <link>/posts/2019/ivar_access_control_in_obj-c/</link>
      <pubDate>Sat, 30 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/ivar_access_control_in_obj-c/</guid>
      <description>Date Notes     2019-03-30 gcc, clang; macOS 10.14.2   2019-04-29 完善 @package    Preface Obj-C 中的成员变量，即 Instance Variables，简称为 ivar。在面向对象的概念中，一个类的对外暴露决定了其所提供的能力，对子类则需要提供一定的扩展性，但有些时候我们不希望外界甚至子类知道一些细节，这时就用到了访问控制（Access Control）。在 C++、Java、Swift 等大多数高级语言中都有这样的概念，这次就来谈谈 Obj-C 中成员变量和类的访问控制。
访问控制修饰符 @public @interface Computer : NSObject { @public NSString *_name; } @end @implementation Computer @end Computer *cpt = [[Computer alloc] init]; cpt-&amp;gt;_name = @&amp;quot;My PC&amp;quot;; NSLog(@&amp;quot;%@&amp;quot;, cpt-&amp;gt;_name); // OUTPUT: // My PC  声明为 @public 的成员变量是访问控制中开放范围最大的，其允许外界可以直接访问到（当然，前提是引入包含该类的头文件）。需要注意的是，在类声明中的属性（@property），系统会自动为我们创建一个 _ 开头的成员变量，这个成员变量的可见程度也默认 @public。</description>
    </item>
    
    <item>
      <title>iOS 中的 KVC</title>
      <link>/posts/2019/kvc_in_ios/</link>
      <pubDate>Mon, 25 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/kvc_in_ios/</guid>
      <description>Date Notes     2019-03-25 首次提交    Preface KVC，即 Key-Value Coding，译作键值编码（下文简称 KVC）。当对象兼容 KVC 时，可以通过统一的 API 访问对象中某个键对应的属性值。Cocoa 中的许多功能都依赖 KVC，比如，KVO、Cocoa 绑定机制、Core Data、以及 AppleScript 等。本文将主要探讨 KVC 及其本质相关，关于其它的内容可参考文末的「Reference」。
Basics How #import &amp;lt;Foundation/Foundation.h&amp;gt; @interface Speaker : NSObject @property (nonatomic) int volume; @end @implementation Speaker @end @interface Computer : NSObject @property (nonatomic) NSString *name; @property (nonatomic) NSArray *speakers; @end @implementation Computer @end int main(int argc, const char * argv[]) { @autoreleasepool { Computer *cpt = [[Computer alloc] init]; // ➡️ 通过 setter 设置 [cpt setName:@&amp;quot;My Mac 1&amp;quot;]; // ➡️ 通过 getter 读取 NSLog(@&amp;quot;name from getter - %@&amp;quot;, [cpt name]); // ➡️ 通过 setValue:forKey: 设置 [cpt setValue:@&amp;quot;My Mac 2&amp;quot; forKey:@&amp;quot;name&amp;quot;]; // ➡️ 通过 valueForKey: 读取 NSLog(@&amp;quot;name from KVC - %@&amp;quot;, [cpt valueForKey:@&amp;quot;name&amp;quot;]); Speaker *s1 = [[Speaker alloc] init]; s1.</description>
    </item>
    
    <item>
      <title>Obj-C 中的重载与重写</title>
      <link>/posts/2019/override_and_overload_in_obj-c/</link>
      <pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/override_and_overload_in_obj-c/</guid>
      <description>Date Platform     2019-03-20 macOS 10.14.2    Preface 重载（Overload）和重写（Override）是面向对象语言中十分基本的两个概念，本文将谈谈 Obj-C 中的重载与重写。
重载  In some programming languages, function overloading or method overloading is the ability to create multiple functions of the same name with different implementations. Calls to an overloaded function will run a specific implementation of that function appropriate to the context of the call, allowing one function call to perform different tasks depending on context.</description>
    </item>
    
    <item>
      <title>Obj-C 中的对象</title>
      <link>/posts/2019/objects_in_obj-c/</link>
      <pubDate>Mon, 18 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/objects_in_obj-c/</guid>
      <description>Date Notes Source Code     2019-03-18 首次提交 objc4-750    对象的分类 Obj-C 中的对象，主要有三种，实例对象（Instance Object）、类对象（Class Object）、以及元类对象（Meta-class Object）。类对象和元类对象的类型均为 Class，即 typedef struct objc_class *Class;，所以它们的结构其实是一致的，只是存放的内容不同。
定义一个继承自 NSObject 的 Computer 类，方便后续的 Demo。
// EDdeviceProtocol 协议 @protocol EDdeviceProtocol - (void)powerOn; @end // Computer 类，继承自 NSObject，遵守 EDdeviceProtocol @interface Computer : NSObject &amp;lt;EDdeviceProtocol&amp;gt; { // 成员变量 @public int _memorySize; int _diskSize; } // 属性 @property (copy) NSString *model; // 实例方法 - (void)print:(NSString *)content; // 类方法 + (NSString *)arch; @end @implementation Computer - (void)print:(NSString *)content { NSLog(@&amp;quot;Print Content: %@&amp;quot;, content); } // 协议方法 - (void)powerOn { NSLog(@&amp;quot;Start.</description>
    </item>
    
    <item>
      <title>iOS 中的 KVO</title>
      <link>/posts/2019/kvo_in_ios/</link>
      <pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/kvo_in_ios/</guid>
      <description>Date Notes     2019-03-13 首次提交    Preface KVO 即 Key-Value Observing，译作键值监听（下文简称 KVO），通常用于监听对象的某个特定属性值的变化。本文将由浅入深，谈谈 iOS 中的 KVO。
How #import &amp;quot;ViewController.h&amp;quot; @interface Computer : NSObject @property (nonatomic, assign) int buttonClickTimes; @end @implementation Computer @end @interface ViewController () @property (nonatomic, strong) Computer *cpt; @end @implementation ViewController - (Computer *)cpt { if (!_cpt) { _cpt = [[Computer alloc] init]; // ➡️ 为 cpt 属性的键路径 buttonClickTimes 增加监听者 self（该控制器） // options 决定监听者将同时接收到新值和旧值 // context 决定附带的上下文信息「ViewController-buttonClickTimes」。 [_cpt addObserver:self forKeyPath:@&amp;quot;buttonClickTimes&amp;quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@&amp;quot;ViewController-buttonClickTimes&amp;quot;]; } return _cpt; } - (void)dealloc { // ➡️ 在监听者销毁前将其移除 [self.</description>
    </item>
    
    <item>
      <title>iOS 中的 NSObject</title>
      <link>/posts/2019/nsobject_in_ios/</link>
      <pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/nsobject_in_ios/</guid>
      <description>Date Notes Source Code     2019-03-13 首次提交 objc4-750、libmalloc-166.220.1、glibc-2.29    NSObject 实例对象的大小 // NSObject Obj-C -&amp;gt; C NSObject_IMPL struct NSObject_IMPL { Class isa; }; // 指向 objc_class 结构体的指针 typedef struct objc_class *Class;  将 Obj-C 源码通过 clang -rewrite-objc 翻译为 C++（其实大部分为 C），可以发现 Obj-C 中的 NSObject 类其实就是 C 中的 NSObject_IMPL 结构体，其中只有一个成员变量，即 isa。isa 的类型是 Class，本质是一个指向 objc_class 结构体的指针。在 64 位系统中，指针占用 8 个字节（Byte），即 NSObject 的实例对象大小应该为 8 个字节。我们也可以尝试用 C 语言中的 sizeof() 运算符来证明这一点：</description>
    </item>
    
    <item>
      <title>iOS 多线程技术实践之 pthreads</title>
      <link>/posts/2019/multithread_techs_in_ios-1/</link>
      <pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/multithread_techs_in_ios-1/</guid>
      <description>Date Notes Swift Xcode     2019-03-08 首次提交 4.2 10.1     在 iOS 中的多线程（Multithreading）技术通常有以下几种实现方式：pthreads、NSThread、GCD、NSOperation。首先，我们来一起看一看 pthreads。
 Preface  POSIX Threads, usually referred to as pthreads, is an execution model that exists independently from a language, as well as a parallel execution model. It allows a program to control multiple different flows of work that overlap in time. Each flow of work is referred to as a thread, and creation and control over these flows is achieved by making calls to the POSIX Threads API.</description>
    </item>
    
    <item>
      <title>Objective-C 与 Swift 桥接中的坑</title>
      <link>/posts/2019/obj-c_swift_bridge_tips/</link>
      <pubDate>Thu, 17 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/obj-c_swift_bridge_tips/</guid>
      <description>Date Notes     2019-01-17 添加「Optional 与 Nullability」
添加「NSNotificationName 与 Notification.Name」    Preface Objective-C 与 Swift 的混编是全面转向 Swift 中的必经之路，本篇即是这一过程中的踩坑「真实」记录。
Optional 与 Nullability  Swift 4.2  在大多数项目中，我们都是在中途决定转向 Swift，Swift 中比较核心且常见的概念便是 Optional，可选类型，而这与 Obj-C 中的概念不大相同。在 Swift 中使用 Obj-C 桥接的属性（特别是 Block）时，尤其要注意：Obj-C 默认属性将被转换为隐式解包类型（SomeClass!），而在 Swift 中这代表开发者要保证值不为 nil，编译器将不再提示。当属性是 Block 时，若直接调用了为 nil 的 Closure 时，将会出现崩溃。
   Obj-C Usage Swift     nullable 可空 SomeClass?   nonnull 不可空 SomeClass   null_unspecified 未指定是否可空（默认） SomeClass!</description>
    </item>
    
    <item>
      <title>2018 年「终」总结</title>
      <link>/posts/2018/year_plan/</link>
      <pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/year_plan/</guid>
      <description>今天是 2018 年 12 月 10 日，一年前的昨天，我从家里坐高铁到达了北京。还记得那天晚上，两个同学来火车站接我，我们一起坐公交去他们在昌平沙河的培训宿舍。一天的奔波加上本来就晕车的我，在公交行驶过高速后就难受的不行，不得不下车休息片刻。
不像刚到上海的时候，没有工作的压力，充满着一些生活的气息。而来到北京就是为了实习，为了工作。虽然目的性更强，但也让我不得不更快地融入这个环境，而没时间去慢慢感受。我是北方人，北京更加令我熟悉，但却总感觉不如上海能带给我的新鲜感。从在北科的宿舍到确定现在住的地方，我一共搬了四次家，最终选择了公司附近但价格相对较高的房间。虽然房租已经逼近当时我的实习工资，但这一年我认为这个投资还是非常值得的，毕竟时间的价值更难以衡量。
在北京实习的日子里，去北大参加了比赛，又回到学校拍了毕业照，再辗转到长沙比赛，又去武汉听了音乐会，回了趟家，最后又返回了北京，正式加入了现在的团队。
在北大的比赛，让我感受到我和这些名校学生的差距并没有想象中的遥不可及，当然我不是说差距不明显而是觉得自己有了信心。当然我也羡慕他们拥有如此丰富的资源，也坚定了我会再去读研的决心。虽然比赛最后的名次并不是很靠前，但和北大学长学姐、北航浙大学弟的这次友谊和合作，令我倍感幸运。
北大比赛结束的第二天，我便一早乘坐高铁回学校，准备再见见大学的同学们，拍拍毕业照。班长为了等我，特意将聚餐时间往后推迟了一日。所以很遗憾有些同学因为工作等原因提早回去，只得有缘再见。在大学的四年里，我担任学委，和大学同学们的相处甚至要好过于高中同学。当然，不得不说毕业聚餐后发生了一些事情，也许是这辈子都不会忘记的事情吧&amp;hellip;虽然学校只是个很普通的二本，这四年也发生了很多事情，但一些老师和这些同学们却让我不后悔来到这里。
要想放下一些事情，就得让自己忙起来。忙完大学生涯最后的篇章，便又启程去了长沙，这次的比赛地点是在长沙的超算中心。说实话，这次的比赛因为没有很好的构思，只能很简单地做了个 Demo，效果也非常一般。这次的比赛是面向华中地区，相较于在上海和北京的比赛，能明显感受到一些差距，但也越发发现这类比赛的作品其实存在着很高的重复性。最后因为赶音乐会的时间紧迫，没能在长沙逗留一段时间，仅有的一丝印象也是一座非常干净、轻松的城市。
离开长沙，坐上高铁，奔向武汉。去武汉的理由很简单，只是在复旦比赛认识的队友多买了一张音乐会的票，于是就随他去了。因为通宵比赛，加上路途奔波，我已经非常疲倦，但这次音乐会对于我个人感受至深。我们还年轻，生活不应该只是对着电脑、手机，生活纵然有不易，但也是如此的丰富多彩。也没有来得及注意武汉，但确实也是一座非常发达的城市。
享受完音乐会，便又马不停蹄地踏上回家之途。其实原本打算是直接回北京，但想到工作之后回家似乎就不那么自由，便还是决定回家一趟。出门久了才知道，什么都抵挡不过父母做的一顿饭，只是这次在家呆不了太久，便又要踏上北上之途。
回京之旅和以往不同，是因为买到了比高铁还要便宜的机票，人生中第一次乘坐了飞机。可能洛阳坐飞机的人并不多，飞机也并没有我想象中那么大，不过飞机起飞加速时的推背感却让我感到很过瘾。
这一年真的是非常丰富的一年，除了上面这一段游记，年初的时候在北京陪韩国留学放假回来的好友在北京玩了几天，看了升旗，逛了故宫，也了解了航天与航空的差异（笑）；在北京去了 Apple Store，和北京的小朋友一起上了 Today at Apple，感受了苹果新的零售哲学；六月中旬去了清华，和来上科大宣讲的外籍教授一对一讨论了 Robotistic（机器人学），也认识了上科大优秀的博士生；第一次正式加入一家公司；主动和团队里的人去美团总部交流技术；在新员工培训中拿到了第一名；周末和同学第一次爬了长城；第一次被拉去蹦了野生迪&amp;hellip;
当然，一年再怎么精彩，也依然会有遗憾。对于那些可以在未来弥补的遗憾，就放在之后的计划中吧，对于那些无法弥补的，就让它过去吧。感谢 2018 年，也感谢这一年遇到的所有人，辗转多地也遇到很多可爱的人。最后，也感谢自己。幸运，总是留给有准备的人。2019，加油！
V.
提笔于 2018.12.10，完结于 2018.12.11 晚；北京
后记 原本以为 2018 年就会如此过去，却没曾想到在最后一周又发生了很多事情。倒数第二周的周末，听闻公司「优化」的消息，又一次下载了脉脉。传言言之凿凿，又加上我还未转正，简直是「性价比」之选。其实工作了一年，确实感觉辛苦，不如学生时代的自由和悠闲。虽然有了所得，但失去的更多。所以如果被「优化」，我就准备先回学校把驾照考完，再去想想自己真正热爱的事情，其实我一直有想法要亲自打造一款产品，那么我想就是时候去做了。
当然，结果是我并没有被「优化」，打造产品的计划又被耽搁了，而让我痛心的是和我一起入职的好几个小伙伴们被「优化」。工作这一年，越发认识到社会上的人久而久之都会变得「油腻」，而这些刚从校园里出来的孩子们却没有社会上的浮躁气息，失去这些同事实在令我可惜。真心希望他们能找到更好的去处，也希望我们友谊长存，也希望我自己能保持初心。
2018 年从实习，到公司被收购，入职，涨薪，裁员，这些经历都让我学习到很多。其实这种「优化」和个人能力的相关性很低，而和个人所在的业务关联性很大。之前总是天真地以为技术是唯一，其实现在才发现，技术只是基本功，个人的能力绝不能仅仅只在技术能力上体现，而是需要全方位的修炼。
2018 年总归要过去，虽然在 2018 年的尾巴上又重新加回了一位好友，也简单地聊了几句，但深感有些事情却再也不会回去了。
Yesterday is history, tomorrow is a mystery, today is God&amp;rsquo;s gift, that&amp;rsquo;s why we call it the present. - Joan Rivers
V.
后记于 2019.01.03 午</description>
    </item>
    
    <item>
      <title>谈谈 iOS 中的 dyld_shared_cache</title>
      <link>/posts/2018/dyld_shared_cache/</link>
      <pubDate>Sun, 14 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/dyld_shared_cache/</guid>
      <description>Date Notes Source Code     2018-12-12 补充 dyld_shared_cache 路径来源 system_cmds-805.220.1   2018-10-14 首次提交 dyld-551.4    What iOS &amp;amp; macOS 作为操作系统，其中内置了许多系统库（Library）。dyld_shared_cache，即动态库共享缓存。自 iOS 3.1 后，所有系统动态库被集合成一个 dyld_shared_cache 文件，以提升性能。当然，macOS 也有 dyld_shared_cache，比较特别的是可以通过 update_dyld_shared_cache 更新。
How 为了研究 dyld_shared_cache，首先要找到其存在的路径。可以在 Apple 开源的 system_cmds 中 dyld_shared_cache.c 文件中发现，其分别存放在 macOS 和 iOS 中的路径。
macOS 上的 dyld_shared_cache 和 iOS 不太相同，每种架构额外对应了一种 .map 文件。因为本文着重在于 iOS，读者想要了解 macOS 相关可以在 system_cmds 中自行检索。
dyld_shared_cache 存在于 iOS 设备的 /System/Library/Caches/com.apple.dyld/ 目录。文件名即为 dyld_shared_cache_arm* 加上对应的架构编号。</description>
    </item>
    
    <item>
      <title>iOS 项目持续集成实践（一）</title>
      <link>/posts/2018/ci_practice_in_ios-1/</link>
      <pubDate>Sat, 07 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/ci_practice_in_ios-1/</guid>
      <description>Preface 一个软件工程项目从编写、到测试、再最终交付到用户通常有很多重复且固定的步骤。虽然作为开发者，我们的核心任务是编写代码，而这些其他的步骤却也不能忽视，持续集成（Continuous Integration）则可以帮助开发者完成这些琐碎的事务，提升团队的开发效率与质量。
本文将主要介绍持续集成是什么，以及其中的好处。当然，您可能也注意到了标题后面「（一）」，没错，持续集成并非一篇文章可以概括，笔者希望尽可能将目前团队中使用到的和持续集成相关的内容进行总结，目的是为了让大家一起思考如何让持续集成更好地服务我们开发。当然，限于笔者能力，文中不免出现遗漏，也望读者能够批评和指出。
What 持续集成，译自 Continuous Integration，简称 CI（在下文中，将统一使用该英文简称）。在 Wikipedia 中，也有针对 CI 特别详细且专业的介绍。简而言之，当开发者通过版本控制系统（例如 Git）提交了代码，CI 系统将为其自动执行构建、分析、测试等服务，当前面的服务一致通过，其也能直接将产品部署到生产环境，而后进入下一个循环。其中每一步都将自动触发、执行，结果也将会自动反馈回开发者。正如下图所示，CI 的重点在于 C——持续。
Why &amp;amp; Why not 那么为什么需要 CI 呢？相比于传统的先开发，再测试，后上线的模式有哪些好处呢？在团队使用 CI 这段时间中，得出了以下主要两个好处：
 及时发现错误。CI 并不能消除错误，但 CI 将发现错误的时机尽可能地提前，所以也更加节省时间来改正错误。当开发者提交代码至代码仓库时，其对于代码的熟悉程度是最高的。如果这个时候尽可能的纠正一些错误或不当，开发者将能很快注意到并将错误改正，避免了由于时间或者团队中其他人对于代码的修改所导致的问题，提升了开发效率。 自动化。市面上的 CI 平台都给了开发者比较高的自由度，能够执行脚本或命令。因此很多自动化的操作都可以制定好，来自动化地执行，节省开发者的时间。  如果这两个显而易见的好处还不足以说服，可以参考文末 Reference 中 EKATERINA NOVOSELTSEVA 的文章。那么 CI 会不会也存在什么难处呢？
 跨技术栈。CI 并不特定于前端或者后端，CI 通常根据不同的平台而有很多不同，包括配置的方法、使用的语言、自由度等等。CI 又和 Docker 的发展有一定的关系，因此跨技术栈可能让一些团队望而却步。不过好的是，DevOps（Development &amp;amp; Operations）也在国内渐渐兴起，越来越被重视。 跨平台。这里所指的平台是指代码托管平台、CI 平台、以及部署平台。在公司开始时，可能并不能轻易考虑到后续的发展，因此在原有平台加入 CI 可能需要跨平台的协作。对于一些「黑盒」的平台，有时便难以很好的集成。不过，现在 Git 的两大平台 GitHub 和 GitLab 都很重视且支持 CI 平台，也便于开发者使用。  如果后面两个问题并没有阻挠你，那么就开始尝试 CI 吧～
How CI 并不依赖于某种特定的技术栈，其属于一种编程范式。但是，具体谈及如何实践，这就需要结合不同的工具和业务，进行定制。</description>
    </item>
    
    <item>
      <title>在 Swift 中对集合类型元素的弱引用</title>
      <link>/posts/2018/weakly_collections/</link>
      <pubDate>Thu, 08 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/weakly_collections/</guid>
      <description>Date Notes Swift Xcode     2018-03-15 更新部分表述，并将题目扩展至集合类型 4.0 9.2   2018-03-08 首次提交 4.0 9.2    Preface 为了方便下述 Demo，这里定义一个 Pencil 类，并会使用 func CFGetRetainCount(_ cf: CoreFoundation.CFTypeRef!) -&amp;gt; CFIndex 方法，即传入一个 CFTypeRef 类型的对象即可获取其引用计数。什么是 CFTypeRef？查阅官方文档即可得知 typealias CFTypeRef = AnyObject，所以 CFTypeRef 其实就是 AnyObject。而 AnyObject 又是所有类隐含遵守的协议。
class Pencil { var type: String var price: Double init(_ type: String, _ price: Double) { self.type = type self.price = price } } CFGetRetainCount(Pencil(&amp;quot;2B&amp;quot;, 1.</description>
    </item>
    
    <item>
      <title>Swift 中的 @autoclosure</title>
      <link>/posts/2018/swift_autoclosure/</link>
      <pubDate>Sat, 13 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/swift_autoclosure/</guid>
      <description>Date Notes Swift Xcode Source Code     2018-04-05 更新并明确源代码所用版本 4.1 9.3 Swift 4.1 Release   2018-01-13 首次提交 4.0.3 9.2 -    What  Closures are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.
— The Swift Programming Language (Swift 4.</description>
    </item>
    
    <item>
      <title>浅谈 iOS 应用启动过程</title>
      <link>/posts/2017/ios_app_start_up/</link>
      <pubDate>Tue, 28 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/ios_app_start_up/</guid>
      <description>Date Notes Swift Xcode     2017-05-26 CS193p UIApplication 3.1 8.3.2   2017-03-28 首次提交 3.0 8.2.1    Preface 首先要感谢没故事的卓同学大大送的泊学会员，在泊学学了几节课，了解了很多不同角度的 iOS 开发知识。这篇文章就启发自其 iOS 101 中的一个纯手工的 Single View Application 一文。但本文将更加深入的叙述了启动过程，且实现均为 Swift 3.0。
本文对应的 Demo 可以在：https://github.com/kingcos/SingleViewAppManually-Demo 查看、下载。
Manually or Storyboard main.m in Objective-C Single View Application
#import &amp;lt;UIKit/UIKit.h&amp;gt; #import &amp;quot;AppDelegate.h&amp;quot; int main(int argc, char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } }   自从 Storyboard 诞生以来，关于纯代码、Xib、以及 Storyboard 的选择就在 iOS 开发圈中炸开了锅。这里不会探讨各种姿势的优劣，只是可能很多和我一样的初学者，从一开始就被 Storyboard 先入为主。加上方便灵活的拖控件，自然而然就可能没有机会去思考一个 iOS 应用是如何启动起来的。加上 Swift 的诞生，使得整个项目的初始结构得到了更大的简化（少了 main.</description>
    </item>
    
    <item>
      <title>从 0 开始使用 Docker 快速搭建 Hadoop 集群环境</title>
      <link>/posts/2017/docker_for_hadoop/</link>
      <pubDate>Mon, 27 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/docker_for_hadoop/</guid>
      <description>Date Notes Hadoop Other     2017-03-27 首次提交 2.7.2 Docker CE, IntelliJ IDEA 2016.3    Preface 自从学习 iOS/Swift 以来，就没有太多时间分配给 Java 专业课，毕竟我不是个三心二用还能样样学好的人。不过作为大三的专业课，分布式计算技术还是有去上课的，毕竟不能最后挂科吧 :]
曾有人说，「开发一个项目，至少有 50% 时间在配置环境」。确实，在折腾了三周的课时之后，我才按照老师给的详细步骤配置好 Hadoop 的环境。尽管如此，由于种种原因，班里仍有很多同学还没有配置好 Hadoop 的环境，导致课程一直停滞。在偶然中，我想到了 Docker，Docker 这个词我至少在半年前已经听说（当然，恕我孤陋寡闻，Docker 早在 13 年即发行），但一直没有去了解和使用。时至今日，我对 Docker 的了解也十分少，简单的来说，Docker 是一种容器（Container）管理工具，通过 Docker 我们可以配置可移植的环境，方便发布。Docker 基于 Linux，但也提供了 macOS 和 Windows 桌面版，方便在我们的本地机器测试、使用。
虽然本文是一个小白向的文章，但下载和安装的过程也不会在本文涉及。一是官方网站必然提供了相应的教程，纯粹的翻译毫无意义；二是下载和安装可能随着后续更新发生略微的区别，而本文只着眼于配置 Hadoop 集群环境的搭建。
不过由于个人对 Hadoop 和 Docker 的了解甚少，如有错误，希望指出，我会学习、改正。
Linux  Info: Ubuntu 16.10 x64   Docker 本身就是基于 Linux 的，所以首先以我的一台服务器做实验。虽然最后跑 wordcount 已经由于内存不足而崩掉，但是之前的过程还是可以参考的。</description>
    </item>
    
    <item>
      <title>探究 UIViewController 生命周期</title>
      <link>/posts/2017/uiviewcontroller_life_cycle/</link>
      <pubDate>Fri, 10 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/uiviewcontroller_life_cycle/</guid>
      <description>Date Notes Swift Xcode     2017-03-10 首次提交 3.0 8.2.1    前言 对象的生命周期一直是开发者所需要关心的，教授 CS193p 的老师 Paul 也详细的讲述了 UIViewController 的生命周期。为了记述这一过程，故作此文。由于 Xcode 提供了纯代码和 Storyboard（Xib 同理）两种布局 UI 的方式，因此初始化部分略有不同。
为了方便观察，我创建了一个 BaseViewController，继承自原本的 UIViewController，重写其中的生命周期方法，并让后续新的控制器继承自该控制器，以便观察。
本文对应的 Demo 可以在 https://github.com/kingcos/UIViewController-UIView-LifecycleDemo 查看、下载。
Initialization Storyboard  OUTPUT:
 init(coder:) awakeFromNib()   init(coder:)  当使用 Storyboard 时，控制器的构造器为 init(coder:)。 该构造器为必需构造器，如果重写其他构造器，则必须重写该构造器。 该构造器为可失败构造器，即有可能构造失败，返回 nil。 该方法来源自 NSCoding 协议，而 UIViewController 遵从这一协议。 该方法被调用意味着控制器有可能（并非一定）在未来会显示。 在控制器生命周期中，该方法只会被调用一次。  awakeFromNib()  当使用 Storyboard 时，该方法会被调用。 当调用该方法时，将保证所有的 outlet 和 action 连接已经完成。 该方法内部必须调用父类该方法，虽然默认实现为空，但 UIKit 中许多类的该方法为非空。 由于控制器中对象的初始化顺序不能确定，所以构造器中不应该向其他对象发送消息，而应当在 awakeFromNib() 中安全地发送。 通常使用 awakeFromNib() 可以进行在设计时无法完成的必要额外设置。  Code  OUTPUT: - init(nibName:bundle:) - NibName: nil, Bundle: nil</description>
    </item>
    
    <item>
      <title>Swift 中的 Selector</title>
      <link>/posts/2017/swift_selector/</link>
      <pubDate>Tue, 31 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/swift_selector/</guid>
      <description>Date Notes Swift Xcode     2017-01-31 首次发布（简书 &amp;amp; 掘金） 3.0 8.2.1    Preface  Focus，即专注。笔者希望可以尽力将一些不是那么透彻的点透过 Demo 和 Source Code 而看到其本质。由于国内软件开发仍很大程度依赖国外的语言、知识，所以该博客中的术语将使用英文表述，除非一些特别统一的词汇或整段翻译时将使用中文，但也会在首次提及时标注英文。笔者英文水平有限，这样的目的也是尽可能减少歧义，但在其中不免有所错误，遗漏，还请大家多多批评、指正。
本文及更新会首发于笔者的 GitHub 的 Perspective 仓库：https://github.com/kingcos/Perspective，欢迎 Star 🌟。
 What 常用纯代码来开发的同学都应该比较熟悉这个方法：
func addTarget(_ target: Any?, action: Selector, for controlEvents: UIControlEvents)  Selector 源自 Objective-C，例如 SEL 类型，以及 @selector() 方法选择器。Swift 中也兼容了这个概念，不过随着 Swift 的迭代，Selector 的一些写法也出现了很大的变化。比较遗憾的是，官方文档对于 Selector 没有介绍。
因此只能自己总结一下 Swift 3.0 中的 Selector，便有利于自己理解，也便于以后的参考。注：以下 Demo 中的 cyanButton 是用 StoryBoard 拖拽的。</description>
    </item>
    
    <item>
      <title>浅谈 Swift 中的属性（Property）</title>
      <link>/posts/2016/swift_properties/</link>
      <pubDate>Wed, 26 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/2016/swift_properties/</guid>
      <description>Date Notes Swift Xcode     2017-04-27 扩充 #延迟存储属性# 部分并新增 #devxoul/Then# 3.1 8.3.2   2016-10-26 首次提交 3.0 8.1 Beta 3    前言 Swift 中的属性分为存储属性与计算属性，存储属性即为我们平时常用的属性，可以直接赋值使用，而计算属性不直接存储值，而是根据其他（存储）属性计算得来的值。
在其他面向对象的编程语言中，例如 Java 和 Objective-C 中，get 和 set 方法提供了统一、规范的接口，可以使得外部访问或设置对象的私有属性，而不破坏封装性，也可以很好的控制权限（选择性实现 get 或 set 方法）。而 Swift 中似乎并没有见到类似的 get 和 set 方法，而 Swift 使用了一种名为属性观察器的概念来解决该问题。
本文简单介绍下 Swift 中的这两种属性，以及属性观察器。
延迟存储属性  存储属性使用广泛，即是类或结构体中的变量或常量，可以直接赋初始值，也可以修改其初始值（仅指变量）。 延迟存储属性是指第一次使用到该变量再进行运算（这里的运算不能依赖其他成员属性，但可以使用静态／类属性）。 延迟存储属性必须声明为 var 变量，因为其属性值在对象实例化前可能无法得到，而常量必须在初始化完成前拥有初始值。 在 Swift 中，可以将消耗性能才能得到的值作为延迟存储属性，即懒加载。 全局的常量和变量也是延迟存储属性，但不需要显式声明为 lazy（不支持 Playground）。  Demo  这里假定在 ViewController.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>iOSer/Swifter/DevOps/Full-stacker
👨🏻‍💻 at MTDP · Mobike
 For more:
 GitHub&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;· @kingcos Twitter&amp;nbsp;&amp;nbsp;&amp;nbsp;· @kingcos_v Instagram&amp;nbsp;· @kingcos_v  Blog &amp;amp; Theme:
 Blog&amp;nbsp; by Hugo Theme by panr   </description>
    </item>
    
    <item>
      <title>Links</title>
      <link>/links/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
      
      <guid>/links/</guid>
      <description> Here are my friends blogs or websites:  Daily Growing · by Zansy  </description>
    </item>
    
    <item>
      <title>Perspective</title>
      <link>/perspective/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
      
      <guid>/perspective/</guid>
      <description>Think with perspectives.
&amp;ndash; kingcos
  2019.04.25  「面向实现编程」 昨天在和同事沟通一个问题时，他提出了「个人觉得内测调试功能应该通过「面向实现编程」来落地」的说法，这里先简单说一下上下文。我们需要在调试阶段，使用一个 Debug 库提供的功能，因此该部分代码最终并不会上线。我所采取的做法是，首先引入了该库，并使用其对外暴露的 API 进行调用。
引入并调用是大多数库所使用的基本逻辑，而他所说的「面向实现编程」意思是针对调试阶段的库，与具体业务没有关系，那么就不推荐直接引入并调用 API，而通过运行时（Runtime）等其他非耦合方式会更加适合。松耦合的方式虽然存在一定的风险，但是因为该部分生而为调试，并不会干扰线上代码，影响产品质量；而这样做降低了调试库与业务等组件之间的耦合度，使得调试库本身更加灵活。对于这些调试库，也要「在设计的时候就得沿着松耦合的使用方式来做才对（比如基于数据交互的，比如基于应用内请求的，比如基于 Runtime 的）」，而「依赖 API 来做是比较紧的耦合」。
对于不同的库，由于其最终面向的用户不同而应当采用不同的设计思路，当作为基础能力的库，应当暴露完整的 API，隐藏内部细节，供外界正常使用；而对于调试的库，由于面对的其实是开发者，那么应当不与其他模块耦合，或许才更加合理。
 2019.01.20  Thought - 20190120 在基础建设还不完善的时候，需要很多的搬砖劳工来献身建设；当建设到一定规模后，觉得以前的建筑不满足现在的需要，就可能推到重建。
所以越来越认识到，Programmer 其实基本上是金字塔最底层的，大部分任务是需要将 PRD 实现即可，而不需要也关心不到业务本身。只会去抱怨又改需求，而不知道为什么要改需求。然而技术只是手段，其门槛会越来越低，人会越来越多，泡沫也会变大。所以未来一定有新的工业革命来解放这些人的生产力了。不过，仔细想一想，解放生产力对谁来说是好事？
所以想想 996，周末加班的「现代互联网」企业和以前黑心的包工头有什么区别呢？他们不怕没有人来，所以即使你没有去，也有人去。所以这些最基本的东西也在一步步沦丧。
突然发现很多事情可以类比，我们在写代码的时候，在重复使用一个相同或相似输入输出的代码段时，久而久之，我们就会去把这段代码封装成函数，为了满足更多的需要，就会对其进行一定的抽象，之后我们就可以只调用这个函数，而不需要冗长又针对特定业务的代码段。其实生活、历史中的有些事情也是同理的。
 2018.08.05  Thought - 100 個基本 今天偶然间走进了一家书店，在畅销书中摆着几本《100 个基本》，便随手翻看了起来。对其中的内容倒不是非常印象深刻，而是挺喜欢这种形式：书中一页简单写着一句基本信条，而另一页简单地阐述了对其的思考。
正如松浦弥太郎这些基本，我们也可以简单地树立自己的信条，不断遵守，不断修正，不断美好。
 001. 每天早上，备一份早餐，开始一天；每天晚上，读几页书，结束一天。   生活中不是所有事情，都必须要有意义。正如吃了饭总会饿，读了书总会忘，人活着总会死。所以，面对生活也说一句「いただきます（我要开动啦）」吧～
  002. 提前一点，而不是推迟一点。   熬夜、晚起，有时候其实并不是「生物钟」，而是习惯了推迟、拖延。不要等待，不要犹豫，任何事情都提前一点，做好准备吧，该来的总会来，不如迎头赶上呢～
  2018.07.27  Thought - 人生の目覚める 为什么突然用日语当标题了呢？是因为我突然想起「觉醒」这个词，感觉其日语似曾相识。</description>
    </item>
    
    <item>
      <title>Words</title>
      <link>/words/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
      
      <guid>/words/</guid>
      <description>⚠️ Extremely subjective, no values, irresponsible, and none sense words. ⚠️
「宁可信其有，不可信其无」这句话成了很多人探求真相的绊脚石。
 2019.04.30  筷子和刀叉能让不同习惯的人吃上饭，也可以看作解决了问题。那么为什么西餐不提供筷子呢？因为并不是所有时候都要解决问题。或者说，并不是要解决单纯地吃饭问题。
 N.M. 2019.04.30  </description>
    </item>
    
  </channel>
</rss>