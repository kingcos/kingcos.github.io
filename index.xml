<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>iBlog</title>
    <link>/</link>
    <description>Recent content on iBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 17 Apr 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>iOS 中的 &#43;load 方法</title>
      <link>/posts/2019/&#43;load_in_ios/</link>
      <pubDate>Wed, 17 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/&#43;load_in_ios/</guid>
      <description>Date Notes Source Code     2019-04-17 首次提交 objc4-750    Preface 在 Obj-C 中，我们经常会使用 +load 方法来做一些早于所有类被使用时机的操作。比如方法交换（Method Swizzle）、注册路由（Router）等。那么 +load 到底是在什么时机调用的呢？+load 滥用的后果又是什么呢？
What // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { + (void)load; }  Obj-C 中的 +load 方法指的是 NSObject 中的 + (void)load 类方法。官方文档的 +load 如下：
 Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</description>
    </item>
    
    <item>
      <title>iOS 项目持续集成实践（二）</title>
      <link>/posts/2019/ci_practice_in_ios-2/</link>
      <pubDate>Wed, 17 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/ci_practice_in_ios-2/</guid>
      <description>Preface 自从「iOS 项目持续集成实践（一）」发布之后，发生了很多事情，原本计划持续更新的系列文章也因此没有更新。这次我将重拾该系列，本篇的围绕核心为「使用 GitLab Runner 搭建 CI」。
What 由于我们目前使用的 Git 托管平台是公司内部的 GitLab EE，所以为了更加容易集成且统一化，选择了 GitLab CI。为了能将 CI 的状态更加好的兼容 GitLab，我们选择了 GitLab Runner 作为容器执行一些代码检查、图片压缩的任务。
How 环境搭建 为了使用 GitLab Runner，我们需要先配置一下环境。因为我们是针对 iOS 项目的 CI，必须使用 macOS 系统的机器，因此我们选择的 CI 机器是一台 Mac Pro，并重装了目前最新版本的 macOS。
   Mac Pro Info     Version Late 2013   Processor 3.5 GHz 6-Core Intel Xeon E5   Memory 16 GB 1866 MHz DDR3   Storage 256 GB Flash Storage   System macOS 10.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Sun, 14 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>iOSer/Swifter/DevOps/Full-stacker
👨🏻‍💻 at MTDP · Mobike
 For more:  GitHub&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;· @kingcos Twitter&amp;nbsp;&amp;nbsp;&amp;nbsp;· @kingcos_v Instagram&amp;nbsp;· @kingcos_v   Powered by Hugo :: Theme made by panr</description>
    </item>
    
    <item>
      <title>Links</title>
      <link>/links/</link>
      <pubDate>Sun, 14 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/links/</guid>
      <description> Here are my friends blogs or websites:  Daily Growing · by Zansy  </description>
    </item>
    
    <item>
      <title>iOS 中的 Category</title>
      <link>/posts/2019/category_in_ios/</link>
      <pubDate>Sat, 13 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/category_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-04-16 优化结构 - -   2019-04-13 首次提交 objc4-750、xnu-4903.221.2 Category in iOS    Preface iOS 中的 Category 中文常译作分类、类别（为表述统一，本文将使用 Category 特指该技术）。我们经常会使用 Category 来对一个类进行扩展，使得在不破坏主类结构的同时可以具备更多的功能；也可以使用 Category 对一个类进行拆分，使得其结构更加清晰条理。本文将从 What - How - Why 谈谈 iOS 中 Category。
What 什么是 Category 呢？
Category 是 Obj-C 语言中所提供的一项功能，它可以为 Obj-C 类添加额外的属性、方法，也可以遵守其他协议。
Xcode 中已经为 Category 已经提供了模版来建立，只需要指定 Category 的名称以及被添加 Category 类名即可。当然，我们也可以手动来自己建立，Category 的语法与类的声明与实现比较类似：
@interface Foo (Bar) &amp;lt;SomeProtocol&amp;gt; - (void)foo; @end @implementation Foo (Bar) - (void)foo {} - (void)someMethodFromProtocol {} @end  How Category 通常都有哪些用处呢？</description>
    </item>
    
    <item>
      <title>Obj-C &amp; Swift 的类型内省与反射</title>
      <link>/posts/2019/type_introspection_and_reflection/</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/type_introspection_and_reflection/</guid>
      <description>Date Notes Swift Demo     2019-04-08 首次提交 4.2 Type Introspection and Reflection    Preface 许多编程语言中都有类型内省（又称自省，Introspection）和反射（Reflection）这两个概念，本文将探讨一下 Obj-C 和 Swift 中类型内省和反射的相关概念与具体使用。
What 维基百科中对于类型内省定义如下：
 In computing, type introspection is the ability of a program to examine the type or properties of an object at runtime. Some programming languages possess this capability.
Introspection should not be confused with reflection, which goes a step further and is the ability for a program to manipulate the values, meta-data, properties and/or functions of an object at runtime.</description>
    </item>
    
    <item>
      <title>Xcode 中的 Link Map 文件</title>
      <link>/posts/2019/link_map_file_in_xcode/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/link_map_file_in_xcode/</guid>
      <description>Date Notes Xcode Swift     2019-04-16 增加 Swift 项目 10.1 4.2   2019-04-01 首次提交 10.1 -    Preface Link Map File，译作链接映射文件（下文将称 Link Map 文件）。Xcode 在构建可执行文件之前，需要先编译为目标文件（Object File），并链接所需要的其他库，那么 Link Map 文件就记录了链接器（Linker）在链接过程中产生的一些信息，本文将谈谈这个文件的构成。
What Xcode 中默认是不会将 Link Map 文件在构建时暴露出来的，需要我们手动在「Build Settings」-「Write Link Map File」-「Yes」打开该写入该文件的设置。这样当我们再次编译项目，默认就可以在 ~/Library/Developer/Xcode/DerivedData/&amp;lt;TARGET_NAME&amp;gt;-&amp;lt;Random_ID&amp;gt;/Build/Intermediates.noindex/&amp;lt;TARGET_NAME&amp;gt;.build/Debug-&amp;lt;Device_Type&amp;gt;/&amp;lt;TARGET_NAME&amp;gt;.build/&amp;lt;TARGET_NAME&amp;gt;-LinkMap-normal-&amp;lt;Arch&amp;gt;.txt 中找到。如有更改 Link Map 文件路径的需求也可以在「Path to Link Map File」中更改。
举个例子，我的 DemoiOS 项目（Obj-C）中 Link Map 文件的完整路径为：/Users/kingcos/Library/Developer/Xcode/DerivedData/DemoiOS-hifhuapijabsaxgpelrpiwhbzlqv/Build/Intermediates.noindex/DemoiOS.build/Debug-iphonesimulator/DemoiOS.build/DemoiOS-LinkMap-normal-x86_64.txt。
How 下面来分析一下 Link Map 文件的构成。
Path # Path: /Users/kingcos/Library/Developer/Xcode/DerivedData/DemoiOS-hifhuapijabsaxgpelrpiwhbzlqv/Build/Products/Debug-iphonesimulator/DemoiOS.</description>
    </item>
    
    <item>
      <title>Obj-C 中成员变量和类的访问控制</title>
      <link>/posts/2019/ivar_access_control_in_obj-c/</link>
      <pubDate>Sat, 30 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/ivar_access_control_in_obj-c/</guid>
      <description>Date Notes macOS     2019-03-30 gcc, clang macOS 10.14.2    Preface Obj-C 中的成员变量，即 Instance Variables，简称为 ivar。在面向对象的概念中，一个类的对外暴露决定了其所提供的能力，对子类则需要提供一定的扩展性，但有些时候我们不希望外界甚至子类知道一些细节，这时就用到了访问控制（Access Control）。在 C++、Java、Swift 等大多数高级语言中都有这样的概念，这次就来谈谈 Obj-C 中成员变量和类的访问控制。
访问控制修饰符 @public @interface Computer : NSObject { @public NSString *_name; } @end @implementation Computer @end Computer *cpt = [[Computer alloc] init]; cpt-&amp;gt;_name = @&amp;quot;My PC&amp;quot;; NSLog(@&amp;quot;%@&amp;quot;, cpt-&amp;gt;_name); // My PC  声明为 @public 的成员变量是访问控制中开放范围最大的，其允许外界可以直接访问到（当然，前提是引入包含该类的头文件）。
@protected @interface Computer : NSObject { int _memorySize; @protected int _diskSize; } @end @implementation Computer @end @interface Mac : Computer - (instancetype)initWithDiskSize:(int)diskSize memorySize:(int)memorySize; - (instancetype)init NS_UNAVAILABLE; - (void)printDiskAndMemoryInfo; @end @implementation Mac - (instancetype)initWithDiskSize:(int)diskSize memorySize:(int)memorySize { self = [super init]; if (self) { _diskSize = diskSize; _memorySize = memorySize; } return self; } - (void)printDiskAndMemoryInfo { NSLog(@&amp;quot;My Mac&#39;s disk size is %d GB, memory size is %d GB.</description>
    </item>
    
    <item>
      <title>iOS 中的 KVC</title>
      <link>/posts/2019/kvc_in_ios/</link>
      <pubDate>Mon, 25 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/kvc_in_ios/</guid>
      <description>Date Notes     2019-03-25 首次提交    Preface KVC，即 Key-Value Coding，译作键值编码（下文简称 KVC）。当对象兼容 KVC 时，可以通过统一的 API 访问对象中某个键对应的属性值。Cocoa 中的许多功能都依赖 KVC，比如，KVO、Cocoa 绑定机制、Core Data、以及 AppleScript 等。本文将主要探讨 KVC 及其本质相关，关于其它的内容可参考文末的「Reference」。
Basics How #import &amp;lt;Foundation/Foundation.h&amp;gt; @interface Speaker : NSObject @property (nonatomic) int volume; @end @implementation Speaker @end @interface Computer : NSObject @property (nonatomic) NSString *name; @property (nonatomic) NSArray *speakers; @end @implementation Computer @end int main(int argc, const char * argv[]) { @autoreleasepool { Computer *cpt = [[Computer alloc] init]; // ➡️ 通过 setter 设置 [cpt setName:@&amp;quot;My Mac 1&amp;quot;]; // ➡️ 通过 getter 读取 NSLog(@&amp;quot;name from getter - %@&amp;quot;, [cpt name]); // ➡️ 通过 setValue:forKey: 设置 [cpt setValue:@&amp;quot;My Mac 2&amp;quot; forKey:@&amp;quot;name&amp;quot;]; // ➡️ 通过 valueForKey: 读取 NSLog(@&amp;quot;name from KVC - %@&amp;quot;, [cpt valueForKey:@&amp;quot;name&amp;quot;]); Speaker *s1 = [[Speaker alloc] init]; s1.</description>
    </item>
    
    <item>
      <title>Obj-C 中的重载与重写</title>
      <link>/posts/2019/override_and_overload_in_obj-c/</link>
      <pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/override_and_overload_in_obj-c/</guid>
      <description>Date Platform     2019-03-20 macOS 10.14.2    Preface 重载（Overload）和重写（Override）是面向对象语言中十分基本的两个概念，本文将谈谈 Obj-C 中的重载与重写。
重载  In some programming languages, function overloading or method overloading is the ability to create multiple functions of the same name with different implementations. Calls to an overloaded function will run a specific implementation of that function appropriate to the context of the call, allowing one function call to perform different tasks depending on context.</description>
    </item>
    
    <item>
      <title>Obj-C 中的对象</title>
      <link>/posts/2019/objects_in_obj-c/</link>
      <pubDate>Mon, 18 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/objects_in_obj-c/</guid>
      <description>Date Notes Source Code     2019-03-18 首次提交 objc4-750    对象的分类 Obj-C 中的对象，主要有三种，实例对象（Instance Object）、类对象（Class Object）、以及元类对象（Meta-class Object）。类对象和元类对象的类型均为 Class，即 typedef struct objc_class *Class;，所以它们的结构其实是一致的，只是存放的内容不同。
定义一个继承自 NSObject 的 Computer 类，方便后续的 Demo。
// EDdeviceProtocol 协议 @protocol EDdeviceProtocol - (void)powerOn; @end // Computer 类，继承自 NSObject，遵守 EDdeviceProtocol @interface Computer : NSObject &amp;lt;EDdeviceProtocol&amp;gt; { // 成员变量 @public int _memorySize; int _diskSize; } // 属性 @property (copy) NSString *model; // 实例方法 - (void)print:(NSString *)content; // 类方法 + (NSString *)arch; @end @implementation Computer - (void)print:(NSString *)content { NSLog(@&amp;quot;Print Content: %@&amp;quot;, content); } // 协议方法 - (void)powerOn { NSLog(@&amp;quot;Start.</description>
    </item>
    
    <item>
      <title>iOS 中的 KVO</title>
      <link>/posts/2019/kvo_in_ios/</link>
      <pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/kvo_in_ios/</guid>
      <description>Date Notes     2019-03-13 首次提交    Preface KVO 即 Key-Value Observing，译作键值监听（下文简称 KVO），通常用于监听对象的某个特定属性值的变化。本文将由浅入深，谈谈 iOS 中的 KVO。
How #import &amp;quot;ViewController.h&amp;quot; @interface Computer : NSObject @property (nonatomic, assign) int buttonClickTimes; @end @implementation Computer @end @interface ViewController () @property (nonatomic, strong) Computer *cpt; @end @implementation ViewController - (Computer *)cpt { if (!_cpt) { _cpt = [[Computer alloc] init]; // ➡️ 为 cpt 属性的键路径 buttonClickTimes 增加监听者 self（该控制器） // options 决定监听者将同时接收到新值和旧值 // context 决定附带的上下文信息「ViewController-buttonClickTimes」。 [_cpt addObserver:self forKeyPath:@&amp;quot;buttonClickTimes&amp;quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@&amp;quot;ViewController-buttonClickTimes&amp;quot;]; } return _cpt; } - (void)dealloc { // ➡️ 在监听者销毁前将其移除 [self.</description>
    </item>
    
    <item>
      <title>iOS 中的 NSObject</title>
      <link>/posts/2019/nsobject_in_ios/</link>
      <pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/nsobject_in_ios/</guid>
      <description>Date Notes Source Code     2019-03-13 首次提交 objc4-750、libmalloc-166.220.1、glibc-2.29    NSObject 实例对象的大小 // NSObject Obj-C -&amp;gt; C NSObject_IMPL struct NSObject_IMPL { Class isa; }; // 指向 objc_class 结构体的指针 typedef struct objc_class *Class;  将 Obj-C 源码通过 clang -rewrite-objc 翻译为 C++（其实大部分为 C），可以发现 Obj-C 中的 NSObject 类其实就是 C 中的 NSObject_IMPL 结构体，其中只有一个成员变量，即 isa。isa 的类型是 Class，本质是一个指向 objc_class 结构体的指针。在 64 位系统中，指针占用 8 个字节（Byte），即 NSObject 的实例对象大小应该为 8 个字节。我们也可以尝试用 C 语言中的 sizeof() 运算符来证明这一点：</description>
    </item>
    
    <item>
      <title>iOS 多线程技术实践之 pthreads</title>
      <link>/posts/2019/multithread_techs_in_ios-1/</link>
      <pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/multithread_techs_in_ios-1/</guid>
      <description>Date Notes Swift Xcode     2019-03-08 首次提交 4.2 10.1     在 iOS 中的多线程（Multithreading）技术通常有以下几种实现方式：pthreads、NSThread、GCD、NSOperation。首先，我们来一起看一看 pthreads。
 Preface  POSIX Threads, usually referred to as pthreads, is an execution model that exists independently from a language, as well as a parallel execution model. It allows a program to control multiple different flows of work that overlap in time. Each flow of work is referred to as a thread, and creation and control over these flows is achieved by making calls to the POSIX Threads API.</description>
    </item>
    
    <item>
      <title>谈谈 iOS 中的 dyld_shared_cache</title>
      <link>/posts/2018/dyld_shared_cache/</link>
      <pubDate>Sun, 14 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/dyld_shared_cache/</guid>
      <description>Date Notes Source Code     2018-12-12 补充 dyld_shared_cache 路径来源 system_cmds-805.220.1   2018-10-14 首次提交 dyld-551.4    What iOS &amp;amp; macOS 作为操作系统，其中内置了许多系统库（Library）。dyld_shared_cache，即动态库共享缓存。自 iOS 3.1 后，所有系统动态库被集合成一个 dyld_shared_cache 文件，以提升性能。当然，macOS 也有 dyld_shared_cache，比较特别的是可以通过 update_dyld_shared_cache 更新。
How 为了研究 dyld_shared_cache，首先要找到其存在的路径。可以在 Apple 开源的 system_cmds 中 dyld_shared_cache.c 文件中发现，其分别存放在 macOS 和 iOS 中的路径。
macOS 上的 dyld_shared_cache 和 iOS 不太相同，每种架构额外对应了一种 .map 文件。因为本文着重在于 iOS，读者想要了解 macOS 相关可以在 system_cmds 中自行检索。
dyld_shared_cache 存在于 iOS 设备的 /System/Library/Caches/com.apple.dyld/ 目录。文件名即为 dyld_shared_cache_arm* 加上对应的架构编号。</description>
    </item>
    
    <item>
      <title>iOS 项目持续集成实践（一）</title>
      <link>/posts/2018/ci_practice_in_ios-1/</link>
      <pubDate>Sat, 07 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/ci_practice_in_ios-1/</guid>
      <description>Preface 一个软件工程项目从编写、到测试、再最终交付到用户通常有很多重复且固定的步骤。虽然作为开发者，我们的核心任务是编写代码，而这些其他的步骤却也不能忽视，持续集成（Continuous Integration）则可以帮助开发者完成这些琐碎的事务，提升团队的开发效率与质量。
本文将主要介绍持续集成是什么，以及其中的好处。当然，您可能也注意到了标题后面「（一）」，没错，持续集成并非一篇文章可以概括，笔者希望尽可能将目前团队中使用到的和持续集成相关的内容进行总结，目的是为了让大家一起思考如何让持续集成更好地服务我们开发。当然，限于笔者能力，文中不免出现遗漏，也望读者能够批评和指出。
What 持续集成，译自 Continuous Integration，简称 CI（在下文中，将统一使用该英文简称）。在 Wikipedia 中，也有针对 CI 特别详细且专业的介绍。简而言之，当开发者通过版本控制系统（例如 Git）提交了代码，CI 系统将为其自动执行构建、分析、测试等服务，当前面的服务一致通过，其也能直接将产品部署到生产环境，而后进入下一个循环。其中每一步都将自动触发、执行，结果也将会自动反馈回开发者。正如下图所示，CI 的重点在于 C——持续。
Why &amp;amp; Why not 那么为什么需要 CI 呢？相比于传统的先开发，再测试，后上线的模式有哪些好处呢？在团队使用 CI 这段时间中，得出了以下主要两个好处：
 及时发现错误。CI 并不能消除错误，但 CI 将发现错误的时机尽可能地提前，所以也更加节省时间来改正错误。当开发者提交代码至代码仓库时，其对于代码的熟悉程度是最高的。如果这个时候尽可能的纠正一些错误或不当，开发者将能很快注意到并将错误改正，避免了由于时间或者团队中其他人对于代码的修改所导致的问题，提升了开发效率。 自动化。市面上的 CI 平台都给了开发者比较高的自由度，能够执行脚本或命令。因此很多自动化的操作都可以制定好，来自动化地执行，节省开发者的时间。  如果这两个显而易见的好处还不足以说服，可以参考文末 Reference 中 EKATERINA NOVOSELTSEVA 的文章。那么 CI 会不会也存在什么难处呢？
 跨技术栈。CI 并不特定于前端或者后端，CI 通常根据不同的平台而有很多不同，包括配置的方法、使用的语言、自由度等等。CI 又和 Docker 的发展有一定的关系，因此跨技术栈可能让一些团队望而却步。不过好的是，DevOps（Development &amp;amp; Operations）也在国内渐渐兴起，越来越被重视。 跨平台。这里所指的平台是指代码托管平台、CI 平台、以及部署平台。在公司开始时，可能并不能轻易考虑到后续的发展，因此在原有平台加入 CI 可能需要跨平台的协作。对于一些「黑盒」的平台，有时便难以很好的集成。不过，现在 Git 的两大平台 GitHub 和 GitLab 都很重视且支持 CI 平台，也便于开发者使用。  如果后面两个问题并没有阻挠你，那么就开始尝试 CI 吧～
How CI 并不依赖于某种特定的技术栈，其属于一种编程范式。但是，具体谈及如何实践，这就需要结合不同的工具和业务，进行定制。</description>
    </item>
    
    <item>
      <title>在 Swift 中对集合类型元素的弱引用</title>
      <link>/posts/2018/weakly_collections/</link>
      <pubDate>Thu, 08 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/weakly_collections/</guid>
      <description>Date Notes Swift Xcode     2018-03-15 更新部分表述，并将题目扩展至集合类型 4.0 9.2   2018-03-08 首次提交 4.0 9.2    Preface 为了方便下述 Demo，这里定义一个 Pencil 类，并会使用 func CFGetRetainCount(_ cf: CoreFoundation.CFTypeRef!) -&amp;gt; CFIndex 方法，即传入一个 CFTypeRef 类型的对象即可获取其引用计数。什么是 CFTypeRef？查阅官方文档即可得知 typealias CFTypeRef = AnyObject，所以 CFTypeRef 其实就是 AnyObject。而 AnyObject 又是所有类隐含遵守的协议。
class Pencil { var type: String var price: Double init(_ type: String, _ price: Double) { self.type = type self.price = price } } CFGetRetainCount(Pencil(&amp;quot;2B&amp;quot;, 1.</description>
    </item>
    
    <item>
      <title>Swift 中的 @autoclosure</title>
      <link>/posts/2018/swift_autoclosure/</link>
      <pubDate>Sat, 13 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/swift_autoclosure/</guid>
      <description>Date Notes Swift Xcode Source Code     2018-04-05 更新并明确源代码所用版本 4.1 9.3 Swift 4.1 Release   2018-01-13 首次提交 4.0.3 9.2 -    What  Closures are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.
— The Swift Programming Language (Swift 4.</description>
    </item>
    
    <item>
      <title>浅谈 iOS 应用启动过程</title>
      <link>/posts/2017/ios_app_start_up/</link>
      <pubDate>Tue, 28 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/ios_app_start_up/</guid>
      <description>Date Notes Swift Xcode     2017-05-26 CS193p UIApplication 3.1 8.3.2   2017-03-28 首次提交 3.0 8.2.1    Preface 首先要感谢没故事的卓同学大大送的泊学会员，在泊学学了几节课，了解了很多不同角度的 iOS 开发知识。这篇文章就启发自其 iOS 101 中的一个纯手工的 Single View Application 一文。但本文将更加深入的叙述了启动过程，且实现均为 Swift 3.0。
本文对应的 Demo 可以在：https://github.com/kingcos/SingleViewAppManually-Demo 查看、下载。
Manually or Storyboard main.m in Objective-C Single View Application
#import &amp;lt;UIKit/UIKit.h&amp;gt; #import &amp;quot;AppDelegate.h&amp;quot; int main(int argc, char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } }   自从 Storyboard 诞生以来，关于纯代码、Xib、以及 Storyboard 的选择就在 iOS 开发圈中炸开了锅。这里不会探讨各种姿势的优劣，只是可能很多和我一样的初学者，从一开始就被 Storyboard 先入为主。加上方便灵活的拖控件，自然而然就可能没有机会去思考一个 iOS 应用是如何启动起来的。加上 Swift 的诞生，使得整个项目的初始结构得到了更大的简化（少了 main.</description>
    </item>
    
    <item>
      <title>从 0 开始使用 Docker 快速搭建 Hadoop 集群环境</title>
      <link>/posts/2017/docker_for_hadoop/</link>
      <pubDate>Mon, 27 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/docker_for_hadoop/</guid>
      <description>Date Notes Hadoop Other     2017-03-27 首次提交 2.7.2 Docker CE, IntelliJ IDEA 2016.3    Preface 自从学习 iOS/Swift 以来，就没有太多时间分配给 Java 专业课，毕竟我不是个三心二用还能样样学好的人。不过作为大三的专业课，分布式计算技术还是有去上课的，毕竟不能最后挂科吧 :]
曾有人说，「开发一个项目，至少有 50% 时间在配置环境」。确实，在折腾了三周的课时之后，我才按照老师给的详细步骤配置好 Hadoop 的环境。尽管如此，由于种种原因，班里仍有很多同学还没有配置好 Hadoop 的环境，导致课程一直停滞。在偶然中，我想到了 Docker，Docker 这个词我至少在半年前已经听说（当然，恕我孤陋寡闻，Docker 早在 13 年即发行），但一直没有去了解和使用。时至今日，我对 Docker 的了解也十分少，简单的来说，Docker 是一种容器（Container）管理工具，通过 Docker 我们可以配置可移植的环境，方便发布。Docker 基于 Linux，但也提供了 macOS 和 Windows 桌面版，方便在我们的本地机器测试、使用。
虽然本文是一个小白向的文章，但下载和安装的过程也不会在本文涉及。一是官方网站必然提供了相应的教程，纯粹的翻译毫无意义；二是下载和安装可能随着后续更新发生略微的区别，而本文只着眼于配置 Hadoop 集群环境的搭建。
不过由于个人对 Hadoop 和 Docker 的了解甚少，如有错误，希望指出，我会学习、改正。
Linux  Info: Ubuntu 16.10 x64   Docker 本身就是基于 Linux 的，所以首先以我的一台服务器做实验。虽然最后跑 wordcount 已经由于内存不足而崩掉，但是之前的过程还是可以参考的。</description>
    </item>
    
    <item>
      <title>探究 UIViewController 生命周期</title>
      <link>/posts/2017/uiviewcontroller_life_cycle/</link>
      <pubDate>Fri, 10 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/uiviewcontroller_life_cycle/</guid>
      <description>Date Notes Swift Xcode     2017-03-10 首次提交 3.0 8.2.1    前言 对象的生命周期一直是开发者所需要关心的，教授 CS193p 的老师 Paul 也详细的讲述了 UIViewController 的生命周期。为了记述这一过程，故作此文。由于 Xcode 提供了纯代码和 Storyboard（Xib 同理）两种布局 UI 的方式，因此初始化部分略有不同。
为了方便观察，我创建了一个 BaseViewController，继承自原本的 UIViewController，重写其中的生命周期方法，并让后续新的控制器继承自该控制器，以便观察。
本文对应的 Demo 可以在 https://github.com/kingcos/UIViewController-UIView-LifecycleDemo 查看、下载。
Initialization Storyboard  OUTPUT:
 init(coder:) awakeFromNib()   init(coder:)  当使用 Storyboard 时，控制器的构造器为 init(coder:)。 该构造器为必需构造器，如果重写其他构造器，则必须重写该构造器。 该构造器为可失败构造器，即有可能构造失败，返回 nil。 该方法来源自 NSCoding 协议，而 UIViewController 遵从这一协议。 该方法被调用意味着控制器有可能（并非一定）在未来会显示。 在控制器生命周期中，该方法只会被调用一次。  awakeFromNib()  当使用 Storyboard 时，该方法会被调用。 当调用该方法时，将保证所有的 outlet 和 action 连接已经完成。 该方法内部必须调用父类该方法，虽然默认实现为空，但 UIKit 中许多类的该方法为非空。 由于控制器中对象的初始化顺序不能确定，所以构造器中不应该向其他对象发送消息，而应当在 awakeFromNib() 中安全地发送。 通常使用 awakeFromNib() 可以进行在设计时无法完成的必要额外设置。  Code  OUTPUT: - init(nibName:bundle:) - NibName: nil, Bundle: nil</description>
    </item>
    
    <item>
      <title>Swift 中的 Selector</title>
      <link>/posts/2017/swift_selector/</link>
      <pubDate>Tue, 31 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/swift_selector/</guid>
      <description>Date Notes Swift Xcode     2017-01-31 首次发布（简书 &amp;amp; 掘金） 3.0 8.2.1    Preface  Focus，即专注。笔者希望可以尽力将一些不是那么透彻的点透过 Demo 和 Source Code 而看到其本质。由于国内软件开发仍很大程度依赖国外的语言、知识，所以该博客中的术语将使用英文表述，除非一些特别统一的词汇或整段翻译时将使用中文，但也会在首次提及时标注英文。笔者英文水平有限，这样的目的也是尽可能减少歧义，但在其中不免有所错误，遗漏，还请大家多多批评、指正。
本文及更新会首发于笔者的 GitHub 的 Perspective 仓库：https://github.com/kingcos/Perspective，欢迎 Star 🌟。
 What 常用纯代码来开发的同学都应该比较熟悉这个方法：
func addTarget(_ target: Any?, action: Selector, for controlEvents: UIControlEvents)  Selector 源自 Objective-C，例如 SEL 类型，以及 @selector() 方法选择器。Swift 中也兼容了这个概念，不过随着 Swift 的迭代，Selector 的一些写法也出现了很大的变化。比较遗憾的是，官方文档对于 Selector 没有介绍。
因此只能自己总结一下 Swift 3.0 中的 Selector，便有利于自己理解，也便于以后的参考。注：以下 Demo 中的 cyanButton 是用 StoryBoard 拖拽的。</description>
    </item>
    
    <item>
      <title>浅谈 Swift 中的属性（Property）</title>
      <link>/posts/2016/swift_properties/</link>
      <pubDate>Wed, 26 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/2016/swift_properties/</guid>
      <description>Date Notes Swift Xcode     2017-04-27 扩充 #延迟存储属性# 部分并新增 #devxoul/Then# 3.1 8.3.2   2016-10-26 首次提交 3.0 8.1 Beta 3    前言 Swift 中的属性分为存储属性与计算属性，存储属性即为我们平时常用的属性，可以直接赋值使用，而计算属性不直接存储值，而是根据其他（存储）属性计算得来的值。
在其他面向对象的编程语言中，例如 Java 和 Objective-C 中，get 和 set 方法提供了统一、规范的接口，可以使得外部访问或设置对象的私有属性，而不破坏封装性，也可以很好的控制权限（选择性实现 get 或 set 方法）。而 Swift 中似乎并没有见到类似的 get 和 set 方法，而 Swift 使用了一种名为属性观察器的概念来解决该问题。
本文简单介绍下 Swift 中的这两种属性，以及属性观察器。
延迟存储属性  存储属性使用广泛，即是类或结构体中的变量或常量，可以直接赋初始值，也可以修改其初始值（仅指变量）。 延迟存储属性是指第一次使用到该变量再进行运算（这里的运算不能依赖其他成员属性，但可以使用静态／类属性）。 延迟存储属性必须声明为 var 变量，因为其属性值在对象实例化前可能无法得到，而常量必须在初始化完成前拥有初始值。 在 Swift 中，可以将消耗性能才能得到的值作为延迟存储属性，即懒加载。 全局的常量和变量也是延迟存储属性，但不需要显式声明为 lazy（不支持 Playground）。  Demo  这里假定在 ViewController.</description>
    </item>
    
  </channel>
</rss>