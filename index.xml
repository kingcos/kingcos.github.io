<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>iBlog</title>
    <link>/</link>
    <description>Recent content on iBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved by kingcos.me</copyright>
    <lastBuildDate>Mon, 27 Jul 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>iOS 中的断言</title>
      <link>/posts/2020/assertion_in_ios/</link>
      <pubDate>Mon, 27 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/assertion_in_ios/</guid>
      <description>Date Notes     2020-07-27 首次提交    Preface 断言（Assertion）是我们常用于 Debug 时的得力助手，其使得程序得以崩溃在早期，引起我们足够的重视，保障代码质量又不影响用户的体验。本文将简单介绍 iOS 中的断言类型以及使用方式与原理。
assert NSAssert &amp;amp; NSCAssert NSAssert
// NSException.h  #if !defined(NS_BLOCK_ASSERTIONS)  #if !defined(_NSAssertBody) #define NSAssert(condition, desc, ...)	\ do {	\ __PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \ if (__builtin_expect(!(condition), 0)) {	\ NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__]; \ __assert_file__ = __assert_file__ ? __assert_file__ : @&amp;#34;&amp;lt;Unknown File&amp;gt;&amp;#34;; \ [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd \ object:self file:__assert_file__ \ lineNumber:__LINE__ description:(desc), ##__VA_ARGS__]; \ }	\ __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \ } while(0) #endif  #if !</description>
    </item>
    
    <item>
      <title>Swift 拾遗 - 内联函数</title>
      <link>/posts/2020/swift_inline/</link>
      <pubDate>Sun, 26 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_inline/</guid>
      <description>Date Notes     2020-07-26 首次提交    Preface 《Swift 拾遗》是一个关于 Swift 的新文章专辑，这个系列的文章将不会涉及基本语法的层面，而是尝试从底层「拾」起之前所忽视的内容。今天我们将一起简单探究 Swift 中的内联函数。
编译器优化等级 由于内联函数会将函数调用展开为函数体，因此当编译器内联某一函数时，该函数本身将不再会被调用。而在 Debug 模式下，由于我们经常会使用打断点等调试手段，如果此时内联将不利于我们排查问题。因此在 Debug 模式下，编译器默认将不进行内联。
控制编译器优化等级的设置位于：Xcode - TARGETS - Build Settings - Swift Compiler - Optimization Level，其中便会影响 Swift 函数是否内联：
Swift 编译器所支持的优化等级具体如下：
   Level Part     [-Onone] 无优化（Debug 模式默认）   [-O] 速度优先（Release 模式默认）   [-Osize] 体积优先    经过实际测试，如下 foo 函数在 [-O] 与 [-Osize] 等级下均被优化：</description>
    </item>
    
    <item>
      <title>Swift 拾遗 - inout</title>
      <link>/posts/2020/swift_inout/</link>
      <pubDate>Sat, 25 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_inout/</guid>
      <description>Date Notes     2020-07-25 首次提交    Preface 《Swift 拾遗》是一个关于 Swift 的新文章专辑，这个系列的文章将不会涉及基本语法的层面，而是尝试从底层「拾」起之前所忽视的内容。今天我们将一起简单探究修饰 Swift 中函数参数的 inout 关键字。
本质 我们声明一个使用 inout 参数的函数，并在外界将变量 &amp;amp; 按地址传入：
var foo = 5 func inoutDemoFunc(_ innerFoo: inout Int) { innerFoo = 9 } inoutDemoFunc(&amp;amp;foo) // BREAKPOINT 🔴 // foo == 9 尝试将以上代码转换为汇编（Xcode Menu - Debug - Debug Workflow - Always Show Disassembly）：
; inout demo`main: 0x100001d60 &amp;lt;+0&amp;gt;: pushq %rbp 0x100001d61 &amp;lt;+1&amp;gt;: movq %rsp, %rbp 0x100001d64 &amp;lt;+4&amp;gt;: subq $0x30, %rsp 0x100001d68 &amp;lt;+8&amp;gt;: leaq 0x1459(%rip), %rax ; leetcode.</description>
    </item>
    
    <item>
      <title>iOS 中的数组</title>
      <link>/posts/2020/array_in_ios/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/array_in_ios/</guid>
      <description>Preface 数组，是我们在开发中经常使用的数据结构，其使用一段连续的内存空间存储。在 Obj-C 中，数组的类型分为 NSArray 不可变数组
Objective-C NSArray &amp;amp; NSMutableArray 我们都知道，NSArray 是 Obj-C 中的不可变数组，而 NSMutableArray 是 Obj-C 的可变数组。这里我将 Obj-C 中几乎所有可能涉及到的数组对象，进行尝试打印其类别信息：
NSLog(@&amp;#34;%@&amp;#34;, [[NSMutableArray alloc] class]); // __NSPlaceholderArray NSLog(@&amp;#34;%@&amp;#34;, [[NSArray alloc] class]); // __NSPlaceholderArray NSLog(@&amp;#34;%@&amp;#34;, [[[NSArray alloc] class] superclass]); // NSMutableArray NSLog(@&amp;#34;%@&amp;#34;, [[[[NSArray alloc] class] superclass] superclass]); // NSArray NSLog(@&amp;#34;%@&amp;#34;, [[[[[NSArray alloc] class] superclass] superclass] superclass]); // NSObject  NSLog(@&amp;#34;%@&amp;#34;, [[NSArray array] class]); // __NSArray0 NSLog(@&amp;#34;%@&amp;#34;, [[[NSArray alloc] init] class]); // __NSArray0 NSLog(@&amp;#34;%@&amp;#34;, [[[[NSArray alloc] init] class] superclass]); // NSArray  NSLog(@&amp;#34;%@&amp;#34;, [[NSMutableArray array] class]); // __NSArrayM NSLog(@&amp;#34;%@&amp;#34;, [[[NSMutableArray array] class] superclass]); // NSMutableArray  NSLog(@&amp;#34;%@&amp;#34;, [@[@1] class]); // __NSSingleObjectArrayI NSLog(@&amp;#34;%@&amp;#34;, [[@[@1] class] superclass]); // NSArray  NSLog(@&amp;#34;%@&amp;#34;, [@[@1, @2] class]); // __NSArrayI NSLog(@&amp;#34;%@&amp;#34;, [[@[@1, @2] class] superclass]); // NSArray  NSMutableArray *arr = [NSMutableArray array]; NSLog(@&amp;#34;%@&amp;#34;, [arr class]); // __NSArrayM  [arr addObject:@1]; NSLog(@&amp;#34;%@&amp;#34;, [arr class]); // __NSArrayM 由以上结果，我们可得出下图的继承树：</description>
    </item>
    
    <item>
      <title>Swift 拾遗 - Swift Tips</title>
      <link>/posts/2020/swift_tips/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_tips/</guid>
      <description>Preface 《Swift 拾遗》是一个关于 Swift 的新文章专辑，这个系列的文章将不会涉及基本语法的层面，而是尝试从底层「拾」起之前所忽视的内容。那么作为起始篇，随着整个系列的进行，其中「遗」漏的基本使用将在本文中得到补充。
Content Void 按照 Swift 标准库的定义，Void 即空元组 ()：
public typealias Void = () 函数重载（Overload） Swift 中的函数重载有一些坑，因此尽量不要产生命名歧义性（比如结合默认参数值等用法）。
 Obj-C 中的重载与重写  @discardableResult Swift 是一门要求很严格的语言，当函数的返回值未被使用到时，编译器就会提示相关的警告。我们可以使用 @discardableResult 将函数声明为可丢弃结果，即可告知编译器不产生警告：
import Foundation func foo() -&amp;gt; String { return &amp;#34;kingcos.me&amp;#34; } @discardableResult func bar() -&amp;gt; String { return &amp;#34;kingcos.me&amp;#34; } foo() // WARNING: Result of call to &amp;#39;foo()&amp;#39; is unused // 当然也可以赋值到占位符 _ 以避免警告 _ = foo() bar()  Defaulting non-Void functions so they warn on unused results - swift-evolution  swiftc swiftc 是 Swift 编译器（前端），位于 Xcode 中 Xcode.</description>
    </item>
    
    <item>
      <title>巨婴国</title>
      <link>/reading/the_giant_baby_nation/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>/reading/the_giant_baby_nation/</guid>
      <description>Name Author ISBN     巨婴国 武志红 9787213076824      在幻想层面把别人的故事替换成自己的故事，用别人的成功掩盖自己的失败；一味突出所谓正能量，使阅读者丧失对现实世界的整体感；忽略对之所以是现在这个状态的原因的思考，用虚幻的未来麻醉自己对当下的感受。
  那些直接告诉你该怎么做的「学说」或者「师傅」，是在剥夺你作为独立个体存在的最重要的东西：自由选择的权利。
  巨婴的意思是，一个个体，在身体上已经发育为成年人，而在精神上还保留着婴儿般的思想、情绪和行为。这些巨婴特点包括：自我意识狭窄，无法预知自己的言行对他人可能造成什么影响；人身依附，使自己成为他人或机构的一部分，丧失或出卖个人良知底线；在人际和社会层面，为了操控而操控，无法施与爱或享受爱。
  因为爱制造分离，而施虐制造忠诚。
  在对外部世界的探索已经非常深入的背景下，启动公众对探索人类自身精神世界的兴趣，并且最大范围地分享已有的探索成果。
  这些人的故事汇总在一起，让我有了一个「中国式好人」的概念：他们看起来对人很好，但情感是淡漠的，缺乏热情，并且总伴随着孤独，就像是活在一个孤岛上。
  婴儿是没法面对失控的，失控会引起他们巨大的无助感，他们需要将失控这件事从自己身上切割出去。
  我们社会的各种制度建设，也包括以儒家为主的思想文化，在我看来，其实都是在试着去压制这个魔鬼。
  用精神分析的话来讲，原始的生命力都是带着攻击性的，一个人必须将他带着攻击性的生命力展现在关系中，以此和另外一个同样如此真实的人建立关系，然后才能得到亲密，并被救赎。
  本能上我们喜欢走的路，是注定走不通的。
  希腊德尔菲神庙有一句箴言：人啊，认识你自己。苏格拉底则说，未经省察的人生，是不值一提的。
  本我、自我和超我，这是弗洛伊德的人格结构理论。放到国人身上，它可具体表达为：全能自恋性的本我、绝对禁止性的超我和软塌塌的自我。
  弗洛伊德则称，驱动人类行为的动力有两个：性和攻击。
  一、每个人都是一个能量体。二、能量体伸展出的每一份能量，如被看到，就变成了光明，变成了生的能量，如热情与创造力。三、能量体伸展出的每一份能量，如不被看到，就变成了黑暗，变成了黑色的、死的能量，如怨恨与破坏力。四、当一个人整个的能量体都被看到，生命就得以证悟。
  爱，就是深深的理解和接纳。美国人本主义心理学家罗杰斯如是说。
  国内的精神分析学界有一个基本共识：中国人的集体心理年龄，没有超过 1 岁，还停留在口欲期。
  弗洛伊德将一个人的心理发展分为五个阶段：口欲期，1 岁前，嘴部是快感中心。肛欲期，1—3 岁，肛门是快感中心。俄狄浦斯期，也称为性蕾期，3—5 岁，孩子有了明确的性意识，快感中心也转移到了生殖器部位，并且男孩有了恋母弑父的动力，女孩有了恋父仇母的动力。潜伏期，6—12 岁，性能量像是突然间消失了一样，孩子们表现为更喜欢与同性伙伴交往。生殖期，13—18 岁，即青春期，性能量大爆炸，一个人身体上做好了生育的准备。</description>
    </item>
    
    <item>
      <title>Obj-C 中的 Boolean</title>
      <link>/posts/2020/booleans_in_objc/</link>
      <pubDate>Tue, 02 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/booleans_in_objc/</guid>
      <description>Date Notes     2020-06-02 首次提交   2020-06-16 增加「逻辑表达式」一节    Preface Boolean，即布尔值，通常用来表明逻辑中的真或假。但在 Obj-C 中，我们似乎既可以使用 BOOL 又可以使用 bool，既可以使用 YES/NO 又可以使用 true/false，那么它们到底有何不同呢？
 ⚠️ 注意：
为了避免读者（和笔者）记混，这里简单说明下 #define 与 typedef 的异同：#define A B 意为将已存在的 B 定义为 A，A 与 B 等价；typedef C D 意为将已存在的 C 定义为 D，C 与 D 等价；后者通常用于类型定义。
 _Bool 与 bool // iOS - stdbool.h  /*===---- stdbool.h - Standard header for booleans -------------------------=== * * Part of the LLVM Project, under the Apache License v2.</description>
    </item>
    
    <item>
      <title>乌合之众</title>
      <link>/reading/the_crowd/</link>
      <pubDate>Tue, 12 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/reading/the_crowd/</guid>
      <description>Name Author Translator ISBN     乌合之众 [法] 古斯塔夫 · 勒庞（Gustave Le Bon） 戴光年 97875104075501      群体中的人有两个共同的特点：首先是每一个人个性消失，其次是他们的感情与思想都在关注同一件事。
  群体中的个人行为表现具有如下四个特点：第一，是自我人格消失；第二，是无意识人格起到决定性的作用；第三，是情感与思想在暗示与传染的作用下转向一个方向；第四，是暗示的观念具有即刻转化为行动的冲动。
  为了提高杀人效率，他们甚至将炮口降低，对准对面的老人和小孩，一次性地将数以万计的无辜百姓碎为齑粉，让之尸骨无存。
  在群体之中，绝对不存在理性的人。因为正如我们前面所说，群体能够消灭个人的独立意识，独立的思考能力。事实上，早在他们的独立意识丧失之前，他们的思想与感情就已经被群体所同化。
  第一，在智力上，群体的表现远不如构成这一群体之中的个人，所以在涉及智慧这方面，我们是绝不能依赖群体的。
  第二，群体比个人更有力量，但是群体的表现是极不稳定的；而个人无论是智力还是能力方面，总是维持在一个平均的水平线上。
  第三，群体的行动是受感情激起并主导的，这种感情的强弱程度，直接决定着群体的行为能力。
  第四，群体的表现有可能比个体更好，或者更差。究竟群体会表现得更好还是更差，这完全取决于周边的环境如何。
  第五，群体能够干出什么来，取决于影响群体的暗示是何种性质。如果这种性质是积极的、进步的、有意义的，那么群体的表现就会是相应的积极进步且有益。反之，如果主宰群体行为的暗示是负面的心理能量，那么群体的表现就会非常可怕——如果把群体比作是一个人，那么这种主宰群体行为的暗示力量就好比人的思想，如果这个人的思想是善良的，那么这个人必然是善良的，反之亦然。
  第六，群体往往会构成骚乱的因由，但群体却更多的表现为一个英雄主义的群体。
  孤立的个人具有主宰自己反应行为的能力，群体则缺乏这种能力。
  群体不仅在好恶情绪之间莫衷一是，它甚至可以眨眼之间就从最野蛮、最血腥的狂热过渡到最为极端的宽宏大量和英雄主义。
  群体没有负罪意识，群体天然合理，他们无论做任何事情都是合乎正义的，他们的数量决定了这一点。
  群体期待暗示，是因为他们需要暗示。
  群体中个人智力泯灭存在着以下四个阶段： 第一个阶段是自我意识模糊； 第二个阶段是独立思考能力下降； 第三个阶段是判断力与逻辑在暗示与传染的作用下趋同一致； 第四个阶段是残存的智力品质被彻底吞噬。</description>
    </item>
    
    <item>
      <title>富爸爸穷爸爸</title>
      <link>/reading/rich_dad_poor_dad/</link>
      <pubDate>Fri, 24 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/reading/rich_dad_poor_dad/</guid>
      <description>Name Authors Translator ISBN     富爸爸穷爸爸 [美] 罗伯特 · 清崎（Robert Kiyosaki）、莎伦 · 莱希特（Sharon Lechter） 萧明 9787541138126      人们通常会做两件事，一些人在生活推着他转的同时，抓住生活赐予的每个机会；而另一些人则非常生气，去与生活抗争。
  真正的学习需要精力、激情和热切的愿望。愤怒是其中一个重要的组成部分，因为激情正是愤怒和热爱的结合体。
  资产是能把钱放进你口袋里的东西。 负债是把钱从你口袋里取走的东西。
  大多数人的财务困境是由于随大流、盲目地跟从其他人所造成的。因此我们都需要不时地照照镜子，相信我们内心的智慧而不是恐惧。
  发生通货膨胀时，价格和所得提高，而美元价值保持不变，纳税人的所得就会被划入较高的税收等级，即使实际所得没有增加，其有效税率也会提高，这种有效税率的提高被称为「所得等级攀升」。
  富爸爸告诉我和迈克，英国和美国在早期是不需纳税的，只有一些因为战争而临时征收的税，英国国王和美国总统把它称为「纳捐」。英国在 1799 年到 1816 年间为了与拿破仑作战而征税，美国则在 1861 年到 1865 年间为了应付内战而征税。 1874 年，英国规定纳税是国民的义务。1913 年，美国通过了《宪法修正案》（第 16 条），也规定了要征收所得税。
  他是政府官员，而我是资本家，我们都得到了报酬，但我们对成功的衡量标准却相反。他的工作是花钱和雇人，他花的钱和雇的人越多，他的机构就会越大。在政府中，谁的机构更大，谁就更受尊敬。而在我的公司中，我雇的人越少，花的钱越少，我就越能受到投资者的尊敬。
  政府的政策是，如果你是一个政府官员，就不应该握有过多的钱；如果你没有用完预算的资金，下次你所得到的钱就可能减少，你不会因为有节余而被认为是有效率。而商人恰恰相反。
  在现实生活中，人们往往是依靠勇气而不是智慧去取得领先的位置的。
  财商是由这 4 项主要技能组成的： 1．财务知识。即阅读理解数字的能力。2．投资策略。即以钱生钱的科学。3．市场、供给与需求。4．法律规章。</description>
    </item>
    
    <item>
      <title>DeskMini 310 黑苹果组装记</title>
      <link>/posts/2020/deskmini_hack/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/deskmini_hack/</guid>
      <description>配置  这台机器仅作为日常工作使用，我个人也不玩电脑游戏，因此未考虑独立显卡而追求体积较小，选择了 DeskMini 作为机箱、主板、电源整套解决方案，为支持 Intel CPU 选择了 310 型号 CPU 选取了 H310 主板能支持的（TDP MAX 65W）最高端型号 i9-9900 对应测试版 i9-9900es，性价比更高，一步到位；如需黑苹果尽量选择 Intel 平台，需追求后续交易或更加稳定可选择 i7-8700 散片 内存选取了单条最高支持的 32GB，方便之后内存降价再补充购入到 64GB 双硬盘对应双系统，互不干扰，互不影响，选择大牌且京东售后更佳；如需黑苹果需注意部分 NVME 硬盘兼容性 散热开始选的 IS-40X，但上机效果堪忧，加价上 AXP90I 纯铜版，效果立竿见影，AIDA 64 烤机维持在 55 度左右；个人并未追求静音效果，如需静音可再做调研 DP 输出 4K 60HZ，需公对公线支持 网卡选择苹果拆机网卡 + 转接卡，无需驱动即可使用 Wi-Fi 蓝牙（AirDrop） 板载网卡信号堪忧，需独立天线 防尘网可避免长时间运转导致机箱灰尘过多     - 型号 购买平台 价格     机箱 + 主板 + 电源 华擎 DeskMini 310 京东 1009 + 69   CPU Intel i9-9900es qqbz 淘宝 1625   内存 威刚 ADATA DDR4 2666 32GB 京东 979   硬盘 1 西部数据 1TB SSD SN550 京东 862   硬盘 2 紫光 S100 240GB 京东 239   散热器 利民 AXP90I 纯铜 京东 279   DP 公对公 胜为 1.</description>
    </item>
    
    <item>
      <title>[译] Swift 编译器</title>
      <link>/posts/2020/swift_compiler/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_compiler/</guid>
      <description>作者 原文链接     Swift.org Swift Compiler    Swift 主仓库中包含了 Swift 编译器和标准库的源代码、相关组件，如 SourceKit（用于 IDE 集成），以及 Swift 回归测试套件和实现级别的文档。
Swift 驱动库中包含了 Swift 编译器驱动（Driver）的新版实现，目的是替换现有编译器驱动，以增强可扩展性、可维护性以及鲁棒性（Robust）。
编译器架构 整体而言，Swift 编译器的主要职责在于将 Swift 源代码翻译为高效执行的机器码。但是 Swift 编译器的前端同样支持许多其它工具，包括与 IDE 集成的语法高亮、代码补全、以及其它提供便利的工具。本文对 Swift 编译器的主要组件提供了高阶描述：
 解析（Parsing）：解析器是一个简易的递归下降解析器（在 lib/Parse 中实现），并带有完整手动编码的词法分析器。 语义分析（Semantic Analysis）：语义分析阶段（在 lib/Sema 中实现）负责获取已解析的 AST（抽象语法树）并将其转换为格式正确且类型检查完备的 AST，以及在源代码中提示出现语义问题的警告或错误。语义分析包含类型推断，如果可以成功推导出类型，则表明此时从已经经过类型检查的最终 AST 生成代码是安全的。 Clang 导入器（Clang Importer）：Clang 导入器（在 lib/ClangImporter 中实现）负责导入 Clang 模块，并将导出的 C 或 Objective-C API 映射到相应的 Swift API 中。最终导入的 AST 可以被语义分析引用。 SIL 生成（SIL Generation）：Swift 中间语言（Swift Intermediate Language，SIL）是一门高级且专用于 Swift 的中间语言，适用于对 Swift 代码的进一步分析和优化。SIL 生成阶段（在 lib/SILGen 中实现）将经过类型检查的 AST 弱化为所谓的「原始」SIL。SIL 的设计在 docs/SIL.</description>
    </item>
    
    <item>
      <title>Obj-C 中实例变量和类的访问控制</title>
      <link>/posts/2019/ivar_access_control_in_obj-c/</link>
      <pubDate>Fri, 17 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/ivar_access_control_in_obj-c/</guid>
      <description>Date Notes     2019-06-14 增加 man nm 截图   2019-04-29 完善 @package   2019-03-30 gcc, clang; macOS 10.14.2   2020-01-17 勘误，部分细节调整    Preface Obj-C 中的实例变量，即 Instance Variables，简称为 ivar。在面向对象的概念中，一个类的对外暴露决定了其所提供的能力，对子类则需要提供一定的扩展性，但有些时候我们不希望外界甚至子类知道一些细节，这时就用到了访问控制（Access Control）。在 C++、Java、Swift 等大多数高级语言中都有这样的概念，那么这次就来谈谈 Obj-C 中实例变量和类的访问控制。
访问控制修饰符 @public @interface Foo : NSObject { @public NSString *_ivar; } @end @implementation Foo @end int main(int argc, char * argv[]) { Foo *f = [[Foo alloc] init]; f-&amp;gt;_ivar = @&amp;#34;kingcos.</description>
    </item>
    
    <item>
      <title>MustOverride 源码解读</title>
      <link>/posts/2019/dive_into_mustoverride/</link>
      <pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/dive_into_mustoverride/</guid>
      <description>Date Notes Source Code Commit / Tag     2019-12-07 首次提交 nicklockwood/MustOverride c63007e / 1.1   2020-01-05 增加 Extension 一节 - -    Preface MustOverride 是 nicklockwood 多年前开源的一个 Obj-C 库。其作用正如其名「MustOverride」即可以使得子类必须重写父类中的某些方法，防止子类因未实现父类的某些方法而出现不可预知的错误。
How 这个库的使用非常简单，如果是 CocoaPods 管理依赖的项目，直接通过 pod &#39;MustOverride&#39; 即可引入；之后引入 MustOverride.h 头文件并在需要必须子类重写的父类（或父类的分类）方法中放入 SUBCLASS_MUST_OVERRIDE; 宏即可：
// Foo.m  #import &amp;#34;Foo.h&amp;#34; #import &amp;#34;MustOverride.h&amp;#34;  @implementation Foo - (void)foo { SUBCLASS_MUST_OVERRIDE; } @end // Foo+Ext.m  #import &amp;#34;Foo+Ext.h&amp;#34; #import &amp;#34;MustOverride.</description>
    </item>
    
    <item>
      <title>「2019 · 结」</title>
      <link>/posts/2019/summary_of_2019/</link>
      <pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/summary_of_2019/</guid>
      <description>一年一度的年终又来了，而 2019 年是 21 世纪 10 年代的最后一年，即将迎来 21 世纪 20 年代 —— 2020 年。而在这一年又一年的更迭之际，又到了总结过去，展望未来的时间。
The Past 博客 ✒️ 今年四月中旬，迫于 GitHub Issue 的文章阅读体验略差，我重新将博客迁回 GitHub Pages，并弃用了之前使用的 Hexo，转为使用 Hugo；并于十月中旬，将使用多年的 maimieng.com 域名更换到 kingcos.me。
我个人一直认为技术的改变要服务于内容。今年博客一共开了 55 个坑，但目前公开的共有 38 篇，主要内容仍然是关于 Obj-C 与 iOS。因为工作与个人原因，Obj-C 这门语言的一些特性仍然是值得去深耕的，预计 2020 年上半年仍然会有大部分内容围绕 Obj-C 与 iOS，其它的内容将更深入基础，比如编译原理、操作系统等。
今年写博客的一个感受是，很多写的内容开始由点连线，而非单一、孤立的知识点，且在工作中时常能进行对已有知识体系的更新与迭代。
与往年写博客不同，以往我会将博客内容分发到简书、掘金、小专栏等平台，而今年则只在自己的博客运营。虽然博客现在流量和评论都很少，搜索引擎优化也因为更换域名有些降低，但这些都不是我写博客所追求的。我写博客的主要目的是为了记录自己学习一个知识点的所思所虑，并在持续迭代与更新中完善知识体系。
在年末这几周，我无意申请了 Google Adsense，没想到竟然一次性就通过了。目前已尝试在页面的最底部加上了广告，「恰饭」无可厚非，但我并不希望广告喧宾夺主，严重影响用户体验，所以是否加、怎么加、加哪里我也会慢慢探索。如果你现在想看看 Google Adsense 广告长什么样，我也在这一行下面插入了一个，不妨帮我测试一下点点看？（笑
 
 (adsbygoogle = window.adsbygoogle || []).push({});  摄影 📷 用「📷」作为这一章节的标题似乎有点伪命题，因为我个人一直是非器材党，即不使用专业的相机拍照，也没有庞大的后期合成，而仅仅使用 iPhone。拍好的照片我会精选较好的一部分，并使用 iOS 相机自带的滤镜 / 光圈 / Live 动效等调整，再发布在 Instagram 或者朋友圈中。今年十月份之前的照片大多使用 iPhone X 拍摄，而十月之后，使用 iPhone 11 Pro Max 拍摄。</description>
    </item>
    
    <item>
      <title>Obj-C 中的对象</title>
      <link>/posts/2019/objects_in_obj-c/</link>
      <pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/objects_in_obj-c/</guid>
      <description>Date Notes Refer.     2019-03-18 首次提交 objc4-750   2019-08-18 抽离 isa 部分；
重整文章结构 Obj-C 中的 isa 指针 - kingcos   2019-08-29 增加 class_rw_t 等细节 -   2019-12-23 细节微调 objc4-756.2    Preface Obj-C 中的对象分为实例对象（Instance Object）、类对象（Class Object）、以及元类对象（Meta-class Object）三种，本文将借助源码简单了解一下不同类型对象的真实构造。
为了方便下文举例，这里我们定义一个 EDdeviceProtocol 协议，并让继承自 NSObject 的 Computer 类遵守该协议：
// EDdeviceProtocol 协议 @protocol EDdeviceProtocol - (void)powerOn; @end // Computer 类，继承自 NSObject，遵守 EDdeviceProtocol @interface Computer : NSObject &amp;lt;EDdeviceProtocol&amp;gt; { // 成员变量 @public int _memorySize; int _diskSize; } // 属性 @property (copy) NSString *model; // 实例方法 - (void)print:(NSString *)content; // 类方法 + (NSString *)arch; @end @implementation Computer - (void)print:(NSString *)content { NSLog(@&amp;#34;Print content: %@.</description>
    </item>
    
    <item>
      <title>iOS 多线程技术实践之 pthreads（一）</title>
      <link>/posts/2019/multithreading_techs_in_ios-1/</link>
      <pubDate>Sat, 14 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/multithreading_techs_in_ios-1/</guid>
      <description>Date Notes Swift Xcode     2019-03-08 首次提交 4.2 10.1   2019-12-14 内容重整 5.1 10.3    Preface 在现代计算机中，操作系统一般都会支持多进程（Process）以及多线程（Thread）技术，使得其可以同时运行多个程序且效率更高。而我们在开发 iOS app 中也时常需要利用到这些特性，以为用户提供更加良好的使用体验。通常来说，一个 iOS app 为一个进程，其中又至少有一个线程，即主线程；前者进程由操作系统创建我们很难干预，而线程则「自由」许多，可以为我们所用。由于多线程技术内容较多，我将把相关内容进行拆分，本文作为该系列第一篇，先从 pthreads 说起。
What  POSIX Threads, usually referred to as pthreads, is an execution model that exists independently from a language, as well as a parallel execution model. It allows a program to control multiple different flows of work that overlap in time.</description>
    </item>
    
    <item>
      <title>将 Obj-C 代码翻译为 C/C&#43;&#43; 代码</title>
      <link>/posts/2019/obj-c_to_c&#43;&#43;/</link>
      <pubDate>Sat, 30 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/obj-c_to_c&#43;&#43;/</guid>
      <description>Date Notes     2019-05-17 首次提交   2019-06-15 增加常用参数列表   2019-11-30 细节补充    Solution ➜ ~ clang --version Apple LLVM version 10.0.0 (clang-1000.11.45.5) Target: x86_64-apple-darwin18.2.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin Xcode 中，C/C++/Obj-C/C++ 的编译器是 clang，其通过 -rewrite-objc 参数可以将 Obj-C 代码翻译为 C++ 代码，即 clang -rewrite-objc main.m -o main.cpp；也可以结合 xcrun -sdk 命令设置编译所基于的 SDK。
   Options Usage     -arch arm64 指定编译架构   -framework UIKit 依赖 UIKit 框架   -fobjc-arc 使用 ARC（自动引用计数）模式   -fnoobjc-arc 使用 MRC（手动引用计数）模式   -fobjc-runtime=ios-12.</description>
    </item>
    
    <item>
      <title>Obj-C 中的 Block</title>
      <link>/posts/2019/block_in_obj-c/</link>
      <pubDate>Sun, 24 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/block_in_obj-c/</guid>
      <description>Date Notes Demo Source Code     2019-07-27 首次提交 - -   2019-11-24 重新整理部分内容；补充《Effective Objective-C 2.0》&amp;amp;《Objective-C 高级编程》相关内容 Block_in_Obj-C objc4-756.2、libclosure-73    Preface 从 OS X Snow Leopard 和 iOS 4 开始，Apple 引入了 Block 的概念。Obj-C 中的 Block 即通常意义上的匿名函数，而之所以引入是因为 C 语言中并不支持匿名函数。这使得 Block 在 Obj-C 中可以称为是一类公民（First-Class Citizen），既可以作为类的属性，也可以作为函数参数或返回值来传递。那么本文就将着眼于此，谈谈 Obj-C 中的 Block。
Prerequisites 匿名函数与 Block 匿名函数顾名思义，即不带名称的函数，而 C 语言中即使是函数指针也仍然需要通过函数名来获得其地址：
// C 语言函数 int cFunc(int arg) { return arg; } int main_1(int argc, const char * argv[]) { int result1 = cFunc(10); // C 语言中的函数指针需要通过函数名来获得其地址  int (*cFuncPtr)(int) = &amp;amp;cFunc; int result2 = (*cFuncPtr)(10); printf(&amp;#34;result1 = %d, result2 = %d\n&amp;#34;, result1, result2); return 0; } // OUTPUT: // result1 = 10, result2 = 10 Obj-C 中的匿名函数被称为 Block，中文有译作块、闭包（Closure），其实很多语言都有类似的机制，比如 Swift 中的 Closure，Java / Python / C++ 11 中的 Lambda（λ）表达式，JavaScript 中的匿名函数等。</description>
    </item>
    
    <item>
      <title>《编写高质量 iOS 与 OS X 代码的 52 个有效方法》阅读笔记</title>
      <link>/posts/2019/effective_obj-c_2.0_notes/</link>
      <pubDate>Sun, 24 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/effective_obj-c_2.0_notes/</guid>
      <description>Book ISBN Notes     《编写高质量 iOS 与 OS X 代码的 52 个有效方法》 9787111451297 《Effective Objective-C 2.0》   Date Num. Xcode   2019-05 1-3 10.2.1   2019-06 4 10.2.1   2019-07 5-12 10.2.1   2019-10 13-20 11.1 &amp;amp; 11.2   2019-11 20-52 11.1 &amp;amp; 11.2    Preface 《编写高质量 iOS 与 OS X 代码的 52 个有效方法》原著名为《Effective Objective-C 2.0》，是类似笔者这样的 iOS 初级入门者必读书目之一。本文不仅是此书的阅读笔记，也有 Demo 代码等，较为独立的篇章内容则融入笔者以往的独立文章中。</description>
    </item>
    
    <item>
      <title>双 11 买买买 - 开始抢购啦 💰</title>
      <link>/posts/2019/shopping_1111/</link>
      <pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/shopping_1111/</guid>
      <description>依稀还记得 618 那篇令我怀疑纯技术博客前途的一篇 😓 ——《618 买买买 - 这个 618 我都买了啥？》。转眼双十一又来了，又刚好遇到新域名切换，流量与搜索引擎收录都不甚乐观&amp;hellip; 不如再来一波？（笑
经历过这两年各个电商的种种购物节，我不得不说：拼多多，真香！
种草 🌿 拼多多    名称 折扣 链接 WHY     大疆灵眸手机云台 3 套装版
DJI OSMO MOBILE 3 ¥ 729 戳我直达 VLOG 吃灰预定？（逃
已恢复原价   任天堂 Switch 续航升级版游戏机 ¥ 2090 戳我直达 ~~塞尔达、健身环大冒险了解一下？~~
暂无游戏打算，拔草    京东    名称 折扣 链接 WHY     保温杯 - - 暂未确定
非刚需，暂不入    已剁 💰    名称 价格 渠道 时间 备注     AirPods Pro with Apple Care + ¥ 1999 + 299</description>
    </item>
    
    <item>
      <title>设计模式之美</title>
      <link>/reading/beauties_of_design_patterns/</link>
      <pubDate>Thu, 07 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/reading/beauties_of_design_patterns/</guid>
      <description>Name Author ISBN     设计模式之美 王争 -      设计原则
 SOLID 原则 - SRP 单一职责原则 SOLID 原则 - OCP 开闭原则 SOLID 原则 - LSP 里式替换原则 SOLID 原则 - ISP 接口隔离原则 SOLID 原则 - DIP 依赖倒置原则 DRY 原则、KISS 原则、YAGNI 原则、LOD 法则    设计模式分类
   创建型 常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。 不常用的有：原型模式。 结构型 常用的有：代理模式、桥接模式、装饰者模式、适配器模式。 不常用的有：门面模式、组合模式、享元模式。 行为型 常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。 不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。  重构的目的（why）、对象（what）、时机（when）、方法（how）； 保证重构不出错的技术手段：单元测试和代码的可测试性； 两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）。</description>
    </item>
    
    <item>
      <title>iOS 中的库与框架</title>
      <link>/posts/2019/libraries_in_ios/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/libraries_in_ios/</guid>
      <description>Date Notes     2019-09-14 首次提交，持续更新完善   2019-09-22 适配 Xcode 11，持续更新完善   2019-10-29 添加 Demo：libraries_in_ios-demo    Preface 随着软件工程的发展，很多我们需要的功能前人都已经很好地实现了，为了提高效率避免重复建设，这些功能实现的代码被封装为代码库，有时也称框架。我们只需要在用到的时候通过依赖管理工具将它们以适当的方式引入即可。本文将简单聊聊 iOS 中的库与框架相关概念。
基本概念 在切入正题之前，我们先来达成一些共识。
不管是老派 Obj-C 还是新秀 Swift，它们的本质都是编译型语言。对于编译型语言，源代码会首先经由编译器编译为目标文件，链接器再将多个目标文件链接为可执行文件。针对链接阶段，主要分为静态链接与动态链接。
静态，即 Static。按照字面意思，静态即一旦确定，就不再容易改变。静态链接，即在链接阶段，直接将多个目标文件链接为一个文件。而静态库就可以理解为共同编译为一个目标文件的源代码集合。
动态，即 Dynamic。按照字面意思，动态即推迟到运行时动态地决议。动态链接，即在运行时才将各个部分组合形成完整的程序。而动态库就可以理解为支持动态链接方式的源代码集合。
静态链接的好处是，运行时不再额外需要时间动态链接；坏处则是由于链接的粒度是目标文件，那么可能会链接了没有使用到的函数，会造成可执行文件过大；而且当某一个目标文件的源代码改动时，那么所有依赖该目标文件的静态库都需要重新编译；动态链接则解决了静态链接的空间浪费与重复编译问题，比如在 iOS 中，系统库采用了 dyld_shared_cache 动态链接，这样其它程序就无需再将系统库重复链接，当 iOS 系统更新时也无需将所有 app 重新编译。而在移动端开发中，app 的启动时间与包体积大小将是一个权衡问题，值得我们侧重与考量。
另外，虽然广义上的库（Library）与框架（Framework）含义是类似的，但在 iOS 开发中，官方将这两个概念进行了区分，因此下文中我们会明确两个词的使用。
Cocoa Touch Static Library 我们先从 Xcode 中能够直接创建的 Cocoa Touch Static Library 说起（注意，在 Xcode 11 中，这里已经变成 Framework 与 Library，更加清晰）：</description>
    </item>
    
    <item>
      <title>iOS 中的 Category</title>
      <link>/posts/2019/category_in_ios/</link>
      <pubDate>Wed, 23 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/category_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-04-16 优化结构 - -   2019-04-13 首次提交 objc4-750、xnu-4903.221.2 Category in iOS   2019-10-23 添加首图，细节微调 - -    Preface iOS 中的 Category 中文常译作分类、类别（为表述统一，本文将使用 Category 特指该技术）。我们经常会使用 Category 来对一个类进行扩展，使得在不破坏主类结构的同时可以具备更多的功能；也可以使用 Category 对一个类进行拆分，使得其结构更加清晰条理。本文将从 What - How - Why 谈谈 iOS 中 Category。
What 什么是 Category 呢？
Category 是 Obj-C 语言中所提供的一项功能，它可以为 Obj-C 类添加额外的属性、方法，也可以遵守其他协议。
Xcode 中已经为 Category 已经提供了模版来建立，只需要指定 Category 的名称以及被添加 Category 类名即可。当然，我们也可以手动来自己建立，Category 的语法与类的声明与实现比较类似：</description>
    </item>
    
    <item>
      <title>浅尝 objc_msgSend</title>
      <link>/posts/2019/objc_msgsend/</link>
      <pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/objc_msgsend/</guid>
      <description>Date Notes Refers.     2019-07-20 首次提交 objc4-750.1   2019-09-07 完成「缓存、动态方法解析」等部分 Obj-C 中的对象 - kingcos   2019-10-21 补充《Effective Objective-C 2.0》相关内容 《〈编写高质量 iOS 与 OS X 代码的 52 个有效方法〉阅读笔记 - kingcos》    Preface Obj-C 中方法调用的本质是消息发送机制，即 [foo bar] 是向 foo 对象发送一条 bar 的消息，而消息发送就是通过 objc_msgSend 所进行的。那么这次本文就简单窥探一下 objc_msgSend 吧。
Why 在开始之前，先思考以下为什么 Obj-C 中方法调用的本质是 objc_msgSend 呢？
我们创建一个使用 Obj-C 的 iOS 项目，如下在 ViewController 中添加一个按钮，并在按钮的点击事件中创建一个 Obj-C 对象，再调用其方法：
#import &amp;#34;ViewController.</description>
    </item>
    
    <item>
      <title>与 Visual Studio Code 共舞</title>
      <link>/posts/2019/coding_with_vs_code/</link>
      <pubDate>Sat, 12 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/coding_with_vs_code/</guid>
      <description>Date Notes     2019-08-30 涵盖 Debug Go &amp;amp; Ruby 配置、设置、插件   2019-11-12 增加 Debug CocoaPods &amp;amp; 插件    Preface VS Code（全称 Visual Studio Code），是微软推出的一款插件化编辑器。比 IDE 轻量，又比终端更容易上手，本文将罗列一些我在使用的设置、配置、插件等，也欢迎大家建言献策～
Debug Settings    Name Effect     Auto Save 自动保存，防止意外   Format On Save 保存时自动进行代码格式化    Go  插件：ms-vscode.Go  // launch.json { &amp;#34;version&amp;#34;: &amp;#34;0.2.0&amp;#34;, &amp;#34;configurations&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;Debug Go Local File by kingcos.</description>
    </item>
    
    <item>
      <title>iOS 自动化测试之 WDA &amp; Appium</title>
      <link>/posts/2019/ios_test_automation/</link>
      <pubDate>Thu, 19 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/ios_test_automation/</guid>
      <description>Date Notes     2019-09-19 首次提交    WebDriverAgent 安装依赖：
./Scripts/bootstrap.sh 打开 WebDriverAgent.xcodeproj，选择 WebDriverAgentLib，并使用「Command + B」编译：
编译后，我们将 Scheme 改为 WebDriverAgentRunner，并使用「Command + U」执行测试：
有时通过网络连接会受很多限制或速度较慢，我们也可以将电脑本机端口映射到 USB 连接的手机端口：
brew install usbmuxd iproxy 8100 8100 此时通过 http://localhost:8100/status 即可测试端口是否映射成功：
{ &amp;#34;value&amp;#34; : { &amp;#34;state&amp;#34; : &amp;#34;success&amp;#34;, &amp;#34;os&amp;#34; : { &amp;#34;name&amp;#34; : &amp;#34;iOS&amp;#34;, &amp;#34;version&amp;#34; : &amp;#34;12.0.1&amp;#34; }, &amp;#34;ios&amp;#34; : { &amp;#34;simulatorVersion&amp;#34; : &amp;#34;12.0.1&amp;#34;, &amp;#34;ip&amp;#34; : &amp;#34;164.20.130.96&amp;#34; }, &amp;#34;build&amp;#34; : { &amp;#34;time&amp;#34; : &amp;#34;Sep 20 2019 20:43:27&amp;#34; } }, &amp;#34;sessionId&amp;#34; : &amp;#34;C1A52844-D32F-43F7-91C7-ADC6B3BF5BD4&amp;#34;, &amp;#34;status&amp;#34; : 0 } Appium Appium 可以使用 npm 来安装，而 npm 可以使用 Homebrew 来安装（如果 npm 速度过慢，可以使用 cnpm）：</description>
    </item>
    
    <item>
      <title>iOS 中的 &#43;load 方法</title>
      <link>/posts/2019/&#43;load_in_ios/</link>
      <pubDate>Fri, 13 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/&#43;load_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-04-20 首次提交 objc4-750 Load_Obj-C_Demo   2019-09-13 增加 Swift 等部分 - -    Preface 在 iOS 开发中，我们经常会使用 +load 方法来做一些在 main 函数之前的操作，比如方法交换（Method Swizzle）等。那么本文就来简单了解下 iOS 中 +load 方法。
What iOS 中的 +load 方法指的是 NSObject 中的 + (void)load 类方法：
// NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { + (void)load; } 官方文档中的 +load 如下：
 Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</description>
    </item>
    
    <item>
      <title>App Store 面面观</title>
      <link>/posts/2019/app_store/</link>
      <pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/app_store/</guid>
      <description>Preface 一款 app 从开发者手里到最终交付到用户桌面的整个过程中，编写代码只是其中小小的一环，我们需要搭建相应的开发环境、分发完整产物进行测试、并最终将其配以合适的宣传文案以供用户享用。本文将叙述作为一名一线 iOS 开发者与 App Store「打交道」的纪实经历。
   Date Notes     2019.08.30 首次提交    分发渠道 App Icon app 图标是用户触及 app 的第一扇门，而由于目前苹果设备分辨率众多，每个设备所需的尺寸都不大一致。另外 iOS/watchOS 会自动对 icon 进行圆角矩形化裁切，并根据某些动画进行拉伸，因此提供的 icon 不要进行手动裁切。
目前最新 Xcode（11.0）中一个项目所需 app icon 的全部尺寸如下表；单位为 pt，可根据 Image Size 相乘换算为所需的 px；划掉的尺寸意味着与其它已有所需尺寸重复，可无需再次提供。
 iOS:      Position Image Size iPhone iPad iPad Pro (12.9)     Notification 1x - 20 * 20 -   Notification 2x 20 * 20 20 * 20 -   Notification 3x 20 * 20 - -   Settings 1x - 29 * 29 -   Settings 2x 29 * 29 29 * 29 -   Settings 3x 29 * 29 - -   Spotlight 1x - 40 * 40 -   Spotlight 2x 40 * 40 40 * 40 -   Spotlight 3x 40 * 40 - -   App 1x - 76 * 76 -   App 2x 60 * 60 76 * 76 83.</description>
    </item>
    
    <item>
      <title>SwiftTips in Reverse</title>
      <link>/posts/2019/swift_tips_in_reverse/</link>
      <pubDate>Tue, 27 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/swift_tips_in_reverse/</guid>
      <description>Preface SwiftTips 是 John Sundell 在 GitHub 开源的 Swift 小技巧列表。随着 Swift 5 的发布以及 ABI 稳定，是时候再学习一遍 Swift 啦。本文将是该列表的实践版本，并保证文中代码的可运行性，且尽可能做到倒序日更。（But why in reverse? 🤫）
关于本文的代码，都可以在 swift-tips-in-practice 下载并实际运行。
   Date Update Date Update Date Update     2019.08.22 #102 2019.08.23 #100 2019.08.27 #99    #102 让异步测试执行更快更稳定 异步代码似乎总是很难去编写单元测试，因为我们不清楚什么时候请求才能回来。现在在 Swift 中，我们可以使用 expectation（预料）简单设定超时时间，并在 Closure 回调时调用 fulfill() 即可轻松实现。
Talk is cheap, show me the code!
import XCTest @testable import TestUnitTest class TestUnitTestTests: XCTestCase { func fetchFromNetwork(_ completion: @escaping (String) -&amp;gt; Void) { DispatchQueue.</description>
    </item>
    
    <item>
      <title>Obj-C 中的 isa 指针</title>
      <link>/posts/2019/isa_in_objc/</link>
      <pubDate>Sun, 18 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/isa_in_objc/</guid>
      <description>Date Notes Refer.     2019-08-18 首次提交 objc4-750.1    Preface isa 指针是所有 Obj-C 对象中都拥有的一个成员。因为除了继承链之外，Obj-C 还特有一条从实例对象到类对象、元类对象的链。而后者正是依靠 isa 而串联起来的，那么本文就将结合源码谈谈 Obj-C 中的 isa。
对于不大熟悉 Obj-C 中对象的同学，可以先行阅读 Obj-C 中的对象一文。
Where // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { #pragma clang diagnostic push #pragma clang diagnostic ignored &amp;#34;-Wobjc-interface-ivars&amp;#34;  Class isa OBJC_ISA_AVAILABILITY; // ⬅️ #pragma clang diagnostic pop } // objc-runtime-new.h struct objc_class : objc_object { // Class ISA; } // objc-private.</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43; 中的位域与共用体</title>
      <link>/posts/2019/bit_field_union_in_cpp/</link>
      <pubDate>Sat, 17 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/bit_field_union_in_cpp/</guid>
      <description>Date Notes Env     2019-08-17 首次提交 clang++、macOS 10.14.4    Preface C/C++ 中有许多「奇技淫巧」来让开发者能够以效率更高的方式使用内存，这也是一些高级语言着力去避讳的一点，但这种能够直面内存细节的「踏实感」让我个人觉得非常安心。本文将简单涉及 C/C++ 中的位域（Bit Field）与共用体（Union）的概念。
位域 布尔类型 对于布尔（Boolean）类型，我们都知道其只有两种值：逻辑真或逻辑假。在 C 语言中，其实并没有严格意义上的布尔类型；而在 C++ 中，则诞生了专用的 bool 类型：
#include &amp;lt;iostream&amp;gt; using namespace std; int main() { bool foo = true; bool bar = 0; cout &amp;lt;&amp;lt; foo &amp;lt;&amp;lt; endl; // 1  cout &amp;lt;&amp;lt; bar &amp;lt;&amp;lt; endl; // 0  cout &amp;lt;&amp;lt; sizeof(foo) &amp;lt;&amp;lt; endl; // 1  cout &amp;lt;&amp;lt; sizeof(bar) &amp;lt;&amp;lt; endl; // 1  return 0; } 如上，在 C++ 中，true 和非 0 代表布尔类型中的逻辑真，false 和 0 代表逻辑假。bool 类型的值通常在 C++ 中占用一个字节长度（「通常」代表对于不同的编译器结果可能并非完全一致）。</description>
    </item>
    
    <item>
      <title>10x 程序员工作法</title>
      <link>/reading/efficient_rules_of_work_for_programmers/</link>
      <pubDate>Thu, 01 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/reading/efficient_rules_of_work_for_programmers/</guid>
      <description>Name Author ISBN     10x 程序员工作法 郑晔 -      本质复杂度（Essential Complexity）和偶然复杂度（Accident Complexity）。 简单来说，本质复杂度就是解决一个问题时，无论怎么做都必须要做的事，而偶然复杂度是因为选用的做事方法不当，而导致要多做的事。
  大部分程序员忙碌解决的问题，都不是程序问题，而是由偶然复杂度导致的问题。
  以终为始； 任务分解； 沟通反馈； 自动化。
  在我看来，所有做软件的人能力都很强，这些问题都只是因为不会工作造成的，但更可怕的是，许多人深陷泥潭而不自知。
  直觉是本能的，无需积累，而洞见是溯因推理（Abductive Reasoning），需要前期进行大量的积累之后，从中发现模式，方能形成洞见。
  你把结果当成了原因，优秀的程序员能够快速解决问题，是因为它已经做了大量积累，有自己的知识体系，任何领域想做到一定的水准都需要刻意练习，而且是大量的刻意练习。
  我希望专栏的读者在学过之后，遇到事情开始动脑想想为什么和怎么做，你的回复让我觉得我的初衷达成了。
  t.cn/EGeYlAA，一个讲本质复杂度和偶然复杂度的视频
  Where are we?（我们现在在哪？） Where are we going?（我们要到哪儿去？） How can we get there?（我们如何到达那里？） 这三个问题实际上是帮我们确定： 现状； 目标； 实现路径。 如果一个人能够清晰地回答出这三个问题，通常意味着他对要做的事有着清晰的认识。
  工作。比如，</description>
    </item>
    
    <item>
      <title>成为乔布斯</title>
      <link>/reading/becoming_steve_jobs/</link>
      <pubDate>Thu, 01 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/reading/becoming_steve_jobs/</guid>
      <description>Name Author ISBN     成为乔布斯 [美] 布伦特 · 施兰德 / [美] 里克 · 特策利 9787508662404      这不是关于成功的故事，而是关于成长的故事。
  他回答问题时字斟句酌，即使是回答意料之外的问题也是如此。
  麦肯纳是史蒂夫早期最重要的导师，他曾经说过「史蒂夫在市场营销方面有着过人的天赋，在 22 岁的时候已经有了敏锐的直觉。他知道索尼的伟大之处，也了解英特尔的伟大之处，他希望自己的产品也能享有如此声誉」。
  他曾在邮件里对我说：「回顾过去没有什么意义，我情愿向前看」。
  NeXT 保证了他职业生涯的后续发展，而皮克斯给了他财务自由。
  史蒂夫对汽车的热爱就如同他对莲黑胶唱机（Linn Sondek）的热爱，以及对摄影大师安塞尔 · 亚当斯（Ansel Adams）的铂盐印相法的热爱。
  他对于电脑的设想直接来源于汽车：功能强大、造型优美、效率高超，没有多余的配件。
  罗伯特 · 弗里德兰（Robert Friedland）和史蒂夫打了声招呼，正是弗里德兰促成了史蒂夫 1974 年的印度朝圣之旅。
  你们应该找最优秀的人，不能退而求其次。
  他极度缺乏耐心，认为唯一值得花力气去解决的问题应该是需要好几年才能解决的难题。
  相信自己是特别的，并且想把事情做到完美，这是史蒂夫从小接受的教育。
  沃兹是工程天才，史蒂夫则是天才的成就者，</description>
    </item>
    
    <item>
      <title>蒂姆 · 库克传</title>
      <link>/reading/about_tim_cook/</link>
      <pubDate>Thu, 01 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/reading/about_tim_cook/</guid>
      <description>   Name Author Translators ISBN     蒂姆 · 库克传 [美] 利恩德 · 卡尼（Leander Kahney） 李世凡、梁德馨 9787521706468      准时生产的理念在美国通常被称作「精益生产」，最初是为了有效满足客户的需求，同时避免生产过剩。20 世纪六七十年代，在丰田的带动下，这种生产理念在日本普及开来。自动化和准时生产是丰田整个生产系统的两大支柱，这种方式不仅提高了生产效率，也提高了投资回报率。
  库克上的道德课让他开始用不同于行业内大多数人的思考方式进行思考，他从中学到的一个道理就是：将你发现的事物留下，并让它们比被发现时更好，从保护环境到尊重雇员，方方面面。这一信条支撑起了库克的信念，并成为这位苹果 CEO 身上一个无法磨灭的印记。
  </description>
    </item>
    
    <item>
      <title>Xcode 中的 Link Map 文件</title>
      <link>/posts/2019/link_map_file_in_xcode/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/link_map_file_in_xcode/</guid>
      <description>Date Notes Xcode Swift     2019-04-01 首次提交 10.1 -   2019-04-16 增加 Swift 项目 10.1 4.2   2019-07-28 增加目录导图，折叠过长内容 - -    Preface Link Map File，译作链接映射文件（下文将称 Link Map 文件）。Xcode 在构建可执行文件之前，需要先编译为目标文件（Object File），并链接所需要的其他库，那么 Link Map 文件就记录了链接器（Linker）在链接过程中产生的一些信息，本文将谈谈这个文件的构成。
What Xcode 中默认是不会将 Link Map 文件在构建时暴露出来的，需要我们手动在「Build Settings」-「Write Link Map File」-「Yes」打开该写入该文件的设置。这样当我们再次编译项目，默认就可以在 ~/Library/Developer/Xcode/DerivedData/&amp;lt;TARGET_NAME&amp;gt;-&amp;lt;Random_ID&amp;gt;/Build/Intermediates.noindex/&amp;lt;TARGET_NAME&amp;gt;.build/Debug-&amp;lt;Device_Type&amp;gt;/&amp;lt;TARGET_NAME&amp;gt;.build/&amp;lt;TARGET_NAME&amp;gt;-LinkMap-normal-&amp;lt;Arch&amp;gt;.txt 中找到。如有更改 Link Map 文件路径的需求也可以在「Path to Link Map File」中更改。
举个例子，我的 DemoiOS 项目（Obj-C）中 Link Map 文件的完整路径为：/Users/kingcos/Library/Developer/Xcode/DerivedData/DemoiOS-hifhuapijabsaxgpelrpiwhbzlqv/Build/Intermediates.noindex/DemoiOS.build/Debug-iphonesimulator/DemoiOS.build/DemoiOS-LinkMap-normal-x86_64.txt。
How 下面来分析一下 Link Map 文件的构成。</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43; 中的 const、static &amp; extern</title>
      <link>/posts/2019/const_static_extern_in_cpp/</link>
      <pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/const_static_extern_in_cpp/</guid>
      <description>Date Notes Env     2019-07-23 首次提交 clang++、macOS 10.14.4    Preface const、static &amp;amp; extern 是 C/C++ 中的关键字，而在 iOS 开发中的 Obj-C/C++ 又是 C/C++ 的超集，那么本篇就简单梳理一下这些关键字的作用。
const 基础类型 int a = 0; a = 10; 对于基础类型，其在内存中存储的即是该类型的变量本身，经过 const 修饰后，此处的变量不可变，即常量。const 的位置并不会影响其作用，更为推荐的写法应当是编译器提示的 const &amp;lt;TYPE&amp;gt;。
以下是在 C/C++ 中的用例，由于 Obj-C/C++ 分别是 C/C++ 的超集，对于 C/C++ 的基础类型，其在 Obj-C/C++ 中的表现是一致的：
const int b = 0; // error: cannot assign to variable &amp;#39;b&amp;#39; with const-qualified type &amp;#39;const int&amp;#39; // b = 10;  int const c = 0; // c = 10; 对于 Obj-C 中特有的基础类型，const 也与修饰 C/C++ 中基础类型的行为一致：</description>
    </item>
    
    <item>
      <title>[译] 摊平由「try?」造成的嵌套可选</title>
      <link>/posts/2019/0230-flatten-optional-try_zh/</link>
      <pubDate>Mon, 08 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/0230-flatten-optional-try_zh/</guid>
      <description>提案: SE-0230 作者: BJ Homer 审查管理员: John McCall 状态: 已实现 (Swift 5) 实现: apple/swift#16942 审查: (论坛帖子) (验收)  介绍 Swift 中的 try? 语句目前很容易引入嵌套可选（译者注：嵌套可选即类似 var foo: String?? 可选的可选类型）。而用户难以推断嵌套可选的产生原因，所以 Swift 尝试避免在一些常见情况下产生嵌套可选。
该文档提议给予 try? 与其它常见的 Swift 功能中相同的可选摊平行为（译者注：可选摊平即将可选类型的值去掉可选的一层），来避免常见的嵌套可选。
Swift-evolution 帖子: 使 try? 与可选链摊平协同工作
动机 目前，使用 try? 非常容易产生嵌套的 Optional 类型。虽然构建嵌套可选是被允许的，但这通常并非是开发者所希望的。
Swift 拥有许多机制来避免意外创建嵌套可选。比如：
// 注意 as? 是如何可以无视被转换的值是否是可选类型的，其总是产生了相同的类型 let x = nonOptionalValue() as? MyType // x 是 &amp;#39;MyType?&amp;#39; 类型 let y = optionalValue() as? MyType // y 是 &amp;#39;MyType?</description>
    </item>
    
    <item>
      <title>爱你就像爱生命</title>
      <link>/reading/love_you_as_loving_lives/</link>
      <pubDate>Fri, 21 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/reading/love_you_as_loving_lives/</guid>
      <description>Name Author ISBN     爱你就像爱生命 王小波、李银河 -      要对人和社会发一点议论就这么费劲，要是先入为主的决定了什么应该赞美，什么应该贬低就容易了，这就是写一流东西的难处。
  有人说当孩子的时候最幸福，其实远非如此。如果说人在童年可以决定自己生命的前途，那么就是当孩子的时候最幸福，其实有一种我们不能左右的力量参加进来决定我们的命运，也就是说，我们被天真欺骗了。
  还有一次规模宏大的把肉麻当有趣，就是六八、六九年闹林彪的时候。
  肉麻是什么呢？肉麻就是人们不得不接受降低人格行为时的感觉
  我有点担心你锋芒太外露。这年头上战场要有点策略，打得赢就打，打不赢就装哑巴。
  大略是现代科学的发达占用了很多的剩余精力，所以现在只能有很低等的文学，这是说西方世界。
  总之，人们应当为自己的剩余精力建设美好的精神生活，这是物质所代替不了的。
  我又在想，什么是文学的基本问题。今天下午三点四十五分我的答案是：人可以拥有什么样的生活。
  中国人真是可怕！有很多很多中国人活在世上什么也不干，只是在周围逡巡，发现了什么就一拥而上。比方说，刘心武写了《班主任》，写得不坏，说了一声：“生活不仅如此！”就有无数的人拥了上去，连声说：“太对太对！您真了不起！您是班主任吧？啧啧，这年头孩子是太坏。”肉麻得叫人毛骨悚然。我觉得这一切真是糟透了。
  还有我。我是爱你的，看见就爱上了。我爱你爱到不自私的地步。就像一个人手里一只鸽子飞走了，他从心里祝福那鸽子的飞翔。你也飞吧。我会难过，也会高兴，到底会怎么样我也不知道。
  我会不爱你吗？不爱你？不会。爱你就像爱生命。算了。不胡扯。
  你想知道我对你的爱情是什么吗？就是从心底里喜欢你，觉得你的一举一动都很亲切，不高兴你比喜欢我更喜欢别人。你要是喜欢了別人我会哭，但是还是喜欢你。你肯用这样的爱情回报我吗？就是你高兴我也高兴，你难过时我来安慰你，还有别爱別人！可惜的是你觉得我长得难看。这怎么办？我来见你时应当怎样化妆？你说吧。
  萧伯纳的名言：“真正的婚姻全是在天上缔结的。”这句话是一个不到二十岁的女孩子爱上一个八十岁以上的萧非特船长时说的。
  我把我整个的灵魂都给你，连同它的怪癖，耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你。
  就是，人是轻易不能知道自己的，因为人的感官全是向外的，比方说人能看见別人，却不能看见自己；人可以对別人有最细微的感觉，对自己就迟钝得多。
  所以我永远不会想把別人的灵魂据为己有。我只希望我们的灵魂可以互通，像一个两倍大的共同体，你知道吗，孤独的灵魂多么寂寞啊，人又有多少弱点啊（这是使自己哭泣的弱点）。
  本着这些信念，我很希望你绝对自由，我希望你的灵魂高飞。
  要是到那时我变了主意，那就是我变坏了，你就丢开我好啦。</description>
    </item>
    
    <item>
      <title>禅与摩托车维修艺术</title>
      <link>/reading/zen_and_the_art_of_motorcycle_maintenance/</link>
      <pubDate>Fri, 21 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/reading/zen_and_the_art_of_motorcycle_maintenance/</guid>
      <description>   Name Author ISBN     禅与摩托车维修艺术 Robert Maynard Pirsig -     在阅读本书约 50% 进度时，觉得翻译有些生硬，继续读下去有点难以继续，因此暂停阅读。
 </description>
    </item>
    
    <item>
      <title>618 买买买 - 买家秀</title>
      <link>/posts/2019/shopping_618_show/</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/shopping_618_show/</guid>
      <description>Preface 首先让大家感受一下技术博客的衰落（逃，自从在 V2EX 简单地回复了一句我的购物清单链接，博客的浏览量暴增 10,000% +，可以看下图感受下～ 😅
下面我将把陆续到货的东西晒单给大家，虽然我也想开个 B 站录点视频，但没有器材，不会剪辑，大家可以简单看看 - -（~~反响好的话我可以考虑 &amp;hellip; 呸，需求写完了吗？又做梦呢？）
办公椅  🤨 几十块的「地摊货」真的有必要晒单？
是的，首次拍摄 vlog，练练手！B 站链接请戳 👉 av56153142，也可以直接看 👇
  Apple Watch 🌈 表带  av57162876
  Reference  618 买买买 - 这个 618 我都买了啥？  </description>
    </item>
    
    <item>
      <title>618 买买买 - 这个 618 我都买了啥？</title>
      <link>/posts/2019/shopping_618/</link>
      <pubDate>Sat, 15 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/shopping_618/</guid>
      <description>Preface 为了让大家窥（zhong）探（cao）我 618 都败（Buy）了什么，特此总结一份清单，方便给大家参考（手动滑稽 🌝。
话说发表那条带有本文链接的回复之后，昨天看了下网站的访问数据，流量瞬间暴增 11,900%&amp;hellip; 果然写技术博客是没前途的。所以是不是可以考虑等这些东西到货，再发一贴开箱贴呢？然后再发到 V2 上～
 薅羊毛宣言：一切为了优惠而不考虑实际需求的消费，都是反撸。
以下订单统计日期均从 2019 年 6 月 1 日起直到 618 当天，目前快递在慢慢到货。我将在另外一篇中进行晒单：戳这里跳转～。
 京东 自从前几年开通了 Plus 会员，和东哥做了兄弟，日常生活所需基本上都交给了东哥。配送快，服务稳，支持价格保护，售后放心，是我和东哥当兄弟看重的几点。
   日期 名称 个数 总价 备注     6.1 美的洗碗机 M1（赠品：只换不修服务、水卫仕洗涤块）+ 全保修 4 年 1 1699-700+139-10=999+129 「秒杀价」购入；「全保修」是在到货前补购的；寄给父母的   6.1 汤臣倍健蛋白粉（赠品：B 族维生素片、摇摇杯） 1 186-10-1.7-57.18-22.37=94.75 Apple Pay 立减优惠未计入总价；寄给父母的   6.1 百乐笑脸钢笔 M 尖 * 1 + 百乐 P500 中性笔 * 1 + 百乐钢笔上墨器 * 1 + 百乐 6 支装墨囊 + 百乐笑脸钢笔 F 尖 * 1 - 174.</description>
    </item>
    
    <item>
      <title>iOS 中的关联对象</title>
      <link>/posts/2019/associated_objects_in_ios/</link>
      <pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/associated_objects_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-05-18 首次提交 objc4-750 -    Preface 提到 iOS 中的关联对象，即 Associated Objects，又可以算是一项利用 Runtime 的「黑魔法」。然而作为初学者，很难从其名称联想到是为谁关联对象，以及是如何关联对象的，那么今天就来一起研究下 iOS 中的关联对象是什么、怎么用、以及为什么。
What 虽然这部分的官方文档已经「年久失修」，不过我们仍然简单看一下官方的概括：
 Associative References
Associative references, available starting in OS X v10.6, simulate the addition of object instance variables to an existing class. Using associative references, you can add storage to an object without modifying the class declaration. This may be useful if you do not have access to the source code for the class, or if for binary-compatibility reasons you cannot alter the layout of the object.</description>
    </item>
    
    <item>
      <title>谈谈我的家庭保险计划</title>
      <link>/posts/2019/insurance_plan/</link>
      <pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/insurance_plan/</guid>
      <description>Date Notes     2019-05-14 首次提交    前言 曾经我也和很多人一样，都认为「保险」是坑人的。但后来经过一番研究，保险也确实很有必要，当然，我们都不希望保险真正被用到。这一篇就简单罗列下我为自己和家人目前配置的保险计划。
后续的更新也将会补充至此。
配置 本人  缺失寿险、终身重疾险、意外险
    名称 类别 平台 价格 推荐指数     好医保 · 长期医疗 医疗险 支付宝 149 元每年 ★★★☆☆   药神保 · 抗癌计划保障（基础版） 医疗险 微信 1 元每月 ★★★★★   微医保 · 重疾险 重疾险 微信 约 28 元每月 ★☆☆☆☆   - - - 共计约 509 元每年 -   微车保 · 驾乘意外险（福利版） 意外险 微信 0 -   相互宝 非保险 支付宝 - ★★★★☆    父母  缺失意外险</description>
    </item>
    
    <item>
      <title>[译] 在 Objective-C API 中指定可空性</title>
      <link>/posts/2019/nullability_in_obj-c/</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/nullability_in_obj-c/</guid>
      <description>作者 原文链接     Apple Inc. Designating Nullability in Objective-C APIs    使用可空性（Nullability）标志或标志一块区域，以控制将 Objective-C 声明导入 Swift 中的方式。
 框架：  Swift 标准库     概览 在 Objective-C 中，常用可以为空的指针来和对象的引用打交道，这（个空）就是 Objective-C 中的 nil。在 Swift 中，所有值——包括对象实例——都被确保为非空（Non-null）。取而代之，表示一个可能丢失的值可以将其包裹在可选（Optional）类型中。当我们需要表示一个值的丢失，可以使用 nil 值。
我们可以在 Objective-C 的代码中标示声明，以指示一个实例是否可以有空（Null）或 nil 值。这些标志改变了 Swift 如何导入声明（的方式）。举个 Swift 如何导入未标示声明的例子，如下：
@interface MyList : NSObject - (MyListItem *)itemWithName:(NSString *)name; - (NSString *)nameForItem:(MyListItem *)item; @property (copy) NSArray&amp;lt;MyListItem *&amp;gt; *allItems; @end Swift 导入了每个对象实例的参数、返回值、以及作为隐式包裹可选的属性（译者注：隐式包裹即 Type!</description>
    </item>
    
    <item>
      <title>Swift/Obj-C 混编项目升级 Swift 5.0 踩坑</title>
      <link>/posts/2019/swift_4_to_5/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/swift_4_to_5/</guid>
      <description>Date Note     2019-05-08 Swift 4.2 -&amp;gt; 5.0   2019-07-08 完善内容    Preface 在 ABI 稳定前，每次 Swift 升级都是一个比较「痛苦」的体验。这次笔者花费约总共一天时间将 Swift/Obj-C 混编项目升级到 Swift 5.0，其中还是有一些踩坑经验值得分享的。
Xcode 为了适配 Swift 5.0，首先需要安装 Xcode 10.2。而我们不能完全抛弃 Xcode 10.1，毕竟在未完全转换到 Swift 5.0 的过渡阶段仍然需要使用。因此我们可以将本地的 Xcode 更名为 Xcode-10.1，再在 https://developer.apple.com/download/more/ 检索 Xcode 下载 10.2 版本即可。
 ⚠️ 注意：为了防止类似 XcodeGhost 事件再次发生，建议从该官方渠道或 App Store 直接下载。
 为了便于区分，我们将新的 Xcode 命名为 Xcode-10.2，并打开、同意安装 Xcode Command Line Tools。由于我们目前安装了两个 Xcode，如果需要命令行执行 swift 或 xcodebuild 等命令，可以使用 xcode-select 来进行切换不同版本。</description>
    </item>
    
    <item>
      <title>[译] URL 加载系统</title>
      <link>/posts/2019/url_loading_system/</link>
      <pubDate>Mon, 06 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/url_loading_system/</guid>
      <description>作者 原文链接     Apple Inc. URL Loading System    使用标准互联网协议与 URL 交互，并和服务器通信。
 框架：  Foundation     概览 URL 加载系统通过标准协议比如 HTTPS 或自建协议提供对 URL 标识资源的访问。加载过程是异步的，所以 App 可以保持响应并当数据到达或出错时进行处理。
使用 URLSession 实例可以创建一个或多个 URLSessionTask 实例，来抓取并返回数据给 App、下载文件、或者上传数据和文件到远程地址。使用 URLSessionConfiguration 对象可以配置会话（Session），可以控制类似如何使用缓存和 Cookie 的行为、以及是否允许蜂窝网络连接。
一个会话可以重复地创建任务。举个例子，浏览器可能有分隔的会话以区分普通和隐私浏览，隐私会话将不缓存数据。图 1 展示了不同配置的两种会话可以创建许多任务。
 默认浏览：URLSession [默认配置] -&amp;gt; URLSessionDataTask 隐私浏览：URLSession [临时配置] -&amp;gt; URLSessionDataTask  为了接收定期的更新（或错误），每个会话都与一个代理关联。默认代理将调用提供的回调 Block；如果选择提供自定义的代理，该 Block 不再调用。
通过配置 App 运行在后台时的会话，即可当 App 被挂起时，系统可以代替其下载数据并唤起 App 以分发结果。</description>
    </item>
    
    <item>
      <title>iOS 中的 &#43;initialize 方法</title>
      <link>/posts/2019/&#43;initialize_in_ios/</link>
      <pubDate>Sun, 21 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/&#43;initialize_in_ios/</guid>
      <description>Date Notes Source Code Demo     2019-04-21 首次提交 objc4-750 -   2019-05-01 补充细节 - Initialize_Demo    Preface 在 iOS 中，经常与 +load 相提并论的一个方法便是 +initialize。从方法名来看，它的作用是进行初始化，但不同于平时使用的 init，+initialize 是一个类方法。那么它的本质到底是什么呢？
为了更好地叙述 +initialize 的特点，本文部分描述尝试与 +load 方法对比，建议阅读本文前先阅读「iOS 中的 +load 方法」。
What // NSObject.h @interface NSObject &amp;lt;NSObject&amp;gt; { + (void)initialize; } Obj-C 中的 +initialize 方法指的是 NSObject 中的 + (void)initialize 类方法。官方文档中的 +initialize 如下：
 Initializes the class before it receives its first message.</description>
    </item>
    
    <item>
      <title>Obj-C &amp; Swift 的类型内省与反射</title>
      <link>/posts/2019/type_introspection_and_reflection/</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/type_introspection_and_reflection/</guid>
      <description>Date Notes Swift Demo     2019-04-08 首次提交 4.2 Type Introspection and Reflection    Preface 许多编程语言中都有类型内省（又称自省，Introspection）和反射（Reflection）这两个概念，本文将探讨一下 Obj-C 和 Swift 中类型内省和反射的相关概念与具体使用。
What 维基百科中对于类型内省定义如下：
 In computing, type introspection is the ability of a program to examine the type or properties of an object at runtime. Some programming languages possess this capability.
Introspection should not be confused with reflection, which goes a step further and is the ability for a program to manipulate the values, meta-data, properties and/or functions of an object at runtime.</description>
    </item>
    
    <item>
      <title>iOS 中的 KVC</title>
      <link>/posts/2019/kvc_in_ios/</link>
      <pubDate>Mon, 25 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/kvc_in_ios/</guid>
      <description>Date Notes     2019-03-25 首次提交    Preface KVC，即 Key-Value Coding，译作键值编码（下文简称 KVC）。当对象兼容 KVC 时，可以通过统一的 API 访问对象中某个键对应的属性值。Cocoa 中的许多功能都依赖 KVC，比如，KVO、Cocoa 绑定机制、Core Data、以及 AppleScript 等。本文将主要探讨 KVC 及其本质相关，关于其它的内容可参考文末的「Reference」。
Basics How #import &amp;lt;Foundation/Foundation.h&amp;gt;  @interface Speaker : NSObject @property (nonatomic) int volume; @end @implementation Speaker @end @interface Computer : NSObject @property (nonatomic) NSString *name; @property (nonatomic) NSArray *speakers; @end @implementation Computer @end int main(int argc, const char * argv[]) { @autoreleasepool { Computer *cpt = [[Computer alloc] init]; // ➡️ 通过 setter 设置  [cpt setName:@&amp;#34;My Mac 1&amp;#34;]; // ➡️ 通过 getter 读取  NSLog(@&amp;#34;name from getter - %@&amp;#34;, [cpt name]); // ➡️ 通过 setValue:forKey: 设置  [cpt setValue:@&amp;#34;My Mac 2&amp;#34; forKey:@&amp;#34;name&amp;#34;]; // ➡️ 通过 valueForKey: 读取  NSLog(@&amp;#34;name from KVC - %@&amp;#34;, [cpt valueForKey:@&amp;#34;name&amp;#34;]); Speaker *s1 = [[Speaker alloc] init]; s1.</description>
    </item>
    
    <item>
      <title>Obj-C 中的重载与重写</title>
      <link>/posts/2019/override_and_overload_in_obj-c/</link>
      <pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/override_and_overload_in_obj-c/</guid>
      <description>Date Platform     2019-03-20 macOS 10.14.2    Preface 重载（Overload）和重写（Override）是面向对象语言中十分基本的两个概念，本文将谈谈 Obj-C 中的重载与重写。
重载  In some programming languages, function overloading or method overloading is the ability to create multiple functions of the same name with different implementations. Calls to an overloaded function will run a specific implementation of that function appropriate to the context of the call, allowing one function call to perform different tasks depending on context.</description>
    </item>
    
    <item>
      <title>[译] Swift 名字修饰（Name Mangling）</title>
      <link>/posts/draft/friday_qa_swift_name_mangling/</link>
      <pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/draft/friday_qa_swift_name_mangling/</guid>
      <description>作者 原文链接   Gwynne Raskind Friday Q&amp;A 2014-08-08: Swift Name Mangling    译者注
1.「Name Mangling」在本文中将译作「名字修饰」，这主要是参考了 Wikipedia 中关于该项技术的翻译；
2.「Friday Q&amp;amp;A」中文意为「周五问与答」，但限于该名称是作者文章的系列名称，故保留原文不再翻译。
 许久没有参与到 Friday Q&amp;amp;A 中，不过我带着全新主题的文章又回来了：Swift。在最近的几篇文章中，Mike 具体介绍了 Swift 的内部结构是什么样的，但他只是轻描淡写了当查看包含 Swift 的二进制文件时，链接器所看到的：被修饰的（Mangled）符号名。
 在 C 之类的编程语言中，任何给定的名称（符号）都只能对应一个函数或者一条数据，那么名字修饰（Name Mangling）就不是必需的。尽管如此，如果我们查看典型的纯 C 二进制文件的符号表，仍然能发现每个函数名中都有一个 _（下划线）作为前缀。举个例子：
$ echo &amp;#39;int main() { return 0; }&amp;#39; | xcrun clang -x c - -o ./test $ xctest nm ./test # 译者注：xctest 命令可能无法直接找到，也可直接使用 nm ./test 0000000100000000 T __mh_execute_header 0000000100000f80 T _main U dyld_stub_binder $ 这种简单的「修饰」没有什么作用，其存在主要是历史原因，由于兼容性与统一性而被保留。按照约定，C 中定义的名称将带有下划线，而纯汇编定义的全局符号则没有（尽管许多汇编语言的作者仍会为了统一性而使用下划线作为前缀）。</description>
    </item>
    
    <item>
      <title>iOS 中的 KVO</title>
      <link>/posts/2019/kvo_in_ios/</link>
      <pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/kvo_in_ios/</guid>
      <description>Date Notes     2019-03-13 首次提交    Preface KVO 即 Key-Value Observing，译作键值监听（下文简称 KVO），通常用于监听对象的某个特定属性值的变化。本文将由浅入深，谈谈 iOS 中的 KVO。
How #import &amp;#34;ViewController.h&amp;#34;  @interface Computer : NSObject @property (nonatomic, assign) int buttonClickTimes; @end @implementation Computer @end @interface ViewController () @property (nonatomic, strong) Computer *cpt; @end @implementation ViewController - (Computer *)cpt { if (!_cpt) { _cpt = [[Computer alloc] init]; // ➡️ 为 cpt 属性的键路径 buttonClickTimes 增加监听者 self（该控制器）  // options 决定监听者将同时接收到新值和旧值  // context 决定附带的上下文信息「ViewController-buttonClickTimes」。  [_cpt addObserver:self forKeyPath:@&amp;#34;buttonClickTimes&amp;#34; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@&amp;#34;ViewController-buttonClickTimes&amp;#34;]; } return _cpt; } - (void)dealloc { // ➡️ 在监听者销毁前将其移除  [self.</description>
    </item>
    
    <item>
      <title>iOS 中的 NSObject</title>
      <link>/posts/2019/nsobject_in_ios/</link>
      <pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/nsobject_in_ios/</guid>
      <description>Date Notes Source Code     2019-03-13 首次提交 objc4-750、libmalloc-166.220.1、glibc-2.29    NSObject 实例对象的大小 // NSObject Obj-C -&amp;gt; C NSObject_IMPL struct NSObject_IMPL { Class isa; }; // 指向 objc_class 结构体的指针 typedef struct objc_class *Class; 将 Obj-C 源码通过 clang -rewrite-objc 翻译为 C++（其实大部分为 C），可以发现 Obj-C 中的 NSObject 类其实就是 C 中的 NSObject_IMPL 结构体，其中只有一个成员变量，即 isa。isa 的类型是 Class，本质是一个指向 objc_class 结构体的指针。在 64 位系统中，指针占用 8 个字节（Byte），即 NSObject 的实例对象大小应该为 8 个字节。我们也可以尝试用 C 语言中的 sizeof() 运算符来证明这一点：</description>
    </item>
    
    <item>
      <title>Combine</title>
      <link>/posts/draft/combine_1/</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/draft/combine_1/</guid>
      <description>Foundation and UIKit/AppKit 中的异步机制：   NotificationCenter：事件发生时执行一段代码（eg. 设备方向改变，软键盘显示或隐藏） 代理（Delegate）模式：定义代表另一个对象的代理对象（eg. AppDelegate 中定义当新的远程推送到达时的操作，但对代码执行时机和次数未知） GCD &amp;amp; NSOperation：安排在穿行队列中顺序执行的代码，或者在不同优先级的不同队列中同时运行多个任务 闭包：创建可分离的代码段，便于其他对象可以决定是否执行、执行次数、以及执行时机  Publisher&amp;lt;Int, Never&amp;gt; ┌────┐ ┌────┐ ┌────┐ ┌────┐ │ │ │ │ │ │ │ │ ───│ 13 │──▶│ 27 │─────▶│ 35 │──▶│ 56 │──│─▶ │ │ │ │ │ │ │ │ └────┘ └────┘ └────┘ └────┘ time 0:01 0:05 0:15 0:19 STOP Publisher /// Declares that a type can transmit a sequence of values over time.</description>
    </item>
    
    <item>
      <title>Objective-C 与 Swift 桥接中的坑</title>
      <link>/posts/2019/obj-c_swift_bridge_tips/</link>
      <pubDate>Thu, 17 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/2019/obj-c_swift_bridge_tips/</guid>
      <description>Date Notes     2019-01-17 添加「Optional 与 Nullability」
添加「NSNotificationName 与 Notification.Name」    Preface Objective-C 与 Swift 的混编是全面转向 Swift 中的必经之路，本篇即是这一过程中的踩坑「真实」记录。
Optional 与 Nullability  Swift 4.2  在大多数项目中，我们都是在中途决定转向 Swift，Swift 中比较核心且常见的概念便是 Optional，可选类型，而这与 Obj-C 中的概念不大相同。在 Swift 中使用 Obj-C 桥接的属性（特别是 Block）时，尤其要注意：Obj-C 默认属性将被转换为隐式解包类型（SomeClass!），而在 Swift 中这代表开发者要保证值不为 nil，编译器将不再提示。当属性是 Block 时，若直接调用了为 nil 的 Closure 时，将会出现崩溃。
   Obj-C Usage Swift     nullable 可空 SomeClass?   nonnull 不可空 SomeClass   null_unspecified 未指定是否可空（默认） SomeClass!</description>
    </item>
    
    <item>
      <title>2018 年「终」总结</title>
      <link>/posts/2018/year_plan/</link>
      <pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/year_plan/</guid>
      <description>今天是 2018 年 12 月 10 日，一年前的昨天，我从家里坐高铁到达了北京。还记得那天晚上，两个同学来火车站接我，我们一起坐公交去他们在昌平沙河的培训宿舍。一天的奔波加上本来就晕车的我，在公交行驶过高速后就难受的不行，不得不下车休息片刻。
不像刚到上海的时候，没有工作的压力，充满着一些生活的气息。而来到北京就是为了实习，为了工作。虽然目的性更强，但也让我不得不更快地融入这个环境，而没时间去慢慢感受。我是北方人，北京更加令我熟悉，但却总感觉不如上海能带给我的新鲜感。从在北科的宿舍到确定现在住的地方，我一共搬了四次家，最终选择了公司附近但价格相对较高的房间。虽然房租已经逼近当时我的实习工资，但这一年我认为这个投资还是非常值得的，毕竟时间的价值更难以衡量。
在北京实习的日子里，去北大参加了比赛，又回到学校拍了毕业照，再辗转到长沙比赛，又去武汉听了音乐会，回了趟家，最后又返回了北京，正式加入了现在的团队。
在北大的比赛，让我感受到我和这些名校学生的差距并没有想象中的遥不可及，当然我不是说差距不明显而是觉得自己有了信心。当然我也羡慕他们拥有如此丰富的资源，也坚定了我会再去读研的决心。虽然比赛最后的名次并不是很靠前，但和北大学长学姐、北航浙大学弟的这次友谊和合作，令我倍感幸运。
北大比赛结束的第二天，我便一早乘坐高铁回学校，准备再见见大学的同学们，拍拍毕业照。班长为了等我，特意将聚餐时间往后推迟了一日。所以很遗憾有些同学因为工作等原因提早回去，只得有缘再见。在大学的四年里，我担任学委，和大学同学们的相处甚至要好过于高中同学。当然，不得不说毕业聚餐后发生了一些事情，也许是这辈子都不会忘记的事情吧&amp;hellip;虽然学校只是个很普通的二本，这四年也发生了很多事情，但一些老师和这些同学们却让我不后悔来到这里。
要想放下一些事情，就得让自己忙起来。忙完大学生涯最后的篇章，便又启程去了长沙，这次的比赛地点是在长沙的超算中心。说实话，这次的比赛因为没有很好的构思，只能很简单地做了个 Demo，效果也非常一般。这次的比赛是面向华中地区，相较于在上海和北京的比赛，能明显感受到一些差距，但也越发发现这类比赛的作品其实存在着很高的重复性。最后因为赶音乐会的时间紧迫，没能在长沙逗留一段时间，仅有的一丝印象也是一座非常干净、轻松的城市。
离开长沙，坐上高铁，奔向武汉。去武汉的理由很简单，只是在复旦比赛认识的队友多买了一张音乐会的票，于是就随他去了。因为通宵比赛，加上路途奔波，我已经非常疲倦，但这次音乐会对于我个人感受至深。我们还年轻，生活不应该只是对着电脑、手机，生活纵然有不易，但也是如此的丰富多彩。也没有来得及注意武汉，但确实也是一座非常发达的城市。
享受完音乐会，便又马不停蹄地踏上回家之途。其实原本打算是直接回北京，但想到工作之后回家似乎就不那么自由，便还是决定回家一趟。出门久了才知道，什么都抵挡不过父母做的一顿饭，只是这次在家呆不了太久，便又要踏上北上之途。
回京之旅和以往不同，是因为买到了比高铁还要便宜的机票，人生中第一次乘坐了飞机。可能洛阳坐飞机的人并不多，飞机也并没有我想象中那么大，不过飞机起飞加速时的推背感却让我感到很过瘾。
这一年真的是非常丰富的一年，除了上面这一段游记，年初的时候在北京陪韩国留学放假回来的好友在北京玩了几天，看了升旗，逛了故宫，也了解了航天与航空的差异（笑）；在北京去了 Apple Store，和北京的小朋友一起上了 Today at Apple，感受了苹果新的零售哲学；六月中旬去了清华，和来上科大宣讲的外籍教授一对一讨论了 Robotistic（机器人学），也认识了上科大优秀的博士生；第一次正式加入一家公司；主动和团队里的人去美团总部交流技术；在新员工培训中拿到了第一名；周末和同学第一次爬了长城；第一次被拉去蹦了野生迪&amp;hellip;
当然，一年再怎么精彩，也依然会有遗憾。对于那些可以在未来弥补的遗憾，就放在之后的计划中吧，对于那些无法弥补的，就让它过去吧。感谢 2018 年，也感谢这一年遇到的所有人，辗转多地也遇到很多可爱的人。最后，也感谢自己。幸运，总是留给有准备的人。2019，加油！
V.
提笔于 2018.12.10，完结于 2018.12.11 晚；北京
 后记 原本以为 2018 年就会如此过去，却没曾想到在最后一周又发生了很多事情。倒数第二周的周末，听闻公司「优化」的消息，又一次下载了脉脉。传言言之凿凿，又加上我还未转正，简直是「性价比」之选。其实工作了一年，确实感觉辛苦，不如学生时代的自由和悠闲。虽然有了所得，但失去的更多。所以如果被「优化」，我就准备先回学校把驾照考完，再去想想自己真正热爱的事情，其实我一直有想法要亲自打造一款产品，那么我想就是时候去做了。
当然，结果是我并没有被「优化」，打造产品的计划又被耽搁了，而让我痛心的是和我一起入职的好几个小伙伴们被「优化」。工作这一年，越发认识到社会上的人久而久之都会变得「油腻」，而这些刚从校园里出来的孩子们却没有社会上的浮躁气息，失去这些同事实在令我可惜。真心希望他们能找到更好的去处，也希望我们友谊长存，也希望我自己能保持初心。
2018 年从实习，到公司被收购，入职，涨薪，裁员，这些经历都让我学习到很多。其实这种「优化」和个人能力的相关性很低，而和个人所在的业务关联性很大。之前总是天真地以为技术是唯一，其实现在才发现，技术只是基本功，个人的能力绝不能仅仅只在技术能力上体现，而是需要全方位的修炼。
2018 年总归要过去，虽然在 2018 年的尾巴上又重新加回了一位好友，也简单地聊了几句，但深感有些事情却再也不会回去了。
Yesterday is history, tomorrow is a mystery, today is God&#39;s gift, that&#39;s why we call it the present. - Joan Rivers V.
后记于 2019.01.03 午</description>
    </item>
    
    <item>
      <title>[译] 为 App 执行一次性设置</title>
      <link>/posts/2018/performing_one-time_setup_for_your_app/</link>
      <pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/performing_one-time_setup_for_your_app/</guid>
      <description>作者 原文链接     Apple Inc. Performing One-Time Setup for Your App    确保 App 环境被正确配置。
 框架  UIKit     概览 当用户第一次启动 App，我们可能希望通过一些一次性任务预备 App 环境。举个例子，可能想要：
 从服务器下载必要的数据。 从 App 包（bundle）中拷贝文档模版或可修改的数据文件至一个可写入的目录。 为用户配置默认偏好设置。 设置用户账户或获取其他必要数据。  在 App 代理的 application(_:willFinishLaunchingWithOptions:) 或 application(_:didFinishLaunchingWithOptions:) 方法中执行任何一次性任务。当非必需用户输入时，绝不要因任务阻塞 App 的主线程。取而代之，使用调度队列（dispatch queue）异步开启任务，当 App 完成启动时，让其运行在后台。对于那些必需用户输入的任务，在 application(_:didFinishLaunchingWithOptions:) 方法中作出用户界面的改变。
在合适的位置安放文件 App 拥有其自身包含的目录来保存文件，我们也应当总是将 App 特定的文件放在 ~/Library 的子目录中。特别地，将以下文件保存在 ~/Library 的子目录：
 ~/Library/Application Support/ —— 保存想要备份用户的其他内容的 App 特定文件（可以根据需要创建自定义的子目录。）使用该目录保存数据文件，配置文件，文档模版，等等。 ~/Library/Caches/ —— 保存便于重复产生或下载的临时文件。  使用 FileManager 的 urls(for:in:) 方法获得 App 容器的目录 URL。</description>
    </item>
    
    <item>
      <title>[译] 关于 App 启动顺序</title>
      <link>/posts/2018/about_the_app_launch_sequence/</link>
      <pubDate>Fri, 16 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/about_the_app_launch_sequence/</guid>
      <description>作者 原文链接     Apple Inc. About the App Launch Sequence    学习在启动时的代码执行顺序。
 框架  UIKit     概览 一个 App 的启动需要经过许多复杂的步骤，其中大部分由 UIKit 自动处理。在启动过程中，UIKit 会调用 App 代理中的方法，因此我们可以执行自定义的任务。图中的步骤展示了从 App 启动的时间开始直到被认为初始化完成的过程。
 由用户显式或系统隐式启动 App。 Xcode 提供的 main 函数调用 UIKit 的 UIApplicationMain(_:_:_:_:) 函数。 UIApplicationMain(_:_:_:_:) 函数创建 UIApplication 对象和 App 代理。 UIKit 从主 storyboard 或 nib 文件加载 App 的默认界面。 UIKit 调用 App 代理的 application(_:willFinishLaunchingWithOptions:) 方法。 UIKit 执行状态恢复（state restoration），即调用 App 代理和视图控制器中的额外的方法。 UIKit 调用 App 代理的 application(_:didFinishLaunchingWithOptions:) 方法。  当初始化完成，系统将 App 转到激活（前台）状态或后台状态。当 App 转到激活状态，其窗口出现在屏幕上，并开始响应用户交互。当 App 转到后台状态，其窗口保持隐藏，并在被暂停前运行极短的时间。</description>
    </item>
    
    <item>
      <title>谈谈 iOS 中的 dyld_shared_cache</title>
      <link>/posts/2018/dyld_shared_cache/</link>
      <pubDate>Sun, 14 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/dyld_shared_cache/</guid>
      <description>Date Notes Source Code     2019-06-11 更新 Shortcuts 相关 -   2018-12-12 补充 dyld_shared_cache 路径来源 system_cmds-805.220.1   2018-10-14 首次提交 dyld-551.4    What iOS &amp;amp; macOS 作为操作系统，其中内置了许多系统库（Library）。dyld_shared_cache，即动态库共享缓存。自 iOS 3.1 后，所有系统动态库被集合成一个 dyld_shared_cache 文件，以提升性能。当然，macOS 也有 dyld_shared_cache，比较特别的是可以通过 update_dyld_shared_cache 更新。
How 为了研究 dyld_shared_cache，首先要找到其存在的路径。可以在 Apple 开源的 system_cmds 中 dyld_shared_cache.c 文件中发现，其分别存放在 macOS 和 iOS 中的路径。
macOS 上的 dyld_shared_cache 和 iOS 不太相同，每种架构额外对应了一种 .map 文件。因为本文着重在于 iOS，读者想要了解 macOS 相关可以在 system_cmds 中自行检索。</description>
    </item>
    
    <item>
      <title>使用 usbmuxd 连接 iPhone</title>
      <link>/posts/2018/usbmuxd/</link>
      <pubDate>Sat, 08 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/usbmuxd/</guid>
      <description>macOS iOS libimobiledevice/usbmuxd     10.13.6 9.0.1 (Jailbroken) v1.0.8    What usbmuxd 全称「USB Multiplexing Daemon」，即 USB 多路传输驻留程序。当 Mac/PC 与 iPhone 之间使用 USB 数据线连接时，iTunes 与 iPhone 间的通信交流便是通过 usbmuxd 服务。usbmuxd 通过给定的端口号和 localhost 建立 TCP 连接。
在 Mac 端，是由「/System/Library/PrivateFrameworks/MobileDevice.framework/Resources/usbmuxd」处理，并通过 launchd 启动。其将会在「/var/run/usbmuxd」创建一个 UNIX Domain Socket（UNIX 域套接字），usbmuxd 将监听 USB 接口的 iPhone 连接。当 iPhone 在正常模式下连接，其将会连接到该 iPhone，并将开始转发通过「/var/run/usbmuxd」接收到的请求。
Solution  通过 usbmuxd 用 USB 代替 Wi-Fi 转发 SSH 请求。
  这里注意选择 1.</description>
    </item>
    
    <item>
      <title>Xcode 10 beta 趟坑</title>
      <link>/posts/2018/xcode_10_beta/</link>
      <pubDate>Wed, 25 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/xcode_10_beta/</guid>
      <description>Xcode macOS     10 beta 2 10.14 beta 2    $(TeamIdentifierPrefix)  Xcode 10 已知 Bug，无法自动替换。  Workaround  可以手动将 entitlements 文件的 Pass Type ID 值设置为 mobileversion 文件中com.apple.developer.pass-type-identifiers 对应值。  libstdc++  Xcode 10 取消了内置支持的 libstdc++ 库，需等待某些第三方 SDK 修复。  Workaround  手动将 Xcode 9（/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib）中的库 libstdc++.6.tbd &amp;amp; libstdc++.6.0.9.tbd 复制到 Xcode 10（/Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib）。  SWIFT_UNAVALIABLE  在 Obj-C 中调用 Swift 子类的 Obj-C 父类的构造器，提示 Unavaliable，由 Xcode 生成的 *-Swift.</description>
    </item>
    
    <item>
      <title>在 macOS 上进行直播推流</title>
      <link>/posts/2018/livestreaming_on_macos/</link>
      <pubDate>Sun, 22 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/livestreaming_on_macos/</guid>
      <description>Date Platform Software     2018.07.22 macOS 10.14 beta 4 OBS Studio, Soundflower   2019.03.30 macOS 10.14.4 -     由于更换了电脑，上次好不容易折腾的配置也都无从参考，这次尽力把整个配置过程，以及音频输入输出的部分完善。直播推流使用了 OBS Studio，直播平台为 Bilibili。
欢迎来围观我的 B 站直播间：https://live.bilibili.com/7900407。
 Solution Basic setup  使用「Homebrew」安装 OBS  brew cask install obs  安装期间可以在 Bilibili 申请开通直播，并获取需要的 RTMP 地址以及直播码   打开「OBS」-「Preference」-「流」   在「URL」和「流名称」分别填写 Bilibili 提供的 RTMP 地址以及直播码 回到主界面为默认的场景添加来源，常用的是「显示捕获」（即完全把自己能看到推流出去）以及「窗口捕获」（即只把选中的窗口推流出去） 点击「开始推流」即可开始直播  Audio  使用「Homebrew」安装 Soundflower  brew cask install soundflower  ⚠️ 注意：</description>
    </item>
    
    <item>
      <title>将树莓派作为 AirPlay 音频服务器</title>
      <link>/posts/2018/airplay_on_pi/</link>
      <pubDate>Sun, 22 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/airplay_on_pi/</guid>
      <description>Raspberry Pi Platform juhovh/shairplay     3 B Raspbian 4.14 765148f98f343b3b9911cc05504ac276cfc44c26    Info 树莓派是个很容易吃灰的设备，配置太低，又弃之可惜。何不作为 AirPlay 来解放你的有线音箱呢？
Solution  SSH 或直接在树莓派的终端中运行以下命令，关于 SSH、VNC、替换源等操作请自行搜索。
 Basic setup  安装依赖  sudo apt-get install autoconf automake libtool sudo apt-get install libltdl-dev libao-dev libavahi-compat-libdnssd-dev sudo apt-get install avahi-daemon  编译安装  cd ~/Desktop mkdir AirPlay cd AirPlay git clone https://github.com/juhovh/shairplay.git cd shairplay ./autogen.sh ./configure make sudo make install  启动  -a 后的参数 为 AirPlay 的名称，可自定义，eg.</description>
    </item>
    
    <item>
      <title>iOS 开发问题解决集锦</title>
      <link>/posts/2018/ios_dev_issue_list/</link>
      <pubDate>Tue, 10 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/ios_dev_issue_list/</guid>
      <description>Unable to boot device in current state: Creating  Xcode: 9.4.1 macOS: 10.13 在使用模拟器或者 xcodebuild test 时可能会出现此问题。  Solution  使用 xcrun simctl list 命令列出所有模拟器机型，用 xcrun simctl erase UDID 还原相应的设备，重试即可。 下面是一个 Python 3 脚本，可以使用 python erase_simulators.py -d &#39;DEVICE_TYPE&#39; 来直接还原相应设备类型的所有设备。  # -*- coding: utf-8 -*- import argparse import subprocess import re def erase_device(device): status, output = subprocess.getstatusoutput(&amp;#39;xcrun simctl list | grep \&amp;#39;&amp;#39; + device + &amp;#39; (\&amp;#39;&amp;#39;) if status == 0: outputs = output.</description>
    </item>
    
    <item>
      <title>[译] 起底 SourceKit</title>
      <link>/posts/2018/uncovering_sourcekit/</link>
      <pubDate>Sun, 08 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/uncovering_sourcekit/</guid>
      <description>作者 原文链接     JP Simard Uncovering SourceKit     为了支持一门新颖的语言（译者注：这里指 Swift），灵活的实时 IDE 特性，以及令人印象深刻的跨语言协同能力（译者注：这里指 Swift 与 Obj-C），Apple 必须开发一些新的基础工具。这里我们将聚焦于 SourceKit，一个被忽视的 Xcode 搭档。
 什么是 SourceKit？ SourceKit 是一套工具集，使得大多数 Swift 源代码层面的操作特性得以支持，例如源代码解析、语法高亮、排版（Typesetting）、代码自动补全、跨语言头文件生成等许多功能。
架构 一般来说，Xcode 在进程中运行其编译器（Clang），这意味着编译器随时可能出现的崩溃都会导致 IDE 崩溃。
更有甚者，Xcode 容易唤起编译器进行成千上万次解析、高亮、以及排版源代码等操作，而所有这一切均在用户按下「⌘ + B」之前。这是因为不像大多数编辑器（Vim、Sublime 等），Xcode 并不使用正则表达式解析源代码，而是使用 Clang 强大的（也的确更加复杂的）解析器（Parser）和令牌生成器（Tokenizer）。
幸运的是，Xcode 6 中的 Swift 抛弃了该架构1，将所有源代码操作的特性组合至一个独立的进程，并和 Xcode 通过 XPC 交流：sourcekitd。每当 Xcode 6 加载任何 Swift 代码时，都将启动该 XPC 守护进程。
Xcode 怎样使用 SourceKit 由于 SourceKit 是一个私有且没有文档记录的工具，我们需要获得一些小点子来学习如何使用它。通过设定 SOURCEKIT_LOGGING2 环境变量，Xcode 将其与 SourceKit 的通信记录到 stdout，从而使我们可以观察到它们的实时交流。这就是本文中的许多命令的来源。</description>
    </item>
    
    <item>
      <title>iOS 项目持续集成实践（一）</title>
      <link>/posts/2018/ci_practice_in_ios-1/</link>
      <pubDate>Sat, 07 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/ci_practice_in_ios-1/</guid>
      <description>Preface 一个软件工程项目从编写、到测试、再最终交付到用户通常有很多重复且固定的步骤。虽然作为开发者，我们的核心任务是编写代码，而这些其他的步骤却也不能忽视，持续集成（Continuous Integration）则可以帮助开发者完成这些琐碎的事务，提升团队的开发效率与质量。
本文将主要介绍持续集成是什么，以及其中的好处。当然，您可能也注意到了标题后面「（一）」，没错，持续集成并非一篇文章可以概括，笔者希望尽可能将目前团队中使用到的和持续集成相关的内容进行总结，目的是为了让大家一起思考如何让持续集成更好地服务我们开发。当然，限于笔者能力，文中不免出现遗漏，也望读者能够批评和指出。
What 持续集成，译自 Continuous Integration，简称 CI（在下文中，将统一使用该英文简称）。在 Wikipedia 中，也有针对 CI 特别详细且专业的介绍。简而言之，当开发者通过版本控制系统（例如 Git）提交了代码，CI 系统将为其自动执行构建、分析、测试等服务，当前面的服务一致通过，其也能直接将产品部署到生产环境，而后进入下一个循环。其中每一步都将自动触发、执行，结果也将会自动反馈回开发者。正如下图所示，CI 的重点在于 C——持续。
Why &amp;amp; Why not 那么为什么需要 CI 呢？相比于传统的先开发，再测试，后上线的模式有哪些好处呢？在团队使用 CI 这段时间中，得出了以下主要两个好处：
 及时发现错误。CI 并不能消除错误，但 CI 将发现错误的时机尽可能地提前，所以也更加节省时间来改正错误。当开发者提交代码至代码仓库时，其对于代码的熟悉程度是最高的。如果这个时候尽可能的纠正一些错误或不当，开发者将能很快注意到并将错误改正，避免了由于时间或者团队中其他人对于代码的修改所导致的问题，提升了开发效率。 自动化。市面上的 CI 平台都给了开发者比较高的自由度，能够执行脚本或命令。因此很多自动化的操作都可以制定好，来自动化地执行，节省开发者的时间。  如果这两个显而易见的好处还不足以说服，可以参考文末 Reference 中 EKATERINA NOVOSELTSEVA 的文章。那么 CI 会不会也存在什么难处呢？
 跨技术栈。CI 并不特定于前端或者后端，CI 通常根据不同的平台而有很多不同，包括配置的方法、使用的语言、自由度等等。CI 又和 Docker 的发展有一定的关系，因此跨技术栈可能让一些团队望而却步。不过好的是，DevOps（Development &amp;amp; Operations）也在国内渐渐兴起，越来越被重视。 跨平台。这里所指的平台是指代码托管平台、CI 平台、以及部署平台。在公司开始时，可能并不能轻易考虑到后续的发展，因此在原有平台加入 CI 可能需要跨平台的协作。对于一些「黑盒」的平台，有时便难以很好的集成。不过，现在 Git 的两大平台 GitHub 和 GitLab 都很重视且支持 CI 平台，也便于开发者使用。  如果后面两个问题并没有阻挠你，那么就开始尝试 CI 吧～
How CI 并不依赖于某种特定的技术栈，其属于一种编程范式。但是，具体谈及如何实践，这就需要结合不同的工具和业务，进行定制。</description>
    </item>
    
    <item>
      <title>Zen of Git</title>
      <link>/posts/draft/zen_of_git/</link>
      <pubDate>Wed, 13 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/draft/zen_of_git/</guid>
      <description>Preface 在现代软件开发的团队协作中，版本控制系统（Version Control System）必不可少，而 Git 已成为绝大多数的团队首选。本文将简单谈谈 Git 相关的工作流、工具链等，以及背后的思考、权衡，当然对于不同的团队，其选择侧重会略有不同，也欢迎大家互相交流。
Workflow Branch Model Rollback Toolchain GitLab Bitbucket Webhook </description>
    </item>
    
    <item>
      <title>Supervisor 的安装与基本使用</title>
      <link>/posts/2018/supervisor/</link>
      <pubDate>Sun, 06 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/supervisor/</guid>
      <description>Platform Supervisor     macOS 10.13.4 3.3.4   Raspbian 4.14 3.3.1    Info Supervisor 是 Linux/UNIX 下的一个由 Python 编写的进程管理工具，可以很方便的用来启动、重启、关闭进程。
Solution Installation macOS  使用 HomeBrew 安装  brew install supervisor Raspbian (Linux) sudo apt-get install supervisor Usage  安装完成后，可以在查看该默认配置，但并非所有配置项均必须定义，可根据自己需要进行配置 macOS  ; macOS - /etc/supervisord.conf [supervisord] http_port=/var/tmp/supervisor.sock ; (default is to run a UNIX domain socket server) ;http_port=127.0.0.1:9001 ; (alternately, ip_address:port specifies AF_INET) ;sockchmod=0700 ; AF_UNIX socketmode (AF_INET ignore, default 0700) ;sockchown=nobody.</description>
    </item>
    
    <item>
      <title>使用 Homebrew 安装 Jenkins</title>
      <link>/posts/2018/jenkins_by_homebrew/</link>
      <pubDate>Sun, 06 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/jenkins_by_homebrew/</guid>
      <description>Platform Notes     macOS 10.13.4 Jenkins 2.114 &amp;amp; Java 8    Solution  安装 Homebrew  /usr/bin/ruby -e &amp;#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;#34;  安装 Jenkins  brew install jenkins  运行 Jenkins  # 当前窗口启动（关闭窗口则关闭 Jenkins） # $JENKINS_VERSION_CODE 为版本号，$PORT 为 Jenkins Web 页面端口号 # java -jar /usr/local/Cellar/jenkins/$JENKINS_VERSION_CODE/libexec/jenkins.war --httpPort=$PORT java -jar /usr/local/Cellar/jenkins/$JENKINS_VERSION_CODE/libexec/jenkins.war --httpPort=8080 # 后台启动（关闭窗口无影响） # $OUTPUT_FILENAME 为终端输出内容存放的文件名 # nohup java -jar /usr/local/Cellar/jenkins/$JENKINS_VERSION_CODE/libexec/jenkins.war &amp;gt;$OUTPUT_FILENAME &amp;amp; nohup java -jar /usr/local/Cellar/jenkins/2.</description>
    </item>
    
    <item>
      <title>使用 Homebrew 安装 MySQL</title>
      <link>/posts/2018/mysql_by_homebrew/</link>
      <pubDate>Sun, 06 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/mysql_by_homebrew/</guid>
      <description>Platform Notes     macOS 10.13.4 MySQL 5.7.21    Solution  安装 Homebrew  /usr/bin/ruby -e &amp;#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;#34;  安装 MySQL（注意观察可能有错误信息，比如 brew link 失败，可能要先在相应文件夹下开启「写」权限后再手动尝试）  brew install mysql  开启 MySQL 服务  # 现在启动，并加入自启动 brew services start mysql # 后台启动 mysql.server start  连接 MySQL（默认端口为 3306）  mysql -uroot  创建用户并授权  -- CREATE USER &amp;#39;USERNAME&amp;#39;@&amp;#39;HOST_NAME&amp;#39; IDENTIFIED BY &amp;#39;PASSWORD&amp;#39;; CREATE USER &amp;#39;temp_user&amp;#39;@&amp;#39;localhost&amp;#39; IDENTIFIED BY &amp;#39;1234&amp;#39;; -- GRANT PRIVILEGE ON DATABASE_NAME.</description>
    </item>
    
    <item>
      <title>简单管理多版本 JDK</title>
      <link>/posts/2018/jdk_multiple_versions/</link>
      <pubDate>Sun, 06 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/jdk_multiple_versions/</guid>
      <description>   Platform Notes     macOS 10.13.4 JDK 8 &amp;amp; 9    Solution  安装 JDK 8 &amp;amp; 9（其他版本同理） vim ~/.zsh_rc（这里使用的是 BashShell，其他 Shell 自行替换） 文末追加：  # Java export JAVA_8_HOME=$(/usr/libexec/java_home -v1.8) export JAVA_9_HOME=$(/usr/libexec/java_home -v9) # Default for Java 8 export JAVA_HOME=$JAVA_8_HOME alias java9=&amp;#39;export JAVA_HOME=$JAVA_9_HOME&amp;#39; alias java8=&amp;#39;export JAVA_HOME=$JAVA_8_HOME&amp;#39;  切换版本：java8 / java9 检查版本：java -version  Extension  jenv  </description>
    </item>
    
    <item>
      <title>在 Swift 中对集合类型元素的弱引用</title>
      <link>/posts/2018/weakly_collections/</link>
      <pubDate>Thu, 08 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/weakly_collections/</guid>
      <description>Date Notes Swift Xcode     2018-03-15 更新部分表述，并将题目扩展至集合类型 4.0 9.2   2018-03-08 首次提交 4.0 9.2    Preface 为了方便下述 Demo，这里定义一个 Pencil 类，并会使用 func CFGetRetainCount(_ cf: CoreFoundation.CFTypeRef!) -&amp;gt; CFIndex 方法，即传入一个 CFTypeRef 类型的对象即可获取其引用计数。什么是 CFTypeRef？查阅官方文档即可得知 typealias CFTypeRef = AnyObject，所以 CFTypeRef 其实就是 AnyObject。而 AnyObject 又是所有类隐含遵守的协议。
class Pencil { var type: String var price: Double init(_ type: String, _ price: Double) { self.type = type self.price = price } } CFGetRetainCount(Pencil(&amp;#34;2B&amp;#34;, 1.</description>
    </item>
    
    <item>
      <title>Swift 中的 @autoclosure</title>
      <link>/posts/2018/swift_autoclosure/</link>
      <pubDate>Sat, 13 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/posts/2018/swift_autoclosure/</guid>
      <description>Date Notes Swift Xcode Source Code     2018-04-05 更新并明确源代码所用版本 4.1 9.3 Swift 4.1 Release   2018-01-13 首次提交 4.0.3 9.2 -    What  Closures are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.
— The Swift Programming Language (Swift 4.</description>
    </item>
    
    <item>
      <title>WWDC17 - 819 Designing for a Global Audience</title>
      <link>/posts/2017/wwdc-17-819/</link>
      <pubDate>Mon, 03 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/wwdc-17-819/</guid>
      <description>Date Notes     2017-07-03 首次提交     WWDC 2017 是苹果开发者大会的 2017 版。Session 822 简要介绍了为什么要将 App 为全球受众适配，以及其中的一些注意点。
 Why   更好的用户体验（Better user experience）
 不要仅仅止步于言语和插图不冒犯用户。    拓展机遇（Expansion opportunities）
  How   制定计划（Make a plan）
 制定下一个将要适配的国家和语言，可以参考 iTunes Connect 中的一些信息。    识别用户（Identify users）
  考虑交流（Think about communication）
  重要优先（Prioritize important localization work）
  语言   替代语（Substitutions）</description>
    </item>
    
    <item>
      <title>WWDC17 - 822 App Icon Design</title>
      <link>/posts/2017/wwdc-17-822/</link>
      <pubDate>Mon, 03 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/wwdc-17-822/</guid>
      <description>Date Notes     2017-07-03 首次提交     WWDC 2017 是苹果开发者大会的 2017 版。Session 822 简要介绍了设计 App 的图标（Icon）时需要注意的点。
 图标设计   象征（Metaphor）
 即人们可以根据图标所联想的事物。    简约（Simplicity）
 清晰简约，可读性强。    连接（Connection）
 图标是用户和应用的桥梁，要有趣，有启发性。    家系（Lineage）
 图标的改变要慎重，有一致性。    设计过程   唯一（Unique）
 在应用的分类中脱颖而出。    体验（Experiment）
 开始可以手绘，也可以与他人共同体验。    测试（Test）
 在桌面，文件夹，设置中测试图标的效果。    耐心（Patience）</description>
    </item>
    
    <item>
      <title>WWDC17 - 102 Platform State of the Union</title>
      <link>/posts/2017/wwdc-17-102/</link>
      <pubDate>Sun, 02 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/wwdc-17-102/</guid>
      <description>Date Notes Swift Xcode     2017-07-02 首次提交 4.0 beta 9.0 beta     WWDC 2017 是苹果开发者大会的 2017 版，今年的更新很多，而且涉及多种平台，开发工具，以及 Swift 语言本身。102 这场演讲涉及了新系统以及新工具中的 features，但没有过多深入。因为后续还有更加独立的 Session 可供我们学习，查看，所以本文仅涉及本人认为需要的内容。关于 Metal 2 和 VR 距离我个人能力所及较远，本文也没有提及。
 macOS  macOS High Sierra 将是最后一个支持 32 位程序的 macOS 版本。 App Store 64 位 App: 2018.01 新 App 务必支持；2018.07 所有 App 务必支持。  Playground 2.0  将集成 API 文档，且支持 AR。  Xcode 9  支持 Swift，Objective-C，C/C++ 重构。 构建速度加快，打包后体积更小。  String  String 在 Swift 4.</description>
    </item>
    
    <item>
      <title>WWDC17 - 823 Designing Glyphs</title>
      <link>/posts/2017/wwdc-17-823/</link>
      <pubDate>Sun, 02 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/wwdc-17-823/</guid>
      <description>Date Notes     2017-07-02 首次提交     WWDC 2017 是苹果开发者大会的 2017 版。Session 823 简要介绍了 Glyph（字形，符号等）的设计原则等。
 Glyph &amp;amp; Icon  Glyph 是单色的，可以用代码（程序化）添加颜色。 Icon 是彩色的，高渲染的资源文件。  高效的 Glyph 设计原则   简化的形式（Simplified form）
  统一的象征（Universal symbology）
 在不同的语言环境，生活环境都能清晰无歧义辨识的标志    上下文中可读性高（Quickly readable in context）
  Glyph 在系统中的使用场景   macOS
 Menu bars Tool bars Touch bar    iOS</description>
    </item>
    
    <item>
      <title>浅谈 iOS 应用启动过程</title>
      <link>/posts/2017/ios_app_start_up/</link>
      <pubDate>Tue, 28 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/ios_app_start_up/</guid>
      <description>Date Notes Swift Xcode     2017-05-26 CS193p UIApplication 3.1 8.3.2   2017-03-28 首次提交 3.0 8.2.1    Preface 首先要感谢没故事的卓同学大大送的泊学会员，在泊学学了几节课，了解了很多不同角度的 iOS 开发知识。这篇文章就启发自其 iOS 101 中的一个纯手工的 Single View Application 一文。但本文将更加深入的叙述了启动过程，且实现均为 Swift 3.0。
本文对应的 Demo 可以在：https://github.com/kingcos/SingleViewAppManually-Demo 查看、下载。
Manually or Storyboard main.m in Objective-C Single View Application
#import &amp;lt;UIKit/UIKit.h&amp;gt; #import &amp;#34;AppDelegate.h&amp;#34;  int main(int argc, char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } }  自从 Storyboard 诞生以来，关于纯代码、Xib、以及 Storyboard 的选择就在 iOS 开发圈中炸开了锅。这里不会探讨各种姿势的优劣，只是可能很多和我一样的初学者，从一开始就被 Storyboard 先入为主。加上方便灵活的拖控件，自然而然就可能没有机会去思考一个 iOS 应用是如何启动起来的。加上 Swift 的诞生，使得整个项目的初始结构得到了更大的简化（少了 main.</description>
    </item>
    
    <item>
      <title>从 0 开始使用 Docker 快速搭建 Hadoop 集群环境</title>
      <link>/posts/2017/docker_for_hadoop/</link>
      <pubDate>Mon, 27 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/docker_for_hadoop/</guid>
      <description>Date Notes Hadoop Other     2017-03-27 首次提交 2.7.2 Docker CE, IntelliJ IDEA 2016.3    Preface 自从学习 iOS/Swift 以来，就没有太多时间分配给 Java 专业课，毕竟我不是个三心二用还能样样学好的人。不过作为大三的专业课，分布式计算技术还是有去上课的，毕竟不能最后挂科吧 :]
曾有人说，「开发一个项目，至少有 50% 时间在配置环境」。确实，在折腾了三周的课时之后，我才按照老师给的详细步骤配置好 Hadoop 的环境。尽管如此，由于种种原因，班里仍有很多同学还没有配置好 Hadoop 的环境，导致课程一直停滞。在偶然中，我想到了 Docker，Docker 这个词我至少在半年前已经听说（当然，恕我孤陋寡闻，Docker 早在 13 年即发行），但一直没有去了解和使用。时至今日，我对 Docker 的了解也十分少，简单的来说，Docker 是一种容器（Container）管理工具，通过 Docker 我们可以配置可移植的环境，方便发布。Docker 基于 Linux，但也提供了 macOS 和 Windows 桌面版，方便在我们的本地机器测试、使用。
虽然本文是一个小白向的文章，但下载和安装的过程也不会在本文涉及。一是官方网站必然提供了相应的教程，纯粹的翻译毫无意义；二是下载和安装可能随着后续更新发生略微的区别，而本文只着眼于配置 Hadoop 集群环境的搭建。
不过由于个人对 Hadoop 和 Docker 的了解甚少，如有错误，希望指出，我会学习、改正。
Linux  Info: Ubuntu 16.10 x64   Docker 本身就是基于 Linux 的，所以首先以我的一台服务器做实验。虽然最后跑 wordcount 已经由于内存不足而崩掉，但是之前的过程还是可以参考的。</description>
    </item>
    
    <item>
      <title>探究 UIViewController 生命周期</title>
      <link>/posts/2017/uiviewcontroller_life_cycle/</link>
      <pubDate>Fri, 10 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/uiviewcontroller_life_cycle/</guid>
      <description>Date Notes Swift Xcode     2017-03-10 首次提交 3.0 8.2.1    前言 对象的生命周期一直是开发者所需要关心的，教授 CS193p 的老师 Paul 也详细的讲述了 UIViewController 的生命周期。为了记述这一过程，故作此文。由于 Xcode 提供了纯代码和 Storyboard（Xib 同理）两种布局 UI 的方式，因此初始化部分略有不同。
为了方便观察，我创建了一个 BaseViewController，继承自原本的 UIViewController，重写其中的生命周期方法，并让后续新的控制器继承自该控制器，以便观察。
本文对应的 Demo 可以在 https://github.com/kingcos/UIViewController-UIView-LifecycleDemo 查看、下载。
Initialization Storyboard  OUTPUT:
 init(coder:) awakeFromNib()   init(coder:)  当使用 Storyboard 时，控制器的构造器为 init(coder:)。 该构造器为必需构造器，如果重写其他构造器，则必须重写该构造器。 该构造器为可失败构造器，即有可能构造失败，返回 nil。 该方法来源自 NSCoding 协议，而 UIViewController 遵从这一协议。 该方法被调用意味着控制器有可能（并非一定）在未来会显示。 在控制器生命周期中，该方法只会被调用一次。  awakeFromNib()  当使用 Storyboard 时，该方法会被调用。 当调用该方法时，将保证所有的 outlet 和 action 连接已经完成。 该方法内部必须调用父类该方法，虽然默认实现为空，但 UIKit 中许多类的该方法为非空。 由于控制器中对象的初始化顺序不能确定，所以构造器中不应该向其他对象发送消息，而应当在 awakeFromNib() 中安全地发送。 通常使用 awakeFromNib() 可以进行在设计时无法完成的必要额外设置。  Code  OUTPUT:</description>
    </item>
    
    <item>
      <title>Swift 中的 Selector</title>
      <link>/posts/2017/swift_selector/</link>
      <pubDate>Tue, 31 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/posts/2017/swift_selector/</guid>
      <description>Date Notes Swift Xcode     2017-01-31 首次发布（简书 &amp;amp; 掘金） 3.0 8.2.1    Preface  Focus，即专注。笔者希望可以尽力将一些不是那么透彻的点透过 Demo 和 Source Code 而看到其本质。由于国内软件开发仍很大程度依赖国外的语言、知识，所以该博客中的术语将使用英文表述，除非一些特别统一的词汇或整段翻译时将使用中文，但也会在首次提及时标注英文。笔者英文水平有限，这样的目的也是尽可能减少歧义，但在其中不免有所错误，遗漏，还请大家多多批评、指正。
本文及更新会首发于笔者的 GitHub 的 Perspective 仓库：https://github.com/kingcos/Perspective，欢迎 Star 🌟。
 What 常用纯代码来开发的同学都应该比较熟悉这个方法：
func addTarget(_ target: Any?, action: Selector, for controlEvents: UIControlEvents) Selector 源自 Objective-C，例如 SEL 类型，以及 @selector() 方法选择器。Swift 中也兼容了这个概念，不过随着 Swift 的迭代，Selector 的一些写法也出现了很大的变化。比较遗憾的是，官方文档对于 Selector 没有介绍。
因此只能自己总结一下 Swift 3.0 中的 Selector，便有利于自己理解，也便于以后的参考。注：以下 Demo 中的 cyanButton 是用 StoryBoard 拖拽的。</description>
    </item>
    
    <item>
      <title>浅谈 Swift 中的属性（Property）</title>
      <link>/posts/2016/swift_properties/</link>
      <pubDate>Wed, 26 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/posts/2016/swift_properties/</guid>
      <description>Date Notes Swift Xcode     2017-04-27 扩充 #延迟存储属性# 部分并新增 #devxoul/Then# 3.1 8.3.2   2016-10-26 首次提交 3.0 8.1 Beta 3    前言 Swift 中的属性分为存储属性与计算属性，存储属性即为我们平时常用的属性，可以直接赋值使用，而计算属性不直接存储值，而是根据其他（存储）属性计算得来的值。
在其他面向对象的编程语言中，例如 Java 和 Objective-C 中，get 和 set 方法提供了统一、规范的接口，可以使得外部访问或设置对象的私有属性，而不破坏封装性，也可以很好的控制权限（选择性实现 get 或 set 方法）。而 Swift 中似乎并没有见到类似的 get 和 set 方法，而 Swift 使用了一种名为属性观察器的概念来解决该问题。
本文简单介绍下 Swift 中的这两种属性，以及属性观察器。
延迟存储属性  存储属性使用广泛，即是类或结构体中的变量或常量，可以直接赋初始值，也可以修改其初始值（仅指变量）。 延迟存储属性是指第一次使用到该变量再进行运算（这里的运算不能依赖其他成员属性，但可以使用静态／类属性）。 延迟存储属性必须声明为 var 变量，因为其属性值在对象实例化前可能无法得到，而常量必须在初始化完成前拥有初始值。 在 Swift 中，可以将消耗性能才能得到的值作为延迟存储属性，即懒加载。 全局的常量和变量也是延迟存储属性，但不需要显式声明为 lazy（不支持 Playground）。  Demo  这里假定在 ViewController.</description>
    </item>
    
    <item>
      <title>Git/GitHub－Note</title>
      <link>/posts/2015/depr_gitgithub-notes/</link>
      <pubDate>Tue, 24 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_gitgithub-notes/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote class=&#34;blockquote-center&#34;&gt;
The things U must know about Git/GitHub.
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>如何解决 MySQL 中文数据问题</title>
      <link>/posts/2015/depr_mysqlqa/</link>
      <pubDate>Wed, 18 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_mysqlqa/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote class=&#34;blockquote-center&#34;&gt;
These tips are just backup for myself.
If something was wrong, please tell me.
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>iDay-11.12 ~ 12.20</title>
      <link>/posts/2015/depr_idaily/</link>
      <pubDate>Fri, 13 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_idaily/</guid>
      <description>本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。
This article is archived from my previous blog, so the content maybe have changed now.
   2015.11.12  现在已是 11 月 13 日凌晨 0: 30 分左右，我一个人还在电脑旁。宿舍的其他人都睡了，这次是真的睡，没有什么人玩手机。
很早之前想在博客上加一个 Time Line 的功能但是没有深究，因为我不想在微博上大放厥词（可能言重了吧，毕竟我只是想督促自己），可能会在未来尝试加上吧&amp;hellip; 这种类似日记的形式我想坚持下去。
不知怎么回事，感觉这学期时间过得飞快，我还没做几期电台，Swift 还没学多少，Java 也没看了，数据结构也放下了，我又不玩游戏，我的时间去哪里了？这已经是第十周了，还有两周专业课结课，接着四级考试，再几周全部结课，到放寒假大概不到两个月。
大概计划下未来几周吧，毕竟我是个爱列计划的人，感觉这样会有信心：
 四级词汇视频至少过 2 遍，可以选择空余时间观看； 四级词汇背诵笔记，高频，单词书，这个主要依靠不需要听课的一些课上学习； 编程方面，必须看完 J4A，数据结构，Swift 书可以暂缓。  至于本周：
 J4A 看完，做完笔记 四级词汇视频刷完第一遍，搞定笔记，开始第二轮 填坑电台！！！ 数据结构实验三  今年必须要做出点东西来，四级也必须要过，我已经感觉到自己碌碌无为了，虽然自我感觉并没有玩多少，但是学的不多，效率也低。新开辟了 English 分类，未来可能将整理的笔记上传，方便自己学习。
Fight!!!
Good night, strangers.
by V. 2015.11.13 00:40 NY
  2015.</description>
    </item>
    
    <item>
      <title>Java 程序语言设计小作业</title>
      <link>/posts/2015/depr_javawf/</link>
      <pubDate>Wed, 28 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_javawf/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote class=&#34;blockquote-center&#34;&gt;
Java 代码——在 URL 使用 SAX 解析 XML
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>What Have I Learnt From This Chapter</title>
      <link>/posts/2015/depr_cs-c2-bcc/</link>
      <pubDate>Tue, 13 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_cs-c2-bcc/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote class=&#34;blockquote-center&#34;&gt;
NIT Excellent Engineer Program.
Thanks for Thomas.
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>The Second Half of 2015 Plan</title>
      <link>/posts/2015/depr_the-2nd-half-year-plan/</link>
      <pubDate>Tue, 22 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_the-2nd-half-year-plan/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote class=&#34;blockquote-center&#34;&gt;
计划还是要有的，万一完成了呢？
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Learning Swift 2.1 - Note &amp; Code</title>
      <link>/posts/2015/depr_swift-2/</link>
      <pubDate>Sat, 19 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_swift-2/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote class=&#34;blockquote-center&#34;&gt;
Based on
[The Swift Programming Language](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/)
Swift 2 Edition
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>初学 Java 4 Android - Note &amp; Code</title>
      <link>/posts/2015/depr_j4a/</link>
      <pubDate>Sun, 13 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_j4a/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote class=&#34;blockquote-center&#34;&gt;
源自《[Java 4 Android](http://study.163.com/course/courseMain.htm?courseId=201001)》-- [Mars](http://www.marschen.com/portal.php)
如有错误，希望指出。
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Tapole 记（下）</title>
      <link>/posts/2015/depr_1st-tapole_3/</link>
      <pubDate>Fri, 21 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_1st-tapole_3/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote class=&#34;blockquote-center&#34;&gt;
已经不记得自己的眼睛是何时近视的了，
架在鼻上，挂在耳边，放在眼前的眼镜已经和我离不开了。
Tapole 的最终产品终于来到，这样一款非数码产品的开箱体验会是什么呢...
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Tapole 记（中）</title>
      <link>/posts/2015/depr_1st-tapole_2/</link>
      <pubDate>Sun, 16 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_1st-tapole_2/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote class=&#34;blockquote-center&#34;&gt;
已经不记得自己的眼睛是何时近视的了，
架在鼻上，挂在耳边，放在眼前的眼镜已经和我离不开了。
Tapole 免费试戴的镜架到了，让我们一起来看看吧...
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Tapole 记（上）</title>
      <link>/posts/2015/depr_1st-tapole_1/</link>
      <pubDate>Sun, 09 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_1st-tapole_1/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote class=&#34;blockquote-center&#34;&gt;
已经不记得自己的眼睛是何时近视的了，
架在鼻上，挂在耳边，放在眼前的眼镜已经和我离不开了。
作为一名普通消费者加天秤座，来跟我一起看看网上配镜前的纠结吧...
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>寻找下一个地球</title>
      <link>/posts/2015/depr_finding-another-earth/</link>
      <pubDate>Sat, 01 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_finding-another-earth/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote class=&#34;blockquote-center&#34;&gt;
人类在宇宙中是如此的渺小，却又如此的幸运。这个蓝色星球承载着我们的一切。
宇宙如此广袤，地球绝不是孑然一身，让我们跟着 NASA，寻找下一个地球...
*本文摘自 NASA 官方网站的一篇题为“[Finding Another Earth](http://www.nasa.gov/jpl/finding-another-earth)”的文章，经本人翻译放出。*
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>这一年，我，去哪里了...</title>
      <link>/posts/2015/depr_where-did-i-go/</link>
      <pubDate>Thu, 23 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_where-did-i-go/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote class=&#34;blockquote-center&#34;&gt;
这篇文章原本计划给某些人看的，不过，这里还不想被人发现，还是等更好的时候吧。
文笔不好，从小写作难，情商低，大家小心被吓着。
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 编程代码风格指南</title>
      <link>/posts/2015/depr_cpp_style_guide/</link>
      <pubDate>Fri, 17 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_cpp_style_guide/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;PS: 为本文标题增加空格 &amp;amp; 内容表格格式修复&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;前言：
本文翻译自&lt;a href=&#34;http://geosoft.no/development/cppstyle.html&#34;&gt;C++ Programming Style Guidelines原文地址&lt;/a&gt;
参考资料：Google机翻
本文仅供参考，如有错误希望指出。如有侵权，会立即删除，决不用于商业用途。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>2015 年 3 月苹果发布会后感</title>
      <link>/posts/2015/depr_apple-conference_03/</link>
      <pubDate>Sat, 04 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_apple-conference_03/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote class=&#34;blockquote-center&#34;&gt;
Apple Watch, new MacBook...
Designed by Apple 还有哪些亮点呢？
让我们谈谈这次的 Apple 发布会吧。
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Count On Me 歌词翻译</title>
      <link>/posts/2015/depr_count-on-me/</link>
      <pubDate>Fri, 03 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_count-on-me/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote class=&#34;blockquote-center&#34;&gt;
Count On Me 是一首很暖心的歌（原唱 Bruno Mars）。
Connie Talbot 的翻唱的却充满童真，
让我们一起欣赏下吧～
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>The First Half of 2015 Plan</title>
      <link>/posts/2015/depr_the-1st-half-year-plan/</link>
      <pubDate>Sat, 21 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_the-1st-half-year-plan/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote class=&#34;blockquote-center&#34;&gt;
计划还是要有的，万一完成了呢？
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>王自如对话 Moto 总裁 Rick Osterloh</title>
      <link>/posts/2015/depr_moto/</link>
      <pubDate>Sun, 01 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>/posts/2015/depr_moto/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文为已归档的历史博客内容，其内容可能随着时间发生已经改变。&lt;br&gt;This article is archived from my previous blog, so the content maybe have changed now.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote class=&#34;blockquote-center&#34;&gt;
Moto回来了。
这次的回归是否能使它在国内的市场涅磐重生？
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>How To Choose A P.C. In 2014?</title>
      <link>/posts/2014/depr_how-to-choose-pc/</link>
      <pubDate>Mon, 09 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>/posts/2014/depr_how-to-choose-pc/</guid>
      <description>这篇文章是 2014 年 6 月 11 日发布在点点轻博客的，本文和手机选购那篇属于同一风格，但由于对电脑了解不深入，所以只能是略微谈谈，不过也算是尽力了，软件专业买电脑的童鞋就不要看了，怕误导你们。
 如何选购个人电脑 电脑是大学的三件套之一，我对电脑的了解并不多，只是简单谈一下好了，首先说明一点，据我所知，有些大学第一年是不允许带电脑过去的，在通知书上应该会提到，原因很简单，第一怕影响学习，第二怕丢，高校的安全措施是很不好的，所以不大建议同学们直接买很高档的电脑，最后沦为打游戏，刷淘宝，看韩剧的用途，而且如果有同学借，你会舍得吗？当然你自己决定，我干涉不了。好了，不谈这些了，我们谈一谈更深入的吧~
系统 这里主要说明以下 Windows 和 Mac OS
Windows 系统就不用追根溯源了，自己百度百科去，Windows 在市面上还在售卖的笔记本所搭载系统为 Win 8.1 、Win 8 、Win 7 基本上就这几种，而且以前两种为主。当然有人说 Win RT，我们还是不说这个半残的系统了= =。Win 8.1 和 Win 8 采用了最新的 Metro UI，就是一块块的小磁贴，图片不想贴了，自己百度，这个界面主要是微软为了应对触屏化，并且和自己的 WP 形成一体的界面，使用户感受得到提升，新一代苹果系统 Mac OS X 10.10 也和 iOS 的扁平化融为一体，目的就是让你用了之后，使得你无法转向别的平台，说难听点就是绑架，但是是好是坏，也并不一定，既方便你又帮人家赚钱，两全其美。
Windows 平台十分宽松，而且我觉得基本上大家对 Windows 的操作已经熟能生巧，而且用户量决定了大量的游戏软件在 Windows 上遍地开花，但是有些软件参差不齐，而且比较容易中毒，其实现在电脑中毒已经很少了，只要不要乱下载软件，有安全措施，其实还是挺安全的，如果中毒了，多半是用户自己误删等导致自己以为中毒，男生还是学学修电脑吧，以后可以帮女生修修电脑修不好没关系= =可以干点别的嘛~我擦，跟你们说的太多了= =还有，再强调一句，学电脑不等于修电脑，汉子们，多用用百度吧，累不死你们的！！！！
这里简单插一点怎么用搜索引擎搜索自己想要的答案：  不要用问人的口吻来问电脑，你确定人家解答问题的人跟你的口气一样？不要加那么多 为什么 标点符号 怎么样 等等类似的，当然百度比较好，出了个百度知道，所以你可以找到一些。 关键词之间用空格来分开，在淘宝中搜索也可以，原因不说了，中学信息技术里面提到过。  继续说 Win。Win 系统的本子太多了，好处，可以找到自己心水的配置外形（土豪果粉滚粗= =）的机机，坏处，机型太乱了，你要是去尸体店，对，没错尸体店，八成会被转型，就是说你在网上查好的配置，机型到了尸体店，他会以各种理由让你放弃你查好的机型，然后给你拿出一款他所谓比你配置更高端的机机，最后你就屈服购买了，还送你一堆配件，到家上网一查，尿了吧，傻了吧，所以其实网购更加透明，安全，只要选择京东或者天猫基本上就 OK，当然你要是觉得自己可以战胜奸商可以去挑战下，战败了别告诉我没提醒你= =
关于配置，不要听那些数据什么 2G 超大显存，独立显卡，1T 超大硬盘，15 寸高清大屏，巧克力键盘。。。数据是数据，数据提升容易，架构完全不同，底层完全不同，数据是死的，所以大家追求大，更大，其实没必要，体验最重要，如果不知道选什么，还是建议大家去实体店体验，不要带钱，一分都不要带！就 OK 了。女孩也许都喜欢外形骚的，炫的，代价不轻，剁手谨慎！</description>
    </item>
    
    <item>
      <title>How To Choose A Phone In 2014?</title>
      <link>/posts/2014/depr_how-to-choose-phone/</link>
      <pubDate>Mon, 09 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>/posts/2014/depr_how-to-choose-phone/</guid>
      <description>这篇文章是 2014 年 6 月 9 日发布在点点轻博客的，（当时刚结束高考啊&amp;hellip;泪奔），所以略有时效性，但由于这篇文章当我今年再看的时候，颇有感慨，所以放在这里，留存吧，也对大家买手机还是有些许参考性的，如果再让我做一次选择，还是买 iPhone 吧&amp;hellip;
 如何选购智能手机 智能手机的普遍性就不啰嗦了，下面就来说一下买智能手机的几个注意点，顺序不分先后。
本文所说手机均为品牌手机，出货量极少的牌子不推荐，因为售后，更新会很难普及。利益相关：果粉- –
价格 智能手机价格分布大概有
1000 元以下 千元机市场一直很火爆，大部分手机采用 MTK 处理器，或者低端高通处理器，参数不再详解，此价格手机最主要看手机的稳定性以及售后。我在这里只推荐红米系列和诺基亚低端 Lumia。因为此价格机器参差不齐，价格战战的用户已经分不出来到底该选什么好。
 红米：  红米采用 MIUI V5 基于安卓高度定制的系统，优化比山寨机之流好很多，各种服务都很齐全，预算不够的同学可以考虑，而且红米为双卡系列，但是要注意一点，红米手机制式很多，建议大家在小米官网购买，不要在淘宝上面购买，容易买到假货，在实体店购买，价格会比网购多很多，自己斟酌；而且选购时要看清楚自己使用的是什么手机卡，联通，电信或是移动，而且要看自己用的是 2G 还是 3G 卡，4G 红米还没有出，因为 4G 专利大部分握在高通之手，而且现在 4G 不太稳定，而且资费还是不便宜。
诺基亚 Lumia 系列：  诺基亚一直以优秀的做工，完美的质量让人信服，但是注意，现在手机屏幕尺寸提升，想让诺基亚砸核桃并不现实。撸妹采用 WP8 系统，马上推送 WP8.1，说实话 WP8.1 才算是一个基本的手机系统，完善很多小 Bug，WP 系统视觉风格完全不同于安卓和 iOS，本人认为，撸妹手机差别只在于：屏幕大小，相机像素，手机外观，运存大小。其实并没有太大差别，而且目前WP商店软件不全，参差不齐，虽然必备软件都有，但是质量不好，尤其喜欢玩大型游戏的人，不建议考虑，当然这种情况在慢慢改善，如果你有耐心，请购买，但我个人不太建议普通小白用户购买。
1000-1500 这个价格有很多选择，基本上为前年的旗舰机，比如小米 2s，魅族 MX2，诺基亚也有很多选择，数码产品有人说买新不买旧，也对，但是如果普通用户，我不建议买太高端的手机，目前手机性能过剩，屏幕过大，没有必要，你要是想装逼那我没话说，手机基本功能差不多，只要不要出现太大的差错就行，一般国产机不建议购买第一批，因为第一批基本上为小白鼠，各种问题，很麻烦，而且第一批购买者基本上是被广告软文害的，所以不建议购入第一批。这个价位手机大家看看其做工，信号，续航即可，如果让我推荐，我只推荐小米 2S，原因，我不知道还有什么，MX2 不推荐是因为不能换电池，发热较严重，续航不足，信号不好，不大建议，当然你要认为这是小事，那你可以购买，而且只要 1299，还送半年延保，具体上官网查看。
小米 2s：
功能齐全，但是不能插内存卡，32G 版本比 16G 版本多 16G 储存空间，而且摄像头从 800W 升级到 1300W，其实这不重要，底下再说。而且 2s 支持更换电池，官网还有大电池套装，性能也很好。</description>
    </item>
    
    <item>
      <title>【Future】骑车回家幻想记</title>
      <link>/posts/2013/depr_dreaming-in-the-way/</link>
      <pubDate>Fri, 26 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>/posts/2013/depr_dreaming-in-the-way/</guid>
      <description>我要的幸福  注：此文最早由本人发表于萌面大道吧，后转于此。
 今天，一个人骑车回家，洛阳的春天又像孩子一样变得热烈起来，整个空气中布满了烦躁，可我还是那么冷静，听说不能留校后便背起书包，骑车回家！ 我不觉得我是个多么有思想的人，但是至少我可以思想，每次来去学校的路上，无聊，便时常观察路上的风景，有时憧憬一下未来，今天，也不知怎的，便开始想象我以后的人生。 我学习不好，至少在一高是这样的，我觉得是自己不够努力，太堕落，没有一个支撑下去的动力。所以我便想，既然学习不太好，所以大学可能考的就不怎么地，但是大学的意义就是让你与和你相似的人在一起，然后去学习做人的规则。大学毕业以后怎么办呢？现在工作难找，况且文凭不好，想不受气只能自己创业，感觉创业这个词太大了，可我也找不到更合适的了。当然这个憧憬假设在我找到了个合适的人。呵呵，某些人别乱猜了= = 如果我长大了，也找到了对的人，我希望我们的幸福可以简单一点，我虽然崇拜乔布斯的伟大，但是我又很想幻想一下一个普通人的幸福。我们可以就在洛阳，对，是洛阳（希望她也是洛阳的），洛阳虽然不算什么发达的城市，但是我爱她，她并没有像别的发达城市一样，总是以经济为主，而抛弃人文。我们在洛阳，开一家小饼店（只是假设，也可以干别的，都听你的），店面不用太大，就我们两个人，刚开始可能我并没有房子车子，我们可以住在店里，或者破一些的出租屋里，每天早晨，我轻轻的起床，在厨房为你做一桌早餐，可能不太丰盛，可能有些咸，或者难吃，然后我把你叫醒，把饭菜端到床上，你起床，享受这早晨的惬意，而我陪你吃完早餐，便整装待发，去准备一天所需要的东西，当我回来时，你已准备好迎接新的一天，我们服务每位顾客，让他们感受到我们的真心。每天你累了，便会悄悄告诉我，我们便结束了一天的忙碌。 中午，我可以去买你最爱吃的东东，晚上我们一起下厨，晚饭过后，我会亲自帮你洗脚，帮你按摩，你也会告诉我电视或者电脑上的新鲜内容。每天，我们都要锻炼身体，我会责怪你又瘦了，让你吃好的，每个星期，我们一起骑车去龙门，去动物园，还有，我们一定要去看我们的爸爸妈妈，让他们享受晚年的乐趣，每个月，我们都要去旅游一次，或是去看你偶像的各种会，可以去放松，去享受属于我们的青春，当我们一点点积累了财富，我们会在洛阳买一套房子，不要太大，温馨就行，我们自己设计。然后我们可以买一辆小车，代步就足够。每个月，我们要拿出一部分钱去捐款，去把钱实实在在的送到需要的人手中。
幻想，总是很简单，而实现很难。我不知道有几个人会喜欢这样简单的幸福，而我也只是想想罢了，呵呵。我也知道我写的很乱，好吧，我只是自己看看，自我陶醉罢了。</description>
    </item>
    
    <item>
      <title>【Friend Ship】仅以此文献给高班和总统</title>
      <link>/posts/2013/depr_only-for-gyy-lmb/</link>
      <pubDate>Sat, 06 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>/posts/2013/depr_only-for-gyy-lmb/</guid>
      <description>注：在很早之前，我的个人贴吧就开张了，不过到现在，带上自己也只有区区 6 人，两年前我在那里写过两篇，这就是其中之一。我文笔不好，不善言谈，但我也要写下来，因为回忆吧。到现在，我仍然没有他们的联系方式，他们也不曾看过这几百个弱小的文字。只希望，一切安好。
 其实很早就有写篇东西给他们的冲动，但是咱文笔不好，没有华丽的词藻，只有平淡的语言，而且会语无伦次。
高班 话说我们是同一个小学的。他很爱踢球，我也是，可我并没有报什么培训班之类的，他总是拿他丰富的经验来耍我（- -承认他技术好，但是主要我太瘦弱了。。。）。当时他在班里也是蛮风骚的。。。（NC 会不会打我呢）木办法啊，人长得 zun，学习也不赖！当然更受欢迎==，而我那个时候太单纯。。。初中，大家各奔东西。到了高中，开始也没见他的影子，后来高一下半学期分班，就正好分到这个八班了，他是班长，但觉得关系还和以前一样。。。不过更负责任，专一了= =足球还是那么好。。。
希望你能好好读军校，刻苦一些，别放弃 NC，加油！就像龙井的《朋友》一样，“都是大老爷们，说的有点女人了”在那边吃好玩好，我也就放心了，可能你看不到这吧，不过证明我有个心意就知足了。你该走的时候，我没有去说什么，甚至一声再见，只是问你要了手机号，我知道以后可能很少联系了（平时也没有= =），祝保重！
总统 你因为和李明博同名，大家就叫你总统。。。记得初中的时候，有次看到一本作业，上面写着你的名字，当时我们就喷了= =~。如今李明博下去了，你也不在回来了，还记得上学期吗？咱俩做同桌，晚自习，我看生物你看政治。。。我还老是问你生物，嘿嘿，还记得那时候，你说你要拿 iPhone 5s 来找我= =，考不好就陪我一起拿 iPhone 6 嘿嘿！（顿时觉得高富帅。。。）当然你最好还是拿着 iPhone 5s 走吧。。。毕竟那条路前途更好，这个学期没和你做同桌，你平时也不是高调的人，总是默默无闻，走的时候，也是自己一个人背着书包走的，没有和别人说，也没人送你，到了大学以后可要开朗一点啊，总统身体好一定能吸引很多人的！记得一定回来告诉我你的电话！！
你们走了，而我也只能努力奋斗了，你们也要继续努力，为了爱而战斗！</description>
    </item>
    
    <item>
      <title>[译] Swift 编译器性能</title>
      <link>/posts/2020/swift_compiler_performance/</link>
      <pubDate>Sun, 25 Jun 2000 00:00:00 +0000</pubDate>
      
      <guid>/posts/2020/swift_compiler_performance/</guid>
      <description>作者 原文链接 版本     apple/swift Swift Compiler Performance 5dcc32f    本文档是一份关于理解、诊断并报告 Swift 编译器编译性能问题的指南。即：编译器编译代码的速度，而非代码运行的速度。
虽然本指南较长，但内容其实相当简单。在很大程度上，性能分析需要耐住性子、考虑周全且坚持不懈，谨小慎微且始终如一地测量，并逐步消除噪音且专注于一个信号。
影响编译性能的流程与因素概述 本节从较为宏观的角度论述关于编译器在运行时所做的工作，不仅包括显而易见的「编译」，以及影响编译器耗时的主要因素。
当我们使用 Xcode 或在命令行中编译或运行 Swift 程序时，通常将调用 swift 或 swiftc（后者是前者的符号链接），这是一个根据不同参数能够以显著不同的方式运行的程序。
虽然它可以直接编译或运行代码，但它通常会反过来运行一个或多个 swift 或 swiftc 副本作为子进程。在典型的批量编译中，swiftc 的第一个副本将被作为驱动（Driver）进程运行，之后它将在进程树中运行一些所谓的前端（Frontend）子进程。当我们要理解 Swift 编译时，我们必须清楚地了解哪些进程在运行，以及它们在做什么：
 驱动：子进程树中的顶层 swiftc 进程。负责决定哪些文件需要被编译或重新编译，以及运行子进程。子进程即所谓的作业（Jobs），它们运行编译和链接步骤。通常在运行时，驱动是空闲的，等待其它子进程完成。 前端作业（Frontend Jobs）：由驱动启动的子进程，运行 swift -frontend ...、运行编译、PCH 文件生成、模块合并等。这些作业大量增加了编译开销。 其它作业（Other Jobs）：由驱动启动的子进程，运行 ld、swift -modulewrap、swift-autolink-extract、dsymutil、dwarfdump，以及涉及收尾前端已完成作业等类似工具。其中一些也是 swift 程序，但它们并非「运行前端作业」，因此将会有完全不同的分析。  这些运行的一系列作业以及它们的耗时方式高度依赖于编译模式。有关编译性能的这些模式信息将在下一节中详述；关于驱动的更多详细信息，请参阅驱动文档、以及有关驱动内部和驱动可解析输出的文档。
在下一节讨论完编译模式之后，我们还将涉及可能在没有明显热点（Hotspot）出现的情况下，所发生的工作量大幅变化，这将分别从懒惰策略（Laziness Strategies）与近似两个角度论述。
编译模式 编译器有许多不同的选项可以控制驱动和前端作业，但导致行为上最显著差异的两个维度通常被称作模式（Modes）。因此当我们着眼于编译时，弄清楚 swiftc 的运行模式便十分重要，以及要时常对每个模式进行独立的分析。这些重要的模式如下：
 主文件（Primary-File）与全模块（Whole-Module）：不同模式取决于驱动是否使用 -wmo（又名 -whole-module-optimization）参数运行。  批量（Batch）与单文件（Single-File）主文件模式：随着 Swift 4.</description>
    </item>
    
    <item>
      <title>About &amp; AMA</title>
      <link>/about/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>📱 iOSer/Swifter/DevOps/Full-stacker · Working at MTDP · Mobike
  For more:
 GitHub · @kingcos Twitter · @kingcos_v Instagram · @kingcos_v YouTuBe · @萌面大道 哔哩哔哩 Bilibili · @萌面大道 微博 WeiBo · @萌面大道 V 微信公众号 · @萌面大道 ⬇       Blog &amp;amp; Theme:
 Blog by Hugo Theme by panr     Change Log 此处将包含本博客的更新内容，而非文章的更新日志。
   Date Change Log     约高中时期 2011-2014 百度个人贴吧   高中毕业后，约 2014.</description>
    </item>
    
    <item>
      <title>Links</title>
      <link>/links/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
      
      <guid>/links/</guid>
      <description> Linking with Others 🔗
  Daily Growing · by Zansy  </description>
    </item>
    
    <item>
      <title>Perspective</title>
      <link>/perspective/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
      
      <guid>/perspective/</guid>
      <description>Thinking with Perspectives 💡
  2020 这是一个需要英雄的年代。但最近「打脸」的事情太多了，我想谈谈「打脸」。随着信息化的加深，个人获取信息的速度和深度都有了很大程度的提升。但很遗憾，信息量的递增对于信息的筛选和甄别造成了更大的压力。我们并非「上帝」，无法真正在这个世界上开启上帝视角。因此无论我们多么谨小慎微，发表个人言论时都会不可避免的带有主观色彩以及偏向，这个偏向受制于我们获取的信息。而如果后续事情的走向与之前有些偏差或者相悖，那么就成了所谓的「打脸」。「扣帽子」总是简单的，但能够去深层次思考是否真的有偏差以及是什么造成了「打脸」的结果却寥寥，或者说大部分人是看热闹的。
当然，每次看到这些「乌合之众」所「不加思考」的「扣帽子」言语，我也是理解的。一是思考是一个耗费精力需要聚合的过程，而人们更愿意去做能够更快收到反馈的事情；二是具有深度思考能力的人是少数的，这一点我个人也不觉得自己完全具有这样的能力。有些时候还是觉得现在的社会有些浮躁，能够真正静下心讨论事情、交换想法的人太少。
 2020.04.04   2019 能力是是否能够胜任的基本，而其它方面则决定了是否卓越。这似乎和当年评选 NS 时我所采取的策略一致。从 85 分提升到 90 分，也许远不如 55 分提升到 60 分效果明显。
 2019.09.22   Data Driven  当你作为一名员工，如果所做的事情难以从数据层面反映你的作用，那么你会怎么办呢？ 反之，为一名领导，你如何判定那些难以以数据衡量作用的下属的绩效呢？  这是我最近（述职晋升季）思考并尝试提问身边同事的两个问题。
 2019.08.06   Apple, Steve Jobs, Johnathan Ive 其实不必避讳，我个人对于 Apple 是充满喜爱的，而最近 Johnathan Ive 也离开 Apple 了，至于用「也」，这是因为上一个走的是 Steve Jobs。相比乔布斯，乔纳森更加居于幕后。最近我也把乔布斯发布 iPhone 的发布会翻出来看了下，以及与比尔盖茨的采访视频、2010 年去世前一年的采访视频。我很有感触，其实才发现 iPhone 第一代就奠定了这么年的基础，11 年过去了，iPhone 的核心功能与交互并没有发生本质改变，即使说上 iOS 7 扁平化的设计。而其实究其本质的创新是在 Apple Watch 和 AirPods 上，当然我们也无从得知乔布斯对于这两个产品是否真正有所规划。</description>
    </item>
    
    <item>
      <title>Reading</title>
      <link>/read/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
      
      <guid>/read/</guid>
      <description> Reading with Perspectives 💭
  2020    Status Name Rating     √ 富爸爸穷爸爸 ★★★★★   √ 乌合之众 ★★★★☆   √ 巨婴国 ★★★★★   - 小王子 -   - 集异璧之大成 -   - 非暴力沟通 -   - 乔纳森传 -   - 1984 -   - Linkers &amp;amp; Loaders -     2019    Status Name Rating     √ 爱你就像爱生命 ★★★★★   √ 蒂姆·库克传 ★★★☆☆   √ 10x 程序员工作法 ★★★★★   √ 成为乔布斯 ★★★★★   Pause 禅与摩托车维修艺术 ★★★☆☆   √ 编写高质量 iOS 与 OS X 代码的 52 个有效方法 ★★★★☆   √ Objective-C 高级编程 ★★★★☆    </description>
    </item>
    
    <item>
      <title>Travelling</title>
      <link>/travelling/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
      
      <guid>/travelling/</guid>
      <description> Travelling the Beauties 🏞️
  Instagram · @kingcos_v   2020 北京  天坛公园 颐和园 中国国家图书馆 保利艺术博物馆 国家动物博物馆 观复博物馆 首都博物馆   2019 北京  圆明园 玉渊潭公园 景山公园  青岛  栈桥 花石楼 青岛海底世界 八大关风景区   2018 北京  故宫博物院 中国科技馆 中国国家博物馆 中国人民革命军事博物馆 八达岭长城 天安门广场 北京大学  </description>
    </item>
    
    <item>
      <title>Words</title>
      <link>/words/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
      
      <guid>/words/</guid>
      <description>Talking to This World 🌍
  2020 从巴黎圣母院失火到科比去世，虽然我不是他们的信徒或忠实铁粉，但越长大就会发现，有些事情真的一旦错过就再也无法挽回。特别是，如果你曾有哪怕一瞬想到要去做。
 2020.04.01   理解也许并不等于包容与接受。
 2020.02.29   2019 打造一款产品，不能站在用户的对立面，而是要与用户站在一起。
 2019.09.26   如果只着眼于眼前利益，而不考虑以开放的心态对未来进行储备、投资，那么未来就可能会处于被动。
 2019.09.10   既要看到硬币的正面，也要看到硬币的反面，更要谨慎硬币的侧面，因为即使侧面，面积也占一面的约 14.8 %（冷）。
 2019.09.02   世界不缺我这一颗「螺丝钉」，而需要一位 &amp;hellip;
 2019.08.13   不同的人，其实就是平行世界。
 2019.08.09   信赖并适当放权于专业之人，才能给予其施展空间，我猜，这也是管理的智慧之一吧。
 2019.08.07   无论是年轻一代不耐烦年长一代，抑或年长一代不理解年轻一代，不得不承认，代沟确实存在，且几乎不可逾越。
 2019.07.24   读完了《爱你就像爱生命》，无以名状。他们的爱情令人羡煞，而阴阳相隔又令人生惜。爱情，多么美好，是两个灵魂的碰撞；却又令人忽明忽暗。我着实喜欢这样朴实无华却充满力量的文字，很遗憾，早年间读书太少，如今是要补一补了。
果然，有人开始对我戴的彩虹色表带「议论」了，无论是否有意，但，我还会戴着它，因为我们要「宽容」。
 2019.07.01   经历过完整义务教育的一代，可能很难意识到微信中比文字权重更高的语音的影响力。文字的门槛要比语言高，毕竟动物也有「语言」而没有文字。—— 观察「70 后聊天群」有感
 2019.06.30   对错暂且不谈，只是觉得，圈中人只能被动接受到一面之词，但又偶能嗅到一丝他味，但身处圈中太久，也不知此味亦真亦假，可悲。</description>
    </item>
    
    <item>
      <title>算法</title>
      <link>/topics/algorithms/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
      
      <guid>/topics/algorithms/</guid>
      <description> </description>
    </item>
    
  </channel>
</rss>